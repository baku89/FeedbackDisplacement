/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(1);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	__webpack_require__(3);
	
	__webpack_require__(4);
	
	__webpack_require__(5);
	
	__webpack_require__(6);
	
	var _vjInterface = __webpack_require__(12);
	
	var _vjInterface2 = _interopRequireDefault(_vjInterface);
	
	var _ticker = __webpack_require__(14);
	
	var _ticker2 = _interopRequireDefault(_ticker);
	
	var _brushPass = __webpack_require__(7);
	
	var _brushPass2 = _interopRequireDefault(_brushPass);
	
	var _basePass = __webpack_require__(8);
	
	var _basePass2 = _interopRequireDefault(_basePass);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	window.Interface = _vjInterface2.default;
	window.renderer = null;
	
	var App = function () {
		function App() {
			_classCallCheck(this, App);
		}
	
		_createClass(App, [{
			key: 'init',
			value: function init() {
	
				this.initScene();
				this.initSource();
			}
		}, {
			key: 'initScene',
			value: function initScene() {
	
				var w = window.innerWidth;
				var h = window.innerHeight;
	
				this.brushPass = new _brushPass2.default(w, h);
	
				// make renderer
				this.renderer = new THREE.WebGLRenderer({
					canvas: document.getElementById('canvas')
				});
				this.renderer.setClearColor(0x000000);
	
				this.prevRenderTarget = new THREE.WebGLRenderTarget(w, h, {});
	
				this.brushPass = new _brushPass2.default(this.renderer);
	
				this.renderPass = new _basePass2.default(this.renderer, {
					renderer: this.renderer,
					fragmentShader: __webpack_require__(11),
					uniforms: {
						texture: { type: 't', value: this.brushPass.texture }
					}
				});
	
				window.addEventListener('resize', this.onResize.bind(this));
				window.addEventListener('click', this.onClick.bind(this));
	
				this.animate = this.animate.bind(this);
	
				this.onResize();
	
				_ticker2.default.on('update', this.animate.bind(this));
				_ticker2.default.start();
			}
		}, {
			key: 'initSource',
			value: function initSource() {}
		}, {
			key: 'animate',
			value: function animate(elapsed) {
	
				_vjInterface2.default.update();
	
				this.brushPass.render();
				this.renderPass.render();
			}
		}, {
			key: 'onResize',
			value: function onResize() {
				var w = window.innerWidth;
				var h = window.innerHeight;
	
				this.brushPass.setSize(w, h);
				this.renderPass.setSize(w, h);
			}
		}, {
			key: 'onClick',
			value: function onClick(e) {
				// this.uniforms.cursor.value.set(e.clientX, e.clientY)
			}
		}]);
	
		return App;
	}();
	
	window.kumiko = new THREE.TextureLoader().load('/assets/kumiko.png', function () {
		new App().init();
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var self = self || {};// File:src/Three.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var THREE = { REVISION: '74' };
	
	//
	
	if ( true ) {
	
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (THREE), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {
	
		module.exports = THREE;
	
	}
	
	//
	
	if ( Number.EPSILON === undefined ) {
	
		Number.EPSILON = Math.pow( 2, - 52 );
	
	}
	
	//
	
	if ( Math.sign === undefined ) {
	
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
	
		Math.sign = function ( x ) {
	
			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;
	
		};
	
	}
	
	if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {
	
		// Missing in IE9-11.
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
	
		Object.defineProperty( Function.prototype, 'name', {
	
			get: function () {
	
				return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];
	
			}
	
		} );
	
	}
	
	if ( Object.assign === undefined ) {
	
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	
		Object.defineProperty( Object, 'assign', {
	
			writable: true,
			configurable: true,
	
			value: function ( target ) {
	
				'use strict';
	
				if ( target === undefined || target === null ) {
	
					throw new TypeError( "Cannot convert first argument to object" );
	
				}
	
				var to = Object( target );
	
				for ( var i = 1, n = arguments.length; i !== n; ++ i ) {
	
					var nextSource = arguments[ i ];
	
					if ( nextSource === undefined || nextSource === null ) continue;
	
					nextSource = Object( nextSource );
	
					var keysArray = Object.keys( nextSource );
	
					for ( var nextIndex = 0, len = keysArray.length; nextIndex !== len; ++ nextIndex ) {
	
						var nextKey = keysArray[ nextIndex ];
						var desc = Object.getOwnPropertyDescriptor( nextSource, nextKey );
	
						if ( desc !== undefined && desc.enumerable ) {
	
							to[ nextKey ] = nextSource[ nextKey ];
	
						}
	
					}
	
				}
	
				return to;
	
			}
	
		} );
	
	}
	
	// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button
	
	THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
	
	// GL STATE CONSTANTS
	
	THREE.CullFaceNone = 0;
	THREE.CullFaceBack = 1;
	THREE.CullFaceFront = 2;
	THREE.CullFaceFrontBack = 3;
	
	THREE.FrontFaceDirectionCW = 0;
	THREE.FrontFaceDirectionCCW = 1;
	
	// SHADOWING TYPES
	
	THREE.BasicShadowMap = 0;
	THREE.PCFShadowMap = 1;
	THREE.PCFSoftShadowMap = 2;
	
	// MATERIAL CONSTANTS
	
	// side
	
	THREE.FrontSide = 0;
	THREE.BackSide = 1;
	THREE.DoubleSide = 2;
	
	// shading
	
	THREE.FlatShading = 1;
	THREE.SmoothShading = 2;
	
	// colors
	
	THREE.NoColors = 0;
	THREE.FaceColors = 1;
	THREE.VertexColors = 2;
	
	// blending modes
	
	THREE.NoBlending = 0;
	THREE.NormalBlending = 1;
	THREE.AdditiveBlending = 2;
	THREE.SubtractiveBlending = 3;
	THREE.MultiplyBlending = 4;
	THREE.CustomBlending = 5;
	
	// custom blending equations
	// (numbers start from 100 not to clash with other
	// mappings to OpenGL constants defined in Texture.js)
	
	THREE.AddEquation = 100;
	THREE.SubtractEquation = 101;
	THREE.ReverseSubtractEquation = 102;
	THREE.MinEquation = 103;
	THREE.MaxEquation = 104;
	
	// custom blending destination factors
	
	THREE.ZeroFactor = 200;
	THREE.OneFactor = 201;
	THREE.SrcColorFactor = 202;
	THREE.OneMinusSrcColorFactor = 203;
	THREE.SrcAlphaFactor = 204;
	THREE.OneMinusSrcAlphaFactor = 205;
	THREE.DstAlphaFactor = 206;
	THREE.OneMinusDstAlphaFactor = 207;
	
	// custom blending source factors
	
	//THREE.ZeroFactor = 200;
	//THREE.OneFactor = 201;
	//THREE.SrcAlphaFactor = 204;
	//THREE.OneMinusSrcAlphaFactor = 205;
	//THREE.DstAlphaFactor = 206;
	//THREE.OneMinusDstAlphaFactor = 207;
	THREE.DstColorFactor = 208;
	THREE.OneMinusDstColorFactor = 209;
	THREE.SrcAlphaSaturateFactor = 210;
	
	// depth modes
	
	THREE.NeverDepth = 0;
	THREE.AlwaysDepth = 1;
	THREE.LessDepth = 2;
	THREE.LessEqualDepth = 3;
	THREE.EqualDepth = 4;
	THREE.GreaterEqualDepth = 5;
	THREE.GreaterDepth = 6;
	THREE.NotEqualDepth = 7;
	
	
	// TEXTURE CONSTANTS
	
	THREE.MultiplyOperation = 0;
	THREE.MixOperation = 1;
	THREE.AddOperation = 2;
	
	// Mapping modes
	
	THREE.UVMapping = 300;
	
	THREE.CubeReflectionMapping = 301;
	THREE.CubeRefractionMapping = 302;
	
	THREE.EquirectangularReflectionMapping = 303;
	THREE.EquirectangularRefractionMapping = 304;
	
	THREE.SphericalReflectionMapping = 305;
	
	// Wrapping modes
	
	THREE.RepeatWrapping = 1000;
	THREE.ClampToEdgeWrapping = 1001;
	THREE.MirroredRepeatWrapping = 1002;
	
	// Filters
	
	THREE.NearestFilter = 1003;
	THREE.NearestMipMapNearestFilter = 1004;
	THREE.NearestMipMapLinearFilter = 1005;
	THREE.LinearFilter = 1006;
	THREE.LinearMipMapNearestFilter = 1007;
	THREE.LinearMipMapLinearFilter = 1008;
	
	// Data types
	
	THREE.UnsignedByteType = 1009;
	THREE.ByteType = 1010;
	THREE.ShortType = 1011;
	THREE.UnsignedShortType = 1012;
	THREE.IntType = 1013;
	THREE.UnsignedIntType = 1014;
	THREE.FloatType = 1015;
	THREE.HalfFloatType = 1025;
	
	// Pixel types
	
	//THREE.UnsignedByteType = 1009;
	THREE.UnsignedShort4444Type = 1016;
	THREE.UnsignedShort5551Type = 1017;
	THREE.UnsignedShort565Type = 1018;
	
	// Pixel formats
	
	THREE.AlphaFormat = 1019;
	THREE.RGBFormat = 1020;
	THREE.RGBAFormat = 1021;
	THREE.LuminanceFormat = 1022;
	THREE.LuminanceAlphaFormat = 1023;
	// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
	THREE.RGBEFormat = THREE.RGBAFormat; //1024;
	
	// DDS / ST3C Compressed texture formats
	
	THREE.RGB_S3TC_DXT1_Format = 2001;
	THREE.RGBA_S3TC_DXT1_Format = 2002;
	THREE.RGBA_S3TC_DXT3_Format = 2003;
	THREE.RGBA_S3TC_DXT5_Format = 2004;
	
	
	// PVRTC compressed texture formats
	
	THREE.RGB_PVRTC_4BPPV1_Format = 2100;
	THREE.RGB_PVRTC_2BPPV1_Format = 2101;
	THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
	THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
	
	// ETC compressed texture formats
	
	THREE.RGB_ETC1_Format = 2151;
	
	// Loop styles for AnimationAction
	
	THREE.LoopOnce = 2200;
	THREE.LoopRepeat = 2201;
	THREE.LoopPingPong = 2202;
	
	// Interpolation
	
	THREE.InterpolateDiscrete = 2300;
	THREE.InterpolateLinear = 2301;
	THREE.InterpolateSmooth = 2302;
	
	// Interpolant ending modes
	
	THREE.ZeroCurvatureEnding = 2400;
	THREE.ZeroSlopeEnding = 2401;
	THREE.WrapAroundEnding = 2402;
	
	// Triangle Draw modes
	
	THREE.TrianglesDrawMode = 0;
	THREE.TriangleStripDrawMode = 1;
	THREE.TriangleFanDrawMode = 2;
	
	// File:src/math/Color.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Color = function ( color ) {
	
		if ( arguments.length === 3 ) {
	
			return this.fromArray( arguments );
	
		}
	
		return this.set( color );
	
	};
	
	THREE.Color.prototype = {
	
		constructor: THREE.Color,
	
		r: 1, g: 1, b: 1,
	
		set: function ( value ) {
	
			if ( value instanceof THREE.Color ) {
	
				this.copy( value );
	
			} else if ( typeof value === 'number' ) {
	
				this.setHex( value );
	
			} else if ( typeof value === 'string' ) {
	
				this.setStyle( value );
	
			}
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.r = scalar;
			this.g = scalar;
			this.b = scalar;
	
		},
	
		setHex: function ( hex ) {
	
			hex = Math.floor( hex );
	
			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;
	
			return this;
	
		},
	
		setRGB: function ( r, g, b ) {
	
			this.r = r;
			this.g = g;
			this.b = b;
	
			return this;
	
		},
	
		setHSL: function () {
	
			function hue2rgb( p, q, t ) {
	
				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;
	
			}
	
			return function ( h, s, l ) {
	
				// h,s,l ranges are in 0.0 - 1.0
				h = THREE.Math.euclideanModulo( h, 1 );
				s = THREE.Math.clamp( s, 0, 1 );
				l = THREE.Math.clamp( l, 0, 1 );
	
				if ( s === 0 ) {
	
					this.r = this.g = this.b = l;
	
				} else {
	
					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;
	
					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );
	
				}
	
				return this;
	
			};
	
		}(),
	
		setStyle: function ( style ) {
	
			function handleAlpha( string ) {
	
				if ( string === undefined ) return;
	
				if ( parseFloat( string ) < 1 ) {
	
					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );
	
				}
	
			}
	
	
			var m;
	
			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {
	
				// rgb / hsl
	
				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];
	
				switch ( name ) {
	
					case 'rgb':
					case 'rgba':
	
						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
	
							handleAlpha( color[ 5 ] );
	
							return this;
	
						}
	
						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
	
							handleAlpha( color[ 5 ] );
	
							return this;
	
						}
	
						break;
	
					case 'hsl':
					case 'hsla':
	
						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;
	
							handleAlpha( color[ 5 ] );
	
							return this.setHSL( h, s, l );
	
						}
	
						break;
	
				}
	
			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {
	
				// hex color
	
				var hex = m[ 1 ];
				var size = hex.length;
	
				if ( size === 3 ) {
	
					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;
	
					return this;
	
				} else if ( size === 6 ) {
	
					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;
	
					return this;
	
				}
	
			}
	
			if ( style && style.length > 0 ) {
	
				// color keywords
				var hex = THREE.ColorKeywords[ style ];
	
				if ( hex !== undefined ) {
	
					// red
					this.setHex( hex );
	
				} else {
	
					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );
	
				}
	
			}
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this.r, this.g, this.b );
	
		},
	
		copy: function ( color ) {
	
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
	
			return this;
	
		},
	
		copyGammaToLinear: function ( color, gammaFactor ) {
	
			if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );
	
			return this;
	
		},
	
		copyLinearToGamma: function ( color, gammaFactor ) {
	
			if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;
	
			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );
	
			return this;
	
		},
	
		convertGammaToLinear: function () {
	
			var r = this.r, g = this.g, b = this.b;
	
			this.r = r * r;
			this.g = g * g;
			this.b = b * b;
	
			return this;
	
		},
	
		convertLinearToGamma: function () {
	
			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );
	
			return this;
	
		},
	
		getHex: function () {
	
			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	
		},
	
		getHexString: function () {
	
			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
	
		},
	
		getHSL: function ( optionalTarget ) {
	
			// h,s,l ranges are in 0.0 - 1.0
	
			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };
	
			var r = this.r, g = this.g, b = this.b;
	
			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );
	
			var hue, saturation;
			var lightness = ( min + max ) / 2.0;
	
			if ( min === max ) {
	
				hue = 0;
				saturation = 0;
	
			} else {
	
				var delta = max - min;
	
				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
	
				switch ( max ) {
	
					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;
	
				}
	
				hue /= 6;
	
			}
	
			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;
	
			return hsl;
	
		},
	
		getStyle: function () {
	
			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	
		},
	
		offsetHSL: function ( h, s, l ) {
	
			var hsl = this.getHSL();
	
			hsl.h += h; hsl.s += s; hsl.l += l;
	
			this.setHSL( hsl.h, hsl.s, hsl.l );
	
			return this;
	
		},
	
		add: function ( color ) {
	
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
	
			return this;
	
		},
	
		addColors: function ( color1, color2 ) {
	
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.r += s;
			this.g += s;
			this.b += s;
	
			return this;
	
		},
	
		multiply: function ( color ) {
	
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.r *= s;
			this.g *= s;
			this.b *= s;
	
			return this;
	
		},
	
		lerp: function ( color, alpha ) {
	
			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;
	
			return this;
	
		},
	
		equals: function ( c ) {
	
			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;
	
			return array;
	
		}
	
	};
	
	THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
	
	// File:src/math/Quaternion.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Quaternion = function ( x, y, z, w ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.Quaternion.prototype = {
	
		constructor: THREE.Quaternion,
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this.onChangeCallback();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this.onChangeCallback();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this.onChangeCallback();
	
		},
	
		get w () {
	
			return this._w;
	
		},
	
		set w ( value ) {
	
			this._w = value;
			this.onChangeCallback();
	
		},
	
		set: function ( x, y, z, w ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this._x, this._y, this._z, this._w );
	
		},
	
		copy: function ( quaternion ) {
	
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromEuler: function ( euler, update ) {
	
			if ( euler instanceof THREE.Euler === false ) {
	
				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
			}
	
			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m
	
			var c1 = Math.cos( euler._x / 2 );
			var c2 = Math.cos( euler._y / 2 );
			var c3 = Math.cos( euler._z / 2 );
			var s1 = Math.sin( euler._x / 2 );
			var s2 = Math.sin( euler._y / 2 );
			var s3 = Math.sin( euler._z / 2 );
	
			var order = euler.order;
	
			if ( order === 'XYZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'YXZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'ZXY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'ZYX' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'YZX' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'XZY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			}
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromAxisAngle: function ( axis, angle ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	
			// assumes axis is normalized
	
			var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
	
				trace = m11 + m22 + m33,
				s;
	
			if ( trace > 0 ) {
	
				s = 0.5 / Math.sqrt( trace + 1.0 );
	
				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;
	
			} else if ( m11 > m22 && m11 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;
	
			} else if ( m22 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;
	
			} else {
	
				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromUnitVectors: function () {
	
			// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
	
			// assumes direction vectors vFrom and vTo are normalized
	
			var v1, r;
	
			var EPS = 0.000001;
	
			return function ( vFrom, vTo ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				r = vFrom.dot( vTo ) + 1;
	
				if ( r < EPS ) {
	
					r = 0;
	
					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	
						v1.set( - vFrom.y, vFrom.x, 0 );
	
					} else {
	
						v1.set( 0, - vFrom.z, vFrom.y );
	
					}
	
				} else {
	
					v1.crossVectors( vFrom, vTo );
	
				}
	
				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;
	
				this.normalize();
	
				return this;
	
			};
	
		}(),
	
		inverse: function () {
	
			this.conjugate().normalize();
	
			return this;
	
		},
	
		conjugate: function () {
	
			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	
		},
	
		lengthSq: function () {
	
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	
		},
	
		normalize: function () {
	
			var l = this.length();
	
			if ( l === 0 ) {
	
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
	
			} else {
	
				l = 1 / l;
	
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		multiply: function ( q, p ) {
	
			if ( p !== undefined ) {
	
				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );
	
			}
	
			return this.multiplyQuaternions( this, q );
	
		},
	
		multiplyQuaternions: function ( a, b ) {
	
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		slerp: function ( qb, t ) {
	
			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );
	
			var x = this._x, y = this._y, z = this._z, w = this._w;
	
			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
			if ( cosHalfTheta < 0 ) {
	
				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;
	
				cosHalfTheta = - cosHalfTheta;
	
			} else {
	
				this.copy( qb );
	
			}
	
			if ( cosHalfTheta >= 1.0 ) {
	
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
	
				return this;
	
			}
	
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
			if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	
				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );
	
				return this;
	
			}
	
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		equals: function ( quaternion ) {
	
			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;
	
			return array;
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {}
	
	};
	
	Object.assign( THREE.Quaternion, {
	
		slerp: function( qa, qb, qm, t ) {
	
			return qm.copy( qa ).slerp( qb, t );
	
		},
	
		slerpFlat: function(
				dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {
	
			// fuzz-free, array-based Quaternion SLERP operation
	
			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],
	
				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];
	
			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {
	
				var s = 1 - t,
	
					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
	
					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;
	
				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {
	
					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );
	
					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;
	
				}
	
				var tDir = t * dir;
	
				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;
	
				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {
	
					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );
	
					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
	
				}
	
			}
	
			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
	
		}
	
	} );
	
	// File:src/math/Vector2.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.Vector2 = function ( x, y ) {
	
		this.x = x || 0;
		this.y = y || 0;
	
	};
	
	THREE.Vector2.prototype = {
	
		constructor: THREE.Vector2,
	
		get width() {
	
			return this.x;
	
		},
	
		set width( value ) {
	
			this.x = value;
	
		},
	
		get height() {
	
			return this.y;
	
		},
	
		set height( value ) {
	
			this.y = value;
	
		},
	
		//
	
		set: function ( x, y ) {
	
			this.x = x;
			this.y = y;
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.x = scalar;
			this.y = scalar;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
	
			return this;
	
		},
	
		multiply: function ( v ) {
	
			this.x *= v.x;
			this.y *= v.y;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			if ( isFinite( scalar ) ) {
	
				this.x *= scalar;
				this.y *= scalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
	
			}
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min, max;
	
			return function clampScalar( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector2();
					max = new THREE.Vector2();
	
				}
	
				min.set( minVal, minVal );
				max.set( maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		clampLength: function ( min, max ) {
	
			var length = this.length();
	
			this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
			return this;
	
		},
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y );
	
		},
	
		lengthManhattan: function() {
	
			return Math.abs( this.x ) + Math.abs( this.y );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		angle: function () {
	
			// computes the angle in radians with respect to the positive x-axis
	
			var angle = Math.atan2( this.y, this.x );
	
			if ( angle < 0 ) angle += 2 * Math.PI;
	
			return angle;
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;
	
		},
	
		setLength: function ( length ) {
	
			return this.multiplyScalar( length / this.length() );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
	
			return this;
	
		},
	
		rotateAround: function ( center, angle ) {
	
			var c = Math.cos( angle ), s = Math.sin( angle );
	
			var x = this.x - center.x;
			var y = this.y - center.y;
	
			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;
	
			return this;
	
		}
	
	};
	
	// File:src/math/Vector3.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector3 = function ( x, y, z ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
	
	};
	
	THREE.Vector3.prototype = {
	
		constructor: THREE.Vector3,
	
		set: function ( x, y, z ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y, this.z );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
			this.z -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
	
			return this;
	
		},
	
		multiply: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );
	
			}
	
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			if ( isFinite( scalar ) ) {
	
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
	
			}
	
			return this;
	
		},
	
		multiplyVectors: function ( a, b ) {
	
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
	
			return this;
	
		},
	
		applyEuler: function () {
	
			var quaternion;
	
			return function applyEuler( euler ) {
	
				if ( euler instanceof THREE.Euler === false ) {
	
					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
				}
	
				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();
	
				this.applyQuaternion( quaternion.setFromEuler( euler ) );
	
				return this;
	
			};
	
		}(),
	
		applyAxisAngle: function () {
	
			var quaternion;
	
			return function applyAxisAngle( axis, angle ) {
	
				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();
	
				this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
	
				return this;
	
			};
	
		}(),
	
		applyMatrix3: function ( m ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];
	
			return this;
	
		},
	
		applyProjection: function ( m ) {
	
			// input: THREE.Matrix4 projection matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
			var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide
	
			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;
	
			return this;
	
		},
	
		applyQuaternion: function ( q ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var qx = q.x;
			var qy = q.y;
			var qz = q.z;
			var qw = q.w;
	
			// calculate quat * vector
	
			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;
	
			// calculate result * inverse quat
	
			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
	
			return this;
	
		},
	
		project: function () {
	
			var matrix;
	
			return function project( camera ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyProjection( matrix );
	
			};
	
		}(),
	
		unproject: function () {
	
			var matrix;
	
			return function unproject( camera ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyProjection( matrix );
	
			};
	
		}(),
	
		transformDirection: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
	
			this.normalize();
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min, max;
	
			return function clampScalar( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector3();
					max = new THREE.Vector3();
	
				}
	
				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		clampLength: function ( min, max ) {
	
			var length = this.length();
	
			this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
			return this;
	
		},
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( length ) {
	
			return this.multiplyScalar( length / this.length() );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			return this;
	
		},
	
		cross: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );
	
			}
	
			var x = this.x, y = this.y, z = this.z;
	
			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;
	
			return this;
	
		},
	
		crossVectors: function ( a, b ) {
	
			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;
	
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
	
			return this;
	
		},
	
		projectOnVector: function () {
	
			var v1, dot;
	
			return function projectOnVector( vector ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				v1.copy( vector ).normalize();
	
				dot = this.dot( v1 );
	
				return this.copy( v1 ).multiplyScalar( dot );
	
			};
	
		}(),
	
		projectOnPlane: function () {
	
			var v1;
	
			return function projectOnPlane( planeNormal ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				v1.copy( this ).projectOnVector( planeNormal );
	
				return this.sub( v1 );
	
			}
	
		}(),
	
		reflect: function () {
	
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
	
			var v1;
	
			return function reflect( normal ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
	
			}
	
		}(),
	
		angleTo: function ( v ) {
	
			var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );
	
			// clamp, to handle numerical problems
	
			return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x;
			var dy = this.y - v.y;
			var dz = this.z - v.z;
	
			return dx * dx + dy * dy + dz * dz;
	
		},
	
		setFromMatrixPosition: function ( m ) {
	
			this.x = m.elements[ 12 ];
			this.y = m.elements[ 13 ];
			this.z = m.elements[ 14 ];
	
			return this;
	
		},
	
		setFromMatrixScale: function ( m ) {
	
			var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
			var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
			var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();
	
			this.x = sx;
			this.y = sy;
			this.z = sz;
	
			return this;
	
		},
	
		setFromMatrixColumn: function ( index, matrix ) {
	
			var offset = index * 4;
	
			var me = matrix.elements;
	
			this.x = me[ offset ];
			this.y = me[ offset + 1 ];
			this.z = me[ offset + 2 ];
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
	
			return this;
	
		}
	
	};
	
	// File:src/math/Vector4.js
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector4 = function ( x, y, z, w ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.Vector4.prototype = {
	
		constructor: THREE.Vector4,
	
		set: function ( x, y, z, w ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setW: function ( w ) {
	
			this.w = w;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y, this.z, this.w );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			if ( isFinite( scalar ) ) {
	
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
				this.w *= scalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 0;
	
			}
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
			var w = this.w;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		setAxisAngleFromQuaternion: function ( q ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	
			// q is assumed to be normalized
	
			this.w = 2 * Math.acos( q.w );
	
			var s = Math.sqrt( 1 - q.w * q.w );
	
			if ( s < 0.0001 ) {
	
				 this.x = 1;
				 this.y = 0;
				 this.z = 0;
	
			} else {
	
				 this.x = q.x / s;
				 this.y = q.y / s;
				 this.z = q.z / s;
	
			}
	
			return this;
	
		},
	
		setAxisAngleFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
	
				te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			if ( ( Math.abs( m12 - m21 ) < epsilon )
			   && ( Math.abs( m13 - m31 ) < epsilon )
			   && ( Math.abs( m23 - m32 ) < epsilon ) ) {
	
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
	
				if ( ( Math.abs( m12 + m21 ) < epsilon2 )
				   && ( Math.abs( m13 + m31 ) < epsilon2 )
				   && ( Math.abs( m23 + m32 ) < epsilon2 )
				   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
	
					// this singularity is identity matrix so angle = 0
	
					this.set( 1, 0, 0, 0 );
	
					return this; // zero angle, arbitrary axis
	
				}
	
				// otherwise this singularity is angle = 180
	
				angle = Math.PI;
	
				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;
	
				if ( ( xx > yy ) && ( xx > zz ) ) {
	
					// m11 is the largest diagonal term
	
					if ( xx < epsilon ) {
	
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
	
					} else {
	
						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;
	
					}
	
				} else if ( yy > zz ) {
	
					// m22 is the largest diagonal term
	
					if ( yy < epsilon ) {
	
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
	
					} else {
	
						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;
	
					}
	
				} else {
	
					// m33 is the largest diagonal term so base result on this
	
					if ( zz < epsilon ) {
	
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
	
					} else {
	
						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;
	
					}
	
				}
	
				this.set( x, y, z, angle );
	
				return this; // return 180 deg rotation
	
			}
	
			// as we have reached here there are no singularities so we can handle normally
	
			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
							  + ( m13 - m31 ) * ( m13 - m31 )
							  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
	
			if ( Math.abs( s ) < 0.001 ) s = 1;
	
			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case
	
			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
	
			return this;
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min, max;
	
			return function clampScalar( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector4();
					max = new THREE.Vector4();
	
				}
	
				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( length ) {
	
			return this.multiplyScalar( length / this.length() );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
			this.w = attribute.array[ index + 3 ];
	
			return this;
	
		}
	
	};
	
	// File:src/math/Euler.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Euler = function ( x, y, z, order ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;
	
	};
	
	THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
	
	THREE.Euler.DefaultOrder = 'XYZ';
	
	THREE.Euler.prototype = {
	
		constructor: THREE.Euler,
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this.onChangeCallback();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this.onChangeCallback();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this.onChangeCallback();
	
		},
	
		get order () {
	
			return this._order;
	
		},
	
		set order ( value ) {
	
			this._order = value;
			this.onChangeCallback();
	
		},
	
		set: function ( x, y, z, order ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this._x, this._y, this._z, this._order );
	
		},
	
		copy: function ( euler ) {
	
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m, order, update ) {
	
			var clamp = THREE.Math.clamp;
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			order = order || this._order;
	
			if ( order === 'XYZ' ) {
	
				this._y = Math.asin( clamp( m13, - 1, 1 ) );
	
				if ( Math.abs( m13 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );
	
				} else {
	
					this._x = Math.atan2( m32, m22 );
					this._z = 0;
	
				}
	
			} else if ( order === 'YXZ' ) {
	
				this._x = Math.asin( - clamp( m23, - 1, 1 ) );
	
				if ( Math.abs( m23 ) < 0.99999 ) {
	
					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );
	
				} else {
	
					this._y = Math.atan2( - m31, m11 );
					this._z = 0;
	
				}
	
			} else if ( order === 'ZXY' ) {
	
				this._x = Math.asin( clamp( m32, - 1, 1 ) );
	
				if ( Math.abs( m32 ) < 0.99999 ) {
	
					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );
	
				} else {
	
					this._y = 0;
					this._z = Math.atan2( m21, m11 );
	
				}
	
			} else if ( order === 'ZYX' ) {
	
				this._y = Math.asin( - clamp( m31, - 1, 1 ) );
	
				if ( Math.abs( m31 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );
	
				} else {
	
					this._x = 0;
					this._z = Math.atan2( - m12, m22 );
	
				}
	
			} else if ( order === 'YZX' ) {
	
				this._z = Math.asin( clamp( m21, - 1, 1 ) );
	
				if ( Math.abs( m21 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );
	
				} else {
	
					this._x = 0;
					this._y = Math.atan2( m13, m33 );
	
				}
	
			} else if ( order === 'XZY' ) {
	
				this._z = Math.asin( - clamp( m12, - 1, 1 ) );
	
				if ( Math.abs( m12 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );
	
				} else {
	
					this._x = Math.atan2( - m23, m33 );
					this._y = 0;
	
				}
	
			} else {
	
				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )
	
			}
	
			this._order = order;
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromQuaternion: function () {
	
			var matrix;
	
			return function ( q, order, update ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
				matrix.makeRotationFromQuaternion( q );
				this.setFromRotationMatrix( matrix, order, update );
	
				return this;
	
			};
	
		}(),
	
		setFromVector3: function ( v, order ) {
	
			return this.set( v.x, v.y, v.z, order || this._order );
	
		},
	
		reorder: function () {
	
			// WARNING: this discards revolution information -bhouston
	
			var q = new THREE.Quaternion();
	
			return function ( newOrder ) {
	
				q.setFromEuler( this );
				this.setFromQuaternion( q, newOrder );
	
			};
	
		}(),
	
		equals: function ( euler ) {
	
			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	
		},
	
		fromArray: function ( array ) {
	
			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;
	
			return array;
	
		},
	
		toVector3: function ( optionalResult ) {
	
			if ( optionalResult ) {
	
				return optionalResult.set( this._x, this._y, this._z );
	
			} else {
	
				return new THREE.Vector3( this._x, this._y, this._z );
	
			}
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {}
	
	};
	
	// File:src/math/Line3.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Line3 = function ( start, end ) {
	
		this.start = ( start !== undefined ) ? start : new THREE.Vector3();
		this.end = ( end !== undefined ) ? end : new THREE.Vector3();
	
	};
	
	THREE.Line3.prototype = {
	
		constructor: THREE.Line3,
	
		set: function ( start, end ) {
	
			this.start.copy( start );
			this.end.copy( end );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( line ) {
	
			this.start.copy( line.start );
			this.end.copy( line.end );
	
			return this;
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
	
		},
	
		delta: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.end, this.start );
	
		},
	
		distanceSq: function () {
	
			return this.start.distanceToSquared( this.end );
	
		},
	
		distance: function () {
	
			return this.start.distanceTo( this.end );
	
		},
	
		at: function ( t, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			return this.delta( result ).multiplyScalar( t ).add( this.start );
	
		},
	
		closestPointToPointParameter: function () {
	
			var startP = new THREE.Vector3();
			var startEnd = new THREE.Vector3();
	
			return function ( point, clampToLine ) {
	
				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );
	
				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );
	
				var t = startEnd_startP / startEnd2;
	
				if ( clampToLine ) {
	
					t = THREE.Math.clamp( t, 0, 1 );
	
				}
	
				return t;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {
	
			var t = this.closestPointToPointParameter( point, clampToLine );
	
			var result = optionalTarget || new THREE.Vector3();
	
			return this.delta( result ).multiplyScalar( t ).add( this.start );
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );
	
			return this;
	
		},
	
		equals: function ( line ) {
	
			return line.start.equals( this.start ) && line.end.equals( this.end );
	
		}
	
	};
	
	// File:src/math/Box2.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Box2 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );
	
	};
	
	THREE.Box2.prototype = {
	
		constructor: THREE.Box2,
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromPoints: function ( points ) {
	
			this.makeEmpty();
	
			for ( var i = 0, il = points.length; i < il; i ++ ) {
	
				this.expandByPoint( points[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function () {
	
			var v1 = new THREE.Vector2();
	
			return function ( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;
	
			return this;
	
		},
	
		isEmpty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
	
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
	
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
	
			return this;
	
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point, optionalTarget ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			var result = optionalTarget || new THREE.Vector2();
	
			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);
	
		},
	
		intersectsBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new THREE.Vector2();
	
			return function ( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		}
	
	};
	
	// File:src/math/Box3.js
	
	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Box3 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );
	
	};
	
	THREE.Box3.prototype = {
	
		constructor: THREE.Box3,
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromArray: function ( array ) {
	
			this.makeEmpty();
	
			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;
	
			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;
	
			for ( var i = 0, il = array.length; i < il; i += 3 ) {
	
				var x = array[ i ];
				var y = array[ i + 1 ];
				var z = array[ i + 2 ];
	
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;
	
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;
	
			}
	
			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );
	
		},
	
		setFromPoints: function ( points ) {
	
			this.makeEmpty();
	
			for ( var i = 0, il = points.length; i < il; i ++ ) {
	
				this.expandByPoint( points[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
	
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		setFromObject: function () {
	
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms
	
			var box;
	
			return function ( object ) {
	
				if ( box === undefined ) box = new THREE.Box3();
	
				var scope = this;
	
				this.makeEmpty();
	
				object.updateMatrixWorld( true );
	
				object.traverse( function ( node ) {
	
					var geometry = node.geometry;
	
					if ( geometry !== undefined ) {
	
						if ( geometry.boundingBox === null ) {
	
							geometry.computeBoundingBox();
	
						}
	
						box.copy( geometry.boundingBox );
						box.applyMatrix4( node.matrixWorld );
						scope.union( box );
	
					}
	
				} );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;
	
			return this;
	
		},
	
		isEmpty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
	
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
	
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
	
			return this;
	
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
					 point.y < this.min.y || point.y > this.max.y ||
					 point.z < this.min.z || point.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
				 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point, optionalTarget ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			var result = optionalTarget || new THREE.Vector3();
	
			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);
	
		},
	
		intersectsBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
					 box.max.y < this.min.y || box.min.y > this.max.y ||
					 box.max.z < this.min.z || box.min.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		intersectsSphere: ( function () {
	
			var closestPoint;
	
			return function intersectsSphere( sphere ) {
	
				if ( closestPoint === undefined ) closestPoint = new THREE.Vector3();
	
				// Find the point on the AABB closest to the sphere center.
				this.clampPoint( sphere.center, closestPoint );
	
				// If that point is inside the sphere, the AABB and sphere intersect.
				return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );
	
			};
	
		} )(),
	
		intersectsPlane: function ( plane ) {
	
			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.
	
			var min, max;
	
			if ( plane.normal.x > 0 ) {
	
				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;
	
			} else {
	
				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;
	
			}
	
			if ( plane.normal.y > 0 ) {
	
				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;
	
			} else {
	
				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;
	
			}
	
			if ( plane.normal.z > 0 ) {
	
				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;
	
			} else {
	
				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;
	
			}
	
			return ( min <= plane.constant && max >= plane.constant );
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		getBoundingSphere: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Sphere();
	
				result.center = this.center();
				result.radius = this.size( v1 ).length() * 0.5;
	
				return result;
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		applyMatrix4: function () {
	
			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
			];
	
			return function ( matrix ) {
	
				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111
	
				this.makeEmpty();
				this.setFromPoints( points );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		}
	
	};
	
	// File:src/math/Matrix3.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Matrix3 = function () {
	
		this.elements = new Float32Array( [
	
			1, 0, 0,
			0, 1, 0,
			0, 0, 1
	
		] );
	
		if ( arguments.length > 0 ) {
	
			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
	
		}
	
	};
	
	THREE.Matrix3.prototype = {
	
		constructor: THREE.Matrix3,
	
		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
			te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
			te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
	
			);
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().fromArray( this.elements );
	
		},
	
		copy: function ( m ) {
	
			var me = m.elements;
	
			this.set(
	
				me[ 0 ], me[ 3 ], me[ 6 ],
				me[ 1 ], me[ 4 ], me[ 7 ],
				me[ 2 ], me[ 5 ], me[ 8 ]
	
			);
	
			return this;
	
		},
	
		applyToVector3Array: function () {
	
			var v1;
	
			return function ( array, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;
	
				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {
	
					v1.fromArray( array, j );
					v1.applyMatrix3( this );
					v1.toArray( array, j );
	
				}
	
				return array;
	
			};
	
		}(),
	
		applyToBuffer: function () {
	
			var v1;
	
			return function applyToBuffer( buffer, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;
	
				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {
	
					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );
	
					v1.applyMatrix3( this );
	
					buffer.setXYZ( v1.x, v1.y, v1.z );
	
				}
	
				return buffer;
	
			};
	
		}(),
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
	
			return this;
	
		},
	
		determinant: function () {
	
			var te = this.elements;
	
			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
	
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	
		},
	
		getInverse: function ( matrix, throwOnDegenerate ) {
	
			// input: THREE.Matrix4
			// ( based on http://code.google.com/p/webgl-mjs/ )
	
			var me = matrix.elements;
			var te = this.elements;
	
			te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
			te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
			te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
			te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
			te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
			te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
			te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
			te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
			te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];
	
			var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];
	
			// no inverse
	
			if ( det === 0 ) {
	
				var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnDegenerate || false ) {
	
					throw new Error( msg );
	
				} else {
	
					console.warn( msg );
	
				}
	
				this.identity();
	
				return this;
	
			}
	
			this.multiplyScalar( 1.0 / det );
	
			return this;
	
		},
	
		transpose: function () {
	
			var tmp, m = this.elements;
	
			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
	
			return this;
	
		},
	
		flattenToArrayOffset: function ( array, offset ) {
	
			var te = this.elements;
	
			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
	
			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
	
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ]  = te[ 8 ];
	
			return array;
	
		},
	
		getNormalMatrix: function ( m ) {
	
			// input: THREE.Matrix4
	
			this.getInverse( m ).transpose();
	
			return this;
	
		},
	
		transposeIntoArray: function ( r ) {
	
			var m = this.elements;
	
			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];
	
			return this;
	
		},
	
		fromArray: function ( array ) {
	
			this.elements.set( array );
	
			return this;
	
		},
	
		toArray: function () {
	
			var te = this.elements;
	
			return [
				te[ 0 ], te[ 1 ], te[ 2 ],
				te[ 3 ], te[ 4 ], te[ 5 ],
				te[ 6 ], te[ 7 ], te[ 8 ]
			];
	
		}
	
	};
	
	// File:src/math/Matrix4.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Matrix4 = function () {
	
		this.elements = new Float32Array( [
	
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
	
		] );
	
		if ( arguments.length > 0 ) {
	
			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
	
		}
	
	};
	
	THREE.Matrix4.prototype = {
	
		constructor: THREE.Matrix4,
	
		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		clone: function () {
	
			return new THREE.Matrix4().fromArray( this.elements );
	
		},
	
		copy: function ( m ) {
	
			this.elements.set( m.elements );
	
			return this;
	
		},
	
		copyPosition: function ( m ) {
	
			var te = this.elements;
			var me = m.elements;
	
			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];
	
			return this;
	
		},
	
		extractBasis: function ( xAxis, yAxis, zAxis ) {
	
			var te = this.elements;
	
			xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
			yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
			zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );
	
			return this;
	
		},
	
		makeBasis: function ( xAxis, yAxis, zAxis ) {
	
			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0,       0,       0,       1
			);
	
			return this;
	
		},
	
		extractRotation: function () {
	
			var v1;
	
			return function ( m ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				var te = this.elements;
				var me = m.elements;
	
				var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
				var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
				var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();
	
				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;
	
				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;
	
				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;
	
				return this;
	
			};
	
		}(),
	
		makeRotationFromEuler: function ( euler ) {
	
			if ( euler instanceof THREE.Euler === false ) {
	
				console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
			}
	
			var te = this.elements;
	
			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );
	
			if ( euler.order === 'XYZ' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;
	
				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;
	
				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YXZ' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;
	
				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;
	
				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZXY' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;
	
				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;
	
				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZYX' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;
	
				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;
	
				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YZX' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;
	
				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;
	
				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;
	
			} else if ( euler.order === 'XZY' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;
	
				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;
	
				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;
	
			}
	
			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
	
			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
	
			return this;
	
		},
	
		makeRotationFromQuaternion: function ( q ) {
	
			var te = this.elements;
	
			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;
	
			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;
	
			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;
	
			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );
	
			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
	
			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
	
			return this;
	
		},
	
		lookAt: function () {
	
			var x, y, z;
	
			return function ( eye, target, up ) {
	
				if ( x === undefined ) x = new THREE.Vector3();
				if ( y === undefined ) y = new THREE.Vector3();
				if ( z === undefined ) z = new THREE.Vector3();
	
				var te = this.elements;
	
				z.subVectors( eye, target ).normalize();
	
				if ( z.lengthSq() === 0 ) {
	
					z.z = 1;
	
				}
	
				x.crossVectors( up, z ).normalize();
	
				if ( x.lengthSq() === 0 ) {
	
					z.x += 0.0001;
					x.crossVectors( up, z ).normalize();
	
				}
	
				y.crossVectors( z, x );
	
	
				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;
	
				return this;
	
			};
	
		}(),
	
		multiply: function ( m, n ) {
	
			if ( n !== undefined ) {
	
				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );
	
			}
	
			return this.multiplyMatrices( this, m );
	
		},
	
		multiplyMatrices: function ( a, b ) {
	
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
	
			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
	
			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
	
			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	
			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	
			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	
			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
			return this;
	
		},
	
		multiplyToArray: function ( a, b, r ) {
	
			var te = this.elements;
	
			this.multiplyMatrices( a, b );
	
			r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
			r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
			r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
			r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
	
			return this;
	
		},
	
		applyToVector3Array: function () {
	
			var v1;
	
			return function ( array, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;
	
				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {
	
					v1.fromArray( array, j );
					v1.applyMatrix4( this );
					v1.toArray( array, j );
	
				}
	
				return array;
	
			};
	
		}(),
	
		applyToBuffer: function () {
	
			var v1;
	
			return function applyToBuffer( buffer, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;
	
				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {
	
					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );
	
					v1.applyMatrix4( this );
	
					buffer.setXYZ( v1.x, v1.y, v1.z );
	
				}
	
				return buffer;
	
			};
	
		}(),
	
		determinant: function () {
	
			var te = this.elements;
	
			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
	
			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	
			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)
	
			);
	
		},
	
		transpose: function () {
	
			var te = this.elements;
			var tmp;
	
			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
	
			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
	
			return this;
	
		},
	
		flattenToArrayOffset: function ( array, offset ) {
	
			var te = this.elements;
	
			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];
	
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
	
			array[ offset + 8 ]  = te[ 8 ];
			array[ offset + 9 ]  = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];
	
			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];
	
			return array;
	
		},
	
		getPosition: function () {
	
			var v1;
	
			return function () {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	
				var te = this.elements;
				return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );
	
			};
	
		}(),
	
		setPosition: function ( v ) {
	
			var te = this.elements;
	
			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;
	
			return this;
	
		},
	
		getInverse: function ( m, throwOnInvertible ) {
	
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements;
			var me = m.elements;
	
			var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
			var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
			var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
			var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];
	
			te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
			te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
			te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
			te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
			te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
			te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
			te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
			te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
			te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
			te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
			te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
			te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
			te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
			te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
			te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
	
			var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];
	
			if ( det === 0 ) {
	
				var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnInvertible || false ) {
	
					throw new Error( msg );
	
				} else {
	
					console.warn( msg );
	
				}
	
				this.identity();
	
				return this;
	
			}
	
			this.multiplyScalar( 1 / det );
	
			return this;
	
		},
	
		scale: function ( v ) {
	
			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;
	
			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
	
			return this;
	
		},
	
		getMaxScaleOnAxis: function () {
	
			var te = this.elements;
	
			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
	
			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
	
		},
	
		makeTranslation: function ( x, y, z ) {
	
			this.set(
	
				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationX: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				1, 0,  0, 0,
				0, c, - s, 0,
				0, s,  c, 0,
				0, 0,  0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationY: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationZ: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				c, - s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationAxis: function ( axis, angle ) {
	
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
	
			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;
	
			this.set(
	
				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1
	
			);
	
			 return this;
	
		},
	
		makeScale: function ( x, y, z ) {
	
			this.set(
	
				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		compose: function ( position, quaternion, scale ) {
	
			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );
	
			return this;
	
		},
	
		decompose: function () {
	
			var vector, matrix;
	
			return function ( position, quaternion, scale ) {
	
				if ( vector === undefined ) vector = new THREE.Vector3();
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				var te = this.elements;
	
				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
	
				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) {
	
					sx = - sx;
	
				}
	
				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];
	
				// scale the rotation part
	
				matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()
	
				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;
	
				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;
	
				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;
	
				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;
	
				quaternion.setFromRotationMatrix( matrix );
	
				scale.x = sx;
				scale.y = sy;
				scale.z = sz;
	
				return this;
	
			};
	
		}(),
	
		makeFrustum: function ( left, right, bottom, top, near, far ) {
	
			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );
	
			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );
	
			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
	
			return this;
	
		},
	
		makePerspective: function ( fov, aspect, near, far ) {
	
			var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;
	
			return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );
	
		},
	
		makeOrthographic: function ( left, right, top, bottom, near, far ) {
	
			var te = this.elements;
			var w = right - left;
			var h = top - bottom;
			var p = far - near;
	
			var x = ( right + left ) / w;
			var y = ( top + bottom ) / h;
			var z = ( far + near ) / p;
	
			te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
	
			return this;
	
		},
	
		equals: function ( matrix ) {
	
			var te = this.elements;
			var me = matrix.elements;
	
			for ( var i = 0; i < 16; i ++ ) {
	
				if ( te[ i ] !== me[ i ] ) return false;
	
			}
	
			return true;
	
		},
	
		fromArray: function ( array ) {
	
			this.elements.set( array );
	
			return this;
	
		},
	
		toArray: function () {
	
			var te = this.elements;
	
			return [
				te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
				te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
				te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
				te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
			];
	
		}
	
	};
	
	// File:src/math/Ray.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Ray = function ( origin, direction ) {
	
		this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
		this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();
	
	};
	
	THREE.Ray.prototype = {
	
		constructor: THREE.Ray,
	
		set: function ( origin, direction ) {
	
			this.origin.copy( origin );
			this.direction.copy( direction );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( ray ) {
	
			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );
	
			return this;
	
		},
	
		at: function ( t, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );
	
		},
	
		lookAt: function ( v ) {
	
			this.direction.copy( v ).sub( this.origin ).normalize();
	
		},
	
		recast: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( t ) {
	
				this.origin.copy( this.at( t, v1 ) );
	
				return this;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );
	
			if ( directionDistance < 0 ) {
	
				return result.copy( this.origin );
	
			}
	
			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
		},
	
		distanceToPoint: function ( point ) {
	
			return Math.sqrt( this.distanceSqToPoint( point ) );
	
		},
	
		distanceSqToPoint: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( point ) {
	
				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
	
				// point behind the ray
	
				if ( directionDistance < 0 ) {
	
					return this.origin.distanceToSquared( point );
	
				}
	
				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
				return v1.distanceToSquared( point );
	
			};
	
		}(),
	
		distanceSqToSegment: function () {
	
			var segCenter = new THREE.Vector3();
			var segDir = new THREE.Vector3();
			var diff = new THREE.Vector3();
	
			return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
	
				// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment
	
				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );
	
				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;
	
				if ( det > 0 ) {
	
					// The ray and segment are not parallel.
	
					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;
	
					if ( s0 >= 0 ) {
	
						if ( s1 >= - extDet ) {
	
							if ( s1 <= extDet ) {
	
								// region 0
								// Minimum at interior points of ray and segment.
	
								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
	
							} else {
	
								// region 1
	
								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						} else {
	
							// region 5
	
							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						}
	
					} else {
	
						if ( s1 <= - extDet ) {
	
							// region 4
	
							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						} else if ( s1 <= extDet ) {
	
							// region 3
	
							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;
	
						} else {
	
							// region 2
	
							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						}
	
					}
	
				} else {
	
					// Ray and segment are parallel.
	
					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
				}
	
				if ( optionalPointOnRay ) {
	
					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
	
				}
	
				if ( optionalPointOnSegment ) {
	
					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );
	
				}
	
				return sqrDist;
	
			};
	
		}(),
	
		intersectSphere: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( sphere, optionalTarget ) {
	
				v1.subVectors( sphere.center, this.origin );
				var tca = v1.dot( this.direction );
				var d2 = v1.dot( v1 ) - tca * tca;
				var radius2 = sphere.radius * sphere.radius;
	
				if ( d2 > radius2 ) return null;
	
				var thc = Math.sqrt( radius2 - d2 );
	
				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;
	
				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;
	
				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;
	
				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, optionalTarget );
	
				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, optionalTarget );
	
			}
	
		}(),
	
		intersectsSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) <= sphere.radius;
	
		},
	
		distanceToPlane: function ( plane ) {
	
			var denominator = plane.normal.dot( this.direction );
	
			if ( denominator === 0 ) {
	
				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {
	
					return 0;
	
				}
	
				// Null is preferable to undefined since undefined means.... it is undefined
	
				return null;
	
			}
	
			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
	
			// Return if the ray never intersects the plane
	
			return t >= 0 ? t :  null;
	
		},
	
		intersectPlane: function ( plane, optionalTarget ) {
	
			var t = this.distanceToPlane( plane );
	
			if ( t === null ) {
	
				return null;
	
			}
	
			return this.at( t, optionalTarget );
	
		},
	
	
	
		intersectsPlane: function ( plane ) {
	
			// check if the ray lies on the plane first
	
			var distToPoint = plane.distanceToPoint( this.origin );
	
			if ( distToPoint === 0 ) {
	
				return true;
	
			}
	
			var denominator = plane.normal.dot( this.direction );
	
			if ( denominator * distToPoint < 0 ) {
	
				return true;
	
			}
	
			// ray origin is behind the plane (and is pointing behind it)
	
			return false;
	
		},
	
		intersectBox: function ( box, optionalTarget ) {
	
			var tmin, tmax, tymin, tymax, tzmin, tzmax;
	
			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;
	
			var origin = this.origin;
	
			if ( invdirx >= 0 ) {
	
				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;
	
			} else {
	
				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;
	
			}
	
			if ( invdiry >= 0 ) {
	
				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;
	
			} else {
	
				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;
	
			}
	
			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;
	
			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN
	
			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;
	
			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;
	
			if ( invdirz >= 0 ) {
	
				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;
	
			} else {
	
				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;
	
			}
	
			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;
	
			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;
	
			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;
	
			//return point closest to the ray (positive side)
	
			if ( tmax < 0 ) return null;
	
			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );
	
		},
	
		intersectsBox: ( function () {
	
			var v = new THREE.Vector3();
	
			return function ( box ) {
	
				return this.intersectBox( box, v ) !== null;
	
			};
	
		} )(),
	
		intersectTriangle: function () {
	
			// Compute the offset origin, edges, and normal.
			var diff = new THREE.Vector3();
			var edge1 = new THREE.Vector3();
			var edge2 = new THREE.Vector3();
			var normal = new THREE.Vector3();
	
			return function ( a, b, c, backfaceCulling, optionalTarget ) {
	
				// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp
	
				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );
	
				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;
	
				if ( DdN > 0 ) {
	
					if ( backfaceCulling ) return null;
					sign = 1;
	
				} else if ( DdN < 0 ) {
	
					sign = - 1;
					DdN = - DdN;
	
				} else {
	
					return null;
	
				}
	
				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );
	
				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {
	
					return null;
	
				}
	
				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );
	
				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {
	
					return null;
	
				}
	
				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {
	
					return null;
	
				}
	
				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );
	
				// t < 0, no intersection
				if ( QdN < 0 ) {
	
					return null;
	
				}
	
				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );
	
			};
	
		}(),
	
		applyMatrix4: function ( matrix4 ) {
	
			this.direction.add( this.origin ).applyMatrix4( matrix4 );
			this.origin.applyMatrix4( matrix4 );
			this.direction.sub( this.origin );
			this.direction.normalize();
	
			return this;
	
		},
	
		equals: function ( ray ) {
	
			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
	
		}
	
	};
	
	// File:src/math/Sphere.js
	
	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Sphere = function ( center, radius ) {
	
		this.center = ( center !== undefined ) ? center : new THREE.Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;
	
	};
	
	THREE.Sphere.prototype = {
	
		constructor: THREE.Sphere,
	
		set: function ( center, radius ) {
	
			this.center.copy( center );
			this.radius = radius;
	
			return this;
	
		},
	
		setFromPoints: function () {
	
			var box = new THREE.Box3();
	
			return function ( points, optionalCenter ) {
	
				var center = this.center;
	
				if ( optionalCenter !== undefined ) {
	
					center.copy( optionalCenter );
	
				} else {
	
					box.setFromPoints( points ).center( center );
	
				}
	
				var maxRadiusSq = 0;
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
	
				}
	
				this.radius = Math.sqrt( maxRadiusSq );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( sphere ) {
	
			this.center.copy( sphere.center );
			this.radius = sphere.radius;
	
			return this;
	
		},
	
		empty: function () {
	
			return ( this.radius <= 0 );
	
		},
	
		containsPoint: function ( point ) {
	
			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
	
		},
	
		distanceToPoint: function ( point ) {
	
			return ( point.distanceTo( this.center ) - this.radius );
	
		},
	
		intersectsSphere: function ( sphere ) {
	
			var radiusSum = this.radius + sphere.radius;
	
			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
	
		},
	
		intersectsBox: function ( box ) {
	
			return box.intersectsSphere( this );
	
		},
	
		intersectsPlane: function ( plane ) {
	
			// We use the following equation to compute the signed distance from
			// the center of the sphere to the plane.
			//
			// distance = q * n - d
			//
			// If this distance is greater than the radius of the sphere,
			// then there is no intersection.
	
			return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var deltaLengthSq = this.center.distanceToSquared( point );
	
			var result = optionalTarget || new THREE.Vector3();
	
			result.copy( point );
	
			if ( deltaLengthSq > ( this.radius * this.radius ) ) {
	
				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );
	
			}
	
			return result;
	
		},
	
		getBoundingBox: function ( optionalTarget ) {
	
			var box = optionalTarget || new THREE.Box3();
	
			box.set( this.center, this.center );
			box.expandByScalar( this.radius );
	
			return box;
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.center.add( offset );
	
			return this;
	
		},
	
		equals: function ( sphere ) {
	
			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
	
		}
	
	};
	
	// File:src/math/Frustum.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {
	
		this.planes = [
	
			( p0 !== undefined ) ? p0 : new THREE.Plane(),
			( p1 !== undefined ) ? p1 : new THREE.Plane(),
			( p2 !== undefined ) ? p2 : new THREE.Plane(),
			( p3 !== undefined ) ? p3 : new THREE.Plane(),
			( p4 !== undefined ) ? p4 : new THREE.Plane(),
			( p5 !== undefined ) ? p5 : new THREE.Plane()
	
		];
	
	};
	
	THREE.Frustum.prototype = {
	
		constructor: THREE.Frustum,
	
		set: function ( p0, p1, p2, p3, p4, p5 ) {
	
			var planes = this.planes;
	
			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( frustum ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				planes[ i ].copy( frustum.planes[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromMatrix: function ( m ) {
	
			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];
	
			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
	
			return this;
	
		},
	
		intersectsObject: function () {
	
			var sphere = new THREE.Sphere();
	
			return function ( object ) {
	
				var geometry = object.geometry;
	
				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( object.matrixWorld );
	
				return this.intersectsSphere( sphere );
	
			};
	
		}(),
	
		intersectsSphere: function ( sphere ) {
	
			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				var distance = planes[ i ].distanceToPoint( center );
	
				if ( distance < negRadius ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		},
	
		intersectsBox: function () {
	
			var p1 = new THREE.Vector3(),
				p2 = new THREE.Vector3();
	
			return function ( box ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6 ; i ++ ) {
	
					var plane = planes[ i ];
	
					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
	
					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );
	
					// if both outside plane, no intersection
	
					if ( d1 < 0 && d2 < 0 ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			};
	
		}(),
	
	
		containsPoint: function ( point ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				if ( planes[ i ].distanceToPoint( point ) < 0 ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		}
	
	};
	
	// File:src/math/Plane.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Plane = function ( normal, constant ) {
	
		this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;
	
	};
	
	THREE.Plane.prototype = {
	
		constructor: THREE.Plane,
	
		set: function ( normal, constant ) {
	
			this.normal.copy( normal );
			this.constant = constant;
	
			return this;
	
		},
	
		setComponents: function ( x, y, z, w ) {
	
			this.normal.set( x, y, z );
			this.constant = w;
	
			return this;
	
		},
	
		setFromNormalAndCoplanarPoint: function ( normal, point ) {
	
			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized
	
			return this;
	
		},
	
		setFromCoplanarPoints: function () {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
	
			return function ( a, b, c ) {
	
				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
	
				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	
				this.setFromNormalAndCoplanarPoint( normal, a );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( plane ) {
	
			this.normal.copy( plane.normal );
			this.constant = plane.constant;
	
			return this;
	
		},
	
		normalize: function () {
	
			// Note: will lead to a divide by zero if the plane is invalid.
	
			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;
	
			return this;
	
		},
	
		negate: function () {
	
			this.constant *= - 1;
			this.normal.negate();
	
			return this;
	
		},
	
		distanceToPoint: function ( point ) {
	
			return this.normal.dot( point ) + this.constant;
	
		},
	
		distanceToSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) - sphere.radius;
	
		},
	
		projectPoint: function ( point, optionalTarget ) {
	
			return this.orthoPoint( point, optionalTarget ).sub( point ).negate();
	
		},
	
		orthoPoint: function ( point, optionalTarget ) {
	
			var perpendicularMagnitude = this.distanceToPoint( point );
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );
	
		},
	
		intersectLine: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( line, optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				var direction = line.delta( v1 );
	
				var denominator = this.normal.dot( direction );
	
				if ( denominator === 0 ) {
	
					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {
	
						return result.copy( line.start );
	
					}
	
					// Unsure if this is the correct method to handle this case.
					return undefined;
	
				}
	
				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
	
				if ( t < 0 || t > 1 ) {
	
					return undefined;
	
				}
	
				return result.copy( direction ).multiplyScalar( t ).add( line.start );
	
			};
	
		}(),
	
		intersectsLine: function ( line ) {
	
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	
			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );
	
			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
	
		},
	
		intersectsBox: function ( box ) {
	
			return box.intersectsPlane( this );
	
		},
	
		intersectsSphere: function ( sphere ) {
	
			return sphere.intersectsPlane( this );
	
		},
	
		coplanarPoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( - this.constant );
	
		},
	
		applyMatrix4: function () {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
			var m1 = new THREE.Matrix3();
	
			return function ( matrix, optionalNormalMatrix ) {
	
				// compute new normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
				var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );
	
				var newCoplanarPoint = this.coplanarPoint( v2 );
				newCoplanarPoint.applyMatrix4( matrix );
	
				this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.constant = this.constant - offset.dot( this.normal );
	
			return this;
	
		},
	
		equals: function ( plane ) {
	
			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );
	
		}
	
	};
	
	// File:src/math/Math.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Math = {
	
		generateUUID: function () {
	
			// http://www.broofa.com/Tools/Math.uuid.htm
	
			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
			var uuid = new Array( 36 );
			var rnd = 0, r;
	
			return function () {
	
				for ( var i = 0; i < 36; i ++ ) {
	
					if ( i === 8 || i === 13 || i === 18 || i === 23 ) {
	
						uuid[ i ] = '-';
	
					} else if ( i === 14 ) {
	
						uuid[ i ] = '4';
	
					} else {
	
						if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];
	
					}
	
				}
	
				return uuid.join( '' );
	
			};
	
		}(),
	
		clamp: function ( value, min, max ) {
	
			return Math.max( min, Math.min( max, value ) );
	
		},
	
		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation
	
		euclideanModulo: function ( n, m ) {
	
			return ( ( n % m ) + m ) % m;
	
		},
	
		// Linear mapping from range <a1, a2> to range <b1, b2>
	
		mapLinear: function ( x, a1, a2, b1, b2 ) {
	
			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	
		},
	
		// http://en.wikipedia.org/wiki/Smoothstep
	
		smoothstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * ( 3 - 2 * x );
	
		},
	
		smootherstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
	
		},
	
		random16: function () {
	
			console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();
	
		},
	
		// Random integer from <low, high> interval
	
		randInt: function ( low, high ) {
	
			return low + Math.floor( Math.random() * ( high - low + 1 ) );
	
		},
	
		// Random float from <low, high> interval
	
		randFloat: function ( low, high ) {
	
			return low + Math.random() * ( high - low );
	
		},
	
		// Random float from <-range/2, range/2> interval
	
		randFloatSpread: function ( range ) {
	
			return range * ( 0.5 - Math.random() );
	
		},
	
		degToRad: function () {
	
			var degreeToRadiansFactor = Math.PI / 180;
	
			return function ( degrees ) {
	
				return degrees * degreeToRadiansFactor;
	
			};
	
		}(),
	
		radToDeg: function () {
	
			var radianToDegreesFactor = 180 / Math.PI;
	
			return function ( radians ) {
	
				return radians * radianToDegreesFactor;
	
			};
	
		}(),
	
		isPowerOfTwo: function ( value ) {
	
			return ( value & ( value - 1 ) ) === 0 && value !== 0;
	
		},
	
		nearestPowerOfTwo: function ( value ) {
	
			return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );
	
		},
	
		nextPowerOfTwo: function ( value ) {
	
			value --;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value ++;
	
			return value;
	
		}
	
	};
	
	// File:src/math/Spline.js
	
	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Spline = function ( points ) {
	
		this.points = points;
	
		var c = [], v3 = { x: 0, y: 0, z: 0 },
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;
	
		this.initFromArray = function ( a ) {
	
			this.points = [];
	
			for ( var i = 0; i < a.length; i ++ ) {
	
				this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };
	
			}
	
		};
	
		this.getPoint = function ( k ) {
	
			point = ( this.points.length - 1 ) * k;
			intPoint = Math.floor( point );
			weight = point - intPoint;
	
			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
	
			pa = this.points[ c[ 0 ] ];
			pb = this.points[ c[ 1 ] ];
			pc = this.points[ c[ 2 ] ];
			pd = this.points[ c[ 3 ] ];
	
			w2 = weight * weight;
			w3 = weight * w2;
	
			v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
			v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
			v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );
	
			return v3;
	
		};
	
		this.getControlPointsArray = function () {
	
			var i, p, l = this.points.length,
				coords = [];
	
			for ( i = 0; i < l; i ++ ) {
	
				p = this.points[ i ];
				coords[ i ] = [ p.x, p.y, p.z ];
	
			}
	
			return coords;
	
		};
	
		// approximate length by summing linear segments
	
		this.getLength = function ( nSubDivisions ) {
	
			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;
	
			// first point has 0 length
	
			chunkLengths[ 0 ] = 0;
	
			if ( ! nSubDivisions ) nSubDivisions = 100;
	
			nSamples = this.points.length * nSubDivisions;
	
			oldPosition.copy( this.points[ 0 ] );
	
			for ( i = 1; i < nSamples; i ++ ) {
	
				index = i / nSamples;
	
				position = this.getPoint( index );
				tmpVec.copy( position );
	
				totalLength += tmpVec.distanceTo( oldPosition );
	
				oldPosition.copy( position );
	
				point = ( this.points.length - 1 ) * index;
				intPoint = Math.floor( point );
	
				if ( intPoint !== oldIntPoint ) {
	
					chunkLengths[ intPoint ] = totalLength;
					oldIntPoint = intPoint;
	
				}
	
			}
	
			// last point ends with total length
	
			chunkLengths[ chunkLengths.length ] = totalLength;
	
			return { chunks: chunkLengths, total: totalLength };
	
		};
	
		this.reparametrizeByArcLength = function ( samplingCoef ) {
	
			var i, j,
				index, indexCurrent, indexNext,
				realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();
	
			newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );
	
			for ( i = 1; i < this.points.length; i ++ ) {
	
				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );
	
				realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];
	
				sampling = Math.ceil( samplingCoef * realDistance / sl.total );
	
				indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
				indexNext = i / ( this.points.length - 1 );
	
				for ( j = 1; j < sampling - 1; j ++ ) {
	
					index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );
	
					position = this.getPoint( index );
					newpoints.push( tmpVec.copy( position ).clone() );
	
				}
	
				newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );
	
			}
	
			this.points = newpoints;
	
		};
	
		// Catmull-Rom
	
		function interpolate( p0, p1, p2, p3, t, t2, t3 ) {
	
			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;
	
			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
	};
	
	// File:src/math/Triangle.js
	
	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Triangle = function ( a, b, c ) {
	
		this.a = ( a !== undefined ) ? a : new THREE.Vector3();
		this.b = ( b !== undefined ) ? b : new THREE.Vector3();
		this.c = ( c !== undefined ) ? c : new THREE.Vector3();
	
	};
	
	THREE.Triangle.normal = function () {
	
		var v0 = new THREE.Vector3();
	
		return function ( a, b, c, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );
	
			var resultLengthSq = result.lengthSq();
			if ( resultLengthSq > 0 ) {
	
				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );
	
			}
	
			return result.set( 0, 0, 0 );
	
		};
	
	}();
	
	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function () {
	
		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
	
		return function ( point, a, b, c, optionalTarget ) {
	
			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );
	
			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );
	
			var denom = ( dot00 * dot11 - dot01 * dot01 );
	
			var result = optionalTarget || new THREE.Vector3();
	
			// collinear or singular triangle
			if ( denom === 0 ) {
	
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( - 2, - 1, - 1 );
	
			}
	
			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
	
			// barycentric coordinates must always sum to 1
			return result.set( 1 - u - v, v, u );
	
		};
	
	}();
	
	THREE.Triangle.containsPoint = function () {
	
		var v1 = new THREE.Vector3();
	
		return function ( point, a, b, c ) {
	
			var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );
	
			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );
	
		};
	
	}();
	
	THREE.Triangle.prototype = {
	
		constructor: THREE.Triangle,
	
		set: function ( a, b, c ) {
	
			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );
	
			return this;
	
		},
	
		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
	
			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( triangle ) {
	
			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );
	
			return this;
	
		},
	
		area: function () {
	
			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();
	
			return function () {
	
				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );
	
				return v0.cross( v1 ).length() * 0.5;
	
			};
	
		}(),
	
		midpoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
	
		},
	
		normal: function ( optionalTarget ) {
	
			return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );
	
		},
	
		plane: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Plane();
	
			return result.setFromCoplanarPoints( this.a, this.b, this.c );
	
		},
	
		barycoordFromPoint: function ( point, optionalTarget ) {
	
			return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );
	
		},
	
		containsPoint: function ( point ) {
	
			return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );
	
		},
	
		equals: function ( triangle ) {
	
			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
	
		}
	
	};
	
	// File:src/math/Interpolant.js
	
	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */
	
	THREE.Interpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;
	
		this.resultBuffer = resultBuffer !== undefined ?
				resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;
	
	};
	
	THREE.Interpolant.prototype = {
	
		constructor: THREE.Interpolant,
	
		evaluate: function( t ) {
	
			var pp = this.parameterPositions,
				i1 = this._cachedIndex,
	
				t1 = pp[   i1   ],
				t0 = pp[ i1 - 1 ];
	
			validate_interval: {
	
				seek: {
	
					var right;
	
					linear_scan: {
	//- See http://jsperf.com/comparison-to-undefined/3
	//- slower code:
	//-
	//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {
	
							for ( var giveUpAt = i1 + 2; ;) {
	
								if ( t1 === undefined ) {
	
									if ( t < t0 ) break forward_scan;
	
									// after end
	
									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );
	
								}
	
								if ( i1 === giveUpAt ) break; // this loop
	
								t0 = t1;
								t1 = pp[ ++ i1 ];
	
								if ( t < t1 ) {
	
									// we have arrived at the sought interval
									break seek;
	
								}
	
							}
	
							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;
	
						}
	
	//- slower code:
	//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {
	
							// looping?
	
							var t1global = pp[ 1 ];
	
							if ( t < t1global ) {
	
								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;
	
							}
	
							// linear reverse scan
	
							for ( var giveUpAt = i1 - 2; ;) {
	
								if ( t0 === undefined ) {
	
									// before start
	
									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );
	
								}
	
								if ( i1 === giveUpAt ) break; // this loop
	
								t1 = t0;
								t0 = pp[ -- i1 - 1 ];
	
								if ( t >= t0 ) {
	
									// we have arrived at the sought interval
									break seek;
	
								}
	
							}
	
							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;
	
						}
	
						// the interval is valid
	
						break validate_interval;
	
					} // linear scan
	
					// binary search
	
					while ( i1 < right ) {
	
						var mid = ( i1 + right ) >>> 1;
	
						if ( t < pp[ mid ] ) {
	
							right = mid;
	
						} else {
	
							i1 = mid + 1;
	
						}
	
					}
	
					t1 = pp[   i1   ];
					t0 = pp[ i1 - 1 ];
	
					// check boundary cases, again
	
					if ( t0 === undefined ) {
	
						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );
	
					}
	
					if ( t1 === undefined ) {
	
						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );
	
					}
	
				} // seek
	
				this._cachedIndex = i1;
	
				this.intervalChanged_( i1, t0, t1 );
	
			} // validate_interval
	
			return this.interpolate_( i1, t0, t, t1 );
	
		},
	
		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.
	
		// --- Protected interface
	
		DefaultSettings_: {},
	
		getSettings_: function() {
	
			return this.settings || this.DefaultSettings_;
	
		},
	
		copySampleValue_: function( index ) {
	
			// copies a sample value to the result buffer
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				result[ i ] = values[ offset + i ];
	
			}
	
			return result;
	
		},
	
		// Template methods for derived classes:
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			throw new Error( "call to abstract method" );
			// implementations shall return this.resultBuffer
	
		},
	
		intervalChanged_: function( i1, t0, t1 ) {
	
			// empty
	
		}
	
	};
	
	Object.assign( THREE.Interpolant.prototype, {
	
		beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
			THREE.Interpolant.prototype.copySampleValue_,
	
		afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
			THREE.Interpolant.prototype.copySampleValue_
	
	} );
	
	// File:src/math/interpolants/CubicInterpolant.js
	
	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */
	
	THREE.CubicInterpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		THREE.Interpolant.call(
				this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		this._weightPrev = -0;
		this._offsetPrev = -0;
		this._weightNext = -0;
		this._offsetNext = -0;
	
	};
	
	THREE.CubicInterpolant.prototype =
			Object.assign( Object.create( THREE.Interpolant.prototype ), {
	
		constructor: THREE.CubicInterpolant,
	
		DefaultSettings_: {
	
			endingStart: 	THREE.ZeroCurvatureEnding,
			endingEnd:		THREE.ZeroCurvatureEnding
	
		},
	
		intervalChanged_: function( i1, t0, t1 ) {
	
			var pp = this.parameterPositions,
				iPrev = i1 - 2,
				iNext = i1 + 1,
	
				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];
	
			if ( tPrev === undefined ) {
	
				switch ( this.getSettings_().endingStart ) {
	
					case THREE.ZeroSlopeEnding:
	
						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;
	
						break;
	
					case THREE.WrapAroundEnding:
	
						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];
	
						break;
	
					default: // ZeroCurvatureEnding
	
						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;
	
				}
	
			}
	
			if ( tNext === undefined ) {
	
				switch ( this.getSettings_().endingEnd ) {
	
					case THREE.ZeroSlopeEnding:
	
						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;
	
						break;
	
					case THREE.WrapAroundEnding:
	
						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];
	
						break;
	
					default: // ZeroCurvatureEnding
	
						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;
	
				}
	
			}
	
			var halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;
	
			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;
	
		},
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
	
				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,
	
				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;
	
			// evaluate polynomials
	
			var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
			var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
			var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
			var sN =       wN   * ppp   -           wN      * pp;
	
			// combine data linearly
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];
	
			}
	
			return result;
	
		}
	
	} );
	
	// File:src/math/interpolants/DiscreteInterpolant.js
	
	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */
	
	THREE.DiscreteInterpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		THREE.Interpolant.call(
				this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
	};
	
	THREE.DiscreteInterpolant.prototype =
			Object.assign( Object.create( THREE.Interpolant.prototype ), {
	
		constructor: THREE.DiscreteInterpolant,
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			return this.copySampleValue_( i1 - 1 );
	
		}
	
	} );
	
	// File:src/math/interpolants/LinearInterpolant.js
	
	/**
	 * @author tschw
	 */
	
	THREE.LinearInterpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		THREE.Interpolant.call(
				this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
	};
	
	THREE.LinearInterpolant.prototype =
			Object.assign( Object.create( THREE.Interpolant.prototype ), {
	
		constructor: THREE.LinearInterpolant,
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
	
				offset1 = i1 * stride,
				offset0 = offset1 - stride,
	
				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;
	
			}
	
			return result;
	
		}
	
	} );
	
	// File:src/math/interpolants/QuaternionLinearInterpolant.js
	
	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */
	
	THREE.QuaternionLinearInterpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		THREE.Interpolant.call(
				this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
	};
	
	THREE.QuaternionLinearInterpolant.prototype =
			Object.assign( Object.create( THREE.Interpolant.prototype ), {
	
		constructor: THREE.QuaternionLinearInterpolant,
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
	
				offset = i1 * stride,
	
				alpha = ( t - t0 ) / ( t1 - t0 );
	
			for ( var end = offset + stride; offset !== end; offset += 4 ) {
	
				THREE.Quaternion.slerpFlat( result, 0,
						values, offset - stride, values, offset, alpha );
	
			}
	
			return result;
	
		}
	
	} );
	
	// File:src/core/Clock.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Clock = function ( autoStart ) {
	
		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
	
		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;
	
		this.running = false;
	
	};
	
	THREE.Clock.prototype = {
	
		constructor: THREE.Clock,
	
		start: function () {
	
			this.startTime = performance.now();
	
			this.oldTime = this.startTime;
			this.running = true;
	
		},
	
		stop: function () {
	
			this.getElapsedTime();
			this.running = false;
	
		},
	
		getElapsedTime: function () {
	
			this.getDelta();
			return this.elapsedTime;
	
		},
	
		getDelta: function () {
	
			var diff = 0;
	
			if ( this.autoStart && ! this.running ) {
	
				this.start();
	
			}
	
			if ( this.running ) {
	
				var newTime = performance.now();
	
				diff = 0.001 * ( newTime - this.oldTime );
				this.oldTime = newTime;
	
				this.elapsedTime += diff;
	
			}
	
			return diff;
	
		}
	
	};
	
	// File:src/core/EventDispatcher.js
	
	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	
	THREE.EventDispatcher = function () {};
	
	THREE.EventDispatcher.prototype = {
	
		constructor: THREE.EventDispatcher,
	
		apply: function ( object ) {
	
			object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
			object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
			object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
			object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
	
		},
	
		addEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) this._listeners = {};
	
			var listeners = this._listeners;
	
			if ( listeners[ type ] === undefined ) {
	
				listeners[ type ] = [];
	
			}
	
			if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	
				listeners[ type ].push( listener );
	
			}
	
		},
	
		hasEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return false;
	
			var listeners = this._listeners;
	
			if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		removeEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return;
	
			var listeners = this._listeners;
			var listenerArray = listeners[ type ];
	
			if ( listenerArray !== undefined ) {
	
				var index = listenerArray.indexOf( listener );
	
				if ( index !== - 1 ) {
	
					listenerArray.splice( index, 1 );
	
				}
	
			}
	
		},
	
		dispatchEvent: function ( event ) {
	
			if ( this._listeners === undefined ) return;
	
			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];
	
			if ( listenerArray !== undefined ) {
	
				event.target = this;
	
				var array = [];
				var length = listenerArray.length;
	
				for ( var i = 0; i < length; i ++ ) {
	
					array[ i ] = listenerArray[ i ];
	
				}
	
				for ( var i = 0; i < length; i ++ ) {
	
					array[ i ].call( this, event );
	
				}
	
			}
	
		}
	
	};
	
	// File:src/core/Layers.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Layers = function () {
	
		this.mask = 1;
	
	};
	
	THREE.Layers.prototype = {
	
		constructor: THREE.Layers,
	
		set: function ( channel ) {
	
			this.mask = 1 << channel;
	
		},
	
		enable: function ( channel ) {
	
			this.mask |= 1 << channel;
	
		},
	
		toggle: function ( channel ) {
	
			this.mask ^= 1 << channel;
	
		},
	
		disable: function ( channel ) {
	
			this.mask &= ~ ( 1 << channel );
	
		},
	
		test: function ( layers ) {
	
			return ( this.mask & layers.mask ) !== 0;
	
		}
	
	};
	
	// File:src/core/Raycaster.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */
	
	( function ( THREE ) {
	
		THREE.Raycaster = function ( origin, direction, near, far ) {
	
			this.ray = new THREE.Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)
	
			this.near = near || 0;
			this.far = far || Infinity;
	
			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};
	
			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );
	
		};
	
		function ascSort( a, b ) {
	
			return a.distance - b.distance;
	
		}
	
		function intersectObject( object, raycaster, intersects, recursive ) {
	
			if ( object.visible === false ) return;
	
			object.raycast( raycaster, intersects );
	
			if ( recursive === true ) {
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					intersectObject( children[ i ], raycaster, intersects, true );
	
				}
	
			}
	
		}
	
		//
	
		THREE.Raycaster.prototype = {
	
			constructor: THREE.Raycaster,
	
			linePrecision: 1,
	
			set: function ( origin, direction ) {
	
				// direction is assumed to be normalized (for accurate distance calculations)
	
				this.ray.set( origin, direction );
	
			},
	
			setFromCamera: function ( coords, camera ) {
	
				if ( camera instanceof THREE.PerspectiveCamera ) {
	
					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
	
				} else if ( camera instanceof THREE.OrthographicCamera ) {
	
					this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
	
				} else {
	
					console.error( 'THREE.Raycaster: Unsupported camera type.' );
	
				}
	
			},
	
			intersectObject: function ( object, recursive ) {
	
				var intersects = [];
	
				intersectObject( object, this, intersects, recursive );
	
				intersects.sort( ascSort );
	
				return intersects;
	
			},
	
			intersectObjects: function ( objects, recursive ) {
	
				var intersects = [];
	
				if ( Array.isArray( objects ) === false ) {
	
					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;
	
				}
	
				for ( var i = 0, l = objects.length; i < l; i ++ ) {
	
					intersectObject( objects[ i ], this, intersects, recursive );
	
				}
	
				intersects.sort( ascSort );
	
				return intersects;
	
			}
	
		};
	
	}( THREE ) );
	
	// File:src/core/Object3D.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */
	
	THREE.Object3D = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Object3D';
	
		this.parent = null;
		this.children = [];
	
		this.up = THREE.Object3D.DefaultUp.clone();
	
		var position = new THREE.Vector3();
		var rotation = new THREE.Euler();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3( 1, 1, 1 );
	
		function onRotationChange() {
	
			quaternion.setFromEuler( rotation, false );
	
		}
	
		function onQuaternionChange() {
	
			rotation.setFromQuaternion( quaternion, undefined, false );
	
		}
	
		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );
	
		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new THREE.Matrix4()
			},
			normalMatrix: {
				value: new THREE.Matrix3()
			}
		} );
	
		this.rotationAutoUpdate = true;
	
		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();
	
		this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;
	
		this.layers = new THREE.Layers();
		this.visible = true;
	
		this.castShadow = false;
		this.receiveShadow = false;
	
		this.frustumCulled = true;
		this.renderOrder = 0;
	
		this.userData = {};
	
	};
	
	THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
	THREE.Object3D.DefaultMatrixAutoUpdate = true;
	
	THREE.Object3D.prototype = {
	
		constructor: THREE.Object3D,
	
		applyMatrix: function ( matrix ) {
	
			this.matrix.multiplyMatrices( matrix, this.matrix );
	
			this.matrix.decompose( this.position, this.quaternion, this.scale );
	
		},
	
		setRotationFromAxisAngle: function ( axis, angle ) {
	
			// assumes axis is normalized
	
			this.quaternion.setFromAxisAngle( axis, angle );
	
		},
	
		setRotationFromEuler: function ( euler ) {
	
			this.quaternion.setFromEuler( euler, true );
	
		},
	
		setRotationFromMatrix: function ( m ) {
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			this.quaternion.setFromRotationMatrix( m );
	
		},
	
		setRotationFromQuaternion: function ( q ) {
	
			// assumes q is normalized
	
			this.quaternion.copy( q );
	
		},
	
		rotateOnAxis: function () {
	
			// rotate object on axis in object space
			// axis is assumed to be normalized
	
			var q1 = new THREE.Quaternion();
	
			return function ( axis, angle ) {
	
				q1.setFromAxisAngle( axis, angle );
	
				this.quaternion.multiply( q1 );
	
				return this;
	
			};
	
		}(),
	
		rotateX: function () {
	
			var v1 = new THREE.Vector3( 1, 0, 0 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateY: function () {
	
			var v1 = new THREE.Vector3( 0, 1, 0 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateZ: function () {
	
			var v1 = new THREE.Vector3( 0, 0, 1 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		translateOnAxis: function () {
	
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
	
			var v1 = new THREE.Vector3();
	
			return function ( axis, distance ) {
	
				v1.copy( axis ).applyQuaternion( this.quaternion );
	
				this.position.add( v1.multiplyScalar( distance ) );
	
				return this;
	
			};
	
		}(),
	
		translateX: function () {
	
			var v1 = new THREE.Vector3( 1, 0, 0 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateY: function () {
	
			var v1 = new THREE.Vector3( 0, 1, 0 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateZ: function () {
	
			var v1 = new THREE.Vector3( 0, 0, 1 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		localToWorld: function ( vector ) {
	
			return vector.applyMatrix4( this.matrixWorld );
	
		},
	
		worldToLocal: function () {
	
			var m1 = new THREE.Matrix4();
	
			return function ( vector ) {
	
				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );
	
			};
	
		}(),
	
		lookAt: function () {
	
			// This routine does not support objects with rotated and/or translated parent(s)
	
			var m1 = new THREE.Matrix4();
	
			return function ( vector ) {
	
				m1.lookAt( vector, this.position, this.up );
	
				this.quaternion.setFromRotationMatrix( m1 );
	
			};
	
		}(),
	
		add: function ( object ) {
	
			if ( arguments.length > 1 ) {
	
				for ( var i = 0; i < arguments.length; i ++ ) {
	
					this.add( arguments[ i ] );
	
				}
	
				return this;
	
			}
	
			if ( object === this ) {
	
				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;
	
			}
	
			if ( object instanceof THREE.Object3D ) {
	
				if ( object.parent !== null ) {
	
					object.parent.remove( object );
	
				}
	
				object.parent = this;
				object.dispatchEvent( { type: 'added' } );
	
				this.children.push( object );
	
			} else {
	
				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );
	
			}
	
			return this;
	
		},
	
		remove: function ( object ) {
	
			if ( arguments.length > 1 ) {
	
				for ( var i = 0; i < arguments.length; i ++ ) {
	
					this.remove( arguments[ i ] );
	
				}
	
			}
	
			var index = this.children.indexOf( object );
	
			if ( index !== - 1 ) {
	
				object.parent = null;
	
				object.dispatchEvent( { type: 'removed' } );
	
				this.children.splice( index, 1 );
	
			}
	
		},
	
		getObjectById: function ( id ) {
	
			return this.getObjectByProperty( 'id', id );
	
		},
	
		getObjectByName: function ( name ) {
	
			return this.getObjectByProperty( 'name', name );
	
		},
	
		getObjectByProperty: function ( name, value ) {
	
			if ( this[ name ] === value ) return this;
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );
	
				if ( object !== undefined ) {
	
					return object;
	
				}
	
			}
	
			return undefined;
	
		},
	
		getWorldPosition: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			this.updateMatrixWorld( true );
	
			return result.setFromMatrixPosition( this.matrixWorld );
	
		},
	
		getWorldQuaternion: function () {
	
			var position = new THREE.Vector3();
			var scale = new THREE.Vector3();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Quaternion();
	
				this.updateMatrixWorld( true );
	
				this.matrixWorld.decompose( position, result, scale );
	
				return result;
	
			};
	
		}(),
	
		getWorldRotation: function () {
	
			var quaternion = new THREE.Quaternion();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Euler();
	
				this.getWorldQuaternion( quaternion );
	
				return result.setFromQuaternion( quaternion, this.rotation.order, false );
	
			};
	
		}(),
	
		getWorldScale: function () {
	
			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				this.updateMatrixWorld( true );
	
				this.matrixWorld.decompose( position, quaternion, result );
	
				return result;
	
			};
	
		}(),
	
		getWorldDirection: function () {
	
			var quaternion = new THREE.Quaternion();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				this.getWorldQuaternion( quaternion );
	
				return result.set( 0, 0, 1 ).applyQuaternion( quaternion );
	
			};
	
		}(),
	
		raycast: function () {},
	
		traverse: function ( callback ) {
	
			callback( this );
	
			var children = this.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				children[ i ].traverse( callback );
	
			}
	
		},
	
		traverseVisible: function ( callback ) {
	
			if ( this.visible === false ) return;
	
			callback( this );
	
			var children = this.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				children[ i ].traverseVisible( callback );
	
			}
	
		},
	
		traverseAncestors: function ( callback ) {
	
			var parent = this.parent;
	
			if ( parent !== null ) {
	
				callback( parent );
	
				parent.traverseAncestors( callback );
	
			}
	
		},
	
		updateMatrix: function () {
	
			this.matrix.compose( this.position, this.quaternion, this.scale );
	
			this.matrixWorldNeedsUpdate = true;
	
		},
	
		updateMatrixWorld: function ( force ) {
	
			if ( this.matrixAutoUpdate === true ) this.updateMatrix();
	
			if ( this.matrixWorldNeedsUpdate === true || force === true ) {
	
				if ( this.parent === null ) {
	
					this.matrixWorld.copy( this.matrix );
	
				} else {
	
					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
				}
	
				this.matrixWorldNeedsUpdate = false;
	
				force = true;
	
			}
	
			// update children
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].updateMatrixWorld( force );
	
			}
	
		},
	
		toJSON: function ( meta ) {
	
			var isRootObject = ( meta === undefined );
	
			var output = {};
	
			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {
	
				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {}
				};
	
				output.metadata = {
					version: 4.4,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};
	
			}
	
			// standard Object3D serialization
	
			var object = {};
	
			object.uuid = this.uuid;
			object.type = this.type;
	
			if ( this.name !== '' ) object.name = this.name;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
	
			object.matrix = this.matrix.toArray();
	
			//
	
			if ( this.geometry !== undefined ) {
	
				if ( meta.geometries[ this.geometry.uuid ] === undefined ) {
	
					meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );
	
				}
	
				object.geometry = this.geometry.uuid;
	
			}
	
			if ( this.material !== undefined ) {
	
				if ( meta.materials[ this.material.uuid ] === undefined ) {
	
					meta.materials[ this.material.uuid ] = this.material.toJSON( meta );
	
				}
	
				object.material = this.material.uuid;
	
			}
	
			//
	
			if ( this.children.length > 0 ) {
	
				object.children = [];
	
				for ( var i = 0; i < this.children.length; i ++ ) {
	
					object.children.push( this.children[ i ].toJSON( meta ).object );
	
				}
	
			}
	
			if ( isRootObject ) {
	
				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
	
				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
	
			}
	
			output.object = object;
	
			return output;
	
			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache ( cache ) {
	
				var values = [];
				for ( var key in cache ) {
	
					var data = cache[ key ];
					delete data.metadata;
					values.push( data );
	
				}
				return values;
	
			}
	
		},
	
		clone: function ( recursive ) {
	
			return new this.constructor().copy( this, recursive );
	
		},
	
		copy: function ( source, recursive ) {
	
			if ( recursive === undefined ) recursive = true;
	
			this.name = source.name;
	
			this.up.copy( source.up );
	
			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );
	
			this.rotationAutoUpdate = source.rotationAutoUpdate;
	
			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );
	
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
	
			this.visible = source.visible;
	
			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;
	
			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;
	
			this.userData = JSON.parse( JSON.stringify( source.userData ) );
	
			if ( recursive === true ) {
	
				for ( var i = 0; i < source.children.length; i ++ ) {
	
					var child = source.children[ i ];
					this.add( child.clone() );
	
				}
	
			}
	
			return this;
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );
	
	THREE.Object3DIdCount = 0;
	
	// File:src/core/Face3.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {
	
		this.a = a;
		this.b = b;
		this.c = c;
	
		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];
	
		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = Array.isArray( color ) ? color : [];
	
		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	
	};
	
	THREE.Face3.prototype = {
	
		constructor: THREE.Face3,
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.a = source.a;
			this.b = source.b;
			this.c = source.c;
	
			this.normal.copy( source.normal );
			this.color.copy( source.color );
	
			this.materialIndex = source.materialIndex;
	
			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {
	
				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();
	
			}
	
			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {
	
				this.vertexColors[ i ] = source.vertexColors[ i ].clone();
	
			}
	
			return this;
	
		}
	
	};
	
	// File:src/core/BufferAttribute.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferAttribute = function ( array, itemSize ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.array = array;
		this.itemSize = itemSize;
	
		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };
	
		this.version = 0;
	
	};
	
	THREE.BufferAttribute.prototype = {
	
		constructor: THREE.BufferAttribute,
	
		get count() {
	
			return this.array.length / this.itemSize;
	
		},
	
		set needsUpdate( value ) {
	
			if ( value === true ) this.version ++;
	
		},
	
		setDynamic: function ( value ) {
	
			this.dynamic = value;
	
			return this;
	
		},
	
		copy: function ( source ) {
	
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
	
			this.dynamic = source.dynamic;
	
			return this;
	
		},
	
		copyAt: function ( index1, attribute, index2 ) {
	
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;
	
			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {
	
				this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
			}
	
			return this;
	
		},
	
		copyArray: function ( array ) {
	
			this.array.set( array );
	
			return this;
	
		},
	
		copyColorsArray: function ( colors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = colors.length; i < l; i ++ ) {
	
				var color = colors[ i ];
	
				if ( color === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new THREE.Color();
	
				}
	
				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;
	
			}
	
			return this;
	
		},
	
		copyIndicesArray: function ( indices ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
				var index = indices[ i ];
	
				array[ offset ++ ] = index.a;
				array[ offset ++ ] = index.b;
				array[ offset ++ ] = index.c;
	
			}
	
			return this;
	
		},
	
		copyVector2sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new THREE.Vector2();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
	
			}
	
			return this;
	
		},
	
		copyVector3sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new THREE.Vector3();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
	
			}
	
			return this;
	
		},
	
		copyVector4sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new THREE.Vector4();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;
	
			}
	
			return this;
	
		},
	
		set: function ( value, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.array.set( value, offset );
	
			return this;
	
		},
	
		getX: function ( index ) {
	
			return this.array[ index * this.itemSize ];
	
		},
	
		setX: function ( index, x ) {
	
			this.array[ index * this.itemSize ] = x;
	
			return this;
	
		},
	
		getY: function ( index ) {
	
			return this.array[ index * this.itemSize + 1 ];
	
		},
	
		setY: function ( index, y ) {
	
			this.array[ index * this.itemSize + 1 ] = y;
	
			return this;
	
		},
	
		getZ: function ( index ) {
	
			return this.array[ index * this.itemSize + 2 ];
	
		},
	
		setZ: function ( index, z ) {
	
			this.array[ index * this.itemSize + 2 ] = z;
	
			return this;
	
		},
	
		getW: function ( index ) {
	
			return this.array[ index * this.itemSize + 3 ];
	
		},
	
		setW: function ( index, w ) {
	
			this.array[ index * this.itemSize + 3 ] = w;
	
			return this;
	
		},
	
		setXY: function ( index, x, y ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
	
			return this;
	
		},
	
		setXYZ: function ( index, x, y, z ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
	
			return this;
	
		},
	
		setXYZW: function ( index, x, y, z, w ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	};
	
	//
	
	THREE.Int8Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Int8Array( array ), itemSize );
	
	};
	
	THREE.Uint8Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );
	
	};
	
	THREE.Uint8ClampedAttribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );
	
	};
	
	THREE.Int16Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Int16Array( array ), itemSize );
	
	};
	
	THREE.Uint16Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );
	
	};
	
	THREE.Int32Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Int32Array( array ), itemSize );
	
	};
	
	THREE.Uint32Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );
	
	};
	
	THREE.Float32Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Float32Array( array ), itemSize );
	
	};
	
	THREE.Float64Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Float64Array( array ), itemSize );
	
	};
	
	
	// Deprecated
	
	THREE.DynamicBufferAttribute = function ( array, itemSize ) {
	
		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );
	
	};
	
	// File:src/core/InstancedBufferAttribute.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {
	
		THREE.BufferAttribute.call( this, array, itemSize );
	
		this.meshPerAttribute = meshPerAttribute || 1;
	
	};
	
	THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
	THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;
	
	THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {
	
		THREE.BufferAttribute.prototype.copy.call( this, source );
	
		this.meshPerAttribute = source.meshPerAttribute;
	
		return this;
	
	};
	
	// File:src/core/InterleavedBuffer.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InterleavedBuffer = function ( array, stride ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.array = array;
		this.stride = stride;
	
		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };
	
		this.version = 0;
	
	};
	
	THREE.InterleavedBuffer.prototype = {
	
		constructor: THREE.InterleavedBuffer,
	
		get length () {
	
			return this.array.length;
	
		},
	
		get count () {
	
			return this.array.length / this.stride;
	
		},
	
		set needsUpdate( value ) {
	
			if ( value === true ) this.version ++;
	
		},
	
		setDynamic: function ( value ) {
	
			this.dynamic = value;
	
			return this;
	
		},
	
		copy: function ( source ) {
	
			this.array = new source.array.constructor( source.array );
			this.stride = source.stride;
			this.dynamic = source.dynamic;
	
			return this;
	
		},
	
		copyAt: function ( index1, attribute, index2 ) {
	
			index1 *= this.stride;
			index2 *= attribute.stride;
	
			for ( var i = 0, l = this.stride; i < l; i ++ ) {
	
				this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
			}
	
			return this;
	
		},
	
		set: function ( value, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.array.set( value, offset );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	};
	
	// File:src/core/InstancedInterleavedBuffer.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {
	
		THREE.InterleavedBuffer.call( this, array, stride );
	
		this.meshPerAttribute = meshPerAttribute || 1;
	
	};
	
	THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
	THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;
	
	THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {
	
		THREE.InterleavedBuffer.prototype.copy.call( this, source );
	
		this.meshPerAttribute = source.meshPerAttribute;
	
		return this;
	
	};
	
	// File:src/core/InterleavedBufferAttribute.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;
	
	};
	
	
	THREE.InterleavedBufferAttribute.prototype = {
	
		constructor: THREE.InterleavedBufferAttribute,
	
		get length() {
	
			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;
	
		},
	
		get count() {
	
			return this.data.count;
	
		},
	
		setX: function ( index, x ) {
	
			this.data.array[ index * this.data.stride + this.offset ] = x;
	
			return this;
	
		},
	
		setY: function ( index, y ) {
	
			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;
	
			return this;
	
		},
	
		setZ: function ( index, z ) {
	
			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;
	
			return this;
	
		},
	
		setW: function ( index, w ) {
	
			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;
	
			return this;
	
		},
	
		getX: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset ];
	
		},
	
		getY: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 1 ];
	
		},
	
		getZ: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 2 ];
	
		},
	
		getW: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 3 ];
	
		},
	
		setXY: function ( index, x, y ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
	
			return this;
	
		},
	
		setXYZ: function ( index, x, y, z ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
	
			return this;
	
		},
	
		setXYZW: function ( index, x, y, z, w ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;
	
			return this;
	
		}
	
	};
	
	// File:src/core/Geometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Geometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Geometry';
	
		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [ [] ];
	
		this.morphTargets = [];
		this.morphNormals = [];
	
		this.skinWeights = [];
		this.skinIndices = [];
	
		this.lineDistances = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		// update flags
	
		this.verticesNeedUpdate = false;
		this.elementsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;
	
	};
	
	THREE.Geometry.prototype = {
	
		constructor: THREE.Geometry,
	
		applyMatrix: function ( matrix ) {
	
			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );
	
			}
	
			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
	
				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();
	
				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
	
				}
	
			}
	
			if ( this.boundingBox !== null ) {
	
				this.computeBoundingBox();
	
			}
	
			if ( this.boundingSphere !== null ) {
	
				this.computeBoundingSphere();
	
			}
	
			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;
	
		},
	
		rotateX: function () {
	
			// rotate geometry around world x-axis
	
			var m1;
	
			return function rotateX( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationX( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateY: function () {
	
			// rotate geometry around world y-axis
	
			var m1;
	
			return function rotateY( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationY( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateZ: function () {
	
			// rotate geometry around world z-axis
	
			var m1;
	
			return function rotateZ( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationZ( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		translate: function () {
	
			// translate geometry
	
			var m1;
	
			return function translate( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeTranslation( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		scale: function () {
	
			// scale geometry
	
			var m1;
	
			return function scale( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeScale( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		lookAt: function () {
	
			var obj;
	
			return function lookAt( vector ) {
	
				if ( obj === undefined ) obj = new THREE.Object3D();
	
				obj.lookAt( vector );
	
				obj.updateMatrix();
	
				this.applyMatrix( obj.matrix );
	
			};
	
		}(),
	
		fromBufferGeometry: function ( geometry ) {
	
			var scope = this;
	
			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;
	
			var positions = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
	
			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];
	
			var tempNormals = [];
			var tempUVs = [];
			var tempUVs2 = [];
	
			for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {
	
				scope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );
	
				if ( normals !== undefined ) {
	
					tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );
	
				}
	
				if ( colors !== undefined ) {
	
					scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );
	
				}
	
				if ( uvs !== undefined ) {
	
					tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );
	
				}
	
				if ( uvs2 !== undefined ) {
	
					tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );
	
				}
	
			}
	
			function addFace( a, b, c ) {
	
				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];
	
				var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );
	
				scope.faces.push( face );
	
				if ( uvs !== undefined ) {
	
					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );
	
				}
	
				if ( uvs2 !== undefined ) {
	
					scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );
	
				}
	
			}
	
			if ( indices !== undefined ) {
	
				var groups = geometry.groups;
	
				if ( groups.length > 0 ) {
	
					for ( var i = 0; i < groups.length; i ++ ) {
	
						var group = groups[ i ];
	
						var start = group.start;
						var count = group.count;
	
						for ( var j = start, jl = start + count; j < jl; j += 3 ) {
	
							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );
	
						}
	
					}
	
				} else {
	
					for ( var i = 0; i < indices.length; i += 3 ) {
	
						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );
	
					}
	
				}
	
			} else {
	
				for ( var i = 0; i < positions.length / 3; i += 3 ) {
	
					addFace( i, i + 1, i + 2 );
	
				}
	
			}
	
			this.computeFaceNormals();
	
			if ( geometry.boundingBox !== null ) {
	
				this.boundingBox = geometry.boundingBox.clone();
	
			}
	
			if ( geometry.boundingSphere !== null ) {
	
				this.boundingSphere = geometry.boundingSphere.clone();
	
			}
	
			return this;
	
		},
	
		center: function () {
	
			this.computeBoundingBox();
	
			var offset = this.boundingBox.center().negate();
	
			this.translate( offset.x, offset.y, offset.z );
	
			return offset;
	
		},
	
		normalize: function () {
	
			this.computeBoundingSphere();
	
			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;
	
			var s = radius === 0 ? 1 : 1.0 / radius;
	
			var matrix = new THREE.Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);
	
			this.applyMatrix( matrix );
	
			return this;
	
		},
	
		computeFaceNormals: function () {
	
			var cb = new THREE.Vector3(), ab = new THREE.Vector3();
	
			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				var face = this.faces[ f ];
	
				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];
	
				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );
	
				cb.normalize();
	
				face.normal.copy( cb );
	
			}
	
		},
	
		computeVertexNormals: function ( areaWeighted ) {
	
			if ( areaWeighted === undefined ) areaWeighted = true;
	
			var v, vl, f, fl, face, vertices;
	
			vertices = new Array( this.vertices.length );
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ] = new THREE.Vector3();
	
			}
	
			if ( areaWeighted ) {
	
				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm
	
				var vA, vB, vC;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3();
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];
	
					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );
	
					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );
	
				}
	
			} else {
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );
	
				}
	
			}
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ].normalize();
	
			}
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				var vertexNormals = face.vertexNormals;
	
				if ( vertexNormals.length === 3 ) {
	
					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );
	
				} else {
	
					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();
	
				}
	
			}
	
			if ( this.faces.length > 0 ) {
	
				this.normalsNeedUpdate = true;
	
			}
	
		},
	
		computeMorphNormals: function () {
	
			var i, il, f, fl, face;
	
			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				if ( ! face.__originalFaceNormal ) {
	
					face.__originalFaceNormal = face.normal.clone();
	
				} else {
	
					face.__originalFaceNormal.copy( face.normal );
	
				}
	
				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
	
				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
	
					if ( ! face.__originalVertexNormals[ i ] ) {
	
						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
	
					} else {
	
						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
	
					}
	
				}
	
			}
	
			// use temp geometry to compute face and vertex normals for each morph
	
			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;
	
			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
	
				// create on first access
	
				if ( ! this.morphNormals[ i ] ) {
	
					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];
	
					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
	
					var faceNormal, vertexNormals;
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						faceNormal = new THREE.Vector3();
						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };
	
						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );
	
					}
	
				}
	
				var morphNormals = this.morphNormals[ i ];
	
				// set vertices to morph target
	
				tmpGeo.vertices = this.morphTargets[ i ].vertices;
	
				// compute morph normals
	
				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();
	
				// store morph normals
	
				var faceNormal, vertexNormals;
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];
	
					faceNormal.copy( face.normal );
	
					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );
	
				}
	
			}
	
			// restore original normals
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;
	
			}
	
		},
	
		computeTangents: function () {
	
			console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );
	
		},
	
		computeLineDistances: function () {
	
			var d = 0;
			var vertices = this.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				if ( i > 0 ) {
	
					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );
	
				}
	
				this.lineDistances[ i ] = d;
	
			}
	
		},
	
		computeBoundingBox: function () {
	
			if ( this.boundingBox === null ) {
	
				this.boundingBox = new THREE.Box3();
	
			}
	
			this.boundingBox.setFromPoints( this.vertices );
	
		},
	
		computeBoundingSphere: function () {
	
			if ( this.boundingSphere === null ) {
	
				this.boundingSphere = new THREE.Sphere();
	
			}
	
			this.boundingSphere.setFromPoints( this.vertices );
	
		},
	
		merge: function ( geometry, matrix, materialIndexOffset ) {
	
			if ( geometry instanceof THREE.Geometry === false ) {
	
				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;
	
			}
	
			var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ];
	
			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
	
			if ( matrix !== undefined ) {
	
				normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
			}
	
			// vertices
	
			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
	
				var vertex = vertices2[ i ];
	
				var vertexCopy = vertex.clone();
	
				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );
	
				vertices1.push( vertexCopy );
	
			}
	
			// faces
	
			for ( i = 0, il = faces2.length; i < il; i ++ ) {
	
				var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;
	
				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );
	
				if ( normalMatrix !== undefined ) {
	
					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
	
				}
	
				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
	
					normal = faceVertexNormals[ j ].clone();
	
					if ( normalMatrix !== undefined ) {
	
						normal.applyMatrix3( normalMatrix ).normalize();
	
					}
	
					faceCopy.vertexNormals.push( normal );
	
				}
	
				faceCopy.color.copy( face.color );
	
				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
	
					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );
	
				}
	
				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
	
				faces1.push( faceCopy );
	
			}
	
			// uvs
	
			for ( i = 0, il = uvs2.length; i < il; i ++ ) {
	
				var uv = uvs2[ i ], uvCopy = [];
	
				if ( uv === undefined ) {
	
					continue;
	
				}
	
				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
					uvCopy.push( uv[ j ].clone() );
	
				}
	
				uvs1.push( uvCopy );
	
			}
	
		},
	
		mergeMesh: function ( mesh ) {
	
			if ( mesh instanceof THREE.Mesh === false ) {
	
				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;
	
			}
	
			mesh.matrixAutoUpdate && mesh.updateMatrix();
	
			this.merge( mesh.geometry, mesh.matrix );
	
		},
	
		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */
	
		mergeVertices: function () {
	
			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];
	
			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;
	
			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
	
				if ( verticesMap[ key ] === undefined ) {
	
					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;
	
				} else {
	
					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];
	
				}
	
			}
	
	
			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];
	
			for ( i = 0, il = this.faces.length; i < il; i ++ ) {
	
				face = this.faces[ i ];
	
				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];
	
				indices = [ face.a, face.b, face.c ];
	
				var dupIndex = - 1;
	
				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {
	
					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {
	
						dupIndex = n;
						faceIndicesToRemove.push( i );
						break;
	
					}
	
				}
	
			}
	
			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
	
				var idx = faceIndicesToRemove[ i ];
	
				this.faces.splice( idx, 1 );
	
				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
	
					this.faceVertexUvs[ j ].splice( idx, 1 );
	
				}
	
			}
	
			// Use unique set of vertices
	
			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;
	
		},
	
		sortFacesByMaterialIndex: function () {
	
			var faces = this.faces;
			var length = faces.length;
	
			// tag faces
	
			for ( var i = 0; i < length; i ++ ) {
	
				faces[ i ]._id = i;
	
			}
	
			// sort faces
	
			function materialIndexSort( a, b ) {
	
				return a.materialIndex - b.materialIndex;
	
			}
	
			faces.sort( materialIndexSort );
	
			// sort uvs
	
			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];
	
			var newUvs1, newUvs2;
	
			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
			if ( uvs2 && uvs2.length === length ) newUvs2 = [];
	
			for ( var i = 0; i < length; i ++ ) {
	
				var id = faces[ i ]._id;
	
				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );
	
			}
	
			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;
	
		},
	
		toJSON: function () {
	
			var data = {
				metadata: {
					version: 4.4,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};
	
			// standard Geometry serialization
	
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.parameters !== undefined ) {
	
				var parameters = this.parameters;
	
				for ( var key in parameters ) {
	
					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
				}
	
				return data;
	
			}
	
			var vertices = [];
	
			for ( var i = 0; i < this.vertices.length; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );
	
			}
	
			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};
	
			for ( var i = 0; i < this.faces.length; i ++ ) {
	
				var face = this.faces[ i ];
	
				var hasMaterial = true;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;
	
				var faceType = 0;
	
				faceType = setBit( faceType, 0, 0 ); // isQuad
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );
	
				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
				faces.push( face.materialIndex );
	
				if ( hasFaceVertexUv ) {
	
					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];
	
					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);
	
				}
	
				if ( hasFaceNormal ) {
	
					faces.push( getNormalIndex( face.normal ) );
	
				}
	
				if ( hasFaceVertexNormal ) {
	
					var vertexNormals = face.vertexNormals;
	
					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);
	
				}
	
				if ( hasFaceColor ) {
	
					faces.push( getColorIndex( face.color ) );
	
				}
	
				if ( hasFaceVertexColor ) {
	
					var vertexColors = face.vertexColors;
	
					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);
	
				}
	
			}
	
			function setBit( value, position, enabled ) {
	
				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );
	
			}
	
			function getNormalIndex( normal ) {
	
				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
	
				if ( normalsHash[ hash ] !== undefined ) {
	
					return normalsHash[ hash ];
	
				}
	
				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );
	
				return normalsHash[ hash ];
	
			}
	
			function getColorIndex( color ) {
	
				var hash = color.r.toString() + color.g.toString() + color.b.toString();
	
				if ( colorsHash[ hash ] !== undefined ) {
	
					return colorsHash[ hash ];
	
				}
	
				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );
	
				return colorsHash[ hash ];
	
			}
	
			function getUvIndex( uv ) {
	
				var hash = uv.x.toString() + uv.y.toString();
	
				if ( uvsHash[ hash ] !== undefined ) {
	
					return uvsHash[ hash ];
	
				}
	
				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );
	
				return uvsHash[ hash ];
	
			}
	
			data.data = {};
	
			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;
	
			return data;
	
		},
	
		clone: function () {
	
			/*
			// Handle primitives
	
			var parameters = this.parameters;
	
			if ( parameters !== undefined ) {
	
				var values = [];
	
				for ( var key in parameters ) {
	
					values.push( parameters[ key ] );
	
				}
	
				var geometry = Object.create( this.constructor.prototype );
				this.constructor.apply( geometry, values );
				return geometry;
	
			}
	
			return new this.constructor().copy( this );
			*/
	
			return new THREE.Geometry().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.vertices = [];
			this.faces = [];
			this.faceVertexUvs = [ [] ];
	
			var vertices = source.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				this.vertices.push( vertices[ i ].clone() );
	
			}
	
			var faces = source.faces;
	
			for ( var i = 0, il = faces.length; i < il; i ++ ) {
	
				this.faces.push( faces[ i ].clone() );
	
			}
	
			for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {
	
				var faceVertexUvs = source.faceVertexUvs[ i ];
	
				if ( this.faceVertexUvs[ i ] === undefined ) {
	
					this.faceVertexUvs[ i ] = [];
	
				}
	
				for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {
	
					var uvs = faceVertexUvs[ j ], uvsCopy = [];
	
					for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {
	
						var uv = uvs[ k ];
	
						uvsCopy.push( uv.clone() );
	
					}
	
					this.faceVertexUvs[ i ].push( uvsCopy );
	
				}
	
			}
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );
	
	THREE.GeometryIdCount = 0;
	
	// File:src/core/DirectGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.DirectGeometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'DirectGeometry';
	
		this.indices = [];
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];
	
		this.groups = [];
	
		this.morphTargets = {};
	
		this.skinWeights = [];
		this.skinIndices = [];
	
		// this.lineDistances = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		// update flags
	
		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;
	
	};
	
	THREE.DirectGeometry.prototype = {
	
		constructor: THREE.DirectGeometry,
	
		computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
		computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
	
		computeFaceNormals: function () {
	
			console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );
	
		},
	
		computeVertexNormals: function () {
	
			console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );
	
		},
	
		computeGroups: function ( geometry ) {
	
			var group;
			var groups = [];
			var materialIndex;
	
			var faces = geometry.faces;
	
			for ( var i = 0; i < faces.length; i ++ ) {
	
				var face = faces[ i ];
	
				// materials
	
				if ( face.materialIndex !== materialIndex ) {
	
					materialIndex = face.materialIndex;
	
					if ( group !== undefined ) {
	
						group.count = ( i * 3 ) - group.start;
						groups.push( group );
	
					}
	
					group = {
						start: i * 3,
						materialIndex: materialIndex
					};
	
				}
	
			}
	
			if ( group !== undefined ) {
	
				group.count = ( i * 3 ) - group.start;
				groups.push( group );
	
			}
	
			this.groups = groups;
	
		},
	
		fromGeometry: function ( geometry ) {
	
			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;
	
			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;
	
			// morphs
	
			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;
	
			var morphTargetsPosition;
	
			if ( morphTargetsLength > 0 ) {
	
				morphTargetsPosition = [];
	
				for ( var i = 0; i < morphTargetsLength; i ++ ) {
	
					morphTargetsPosition[ i ] = [];
	
				}
	
				this.morphTargets.position = morphTargetsPosition;
	
			}
	
			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;
	
			var morphTargetsNormal;
	
			if ( morphNormalsLength > 0 ) {
	
				morphTargetsNormal = [];
	
				for ( var i = 0; i < morphNormalsLength; i ++ ) {
	
					morphTargetsNormal[ i ] = [];
	
				}
	
				this.morphTargets.normal = morphTargetsNormal;
	
			}
	
			// skins
	
			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;
	
			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;
	
			//
	
			for ( var i = 0; i < faces.length; i ++ ) {
	
				var face = faces[ i ];
	
				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );
	
				var vertexNormals = face.vertexNormals;
	
				if ( vertexNormals.length === 3 ) {
	
					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );
	
				} else {
	
					var normal = face.normal;
	
					this.normals.push( normal, normal, normal );
	
				}
	
				var vertexColors = face.vertexColors;
	
				if ( vertexColors.length === 3 ) {
	
					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );
	
				} else {
	
					var color = face.color;
	
					this.colors.push( color, color, color );
	
				}
	
				if ( hasFaceVertexUv === true ) {
	
					var vertexUvs = faceVertexUvs[ 0 ][ i ];
	
					if ( vertexUvs !== undefined ) {
	
						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
					} else {
	
						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );
	
						this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );
	
					}
	
				}
	
				if ( hasFaceVertexUv2 === true ) {
	
					var vertexUvs = faceVertexUvs[ 1 ][ i ];
	
					if ( vertexUvs !== undefined ) {
	
						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
					} else {
	
						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );
	
						this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );
	
					}
	
				}
	
				// morphs
	
				for ( var j = 0; j < morphTargetsLength; j ++ ) {
	
					var morphTarget = morphTargets[ j ].vertices;
	
					morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );
	
				}
	
				for ( var j = 0; j < morphNormalsLength; j ++ ) {
	
					var morphNormal = morphNormals[ j ].vertexNormals[ i ];
	
					morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );
	
				}
	
				// skins
	
				if ( hasSkinIndices ) {
	
					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );
	
				}
	
				if ( hasSkinWeights ) {
	
					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );
	
				}
	
			}
	
			this.computeGroups( geometry );
	
			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );
	
	// File:src/core/BufferGeometry.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferGeometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'BufferGeometry';
	
		this.index = null;
		this.attributes = {};
	
		this.morphAttributes = {};
	
		this.groups = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		this.drawRange = { start: 0, count: Infinity };
	
	};
	
	THREE.BufferGeometry.prototype = {
	
		constructor: THREE.BufferGeometry,
	
		getIndex: function () {
	
			return this.index;
	
		},
	
		setIndex: function ( index ) {
	
			this.index = index;
	
		},
	
		addAttribute: function ( name, attribute ) {
	
			if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {
	
				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );
	
				this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );
	
				return;
	
			}
	
			if ( name === 'index' ) {
	
				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );
	
				return;
	
			}
	
			this.attributes[ name ] = attribute;
	
			return this;
	
		},
	
		getAttribute: function ( name ) {
	
			return this.attributes[ name ];
	
		},
	
		removeAttribute: function ( name ) {
	
			delete this.attributes[ name ];
	
			return this;
	
		},
	
		addGroup: function ( start, count, materialIndex ) {
	
			this.groups.push( {
	
				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0
	
			} );
	
		},
	
		clearGroups: function () {
	
			this.groups = [];
	
		},
	
		setDrawRange: function ( start, count ) {
	
			this.drawRange.start = start;
			this.drawRange.count = count;
	
		},
	
		applyMatrix: function ( matrix ) {
	
			var position = this.attributes.position;
	
			if ( position !== undefined ) {
	
				matrix.applyToVector3Array( position.array );
				position.needsUpdate = true;
	
			}
	
			var normal = this.attributes.normal;
	
			if ( normal !== undefined ) {
	
				var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
				normalMatrix.applyToVector3Array( normal.array );
				normal.needsUpdate = true;
	
			}
	
			if ( this.boundingBox !== null ) {
	
				this.computeBoundingBox();
	
			}
	
			if ( this.boundingSphere !== null ) {
	
				this.computeBoundingSphere();
	
			}
	
		},
	
		rotateX: function () {
	
			// rotate geometry around world x-axis
	
			var m1;
	
			return function rotateX( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationX( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateY: function () {
	
			// rotate geometry around world y-axis
	
			var m1;
	
			return function rotateY( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationY( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateZ: function () {
	
			// rotate geometry around world z-axis
	
			var m1;
	
			return function rotateZ( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationZ( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		translate: function () {
	
			// translate geometry
	
			var m1;
	
			return function translate( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeTranslation( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		scale: function () {
	
			// scale geometry
	
			var m1;
	
			return function scale( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeScale( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		lookAt: function () {
	
			var obj;
	
			return function lookAt( vector ) {
	
				if ( obj === undefined ) obj = new THREE.Object3D();
	
				obj.lookAt( vector );
	
				obj.updateMatrix();
	
				this.applyMatrix( obj.matrix );
	
			};
	
		}(),
	
		center: function () {
	
			this.computeBoundingBox();
	
			var offset = this.boundingBox.center().negate();
	
			this.translate( offset.x, offset.y, offset.z );
	
			return offset;
	
		},
	
		setFromObject: function ( object ) {
	
			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
	
			var geometry = object.geometry;
	
			if ( object instanceof THREE.Points || object instanceof THREE.Line ) {
	
				var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
				var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );
	
				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );
	
				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {
	
					var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );
	
					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );
	
				}
	
				if ( geometry.boundingSphere !== null ) {
	
					this.boundingSphere = geometry.boundingSphere.clone();
	
				}
	
				if ( geometry.boundingBox !== null ) {
	
					this.boundingBox = geometry.boundingBox.clone();
	
				}
	
			} else if ( object instanceof THREE.Mesh ) {
	
				if ( geometry instanceof THREE.Geometry ) {
	
					this.fromGeometry( geometry );
	
				}
	
			}
	
			return this;
	
		},
	
		updateFromObject: function ( object ) {
	
			var geometry = object.geometry;
	
			if ( object instanceof THREE.Mesh ) {
	
				var direct = geometry.__directGeometry;
	
				if ( direct === undefined ) {
	
					return this.fromGeometry( geometry );
	
				}
	
				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;
	
				geometry = direct;
	
			}
	
			if ( geometry.verticesNeedUpdate === true ) {
	
				var attribute = this.attributes.position;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;
	
				}
	
				geometry.verticesNeedUpdate = false;
	
			}
	
			if ( geometry.normalsNeedUpdate === true ) {
	
				var attribute = this.attributes.normal;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;
	
				}
	
				geometry.normalsNeedUpdate = false;
	
			}
	
			if ( geometry.colorsNeedUpdate === true ) {
	
				var attribute = this.attributes.color;
	
				if ( attribute !== undefined ) {
	
					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;
	
				}
	
				geometry.colorsNeedUpdate = false;
	
			}
	
			if ( geometry.uvsNeedUpdate ) {
	
				var attribute = this.attributes.uv;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector2sArray( geometry.uvs );
					attribute.needsUpdate = true;
	
				}
	
				geometry.uvsNeedUpdate = false;
	
			}
	
			if ( geometry.lineDistancesNeedUpdate ) {
	
				var attribute = this.attributes.lineDistance;
	
				if ( attribute !== undefined ) {
	
					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;
	
				}
	
				geometry.lineDistancesNeedUpdate = false;
	
			}
	
			if ( geometry.groupsNeedUpdate ) {
	
				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;
	
				geometry.groupsNeedUpdate = false;
	
			}
	
			return this;
	
		},
	
		fromGeometry: function ( geometry ) {
	
			geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );
	
			return this.fromDirectGeometry( geometry.__directGeometry );
	
		},
	
		fromDirectGeometry: function ( geometry ) {
	
			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );
	
			if ( geometry.normals.length > 0 ) {
	
				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );
	
			}
	
			if ( geometry.colors.length > 0 ) {
	
				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );
	
			}
	
			if ( geometry.uvs.length > 0 ) {
	
				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );
	
			}
	
			if ( geometry.uvs2.length > 0 ) {
	
				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );
	
			}
	
			if ( geometry.indices.length > 0 ) {
	
				var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
				var indices = new TypeArray( geometry.indices.length * 3 );
				this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );
	
			}
	
			// groups
	
			this.groups = geometry.groups;
	
			// morphs
	
			for ( var name in geometry.morphTargets ) {
	
				var array = [];
				var morphTargets = geometry.morphTargets[ name ];
	
				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {
	
					var morphTarget = morphTargets[ i ];
	
					var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );
	
					array.push( attribute.copyVector3sArray( morphTarget ) );
	
				}
	
				this.morphAttributes[ name ] = array;
	
			}
	
			// skinning
	
			if ( geometry.skinIndices.length > 0 ) {
	
				var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );
	
			}
	
			if ( geometry.skinWeights.length > 0 ) {
	
				var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );
	
			}
	
			//
	
			if ( geometry.boundingSphere !== null ) {
	
				this.boundingSphere = geometry.boundingSphere.clone();
	
			}
	
			if ( geometry.boundingBox !== null ) {
	
				this.boundingBox = geometry.boundingBox.clone();
	
			}
	
			return this;
	
		},
	
		computeBoundingBox: function () {
	
			var vector = new THREE.Vector3();
	
			return function () {
	
				if ( this.boundingBox === null ) {
	
					this.boundingBox = new THREE.Box3();
	
				}
	
				var positions = this.attributes.position.array;
	
				if ( positions ) {
	
					this.boundingBox.setFromArray( positions );
	
				}
	
				if ( positions === undefined || positions.length === 0 ) {
	
					this.boundingBox.min.set( 0, 0, 0 );
					this.boundingBox.max.set( 0, 0, 0 );
	
				}
	
				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
	
					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
	
				}
	
			};
	
		}(),
	
		computeBoundingSphere: function () {
	
			var box = new THREE.Box3();
			var vector = new THREE.Vector3();
	
			return function () {
	
				if ( this.boundingSphere === null ) {
	
					this.boundingSphere = new THREE.Sphere();
	
				}
	
				var positions = this.attributes.position.array;
	
				if ( positions ) {
	
					var center = this.boundingSphere.center;
	
					box.setFromArray( positions );
					box.center( center );
	
					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
	
					var maxRadiusSq = 0;
	
					for ( var i = 0, il = positions.length; i < il; i += 3 ) {
	
						vector.fromArray( positions, i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );
	
					}
	
					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
	
					if ( isNaN( this.boundingSphere.radius ) ) {
	
						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );
	
					}
	
				}
	
			};
	
		}(),
	
		computeFaceNormals: function () {
	
			// backwards compatibility
	
		},
	
		computeVertexNormals: function () {
	
			var index = this.index;
			var attributes = this.attributes;
			var groups = this.groups;
	
			if ( attributes.position ) {
	
				var positions = attributes.position.array;
	
				if ( attributes.normal === undefined ) {
	
					this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );
	
				} else {
	
					// reset existing normals to zero
	
					var array = attributes.normal.array;
	
					for ( var i = 0, il = array.length; i < il; i ++ ) {
	
						array[ i ] = 0;
	
					}
	
				}
	
				var normals = attributes.normal.array;
	
				var vA, vB, vC,
	
				pA = new THREE.Vector3(),
				pB = new THREE.Vector3(),
				pC = new THREE.Vector3(),
	
				cb = new THREE.Vector3(),
				ab = new THREE.Vector3();
	
				// indexed elements
	
				if ( index ) {
	
					var indices = index.array;
	
					if ( groups.length === 0 ) {
	
						this.addGroup( 0, indices.length );
	
					}
	
					for ( var j = 0, jl = groups.length; j < jl; ++ j ) {
	
						var group = groups[ j ];
	
						var start = group.start;
						var count = group.count;
	
						for ( var i = start, il = start + count; i < il; i += 3 ) {
	
							vA = indices[ i + 0 ] * 3;
							vB = indices[ i + 1 ] * 3;
							vC = indices[ i + 2 ] * 3;
	
							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );
	
							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );
	
							normals[ vA ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;
	
							normals[ vB ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;
	
							normals[ vC ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;
	
						}
	
					}
	
				} else {
	
					// non-indexed elements (unconnected triangle soup)
	
					for ( var i = 0, il = positions.length; i < il; i += 9 ) {
	
						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );
	
						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );
	
						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;
	
						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;
	
						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;
	
					}
	
				}
	
				this.normalizeNormals();
	
				attributes.normal.needsUpdate = true;
	
			}
	
		},
	
		merge: function ( geometry, offset ) {
	
			if ( geometry instanceof THREE.BufferGeometry === false ) {
	
				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;
	
			}
	
			if ( offset === undefined ) offset = 0;
	
			var attributes = this.attributes;
	
			for ( var key in attributes ) {
	
				if ( geometry.attributes[ key ] === undefined ) continue;
	
				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;
	
				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;
	
				var attributeSize = attribute2.itemSize;
	
				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {
	
					attributeArray1[ j ] = attributeArray2[ i ];
	
				}
	
			}
	
			return this;
	
		},
	
		normalizeNormals: function () {
	
			var normals = this.attributes.normal.array;
	
			var x, y, z, n;
	
			for ( var i = 0, il = normals.length; i < il; i += 3 ) {
	
				x = normals[ i ];
				y = normals[ i + 1 ];
				z = normals[ i + 2 ];
	
				n = 1.0 / Math.sqrt( x * x + y * y + z * z );
	
				normals[ i ] *= n;
				normals[ i + 1 ] *= n;
				normals[ i + 2 ] *= n;
	
			}
	
		},
	
		toNonIndexed: function () {
	
			if ( this.index === null ) {
	
				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;
	
			}
	
			var geometry2 = new THREE.BufferGeometry();
	
			var indices = this.index.array;
			var attributes = this.attributes;
	
			for ( var name in attributes ) {
	
				var attribute = attributes[ name ];
	
				var array = attribute.array;
				var itemSize = attribute.itemSize;
	
				var array2 = new array.constructor( indices.length * itemSize );
	
				var index = 0, index2 = 0;
	
				for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
					index = indices[ i ] * itemSize;
	
					for ( var j = 0; j < itemSize; j ++ ) {
	
						array2[ index2 ++ ] = array[ index ++ ];
	
					}
	
				}
	
				geometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );
	
			}
	
			return geometry2;
	
		},
	
		toJSON: function () {
	
			var data = {
				metadata: {
					version: 4.4,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};
	
			// standard BufferGeometry serialization
	
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.parameters !== undefined ) {
	
				var parameters = this.parameters;
	
				for ( var key in parameters ) {
	
					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
				}
	
				return data;
	
			}
	
			data.data = { attributes: {} };
	
			var index = this.index;
	
			if ( index !== null ) {
	
				var array = Array.prototype.slice.call( index.array );
	
				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};
	
			}
	
			var attributes = this.attributes;
	
			for ( var key in attributes ) {
	
				var attribute = attributes[ key ];
	
				var array = Array.prototype.slice.call( attribute.array );
	
				data.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array
				};
	
			}
	
			var groups = this.groups;
	
			if ( groups.length > 0 ) {
	
				data.data.groups = JSON.parse( JSON.stringify( groups ) );
	
			}
	
			var boundingSphere = this.boundingSphere;
	
			if ( boundingSphere !== null ) {
	
				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};
	
			}
	
			return data;
	
		},
	
		clone: function () {
	
			/*
			// Handle primitives
	
			var parameters = this.parameters;
	
			if ( parameters !== undefined ) {
	
				var values = [];
	
				for ( var key in parameters ) {
	
					values.push( parameters[ key ] );
	
				}
	
				var geometry = Object.create( this.constructor.prototype );
				this.constructor.apply( geometry, values );
				return geometry;
	
			}
	
			return new this.constructor().copy( this );
			*/
	
			return new THREE.BufferGeometry().copy( this );
	
		},
	
		copy: function ( source ) {
	
			var index = source.index;
	
			if ( index !== null ) {
	
				this.setIndex( index.clone() );
	
			}
	
			var attributes = source.attributes;
	
			for ( var name in attributes ) {
	
				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );
	
			}
	
			var groups = source.groups;
	
			for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
				var group = groups[ i ];
				this.addGroup( group.start, group.count );
	
			}
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );
	
	THREE.BufferGeometry.MaxIndex = 65535;
	
	// File:src/core/InstancedBufferGeometry.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InstancedBufferGeometry = function () {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;
	
	};
	
	THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;
	
	THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {
	
		this.groups.push( {
	
			start: start,
			count: count,
			instances: instances
	
		} );
	
	};
	
	THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {
	
		var index = source.index;
	
		if ( index !== null ) {
	
			this.setIndex( index.clone() );
	
		}
	
		var attributes = source.attributes;
	
		for ( var name in attributes ) {
	
			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );
	
		}
	
		var groups = source.groups;
	
		for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.instances );
	
		}
	
		return this;
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );
	
	// File:src/core/Uniform.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Uniform = function ( type, value ) {
	
		this.type = type;
		this.value = value;
	
		this.dynamic = false;
	
	};
	
	THREE.Uniform.prototype = {
	
		constructor: THREE.Uniform,
	
		onUpdate: function ( callback ) {
	
			this.dynamic = true;
			this.onUpdateCallback = callback;
	
			return this;
	
		}
	
	};
	
	// File:src/animation/AnimationClip.js
	
	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.AnimationClip = function ( name, duration, tracks ) {
	
		this.name = name || THREE.Math.generateUUID();
		this.tracks = tracks;
		this.duration = ( duration !== undefined ) ? duration : -1;
	
		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {
	
			this.resetDuration();
	
		}
	
		// maybe only do these on demand, as doing them here could potentially slow down loading
		// but leaving these here during development as this ensures a lot of testing of these functions
		this.trim();
		this.optimize();
	
	};
	
	THREE.AnimationClip.prototype = {
	
		constructor: THREE.AnimationClip,
	
		resetDuration: function() {
	
			var tracks = this.tracks,
				duration = 0;
	
			for ( var i = 0, n = tracks.length; i !== n; ++ i ) {
	
				var track = this.tracks[ i ];
	
				duration = Math.max(
						duration, track.times[ track.times.length - 1 ] );
	
			}
	
			this.duration = duration;
	
		},
	
		trim: function() {
	
			for ( var i = 0; i < this.tracks.length; i ++ ) {
	
				this.tracks[ i ].trim( 0, this.duration );
	
			}
	
			return this;
	
		},
	
		optimize: function() {
	
			for ( var i = 0; i < this.tracks.length; i ++ ) {
	
				this.tracks[ i ].optimize();
	
			}
	
			return this;
	
		}
	
	};
	
	// Static methods:
	
	Object.assign( THREE.AnimationClip, {
	
		parse: function( json ) {
	
			var tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );
	
			for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {
	
				tracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );
	
			}
	
			return new THREE.AnimationClip( json.name, json.duration, tracks );
	
		},
	
	
		toJSON: function( clip ) {
	
			var tracks = [],
				clipTracks = clip.tracks;
	
			var json = {
	
				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks
	
			};
	
			for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {
	
				tracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );
	
			}
	
			return json;
	
		},
	
	
		CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps ) {
	
			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];
	
			for ( var i = 0; i < numMorphTargets; i ++ ) {
	
				var times = [];
				var values = [];
	
				times.push(
						( i + numMorphTargets - 1 ) % numMorphTargets,
						i,
						( i + 1 ) % numMorphTargets );
	
				values.push( 0, 1, 0 );
	
				var order = THREE.AnimationUtils.getKeyframeOrder( times );
				times = THREE.AnimationUtils.sortedArray( times, 1, order );
				values = THREE.AnimationUtils.sortedArray( values, 1, order );
	
				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( times[ 0 ] === 0 ) {
	
					times.push( numMorphTargets );
					values.push( values[ 0 ] );
	
				}
	
				tracks.push(
						new THREE.NumberKeyframeTrack(
							'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
							times, values
						).scale( 1.0 / fps ) );
			}
	
			return new THREE.AnimationClip( name, -1, tracks );
	
		},
	
		findByName: function( clipArray, name ) {
	
			for ( var i = 0; i < clipArray.length; i ++ ) {
	
				if ( clipArray[ i ].name === name ) {
	
					return clipArray[ i ];
	
				}
			}
	
			return null;
	
		},
	
		CreateClipsFromMorphTargetSequences: function( morphTargets, fps ) {
	
			var animationToMorphTargets = {};
	
			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			var pattern = /^([\w-]*?)([\d]+)$/;
	
			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {
	
				var morphTarget = morphTargets[ i ];
				var parts = morphTarget.name.match( pattern );
	
				if ( parts && parts.length > 1 ) {
	
					var name = parts[ 1 ];
	
					var animationMorphTargets = animationToMorphTargets[ name ];
					if ( ! animationMorphTargets ) {
	
						animationToMorphTargets[ name ] = animationMorphTargets = [];
	
					}
	
					animationMorphTargets.push( morphTarget );
	
				}
	
			}
	
			var clips = [];
	
			for ( var name in animationToMorphTargets ) {
	
				clips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps ) );
	
			}
	
			return clips;
	
		},
	
		// parse the animation.hierarchy format
		parseAnimation: function( animation, bones, nodeName ) {
	
			if ( ! animation ) {
	
				console.error( "  no animation in JSONLoader data" );
				return null;
	
			}
	
			var addNonemptyTrack = function(
					trackType, trackName, animationKeys, propertyName, destTracks ) {
	
				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {
	
					var times = [];
					var values = [];
	
					THREE.AnimationUtils.flattenJSON(
							animationKeys, times, values, propertyName );
	
					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {
	
						destTracks.push( new trackType( trackName, times, values ) );
	
					}
	
				}
	
			};
	
			var tracks = [];
	
			var clipName = animation.name || 'default';
			// automatic length determination in AnimationClip.
			var duration = animation.length || -1;
			var fps = animation.fps || 30;
	
			var hierarchyTracks = animation.hierarchy || [];
	
			for ( var h = 0; h < hierarchyTracks.length; h ++ ) {
	
				var animationKeys = hierarchyTracks[ h ].keys;
	
				// skip empty tracks
				if ( ! animationKeys || animationKeys.length == 0 ) continue;
	
				// process morph targets in a way exactly compatible
				// with AnimationHandler.init( animation )
				if ( animationKeys[0].morphTargets ) {
	
					// figure out all morph targets used in this track
					var morphTargetNames = {};
					for ( var k = 0; k < animationKeys.length; k ++ ) {
	
						if ( animationKeys[k].morphTargets ) {
	
							for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {
	
								morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
							}
	
						}
	
					}
	
					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( var morphTargetName in morphTargetNames ) {
	
						var times = [];
						var values = [];
	
						for ( var m = 0;
								m !== animationKeys[k].morphTargets.length; ++ m ) {
	
							var animationKey = animationKeys[k];
	
							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )
	
						}
	
						tracks.push( new THREE.NumberKeyframeTrack(
								'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );
	
					}
	
					duration = morphTargetNames.length * ( fps || 1.0 );
	
				} else {
					// ...assume skeletal animation
	
					var boneName = '.bones[' + bones[ h ].name + ']';
	
					addNonemptyTrack(
							THREE.VectorKeyframeTrack, boneName + '.position',
							animationKeys, 'pos', tracks );
	
					addNonemptyTrack(
							THREE.QuaternionKeyframeTrack, boneName + '.quaternion',
							animationKeys, 'rot', tracks );
	
					addNonemptyTrack(
							THREE.VectorKeyframeTrack, boneName + '.scale',
							animationKeys, 'scl', tracks );
	
				}
	
			}
	
			if ( tracks.length === 0 ) {
	
				return null;
	
			}
	
			var clip = new THREE.AnimationClip( clipName, duration, tracks );
	
			return clip;
	
		}
	
	} );
	
	
	// File:src/animation/AnimationMixer.js
	
	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.AnimationMixer = function( root ) {
	
		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
	
		this.time = 0;
	
		this.timeScale = 1.0;
	
	};
	
	THREE.AnimationMixer.prototype = {
	
		constructor: THREE.AnimationMixer,
	
		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction: function( clip, optionalRoot ) {
	
			var root = optionalRoot || this._root,
				rootUuid = root.uuid,
				clipName = ( typeof clip === 'string' ) ? clip : clip.name,
				clipObject = ( clip !== clipName ) ? clip : null,
	
				actionsForClip = this._actionsByClip[ clipName ],
				prototypeAction;
	
			if ( actionsForClip !== undefined ) {
	
				var existingAction =
						actionsForClip.actionByRoot[ rootUuid ];
	
				if ( existingAction !== undefined ) {
	
					return existingAction;
	
				}
	
				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];
	
				// also, take the clip from the prototype action
				clipObject = prototypeAction._clip;
	
				if ( clip !== clipName && clip !== clipObject ) {
	
					throw new Error(
							"Different clips with the same name detected!" );
	
				}
	
			}
	
			// clip must be known when specified via string
			if ( clipObject === null ) return null;
	
			// allocate all resources required to run it
			var newAction = new THREE.
					AnimationMixer._Action( this, clipObject, optionalRoot );
	
			this._bindAction( newAction, prototypeAction );
	
			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipName, rootUuid );
	
			return newAction;
	
		},
	
		// get an existing action
		existingAction: function( clip, optionalRoot ) {
	
			var root = optionalRoot || this._root,
				rootUuid = root.uuid,
				clipName = ( typeof clip === 'string' ) ? clip : clip.name,
				actionsForClip = this._actionsByClip[ clipName ];
	
			if ( actionsForClip !== undefined ) {
	
				return actionsForClip.actionByRoot[ rootUuid ] || null;
	
			}
	
			return null;
	
		},
	
		// deactivates all previously scheduled actions
		stopAllAction: function() {
	
			var actions = this._actions,
				nActions = this._nActiveActions,
				bindings = this._bindings,
				nBindings = this._nActiveBindings;
	
			this._nActiveActions = 0;
			this._nActiveBindings = 0;
	
			for ( var i = 0; i !== nActions; ++ i ) {
	
				actions[ i ].reset();
	
			}
	
			for ( var i = 0; i !== nBindings; ++ i ) {
	
				bindings[ i ].useCount = 0;
	
			}
	
			return this;
	
		},
	
		// advance the time and update apply the animation
		update: function( deltaTime ) {
	
			deltaTime *= this.timeScale;
	
			var actions = this._actions,
				nActions = this._nActiveActions,
	
				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),
	
				accuIndex = this._accuIndex ^= 1;
	
			// run active actions
	
			for ( var i = 0; i !== nActions; ++ i ) {
	
				var action = actions[ i ];
	
				if ( action.enabled ) {
	
					action._update( time, deltaTime, timeDirection, accuIndex );
	
				}
	
			}
	
			// update scene graph
	
			var bindings = this._bindings,
				nBindings = this._nActiveBindings;
	
			for ( var i = 0; i !== nBindings; ++ i ) {
	
				bindings[ i ].apply( accuIndex );
	
			}
	
			return this;
	
		},
	
		// return this mixer's root target object
		getRoot: function() {
	
			return this._root;
	
		},
	
		// free all resources specific to a particular clip
		uncacheClip: function( clip ) {
	
			var actions = this._actions,
				clipName = clip.name,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipName ];
	
			if ( actionsForClip !== undefined ) {
	
				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away
	
				var actionsToRemove = actionsForClip.knownActions;
	
				for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {
	
					var action = actionsToRemove[ i ];
	
					this._deactivateAction( action );
	
					var cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];
	
					action._cacheIndex = null;
					action._byClipCacheIndex = null;
	
					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();
	
					this._removeInactiveBindingsForAction( action );
	
				}
	
				delete actionsByClip[ clipName ];
	
			}
	
		},
	
		// free all resources specific to a particular root target object
		uncacheRoot: function( root ) {
	
			var rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;
	
			for ( var clipName in actionsByClip ) {
	
				var actionByRoot = actionsByClip[ clipName ].actionByRoot,
					action = actionByRoot[ rootUuid ];
	
				if ( action !== undefined ) {
	
					this._deactivateAction( action );
					this._removeInactiveAction( action );
	
				}
	
			}
	
			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];
	
			if ( bindingByName !== undefined ) {
	
				for ( var trackName in bindingByName ) {
	
					var binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );
	
				}
	
			}
	
		},
	
		// remove a targeted clip from the cache
		uncacheAction: function( clip, optionalRoot ) {
	
			var action = this.existingAction( clip, optionalRoot );
	
			if ( action !== null ) {
	
				this._deactivateAction( action );
				this._removeInactiveAction( action );
	
			}
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );
	
	THREE.AnimationMixer._Action =
			function( mixer, clip, localRoot ) {
	
		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot || null;
	
		var tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );
	
		var interpolantSettings = {
				endingStart: 	THREE.ZeroCurvatureEnding,
				endingEnd:		THREE.ZeroCurvatureEnding
		};
	
		for ( var i = 0; i !== nTracks; ++ i ) {
	
			var interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings
	
		}
	
		this._interpolantSettings = interpolantSettings;
	
		this._interpolants = interpolants;	// bound by the mixer
	
		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );
	
		this._cacheIndex = null;			// for the memory manager
		this._byClipCacheIndex = null;		// for the memory manager
	
		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;
	
		this.loop = THREE.LoopRepeat;
		this._loopCount = -1;
	
		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;
	
		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;
	
		this.timeScale = 1;
		this._effectiveTimeScale = 1;
	
		this.weight = 1;
		this._effectiveWeight = 1;
	
		this.repetitions = Infinity; 		// no. of repetitions when looping
	
		this.paused = false;				// false -> zero effective time scale
		this.enabled = true;				// true -> zero effective weight
	
		this.clampWhenFinished 	= false;	// keep feeding the last frame?
	
		this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd		= true;		// clips for start, loop and end
	
	};
	
	THREE.AnimationMixer._Action.prototype = {
	
		constructor: THREE.AnimationMixer._Action,
	
		// State & Scheduling
	
		play: function() {
	
			this._mixer._activateAction( this );
	
			return this;
	
		},
	
		stop: function() {
	
			this._mixer._deactivateAction( this );
	
			return this.reset();
	
		},
	
		reset: function() {
	
			this.paused = false;
			this.enabled = true;
	
			this.time = 0;			// restart clip
			this._loopCount = -1;	// forget previous loops
			this._startTime = null;	// forget scheduling
	
			return this.stopFading().stopWarping();
	
		},
	
		isRunning: function() {
	
			var start = this._startTime;
	
			return this.enabled && ! this.paused && this.timeScale !== 0 &&
					this._startTime === null && this._mixer._isActiveAction( this )
	
		},
	
		// return true when play has been called
		isScheduled: function() {
	
			return this._mixer._isActiveAction( this );
	
		},
	
		startAt: function( time ) {
	
			this._startTime = time;
	
			return this;
	
		},
	
		setLoop: function( mode, repetitions ) {
	
			this.loop = mode;
			this.repetitions = repetitions;
	
			return this;
	
		},
	
		// Weight
	
		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight: function( weight ) {
	
			this.weight = weight;
	
			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;
	
			return this.stopFading();
	
		},
	
		// return the weight considering fading and .enabled
		getEffectiveWeight: function() {
	
			return this._effectiveWeight;
	
		},
	
		fadeIn: function( duration ) {
	
			return this._scheduleFading( duration, 0, 1 );
	
		},
	
		fadeOut: function( duration ) {
	
			return this._scheduleFading( duration, 1, 0 );
	
		},
	
		crossFadeFrom: function( fadeOutAction, duration, warp ) {
	
			var mixer = this._mixer;
	
			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );
	
			if( warp ) {
	
				var fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,
	
					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;
	
				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );
	
			}
	
			return this;
	
		},
	
		crossFadeTo: function( fadeInAction, duration, warp ) {
	
			return fadeInAction.crossFadeFrom( this, duration, warp );
	
		},
	
		stopFading: function() {
	
			var weightInterpolant = this._weightInterpolant;
	
			if ( weightInterpolant !== null ) {
	
				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );
	
			}
	
			return this;
	
		},
	
		// Time Scale Control
	
		// set the weight stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale: function( timeScale ) {
	
			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 :timeScale;
	
			return this.stopWarping();
	
		},
	
		// return the time scale considering warping and .paused
		getEffectiveTimeScale: function() {
	
			return this._effectiveTimeScale;
	
		},
	
		setDuration: function( duration ) {
	
			this.timeScale = this._clip.duration / duration;
	
			return this.stopWarping();
	
		},
	
		syncWith: function( action ) {
	
			this.time = action.time;
			this.timeScale = action.timeScale;
	
			return this.stopWarping();
	
		},
	
		halt: function( duration ) {
	
			return this.warp( this._currentTimeScale, 0, duration );
	
		},
	
		warp: function( startTimeScale, endTimeScale, duration ) {
	
			var mixer = this._mixer, now = mixer.time,
				interpolant = this._timeScaleInterpolant,
	
				timeScale = this.timeScale;
	
			if ( interpolant === null ) {
	
				interpolant = mixer._lendControlInterpolant(),
				this._timeScaleInterpolant = interpolant;
	
			}
	
			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;
	
			times[ 0 ] = now;
			times[ 1 ] = now + duration;
	
			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;
	
			return this;
	
		},
	
		stopWarping: function() {
	
			var timeScaleInterpolant = this._timeScaleInterpolant;
	
			if ( timeScaleInterpolant !== null ) {
	
				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );
	
			}
	
			return this;
	
		},
	
		// Object Accessors
	
		getMixer: function() {
	
			return this._mixer;
	
		},
	
		getClip: function() {
	
			return this._clip;
	
		},
	
		getRoot: function() {
	
			return this._localRoot || this._mixer._root;
	
		},
	
		// Interna
	
		_update: function( time, deltaTime, timeDirection, accuIndex ) {
			// called by the mixer
	
			var startTime = this._startTime;
	
			if ( startTime !== null ) {
	
				// check for scheduled start of action
	
				var timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning < 0 || timeDirection === 0 ) {
	
					return; // yet to come / don't decide when delta = 0
	
				}
	
				// start
	
				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;
	
			}
	
			// apply time scale and advance time
	
			deltaTime *= this._updateTimeScale( time );
			var clipTime = this._updateTime( deltaTime );
	
			// note: _updateTime may disable the action resulting in
			// an effective weight of 0
	
			var weight = this._updateWeight( time );
	
			if ( weight > 0 ) {
	
				var interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;
	
				for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {
	
					interpolants[ j ].evaluate( clipTime );
					propertyMixers[ j ].accumulate( accuIndex, weight );
	
				}
	
			}
	
		},
	
		_updateWeight: function( time ) {
	
			var weight = 0;
	
			if ( this.enabled ) {
	
				weight = this.weight;
				var interpolant = this._weightInterpolant;
	
				if ( interpolant !== null ) {
	
					var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
					weight *= interpolantValue;
	
					if ( time > interpolant.parameterPositions[ 1 ] ) {
	
						this.stopFading();
	
						if ( interpolantValue === 0 ) {
	
							// faded out, disable
							this.enabled = false;
	
						}
	
					}
	
				}
	
			}
	
			this._effectiveWeight = weight;
			return weight;
	
		},
	
		_updateTimeScale: function( time ) {
	
			var timeScale = 0;
	
			if ( ! this.paused ) {
	
				timeScale = this.timeScale;
	
				var interpolant = this._timeScaleInterpolant;
	
				if ( interpolant !== null ) {
	
					var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
					timeScale *= interpolantValue;
	
					if ( time > interpolant.parameterPositions[ 1 ] ) {
	
						this.stopWarping();
	
						if ( timeScale === 0 ) {
	
							// motion has halted, pause
							this.pause = true;
	
						} else {
	
							// warp done - apply final time scale
							this.timeScale = timeScale;
	
						}
	
					}
	
				}
	
			}
	
			this._effectiveTimeScale = timeScale;
			return timeScale;
	
		},
	
		_updateTime: function( deltaTime ) {
	
			var time = this.time + deltaTime;
	
			if ( deltaTime === 0 ) return time;
	
			var duration = this._clip.duration,
	
				loop = this.loop,
				loopCount = this._loopCount,
	
				pingPong = false;
	
			switch ( loop ) {
	
				case THREE.LoopOnce:
	
					if ( loopCount === -1 ) {
	
						// just started
	
						this.loopCount = 0;
						this._setEndings( true, true, false );
	
					}
	
					if ( time >= duration ) {
	
						time = duration;
	
					} else if ( time < 0 ) {
	
						time = 0;
	
					} else break;
	
					// reached the end
	
					if ( this.clampWhenFinished ) this.pause = true;
					else this.enabled = false;
	
					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime < 0 ? -1 : 1
					} );
	
					break;
	
				case THREE.LoopPingPong:
	
					pingPong = true;
	
				case THREE.LoopRepeat:
	
					if ( loopCount === -1 ) {
	
						// just started
	
						if ( deltaTime > 0 ) {
	
							loopCount = 0;
	
							this._setEndings(
									true, this.repetitions === 0, pingPong );
	
						} else {
	
							// when looping in reverse direction, the initial
							// transition through zero counts as a repetition,
							// so leave loopCount at -1
	
							this._setEndings(
									this.repetitions === 0, true, pingPong );
	
						}
	
					}
	
					if ( time >= duration || time < 0 ) {
	
						// wrap around
	
						var loopDelta = Math.floor( time / duration ); // signed
						time -= duration * loopDelta;
	
						loopCount += Math.abs( loopDelta );
	
						var pending = this.repetitions - loopCount;
	
						if ( pending < 0 ) {
	
							// stop (switch state, clamp time, fire event)
	
							if ( this.clampWhenFinished ) this.paused = true;
							else this.enabled = false;
	
							time = deltaTime > 0 ? duration : 0;
	
							this._mixer.dispatchEvent( {
								type: 'finished', action: this,
								direction: deltaTime > 0 ? 1 : -1
							} );
	
							break;
	
						} else if ( pending === 0 ) {
	
							// transition to last round
	
							var atStart = deltaTime < 0;
							this._setEndings( atStart, ! atStart, pingPong );
	
						} else {
	
							this._setEndings( false, false, pingPong );
	
						}
	
						this._loopCount = loopCount;
	
						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );
	
					}
	
					if ( loop === THREE.LoopPingPong && ( loopCount & 1 ) === 1 ) {
	
						// invert time for the "pong round"
	
						this.time = time;
	
						return duration - time;
	
					}
	
					break;
	
			}
	
			this.time = time;
	
			return time;
	
		},
	
		_setEndings: function( atStart, atEnd, pingPong ) {
	
			var settings = this._interpolantSettings;
	
			if ( pingPong ) {
	
				settings.endingStart 	= THREE.ZeroSlopeEnding;
				settings.endingEnd		= THREE.ZeroSlopeEnding;
	
			} else {
	
				// assuming for LoopOnce atStart == atEnd == true
	
				if ( atStart ) {
	
					settings.endingStart = this.zeroSlopeAtStart ?
							THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;
	
				} else {
	
					settings.endingStart = THREE.WrapAroundEnding;
	
				}
	
				if ( atEnd ) {
	
					settings.endingEnd = this.zeroSlopeAtEnd ?
							THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;
	
				} else {
	
					settings.endingEnd 	 = THREE.WrapAroundEnding;
	
				}
	
			}
	
		},
	
		_scheduleFading: function( duration, weightNow, weightThen ) {
	
			var mixer = this._mixer, now = mixer.time,
				interpolant = this._weightInterpolant;
	
			if ( interpolant === null ) {
	
				interpolant = mixer._lendControlInterpolant(),
				this._weightInterpolant = interpolant;
	
			}
	
			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;
	
			times[ 0 ] = now; 				values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;	values[ 1 ] = weightThen;
	
			return this;
	
		}
	
	};
	
	// Implementation details:
	
	Object.assign( THREE.AnimationMixer.prototype, {
	
		_bindAction: function( action, prototypeAction ) {
	
			var root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingsByName = bindingsByRoot[ rootUuid ];
	
			if ( bindingsByName === undefined ) {
	
				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;
	
			}
	
			for ( var i = 0; i !== nTracks; ++ i ) {
	
				var track = tracks[ i ],
					trackName = track.name,
					binding = bindingsByName[ trackName ];
	
				if ( binding !== undefined ) {
	
					bindings[ i ] = binding;
	
				} else {
	
					binding = bindings[ i ];
	
					if ( binding !== undefined ) {
	
						// existing binding, make sure the cache knows
	
						if ( binding._cacheIndex === null ) {
	
							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );
	
						}
	
						continue;
	
					}
	
					var path = prototypeAction && prototypeAction.
							_propertyBindings[ i ].binding.parsedPath;
	
					binding = new THREE.PropertyMixer(
							THREE.PropertyBinding.create( root, trackName, path ),
							track.ValueTypeName, track.getValueSize() );
	
					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );
	
					bindings[ i ] = binding;
	
				}
	
				interpolants[ i ].resultBuffer = binding.buffer;
	
			}
	
		},
	
		_activateAction: function( action ) {
	
			if ( ! this._isActiveAction( action ) ) {
	
				if ( action._cacheIndex === null ) {
	
					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind
	
					var rootUuid = ( action._localRoot || this._root ).uuid,
						clipName = action._clip.name,
						actionsForClip = this._actionsByClip[ clipName ];
	
					this._bindAction( action,
							actionsForClip && actionsForClip.knownActions[ 0 ] );
	
					this._addInactiveAction( action, clipName, rootUuid );
	
				}
	
				var bindings = action._propertyBindings;
	
				// increment reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
					var binding = bindings[ i ];
	
					if ( binding.useCount ++ === 0 ) {
	
						this._lendBinding( binding );
						binding.saveOriginalState();
	
					}
	
				}
	
				this._lendAction( action );
	
			}
	
		},
	
		_deactivateAction: function( action ) {
	
			if ( this._isActiveAction( action ) ) {
	
				var bindings = action._propertyBindings;
	
				// decrement reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
					var binding = bindings[ i ];
	
					if ( -- binding.useCount === 0 ) {
	
						binding.restoreOriginalState();
						this._takeBackBinding( binding );
	
					}
	
				}
	
				this._takeBackAction( action );
	
			}
	
		},
	
		// Memory manager
	
		_initMemoryManager: function() {
	
			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;
	
			this._actionsByClip = {};
			// inside:
			// {
			// 		knownActions: Array< _Action >	- used as prototypes
			// 		actionByRoot: _Action			- lookup
			// }
	
	
			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;
	
			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
	
	
			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;
	
			var scope = this;
	
			this.stats = {
	
				actions: {
					get total() { return scope._actions.length; },
					get inUse() { return scope._nActiveActions; }
				},
				bindings: {
					get total() { return scope._bindings.length; },
					get inUse() { return scope._nActiveBindings; }
				},
				controlInterpolants: {
					get total() { return scope._controlInterpolants.length; },
					get inUse() { return scope._nActiveControlInterpolants; }
				}
	
			};
	
		},
	
		// Memory management for _Action objects
	
		_isActiveAction: function( action ) {
	
			var index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;
	
		},
	
		_addInactiveAction: function( action, clipName, rootUuid ) {
	
			var actions = this._actions,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipName ];
	
			if ( actionsForClip === undefined ) {
	
				actionsForClip = {
	
					knownActions: [ action ],
					actionByRoot: {}
	
				};
	
				action._byClipCacheIndex = 0;
	
				actionsByClip[ clipName ] = actionsForClip;
	
			} else {
	
				var knownActions = actionsForClip.knownActions;
	
				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );
	
			}
	
			action._cacheIndex = actions.length;
			actions.push( action );
	
			actionsForClip.actionByRoot[ rootUuid ] = action;
	
		},
	
		_removeInactiveAction: function( action ) {
	
			var actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;
	
			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();
	
			action._cacheIndex = null;
	
	
			var clipName = action._clip.name,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipName ],
				knownActionsForClip = actionsForClip.knownActions,
	
				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],
	
				byClipCacheIndex = action._byClipCacheIndex;
	
			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();
	
			action._byClipCacheIndex = null;
	
	
			var actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( actions._localRoot || this._root ).uuid;
	
			delete actionByRoot[ rootUuid ];
	
			if ( knownActionsForClip.length === 0 ) {
	
				delete actionsByClip[ clipName ];
	
			}
	
			this._removeInactiveBindingsForAction( action );
	
		},
	
		_removeInactiveBindingsForAction: function( action ) {
	
			var bindings = action._propertyBindings;
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
				var binding = bindings[ i ];
	
				if ( -- binding.referenceCount === 0 ) {
	
					this._removeInactiveBinding( binding );
	
				}
	
			}
	
		},
	
		_lendAction: function( action ) {
	
			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s
	
			var actions = this._actions,
				prevIndex = action._cacheIndex,
	
				lastActiveIndex = this._nActiveActions ++,
	
				firstInactiveAction = actions[ lastActiveIndex ];
	
			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;
	
			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;
	
		},
	
		_takeBackAction: function( action ) {
	
			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a
	
			var actions = this._actions,
				prevIndex = action._cacheIndex,
	
				firstInactiveIndex = -- this._nActiveActions,
	
				lastActiveAction = actions[ firstInactiveIndex ];
	
			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;
	
			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;
	
		},
	
		// Memory management for PropertyMixer objects
	
		_addInactiveBinding: function( binding, rootUuid, trackName ) {
	
			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],
	
				bindings = this._bindings;
	
			if ( bindingByName === undefined ) {
	
				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;
	
			}
	
			bindingByName[ trackName ] = binding;
	
			binding._cacheIndex = bindings.length;
			bindings.push( binding );
	
		},
	
		_removeInactiveBinding: function( binding ) {
	
			var bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],
	
				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;
	
			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();
	
			delete bindingByName[ trackName ];
	
			remove_empty_map: {
	
				for ( var _ in bindingByName ) break remove_empty_map;
	
				delete bindingsByRoot[ rootUuid ];
	
			}
	
		},
	
		_lendBinding: function( binding ) {
	
			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,
	
				lastActiveIndex = this._nActiveBindings ++,
	
				firstInactiveBinding = bindings[ lastActiveIndex ];
	
			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;
	
			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;
	
		},
	
		_takeBackBinding: function( binding ) {
	
			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,
	
				firstInactiveIndex = -- this._nActiveBindings,
	
				lastActiveBinding = bindings[ firstInactiveIndex ];
	
			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;
	
			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;
	
		},
	
	
		// Memory management of Interpolants for weight and time scale
	
		_lendControlInterpolant: function() {
	
			var interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++,
				interpolant = interpolants[ lastActiveIndex ];
	
			if ( interpolant === undefined ) {
	
				interpolant = new THREE.LinearInterpolant(
						new Float32Array( 2 ), new Float32Array( 2 ),
							1, this._controlInterpolantsResultBuffer );
	
				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;
	
			}
	
			return interpolant;
	
		},
	
		_takeBackControlInterpolant: function( interpolant ) {
	
			var interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,
	
				firstInactiveIndex = -- this._nActiveControlInterpolants,
	
				lastActiveInterpolant = interpolants[ firstInactiveIndex ];
	
			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;
	
			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;
	
		},
	
		_controlInterpolantsResultBuffer: new Float32Array( 1 )
	
	} );
	
	
	// File:src/animation/AnimationObjectGroup.js
	
	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 * 	-	Add objects you would otherwise pass as 'root' to the
	 * 		constructor or the .clipAction method of AnimationMixer.
	 *
	 * 	-	Instead pass this object as 'root'.
	 *
	 * 	-	You can also add and remove objects later when the mixer
	 * 		is running.
	 *
	 * Note:
	 *
	 *  	Objects of this class appear as one object to the mixer,
	 *  	so cache control of the individual objects must be done
	 *  	on the group.
	 *
	 * Limitation:
	 *
	 * 	- 	The animated properties must be compatible among the
	 * 		all objects in the group.
	 *
	 *  -	A single property can either be controlled through a
	 *  	target group or directly, but not both.
	 *
	 * @author tschw
	 */
	
	THREE.AnimationObjectGroup = function( var_args ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );
	
		this.nCachedObjects_ = 0;			// threshold
		// note: read by PropertyBinding.Composite
	
		var indices = {};
		this._indicesByUUID = indices;		// for bookkeeping
	
		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
			indices[ arguments[ i ].uuid ] = i;
	
		}
	
		this._paths = [];					// inside: string
		this._parsedPaths = [];				// inside: { we don't care, here }
		this._bindings = []; 				// inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays
	
		var scope = this;
	
		this.stats = {
	
			objects: {
				get total() { return scope._objects.length; },
				get inUse() { return this.total - scope.nCachedObjects_;  }
			},
	
			get bindingsPerObject() { return scope._bindings.length; }
	
		};
	
	};
	
	THREE.AnimationObjectGroup.prototype = {
	
		constructor: THREE.AnimationObjectGroup,
	
		add: function( var_args ) {
	
			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length;
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
	
				if ( index === undefined ) {
	
					// unknown object -> add it to the ACTIVE region
	
					index = nObjects ++;
					indicesByUUID[ uuid ] = index;
					objects.push( object );
	
					// accounting is done, now do the same for all bindings
	
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
						bindings[ j ].push(
								new THREE.PropertyBinding(
									object, paths[ j ], parsedPaths[ j ] ) );
	
					}
	
				} else if ( index < nCachedObjects ) {
	
					var knownObject = objects[ index ];
	
					// move existing object to the ACTIVE region
	
					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ];
	
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;
	
					indicesByUUID[ uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = object;
	
					// accounting is done, now do the same for all bindings
	
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							binding = bindingsForPath[ index ];
	
						bindingsForPath[ index ] = lastCached;
	
						if ( binding === undefined ) {
	
							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist
	
							binding = new THREE.PropertyBinding(
									object, paths[ j ], parsedPaths[ j ] );
	
						}
	
						bindingsForPath[ firstActiveIndex ] = binding;
	
					}
	
				} else if ( objects[ index ] !== knownObject) {
	
					console.error( "Different objects with the same UUID " +
							"detected. Clean the caches or recreate your " +
							"infrastructure when reloading scenes..." );
	
				} // else the object is already where we want it to be
	
			} // for arguments
	
			this.nCachedObjects_ = nCachedObjects;
	
		},
	
		remove: function( var_args ) {
	
			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
	
				if ( index !== undefined && index >= nCachedObjects ) {
	
					// move existing object into the CACHED region
	
					var lastCachedIndex = nCachedObjects ++,
						firstActiveObject = objects[ lastCachedIndex ];
	
					indicesByUUID[ firstActiveObject.uuid ] = index;
					objects[ index ] = firstActiveObject;
	
					indicesByUUID[ uuid ] = lastCachedIndex;
					objects[ lastCachedIndex ] = object;
	
					// accounting is done, now do the same for all bindings
	
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
						var bindingsForPath = bindings[ j ],
							firstActive = bindingsForPath[ lastCachedIndex ],
							binding = bindingsForPath[ index ];
	
						bindingsForPath[ index ] = firstActive;
						bindingsForPath[ lastCachedIndex ] = binding;
	
					}
	
				}
	
			} // for arguments
	
			this.nCachedObjects_ = nCachedObjects;
	
		},
	
		// remove & forget
		uncache: function( var_args ) {
	
			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
	
				if ( index !== undefined ) {
	
					delete indicesByUUID[ uuid ];
	
					if ( index < nCachedObjects ) {
	
						// object is cached, shrink the CACHED region
	
						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ],
							lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];
	
						// last cached object takes this object's place
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;
	
						// last object goes to the activated slot and pop
						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = lastObject;
						objects.pop();
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								last = bindingsForPath[ lastIndex ];
	
							bindingsForPath[ index ] = lastCached;
							bindingsForPath[ firstActiveIndex ] = last;
							bindingsForPath.pop();
	
						}
	
					} else {
	
						// object is active, just swap with the last and pop
	
						var lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];
	
						indicesByUUID[ lastObject.uuid ] = index;
						objects[ index ] = lastObject;
						objects.pop();
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ];
	
							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
							bindingsForPath.pop();
	
						}
	
					} // cached or active
	
				} // if object is known
	
			} // for arguments
	
			this.nCachedObjects_ = nCachedObjects;
	
		},
	
		// Internal interface used by befriended PropertyBinding.Composite:
	
		subscribe_: function( path, parsedPath ) {
			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group
	
			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ],
				bindings = this._bindings;
	
			if ( index !== undefined ) return bindings[ index ];
	
			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array( nObjects );
	
			index = bindings.length;
	
			indicesByPath[ path ] = index;
	
			paths.push( path );
			parsedPaths.push( parsedPath );
			bindings.push( bindingsForPath );
	
			for ( var i = nCachedObjects,
					n = objects.length; i !== n; ++ i ) {
	
				var object = objects[ i ];
	
				bindingsForPath[ i ] =
						new THREE.PropertyBinding( object, path, parsedPath );
	
			}
	
			return bindingsForPath;
	
		},
	
		unsubscribe_: function( path ) {
			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'
	
			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ];
	
			if ( index !== undefined ) {
	
				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[ lastBindingsIndex ],
					lastBindingsPath = path[ lastBindingsIndex ];
	
				indicesByPath[ lastBindingsPath ] = index;
	
				bindings[ index ] = lastBindings;
				bindings.pop();
	
				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
				parsedPaths.pop();
	
				paths[ index ] = paths[ lastBindingsIndex ];
				paths.pop();
	
			}
	
		}
	
	};
	
	
	// File:src/animation/AnimationUtils.js
	
	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.AnimationUtils = {
	
		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function( array, from, to ) {
	
			if ( THREE.AnimationUtils.isTypedArray( array ) ) {
	
				return new array.constructor( array.subarray( from, to ) );
	
			}
	
			return array.slice( from, to );
	
		},
	
		// converts an array to a specific type
		convertArray: function( array, type, forceClone ) {
	
			if ( ! array || // let 'undefined' and 'null' pass
					! forceClone && array.constructor === type ) return array;
	
			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {
	
				return new type( array ); // create typed array
	
			}
	
			return Array.prototype.slice.call( array ); // create Array
	
		},
	
		isTypedArray: function( object ) {
	
			return ArrayBuffer.isView( object ) &&
					! ( object instanceof DataView );
	
		},
	
		// returns an array by which times and values can be sorted
		getKeyframeOrder: function( times ) {
	
			function compareTime( i, j ) {
	
				return times[ i ] - times[ j ];
	
			}
	
			var n = times.length;
			var result = new Array( n );
			for ( var i = 0; i !== n; ++ i ) result[ i ] = i;
	
			result.sort( compareTime );
	
			return result;
	
		},
	
		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function( values, stride, order ) {
	
			var nValues = values.length;
			var result = new values.constructor( nValues );
	
			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {
	
				var srcOffset = order[ i ] * stride;
	
				for ( var j = 0; j !== stride; ++ j ) {
	
					result[ dstOffset ++ ] = values[ srcOffset + j ];
	
				}
	
			}
	
			return result;
	
		},
	
		// function for parsing AOS keyframe formats
		flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {
	
			var i = 1, key = jsonKeys[ 0 ];
	
			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {
	
				key = jsonKeys[ i ++ ];
	
			}
	
			if ( key === undefined ) return; // no data
	
			var value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data
	
			if ( Array.isArray( value ) ) {
	
				do {
	
					value = key[ valuePropertyName ];
	
					if ( value !== undefined ) {
	
						times.push( key.time );
						values.push.apply( values, value ); // push all elements
	
					}
	
					key = jsonKeys[ i ++ ];
	
				} while ( key !== undefined );
	
			} else if ( value.toArray !== undefined ) {
				// ...assume THREE.Math-ish
	
				do {
	
					value = key[ valuePropertyName ];
	
					if ( value !== undefined ) {
	
						times.push( key.time );
						value.toArray( values, values.length );
	
					}
	
					key = jsonKeys[ i ++ ];
	
				} while ( key !== undefined );
	
			} else {
				// otherwise push as-is
	
				do {
	
					value = key[ valuePropertyName ];
	
					if ( value !== undefined ) {
	
						times.push( key.time );
						values.push( value );
	
					}
	
					key = jsonKeys[ i ++ ];
	
				} while ( key !== undefined );
	
			}
	
		}
	
	};
	
	// File:src/animation/KeyframeTrack.js
	
	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.KeyframeTrack = function ( name, times, values, interpolation ) {
	
		if( name === undefined ) throw new Error( "track name is undefined" );
	
		if( times === undefined || times.length === 0 ) {
	
			throw new Error( "no keyframes in track named " + name );
	
		}
	
		this.name = name;
	
		this.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );
	
		this.setInterpolation( interpolation || this.DefaultInterpolation );
	
		this.validate();
		this.optimize();
	
	};
	
	THREE.KeyframeTrack.prototype = {
	
		constructor: THREE.KeyframeTrack,
	
		TimeBufferType: Float32Array,
		ValueBufferType: Float32Array,
	
		DefaultInterpolation: THREE.InterpolateLinear,
	
		InterpolantFactoryMethodDiscrete: function( result ) {
	
			return new THREE.DiscreteInterpolant(
					this.times, this.values, this.getValueSize(), result );
	
		},
	
		InterpolantFactoryMethodLinear: function( result ) {
	
			return new THREE.LinearInterpolant(
					this.times, this.values, this.getValueSize(), result );
	
		},
	
		InterpolantFactoryMethodSmooth: function( result ) {
	
			return new THREE.CubicInterpolant(
					this.times, this.values, this.getValueSize(), result );
	
		},
	
		setInterpolation: function( interpolation ) {
	
			var factoryMethod = undefined;
	
			switch ( interpolation ) {
	
				case THREE.InterpolateDiscrete:
	
					factoryMethod = this.InterpolantFactoryMethodDiscrete;
	
					break;
	
				case THREE.InterpolateLinear:
	
					factoryMethod = this.InterpolantFactoryMethodLinear;
	
					break;
	
				case THREE.InterpolateSmooth:
	
					factoryMethod = this.InterpolantFactoryMethodSmooth;
	
					break;
	
			}
	
			if ( factoryMethod === undefined ) {
	
				var message = "unsupported interpolation for " +
						this.ValueTypeName + " keyframe track named " + this.name;
	
				if ( this.createInterpolant === undefined ) {
	
					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {
	
						this.setInterpolation( this.DefaultInterpolation );
	
					} else {
	
						throw new Error( message ); // fatal, in this case
	
					}
	
				}
	
				console.warn( message );
				return;
	
			}
	
			this.createInterpolant = factoryMethod;
	
		},
	
		getInterpolation: function() {
	
			switch ( this.createInterpolant ) {
	
				case this.InterpolantFactoryMethodDiscrete:
	
					return THREE.InterpolateDiscrete;
	
				case this.InterpolantFactoryMethodLinear:
	
					return THREE.InterpolateLinear;
	
				case this.InterpolantFactoryMethodSmooth:
	
					return THREE.InterpolateSmooth;
	
			}
	
		},
	
		getValueSize: function() {
	
			return this.values.length / this.times.length;
	
		},
	
		// move all keyframes either forwards or backwards in time
		shift: function( timeOffset ) {
	
			if( timeOffset !== 0.0 ) {
	
				var times = this.times;
	
				for( var i = 0, n = times.length; i !== n; ++ i ) {
	
					times[ i ] += timeOffset;
	
				}
	
			}
	
			return this;
	
		},
	
		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function( timeScale ) {
	
			if( timeScale !== 1.0 ) {
	
				var times = this.times;
	
				for( var i = 0, n = times.length; i !== n; ++ i ) {
	
					times[ i ] *= timeScale;
	
				}
	
			}
	
			return this;
	
		},
	
		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim: function( startTime, endTime ) {
	
			var times = this.times,
				nKeys = times.length,
				from = 0,
				to = nKeys - 1;
	
			while ( from !== nKeys && times[ from ] < startTime ) ++ from;
			while ( to !== -1 && times[ to ] > endTime ) -- to;
	
			++ to; // inclusive -> exclusive bound
	
			if( from !== 0 || to !== nKeys ) {
	
				// empty tracks are forbidden, so keep at least one keyframe
				if ( from >= to ) to = Math.max( to , 1 ), from = to - 1;
	
				var stride = this.getValueSize();
				this.times = THREE.AnimationUtils.arraySlice( times, from, to );
				this.values = THREE.AnimationUtils.
						arraySlice( this.values, from * stride, to * stride );
	
			}
	
			return this;
	
		},
	
		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate: function() {
	
			var valid = true;
	
			var valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {
	
				console.error( "invalid value size in track", this );
				valid = false;
	
			}
	
			var times = this.times,
				values = this.values,
	
				nKeys = times.length;
	
			if( nKeys === 0 ) {
	
				console.error( "track is empty", this );
				valid = false;
	
			}
	
			var prevTime = null;
	
			for( var i = 0; i !== nKeys; i ++ ) {
	
				var currTime = times[ i ];
	
				if ( typeof currTime === 'number' && isNaN( currTime ) ) {
	
					console.error( "time is not a valid number", this, i, currTime );
					valid = false;
					break;
	
				}
	
				if( prevTime !== null && prevTime > currTime ) {
	
					console.error( "out of order keys", this, i, currTime, prevTime );
					valid = false;
					break;
	
				}
	
				prevTime = currTime;
	
			}
	
			if ( values !== undefined ) {
	
				if ( THREE.AnimationUtils.isTypedArray( values ) ) {
	
					for ( var i = 0, n = values.length; i !== n; ++ i ) {
	
						var value = values[ i ];
	
						if ( isNaN( value ) ) {
	
							console.error( "value is not a valid number", this, i, value );
							valid = false;
							break;
	
						}
	
					}
	
				}
	
			}
	
			return valid;
	
		},
	
		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize: function() {
	
			var times = this.times,
				values = this.values,
				stride = this.getValueSize(),
	
				writeIndex = 1;
	
			for( var i = 1, n = times.length - 1; i <= n; ++ i ) {
	
				var keep = false;
	
				var time = times[ i ];
				var timeNext = times[ i + 1 ];
	
				// remove adjacent keyframes scheduled at the same time
	
				if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {
	
					// remove unnecessary keyframes same as their neighbors
					var offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;
	
					for ( var j = 0; j !== stride; ++ j ) {
	
						var value = values[ offset + j ];
	
						if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {
	
							keep = true;
							break;
	
						}
	
					}
	
				}
	
				// in-place compaction
	
				if ( keep ) {
	
					if ( i !== writeIndex ) {
	
						times[ writeIndex ] = times[ i ];
	
						var readOffset = i * stride,
							writeOffset = writeIndex * stride;
	
						for ( var j = 0; j !== stride; ++ j ) {
	
							values[ writeOffset + j ] = values[ readOffset + j ];
	
						}
	
	
					}
	
					++ writeIndex;
	
				}
	
			}
	
			if ( writeIndex !== times.length ) {
	
				this.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );
				this.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );
	
			}
	
			return this;
	
		}
	
	};
	
	// Static methods:
	
	Object.assign( THREE.KeyframeTrack, {
	
		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):
	
		parse: function( json ) {
	
			if( json.type === undefined ) {
	
				throw new Error( "track type undefined, can not parse" );
	
			}
	
			var trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );
	
			if ( json.times === undefined ) {
	
				console.warn( "legacy JSON format detected, converting" );
	
				var times = [], values = [];
	
				THREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );
	
				json.times = times;
				json.values = values;
	
			}
	
			// derived classes can define a static parse method
			if ( trackType.parse !== undefined ) {
	
				return trackType.parse( json );
	
			} else {
	
				// by default, we asssume a constructor compatible with the base
				return new trackType(
						json.name, json.times, json.values, json.interpolation );
	
			}
	
		},
	
		toJSON: function( track ) {
	
			var trackType = track.constructor;
	
			var json;
	
			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== undefined ) {
	
				json = trackType.toJSON( track );
	
			} else {
	
				// by default, we assume the data can be serialized as-is
				json = {
	
					'name': track.name,
					'times': THREE.AnimationUtils.convertArray( track.times, Array ),
					'values': THREE.AnimationUtils.convertArray( track.values, Array )
	
				};
	
				var interpolation = track.getInterpolation();
	
				if ( interpolation !== track.DefaultInterpolation ) {
	
					json.interpolation = interpolation;
	
				}
	
			}
	
			json.type = track.ValueTypeName; // mandatory
	
			return json;
	
		},
	
		_getTrackTypeForValueTypeName: function( typeName ) {
	
			switch( typeName.toLowerCase() ) {
	
				case "scalar":
				case "double":
				case "float":
				case "number":
				case "integer":
	
					return THREE.NumberKeyframeTrack;
	
				case "vector":
				case "vector2":
				case "vector3":
				case "vector4":
	
					return THREE.VectorKeyframeTrack;
	
				case "color":
	
					return THREE.ColorKeyframeTrack;
	
				case "quaternion":
	
					return THREE.QuaternionKeyframeTrack;
	
				case "bool":
				case "boolean":
	
					return THREE.BooleanKeyframeTrack;
	
				case "string":
	
					return THREE.StringKeyframeTrack;
	
			};
	
			throw new Error( "Unsupported typeName: " + typeName );
	
		}
	
	} );
	
	// File:src/animation/PropertyBinding.js
	
	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.PropertyBinding = function ( rootNode, path, parsedPath ) {
	
		this.path = path;
		this.parsedPath = parsedPath ||
				THREE.PropertyBinding.parseTrackName( path );
	
		this.node = THREE.PropertyBinding.findNode(
				rootNode, this.parsedPath.nodeName ) || rootNode;
	
		this.rootNode = rootNode;
	
	};
	
	THREE.PropertyBinding.prototype = {
	
		constructor: THREE.PropertyBinding,
	
		getValue: function getValue_unbound( targetArray, offset ) {
	
			this.bind();
			this.getValue( targetArray, offset );
	
			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.
	
		},
	
		setValue: function getValue_unbound( sourceArray, offset ) {
	
			this.bind();
			this.setValue( sourceArray, offset );
	
		},
	
		// create getter / setter pair for a property in the scene graph
		bind: function() {
	
			var targetObject = this.node,
				parsedPath = this.parsedPath,
	
				objectName = parsedPath.objectName,
				propertyName = parsedPath.propertyName,
				propertyIndex = parsedPath.propertyIndex;
	
			if ( ! targetObject ) {
	
				targetObject = THREE.PropertyBinding.findNode(
						this.rootNode, parsedPath.nodeName ) || this.rootNode;
	
				this.node = targetObject;
	
			}
	
			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;
	
	 		// ensure there is a value node
			if ( ! targetObject ) {
	
				console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
				return;
	
			}
	
			if( objectName ) {
	
				var objectIndex = parsedPath.objectIndex;
	
				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {
	
					case 'materials':
	
						if( ! targetObject.material ) {
	
							console.error( '  can not bind to material as node does not have a material', this );
							return;
	
						}
	
						if( ! targetObject.material.materials ) {
	
							console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
							return;
	
						}
	
						targetObject = targetObject.material.materials;
	
						break;
	
					case 'bones':
	
						if( ! targetObject.skeleton ) {
	
							console.error( '  can not bind to bones as node does not have a skeleton', this );
							return;
	
						}
	
						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.
	
						targetObject = targetObject.skeleton.bones;
	
						// support resolving morphTarget names into indices.
						for ( var i = 0; i < targetObject.length; i ++ ) {
	
							if ( targetObject[i].name === objectIndex ) {
	
								objectIndex = i;
								break;
	
							}
	
						}
	
						break;
	
					default:
	
						if ( targetObject[ objectName ] === undefined ) {
	
							console.error( '  can not bind to objectName of node, undefined', this );
							return;
	
						}
	
						targetObject = targetObject[ objectName ];
	
				}
	
	
				if ( objectIndex !== undefined ) {
	
					if( targetObject[ objectIndex ] === undefined ) {
	
						console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
						return;
	
					}
	
					targetObject = targetObject[ objectIndex ];
	
				}
	
			}
	
			// resolve property
			var nodeProperty = targetObject[ propertyName ];
	
			if ( ! nodeProperty ) {
	
				var nodeName = parsedPath.nodeName;
	
				console.error( "  trying to update property for track: " + nodeName +
						'.' + propertyName + " but it wasn't found.", targetObject );
				return;
	
			}
	
			// determine versioning scheme
			var versioning = this.Versioning.None;
	
			if ( targetObject.needsUpdate !== undefined ) { // material
	
				versioning = this.Versioning.NeedsUpdate;
				this.targetObject = targetObject;
	
			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform
	
				versioning = this.Versioning.MatrixWorldNeedsUpdate;
				this.targetObject = targetObject;
	
			}
	
			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;
	
			if ( propertyIndex !== undefined ) {
				// access a sub element of the property array (only primitives are supported right now)
	
				if ( propertyName === "morphTargetInfluences" ) {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
	
					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {
	
						console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
						return;
	
					}
	
					if ( ! targetObject.geometry.morphTargets ) {
	
						console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
						return;
	
					}
	
					for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
	
						if ( targetObject.geometry.morphTargets[i].name === propertyIndex ) {
	
							propertyIndex = i;
							break;
	
						}
	
					}
	
				}
	
				bindingType = this.BindingType.ArrayElement;
	
				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;
	
			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
				// must use copy for Object3D.Euler/Quaternion
	
				bindingType = this.BindingType.HasFromToArray;
	
				this.resolvedProperty = nodeProperty;
	
			} else if ( nodeProperty.length !== undefined ) {
	
				bindingType = this.BindingType.EntireArray;
	
				this.resolvedProperty = nodeProperty;
	
			} else {
	
				this.propertyName = propertyName;
	
			}
	
			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];
	
		},
	
		unbind: function() {
	
			this.node = null;
	
			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
	
		}
	
	};
	
	Object.assign( THREE.PropertyBinding.prototype, { // prototype, continued
	
		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function() {},
		_setValue_unavailable: function() {},
	
		// initial state of these methods that calls 'bind'
		_getValue_unbound: THREE.PropertyBinding.prototype.getValue,
		_setValue_unbound: THREE.PropertyBinding.prototype.setValue,
	
		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},
	
		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},
	
		GetterByBindingType: [
	
			function getValue_direct( buffer, offset ) {
	
				buffer[ offset ] = this.node[ this.propertyName ];
	
			},
	
			function getValue_array( buffer, offset ) {
	
				var source = this.resolvedProperty;
	
				for ( var i = 0, n = source.length; i !== n; ++ i ) {
	
					buffer[ offset ++ ] = source[ i ];
	
				}
	
			},
	
			function getValue_arrayElement( buffer, offset ) {
	
				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];
	
			},
	
			function getValue_toArray( buffer, offset ) {
	
				this.resolvedProperty.toArray( buffer, offset );
	
			}
	
		],
	
		SetterByBindingTypeAndVersioning: [
	
			[
				// Direct
	
				function setValue_direct( buffer, offset ) {
	
					this.node[ this.propertyName ] = buffer[ offset ];
	
				},
	
				function setValue_direct_setNeedsUpdate( buffer, offset ) {
	
					this.node[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					this.node[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			], [
	
				// EntireArray
	
				function setValue_array( buffer, offset ) {
	
					var dest = this.resolvedProperty;
	
					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
						dest[ i ] = buffer[ offset ++ ];
	
					}
	
				},
	
				function setValue_array_setNeedsUpdate( buffer, offset ) {
	
					var dest = this.resolvedProperty;
	
					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
						dest[ i ] = buffer[ offset ++ ];
	
					}
	
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					var dest = this.resolvedProperty;
	
					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
						dest[ i ] = buffer[ offset ++ ];
	
					}
	
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			], [
	
				// ArrayElement
	
				function setValue_arrayElement( buffer, offset ) {
	
					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
	
				},
	
				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			], [
	
				// HasToFromArray
	
				function setValue_fromArray( buffer, offset ) {
	
					this.resolvedProperty.fromArray( buffer, offset );
	
				},
	
				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			]
	
		]
	
	} );
	
	THREE.PropertyBinding.Composite =
			function( targetGroup, path, optionalParsedPath ) {
	
		var parsedPath = optionalParsedPath ||
				THREE.PropertyBinding.parseTrackName( path );
	
		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );
	
	};
	
	THREE.PropertyBinding.Composite.prototype = {
	
		constructor: THREE.PropertyBinding.Composite,
	
		getValue: function( array, offset ) {
	
			this.bind(); // bind all binding
	
			var firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];
	
			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );
	
		},
	
		setValue: function( array, offset ) {
	
			var bindings = this._bindings;
	
			for ( var i = this._targetGroup.nCachedObjects_,
					n = bindings.length; i !== n; ++ i ) {
	
				bindings[ i ].setValue( array, offset );
	
			}
	
		},
	
		bind: function() {
	
			var bindings = this._bindings;
	
			for ( var i = this._targetGroup.nCachedObjects_,
					n = bindings.length; i !== n; ++ i ) {
	
				bindings[ i ].bind();
	
			}
	
		},
	
		unbind: function() {
	
			var bindings = this._bindings;
	
			for ( var i = this._targetGroup.nCachedObjects_,
					n = bindings.length; i !== n; ++ i ) {
	
				bindings[ i ].unbind();
	
			}
	
		}
	
	};
	
	THREE.PropertyBinding.create = function( root, path, parsedPath ) {
	
		if ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {
	
			return new THREE.PropertyBinding( root, path, parsedPath );
	
		} else {
	
			return new THREE.PropertyBinding.Composite( root, path, parsedPath );
	
		}
	
	};
	
	THREE.PropertyBinding.parseTrackName = function( trackName ) {
	
		// matches strings in the form of:
		//    nodeName.property
		//    nodeName.property[accessor]
		//    nodeName.material.property[accessor]
		//    uuid.property[accessor]
		//    uuid.objectName[objectIndex].propertyName[propertyIndex]
		//    parentName/nodeName.property
		//    parentName/parentName/nodeName.property[index]
		//	  .bone[Armature.DEF_cog].position
		// created and tested via https://regex101.com/#javascript
	
		var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
		var matches = re.exec(trackName);
	
		if( ! matches ) {
			throw new Error( "cannot parse trackName at all: " + trackName );
		}
	
	    if (matches.index === re.lastIndex) {
	        re.lastIndex++;
	    }
	
		var results = {
			// directoryName: matches[1], // (tschw) currently unused
			nodeName: matches[3], 	// allowed to be null, specified root node.
			objectName: matches[5],
			objectIndex: matches[7],
			propertyName: matches[9],
			propertyIndex: matches[11]	// allowed to be null, specifies that the whole property is set.
		};
	
		if( results.propertyName === null || results.propertyName.length === 0 ) {
			throw new Error( "can not parse propertyName from trackName: " + trackName );
		}
	
		return results;
	
	};
	
	THREE.PropertyBinding.findNode = function( root, nodeName ) {
	
		if( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {
	
			return root;
	
		}
	
		// search into skeleton bones.
		if( root.skeleton ) {
	
			var searchSkeleton = function( skeleton ) {
	
				for( var i = 0; i < skeleton.bones.length; i ++ ) {
	
					var bone = skeleton.bones[i];
	
					if( bone.name === nodeName ) {
	
						return bone;
	
					}
				}
	
				return null;
	
			};
	
			var bone = searchSkeleton( root.skeleton );
	
			if( bone ) {
	
				return bone;
	
			}
		}
	
		// search into node subtree.
		if( root.children ) {
	
			var searchNodeSubtree = function( children ) {
	
				for( var i = 0; i < children.length; i ++ ) {
	
					var childNode = children[i];
	
					if( childNode.name === nodeName || childNode.uuid === nodeName ) {
	
						return childNode;
	
					}
	
					var result = searchNodeSubtree( childNode.children );
	
					if( result ) return result;
	
				}
	
				return null;
	
			};
	
			var subTreeNode = searchNodeSubtree( root.children );
	
			if( subTreeNode ) {
	
				return subTreeNode;
	
			}
	
		}
	
		return null;
	
	}
	
	// File:src/animation/PropertyMixer.js
	
	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.PropertyMixer = function ( binding, typeName, valueSize ) {
	
		this.binding = binding;
		this.valueSize = valueSize;
	
		var bufferType = Float64Array,
			mixFunction;
	
		switch ( typeName ) {
	
			case 'quaternion':			mixFunction = this._slerp;		break;
	
			case 'string':
			case 'bool':
	
				bufferType = Array,		mixFunction = this._select;		break;
	
			default:					mixFunction = this._lerp;
	
		}
	
		this.buffer = new bufferType( valueSize * 4 );
		// layout: [ incoming | accu0 | accu1 | orig ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
	
		this._mixBufferRegion = mixFunction;
	
		this.cumulativeWeight = 0;
	
		this.useCount = 0;
		this.referenceCount = 0;
	
	};
	
	THREE.PropertyMixer.prototype = {
	
		constructor: THREE.PropertyMixer,
	
		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate: function( accuIndex, weight ) {
	
			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place
	
			var buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride,
	
				currentWeight = this.cumulativeWeight;
	
			if ( currentWeight === 0 ) {
	
				// accuN := incoming * weight
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					buffer[ offset + i ] = buffer[ i ];
	
				}
	
				currentWeight = weight;
	
			} else {
	
				// accuN := accuN + incoming * weight
	
				currentWeight += weight;
				var mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );
	
			}
	
			this.cumulativeWeight = currentWeight;
	
		},
	
		// apply the state of 'accu<i>' to the binding when accus differ
		apply: function( accuIndex ) {
	
			var stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,
	
				weight = this.cumulativeWeight,
	
				binding = this.binding;
	
			this.cumulativeWeight = 0;
	
			if ( weight < 1 ) {
	
				// accuN := accuN + original * ( 1 - cumulativeWeight )
	
				var originalValueOffset = stride * 3;
	
				this._mixBufferRegion(
						buffer, offset, originalValueOffset, 1 - weight, stride );
	
			}
	
			for ( var i = stride, e = stride + stride; i !== e; ++ i ) {
	
				if ( buffer[ i ] !== buffer[ i + stride ] ) {
	
					// value has changed -> update scene graph
	
					binding.setValue( buffer, offset );
					break;
	
				}
	
			}
	
		},
	
		// remember the state of the bound property and copy it to both accus
		saveOriginalState: function() {
	
			var binding = this.binding;
	
			var buffer = this.buffer,
				stride = this.valueSize,
	
				originalValueOffset = stride * 3;
	
			binding.getValue( buffer, originalValueOffset );
	
			// accu[0..1] := orig -- initially detect changes against the original
			for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {
	
				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];
	
			}
	
			this.cumulativeWeight = 0;
	
		},
	
		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState: function() {
	
			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );
	
		},
	
	
		// mix functions
	
		_select: function( buffer, dstOffset, srcOffset, t, stride ) {
	
			if ( t >= 0.5 ) {
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];
	
				}
	
			}
	
		},
	
		_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {
	
			THREE.Quaternion.slerpFlat( buffer, dstOffset,
					buffer, dstOffset, buffer, srcOffset, t );
	
		},
	
		_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {
	
			var s = 1 - t;
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				var j = dstOffset + i;
	
				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;
	
			}
	
		}
	
	};
	
	// File:src/animation/tracks/BooleanKeyframeTrack.js
	
	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.BooleanKeyframeTrack = function ( name, times, values ) {
	
		THREE.KeyframeTrack.call( this, name, times, values );
	
	};
	
	THREE.BooleanKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.BooleanKeyframeTrack,
	
		ValueTypeName: 'bool',
		ValueBufferType: Array,
	
		DefaultInterpolation: THREE.IntepolateDiscrete,
	
		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined
	
		// Note: Actually this track could have a optimized / compressed
		// representation of a single value and a custom interpolant that
		// computes "firstValue ^ isOdd( index )".
	
	} );
	
	// File:src/animation/tracks/NumberKeyframeTrack.js
	
	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {
	
		THREE.KeyframeTrack.call( this, name, times, values, interpolation );
	
	};
	
	THREE.NumberKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.NumberKeyframeTrack,
	
		ValueTypeName: 'number',
	
		// ValueBufferType is inherited
	
		// DefaultInterpolation is inherited
	
	} );
	
	// File:src/animation/tracks/QuaternionKeyframeTrack.js
	
	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {
	
		THREE.KeyframeTrack.call( this, name, times, values, interpolation );
	
	};
	
	THREE.QuaternionKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.QuaternionKeyframeTrack,
	
		ValueTypeName: 'quaternion',
	
		// ValueBufferType is inherited
	
		DefaultInterpolation: THREE.InterpolateLinear,
	
		InterpolantFactoryMethodLinear: function( result ) {
	
			return new THREE.QuaternionLinearInterpolant(
					this.times, this.values, this.getValueSize(), result );
	
		},
	
		InterpolantFactoryMethodSmooth: undefined // not yet implemented
	
	} );
	
	// File:src/animation/tracks/StringKeyframeTrack.js
	
	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {
	
		THREE.KeyframeTrack.call( this, name, times, values, interpolation );
	
	};
	
	THREE.StringKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.StringKeyframeTrack,
	
		ValueTypeName: 'string',
		ValueBufferType: Array,
	
		DefaultInterpolation: THREE.IntepolateDiscrete,
	
		InterpolantFactoryMethodLinear: undefined,
	
		InterpolantFactoryMethodSmooth: undefined
	
	} );
	
	// File:src/animation/tracks/VectorKeyframeTrack.js
	
	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {
	
		THREE.KeyframeTrack.call( this, name, times, values, interpolation );
	
	};
	
	THREE.VectorKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.VectorKeyframeTrack,
	
		ValueTypeName: 'vector'
	
		// ValueBufferType is inherited
	
		// DefaultInterpolation is inherited
	
	} );
	
	// File:src/audio/Audio.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Audio = function ( listener ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Audio';
	
		this.context = listener.context;
		this.source = this.context.createBufferSource();
		this.source.onended = this.onEnded.bind( this );
	
		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );
	
		this.autoplay = false;
	
		this.startTime = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';
	
		this.filter = null;
	
	};
	
	THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Audio.prototype.constructor = THREE.Audio;
	
	THREE.Audio.prototype.getOutput = function () {
	
		return this.gain;
	
	};
	
	THREE.Audio.prototype.load = function ( file ) {
	
		var buffer = new THREE.AudioBuffer( this.context );
		buffer.load( file );
	
		this.setBuffer( buffer );
	
		return this;
	
	};
	
	THREE.Audio.prototype.setNodeSource = function ( audioNode ) {
	
		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();
	
		return this;
	
	};
	
	THREE.Audio.prototype.setBuffer = function ( audioBuffer ) {
	
		var scope = this;
	
		audioBuffer.onReady( function( buffer ) {
	
			scope.source.buffer = buffer;
			scope.sourceType = 'buffer';
			if ( scope.autoplay ) scope.play();
	
		} );
	
		return this;
	
	};
	
	THREE.Audio.prototype.play = function () {
	
		if ( this.isPlaying === true ) {
	
			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;
	
		}
	
		if ( this.hasPlaybackControl === false ) {
	
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
	
		}
	
		var source = this.context.createBufferSource();
	
		source.buffer = this.source.buffer;
		source.loop = this.source.loop;
		source.onended = this.source.onended;
		source.start( 0, this.startTime );
		source.playbackRate.value = this.playbackRate;
	
		this.isPlaying = true;
	
		this.source = source;
	
		this.connect();
	
	};
	
	THREE.Audio.prototype.pause = function () {
	
		if ( this.hasPlaybackControl === false ) {
	
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
	
		}
	
		this.source.stop();
		this.startTime = this.context.currentTime;
	
	};
	
	THREE.Audio.prototype.stop = function () {
	
		if ( this.hasPlaybackControl === false ) {
	
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
	
		}
	
		this.source.stop();
		this.startTime = 0;
	
	};
	
	THREE.Audio.prototype.connect = function () {
	
		if ( this.filter !== null ) {
	
			this.source.connect( this.filter );
			this.filter.connect( this.getOutput() );
	
		} else {
	
			this.source.connect( this.getOutput() );
	
		}
	
	};
	
	THREE.Audio.prototype.disconnect = function () {
	
		if ( this.filter !== null ) {
	
			this.source.disconnect( this.filter );
			this.filter.disconnect( this.getOutput() );
	
		} else {
	
			this.source.disconnect( this.getOutput() );
	
		}
	
	};
	
	THREE.Audio.prototype.getFilter = function () {
	
		return this.filter;
	
	};
	
	THREE.Audio.prototype.setFilter = function ( value ) {
	
		if ( value === undefined ) value = null;
	
		if ( this.isPlaying === true ) {
	
			this.disconnect();
			this.filter = value;
			this.connect();
	
		} else {
	
			this.filter = value;
	
		}
	
	};
	
	THREE.Audio.prototype.setPlaybackRate = function ( value ) {
	
		if ( this.hasPlaybackControl === false ) {
	
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
	
		}
	
		this.playbackRate = value;
	
		if ( this.isPlaying === true ) {
	
			this.source.playbackRate.value = this.playbackRate;
	
		}
	
	};
	
	THREE.Audio.prototype.getPlaybackRate = function () {
	
		return this.playbackRate;
	
	};
	
	THREE.Audio.prototype.onEnded = function() {
	
		this.isPlaying = false;
	
	};
	
	THREE.Audio.prototype.setLoop = function ( value ) {
	
		if ( this.hasPlaybackControl === false ) {
	
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
	
		}
	
		this.source.loop = value;
	
	};
	
	THREE.Audio.prototype.getLoop = function () {
	
		if ( this.hasPlaybackControl === false ) {
	
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;
	
		}
	
		return this.source.loop;
	
	};
	
	
	THREE.Audio.prototype.setVolume = function ( value ) {
	
		this.gain.gain.value = value;
	
	};
	
	THREE.Audio.prototype.getVolume = function () {
	
		return this.gain.gain.value;
	
	};
	
	// File:src/audio/AudioAnalyser.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AudioAnalyser = function ( audio, fftSize ) {
	
		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
	
		this.data = new Uint8Array( this.analyser.frequencyBinCount );
	
		audio.getOutput().connect( this.analyser );
	
	};
	
	THREE.AudioAnalyser.prototype = {
	
		constructor: THREE.AudioAnalyser,
	
		getData: function () {
	
			this.analyser.getByteFrequencyData( this.data );
			return this.data;
	
		}
	
	};
	
	// File:src/audio/AudioBuffer.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AudioBuffer = function ( context ) {
	
		this.context = context;
		this.ready = false;
		this.readyCallbacks = [];
	
	};
	
	THREE.AudioBuffer.prototype.load = function ( file ) {
	
		var scope = this;
	
		var request = new XMLHttpRequest();
		request.open( 'GET', file, true );
		request.responseType = 'arraybuffer';
		request.onload = function ( e ) {
	
			scope.context.decodeAudioData( this.response, function ( buffer ) {
	
				scope.buffer = buffer;
				scope.ready = true;
	
				for ( var i = 0; i < scope.readyCallbacks.length; i ++ ) {
	
					scope.readyCallbacks[ i ]( scope.buffer );
	
				}
	
				scope.readyCallbacks = [];
	
			} );
	
		};
		request.send();
	
		return this;
	
	};
	
	THREE.AudioBuffer.prototype.onReady = function ( callback ) {
	
		if ( this.ready ) {
	
			callback( this.buffer );
	
		} else {
	
			this.readyCallbacks.push( callback );
	
		}
	
	};
	
	// File:src/audio/PositionalAudio.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.PositionalAudio = function ( listener ) {
	
		THREE.Audio.call( this, listener );
	
		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );
	
	};
	
	THREE.PositionalAudio.prototype = Object.create( THREE.Audio.prototype );
	THREE.PositionalAudio.prototype.constructor = THREE.PositionalAudio;
	
	THREE.PositionalAudio.prototype.getOutput = function () {
	
		return this.panner;
	
	};
	
	THREE.PositionalAudio.prototype.setRefDistance = function ( value ) {
	
		this.panner.refDistance = value;
	
	};
	
	THREE.PositionalAudio.prototype.getRefDistance = function () {
	
		return this.panner.refDistance;
	
	};
	
	THREE.PositionalAudio.prototype.setRolloffFactor = function ( value ) {
	
		this.panner.rolloffFactor = value;
	
	};
	
	THREE.PositionalAudio.prototype.getRolloffFactor = function () {
	
		return this.panner.rolloffFactor;
	
	};
	
	THREE.PositionalAudio.prototype.setDistanceModel = function ( value ) {
	
		this.panner.distanceModel = value;
	
	};
	
	THREE.PositionalAudio.prototype.getDistanceModel = function () {
	
		return this.panner.distanceModel;
	
	};
	
	THREE.PositionalAudio.prototype.setMaxDistance = function ( value ) {
	
		this.panner.maxDistance = value;
	
	};
	
	THREE.PositionalAudio.prototype.getMaxDistance = function () {
	
		return this.panner.maxDistance;
	
	};
	
	THREE.PositionalAudio.prototype.updateMatrixWorld = ( function () {
	
		var position = new THREE.Vector3();
	
		return function updateMatrixWorld( force ) {
	
			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );
	
			position.setFromMatrixPosition( this.matrixWorld );
	
			this.panner.setPosition( position.x, position.y, position.z );
	
		};
	
	} )();
	
	// File:src/audio/AudioListener.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AudioListener = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'AudioListener';
	
		this.context = new ( window.AudioContext || window.webkitAudioContext )();
	
		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );
	
		this.filter = null;
	
	};
	
	THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
	THREE.AudioListener.prototype.constructor = THREE.AudioListener;
	
	THREE.AudioListener.prototype.getInput = function () {
	
		return this.gain;
	
	};
	
	THREE.AudioListener.prototype.removeFilter = function ( ) {
	
		if ( this.filter !== null ) {
	
			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;
	
		}
	
	};
	
	THREE.AudioListener.prototype.setFilter = function ( value ) {
	
		if ( this.filter !== null ) {
	
			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
	
		} else {
	
			this.gain.disconnect( this.context.destination );
	
		}
	
		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );
	
	};
	
	THREE.AudioListener.prototype.getFilter = function () {
	
		return this.filter;
	
	};
	
	THREE.AudioListener.prototype.setMasterVolume = function ( value ) {
	
		this.gain.gain.value = value;
	
	};
	
	THREE.AudioListener.prototype.getMasterVolume = function () {
	
		return this.gain.gain.value;
	
	};
	
	
	THREE.AudioListener.prototype.updateMatrixWorld = ( function () {
	
		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3();
	
		var orientation = new THREE.Vector3();
	
		return function updateMatrixWorld( force ) {
	
			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );
	
			var listener = this.context.listener;
			var up = this.up;
	
			this.matrixWorld.decompose( position, quaternion, scale );
	
			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
			listener.setPosition( position.x, position.y, position.z );
			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
	
		};
	
	} )();
	
	// File:src/cameras/Camera.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.Camera = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Camera';
	
		this.matrixWorldInverse = new THREE.Matrix4();
		this.projectionMatrix = new THREE.Matrix4();
	
	};
	
	THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Camera.prototype.constructor = THREE.Camera;
	
	THREE.Camera.prototype.getWorldDirection = function () {
	
		var quaternion = new THREE.Quaternion();
	
		return function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			this.getWorldQuaternion( quaternion );
	
			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
		};
	
	}();
	
	THREE.Camera.prototype.lookAt = function () {
	
		// This routine does not support cameras with rotated and/or translated parent(s)
	
		var m1 = new THREE.Matrix4();
	
		return function ( vector ) {
	
			m1.lookAt( this.position, vector, this.up );
	
			this.quaternion.setFromRotationMatrix( m1 );
	
		};
	
	}();
	
	THREE.Camera.prototype.clone = function () {
	
		return new this.constructor().copy( this );
	
	};
	
	THREE.Camera.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source );
	
		this.matrixWorldInverse.copy( source.matrixWorldInverse );
		this.projectionMatrix.copy( source.projectionMatrix );
	
		return this;
	
	};
	
	// File:src/cameras/CubeCamera.js
	
	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CubeCamera = function ( near, far, cubeResolution ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'CubeCamera';
	
		var fov = 90, aspect = 1;
	
		var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
		this.add( cameraPX );
	
		var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );
	
		var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
		this.add( cameraPY );
	
		var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );
	
		var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );
	
		var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );
	
		var options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };
	
		this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
	
		this.updateCubeMap = function ( renderer, scene ) {
	
			if ( this.parent === null ) this.updateMatrixWorld();
	
			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;
	
			renderTarget.texture.generateMipmaps = false;
	
			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );
	
			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );
	
			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );
	
			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );
	
			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );
	
			renderTarget.texture.generateMipmaps = generateMipmaps;
	
			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );
	
			renderer.setRenderTarget( null );
	
		};
	
	};
	
	THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
	
	// File:src/cameras/OrthographicCamera.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {
	
		THREE.Camera.call( this );
	
		this.type = 'OrthographicCamera';
	
		this.zoom = 1;
	
		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;
	
		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
	
	THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
	
		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;
	
		this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );
	
	};
	
	THREE.OrthographicCamera.prototype.copy = function ( source ) {
	
		THREE.Camera.prototype.copy.call( this, source );
	
		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;
	
		this.zoom = source.zoom;
	
		return this;
	
	};
	
	THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;
	
		return data;
	
	};
	
	// File:src/cameras/PerspectiveCamera.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {
	
		THREE.Camera.call( this );
	
		this.type = 'PerspectiveCamera';
	
		this.focalLength = 10;
		this.zoom = 1;
	
		this.fov = fov !== undefined ? fov : 50;
		this.aspect = aspect !== undefined ? aspect : 1;
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
	
	
	/**
	 * Uses Focal Length (in mm) to estimate and set FOV
	 * 35mm (full-frame) camera is used if frame size is not specified;
	 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	 */
	
	THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {
	
		if ( frameHeight === undefined ) frameHeight = 24;
	
		this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
		this.updateProjectionMatrix();
	
	};
	
	
	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	
	THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {
	
		this.fullWidth = fullWidth;
		this.fullHeight = fullHeight;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	
		this.updateProjectionMatrix();
	
	};
	
	
	THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
	
		var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );
	
		if ( this.fullWidth ) {
	
			var aspect = this.fullWidth / this.fullHeight;
			var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
			var bottom = - top;
			var left = aspect * bottom;
			var right = aspect * top;
			var width = Math.abs( right - left );
			var height = Math.abs( top - bottom );
	
			this.projectionMatrix.makeFrustum(
				left + this.x * width / this.fullWidth,
				left + ( this.x + this.width ) * width / this.fullWidth,
				top - ( this.y + this.height ) * height / this.fullHeight,
				top - this.y * height / this.fullHeight,
				this.near,
				this.far
			);
	
		} else {
	
			this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );
	
		}
	
	};
	
	THREE.PerspectiveCamera.prototype.copy = function ( source ) {
	
		THREE.Camera.prototype.copy.call( this, source );
	
		this.focalLength = source.focalLength;
		this.zoom = source.zoom;
	
		this.fov = source.fov;
		this.aspect = source.aspect;
		this.near = source.near;
		this.far = source.far;
	
		return this;
	
	};
	
	THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
		data.object.focalLength = this.focalLength;
		data.object.zoom = this.zoom;
	
		data.object.fov = this.fov;
		data.object.aspect = this.aspect;
		data.object.near = this.near;
		data.object.far = this.far;
	
		return data;
	
	};
	
	// File:src/cameras/StereoCamera.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.StereoCamera = function () {
	
		this.type = 'StereoCamera';
	
		this.aspect = 1;
	
		this.cameraL = new THREE.PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;
	
		this.cameraR = new THREE.PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;
	
	};
	
	THREE.StereoCamera.prototype = {
	
		constructor: THREE.StereoCamera,
	
		update: ( function () {
	
			var focalLength, fov, aspect, near, far;
	
			var eyeRight = new THREE.Matrix4();
			var eyeLeft = new THREE.Matrix4();
	
			return function update ( camera ) {
	
				var needsUpdate = focalLength !== camera.focalLength || fov !== camera.fov ||
													aspect !== camera.aspect * this.aspect || near !== camera.near ||
													far !== camera.far;
	
				if ( needsUpdate ) {
	
					focalLength = camera.focalLength;
					fov = camera.fov;
					aspect = camera.aspect * this.aspect;
					near = camera.near;
					far = camera.far;
	
					// Off-axis stereoscopic effect based on
					// http://paulbourke.net/stereographics/stereorender/
	
					var projectionMatrix = camera.projectionMatrix.clone();
					var eyeSep = 0.064 / 2;
					var eyeSepOnProjection = eyeSep * near / focalLength;
					var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
					var xmin, xmax;
	
					// translate xOffset
	
					eyeLeft.elements[ 12 ] = - eyeSep;
					eyeRight.elements[ 12 ] = eyeSep;
	
					// for left eye
	
					xmin = - ymax * aspect + eyeSepOnProjection;
					xmax = ymax * aspect + eyeSepOnProjection;
	
					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
					this.cameraL.projectionMatrix.copy( projectionMatrix );
	
					// for right eye
	
					xmin = - ymax * aspect - eyeSepOnProjection;
					xmax = ymax * aspect - eyeSepOnProjection;
	
					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
					this.cameraR.projectionMatrix.copy( projectionMatrix );
	
				}
	
				this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
				this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );
	
			};
	
		} )()
	
	};
	
	// File:src/lights/Light.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Light = function ( color, intensity ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Light';
	
		this.color = new THREE.Color( color );
		this.intensity = intensity !== undefined ? intensity : 1;
	
		this.receiveShadow = undefined;
	
	};
	
	THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Light.prototype.constructor = THREE.Light;
	
	THREE.Light.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.intensity = source.intensity;
	
		return this;
	
	};
	
	THREE.Light.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;
	
		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();
	
		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.exponent !== undefined ) data.object.exponent = this.exponent;
	
		return data;
	
	};
	
	// File:src/lights/LightShadow.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LightShadow = function ( camera ) {
	
		this.camera = camera;
	
		this.bias = 0;
		this.radius = 1;
	
		this.mapSize = new THREE.Vector2( 512, 512 );
	
		this.map = null;
		this.matrix = new THREE.Matrix4();
	
	};
	
	THREE.LightShadow.prototype = {
	
		constructor: THREE.LightShadow,
	
		copy: function ( source ) {
	
			this.camera = source.camera.clone();
	
			this.bias = source.bias;
			this.radius = source.radius;
	
			this.mapSize.copy( source.mapSize );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	};
	
	// File:src/lights/AmbientLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AmbientLight = function ( color, intensity ) {
	
		THREE.Light.call( this, color, intensity );
	
		this.type = 'AmbientLight';
	
		this.castShadow = undefined;
	
	};
	
	THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
	THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
	
	// File:src/lights/DirectionalLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DirectionalLight = function ( color, intensity ) {
	
		THREE.Light.call( this, color, intensity );
	
		this.type = 'DirectionalLight';
	
		this.position.set( 0, 1, 0 );
		this.updateMatrix();
	
		this.target = new THREE.Object3D();
	
		this.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );
	
	};
	
	THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
	THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
	
	THREE.DirectionalLight.prototype.copy = function ( source ) {
	
		THREE.Light.prototype.copy.call( this, source );
	
		this.target = source.target.clone();
	
		this.shadow = source.shadow.clone();
	
		return this;
	
	};
	
	// File:src/lights/HemisphereLight.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {
	
		THREE.Light.call( this, skyColor, intensity );
	
		this.type = 'HemisphereLight';
	
		this.castShadow = undefined;
	
		this.position.set( 0, 1, 0 );
		this.updateMatrix();
	
		this.groundColor = new THREE.Color( groundColor );
	
	};
	
	THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
	THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;
	
	THREE.HemisphereLight.prototype.copy = function ( source ) {
	
		THREE.Light.prototype.copy.call( this, source );
	
		this.groundColor.copy( source.groundColor );
	
		return this;
	
	};
	
	// File:src/lights/PointLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	
	THREE.PointLight = function ( color, intensity, distance, decay ) {
	
		THREE.Light.call( this, color, intensity );
	
		this.type = 'PointLight';
	
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
		this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );
	
	};
	
	THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
	THREE.PointLight.prototype.constructor = THREE.PointLight;
	
	THREE.PointLight.prototype.copy = function ( source ) {
	
		THREE.Light.prototype.copy.call( this, source );
	
		this.distance = source.distance;
		this.decay = source.decay;
	
		this.shadow = source.shadow.clone();
	
		return this;
	
	};
	
	// File:src/lights/SpotLight.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {
	
		THREE.Light.call( this, color, intensity );
	
		this.type = 'SpotLight';
	
		this.position.set( 0, 1, 0 );
		this.updateMatrix();
	
		this.target = new THREE.Object3D();
	
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.exponent = ( exponent !== undefined ) ? exponent : 10;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
		this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );
	
	};
	
	THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
	THREE.SpotLight.prototype.constructor = THREE.SpotLight;
	
	THREE.SpotLight.prototype.copy = function ( source ) {
	
		THREE.Light.prototype.copy.call( this, source );
	
		this.distance = source.distance;
		this.angle = source.angle;
		this.exponent = source.exponent;
		this.decay = source.decay;
	
		this.target = source.target.clone();
	
		this.shadow = source.shadow.clone();
	
		return this;
	
	};
	
	// File:src/loaders/Cache.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Cache = {
	
		enabled: false,
	
		files: {},
	
		add: function ( key, file ) {
	
			if ( this.enabled === false ) return;
	
			// console.log( 'THREE.Cache', 'Adding key:', key );
	
			this.files[ key ] = file;
	
		},
	
		get: function ( key ) {
	
			if ( this.enabled === false ) return;
	
			// console.log( 'THREE.Cache', 'Checking key:', key );
	
			return this.files[ key ];
	
		},
	
		remove: function ( key ) {
	
			delete this.files[ key ];
	
		},
	
		clear: function () {
	
			this.files = {};
	
		}
	
	};
	
	// File:src/loaders/Loader.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Loader = function () {
	
		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};
	
	};
	
	THREE.Loader.prototype = {
	
		constructor: THREE.Loader,
	
		crossOrigin: undefined,
	
		extractUrlBase: function ( url ) {
	
			var parts = url.split( '/' );
	
			if ( parts.length === 1 ) return './';
	
			parts.pop();
	
			return parts.join( '/' ) + '/';
	
		},
	
		initMaterials: function ( materials, texturePath, crossOrigin ) {
	
			var array = [];
	
			for ( var i = 0; i < materials.length; ++ i ) {
	
				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );
	
			}
	
			return array;
	
		},
	
		createMaterial: ( function () {
	
			var color, textureLoader, materialLoader;
	
			return function ( m, texturePath, crossOrigin ) {
	
				if ( color === undefined ) color = new THREE.Color();
				if ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();
				if ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();
	
				// convert from old material format
	
				var textures = {};
	
				function loadTexture( path, repeat, offset, wrap, anisotropy ) {
	
					var fullPath = texturePath + path;
					var loader = THREE.Loader.Handlers.get( fullPath );
	
					var texture;
	
					if ( loader !== null ) {
	
						texture = loader.load( fullPath );
	
					} else {
	
						textureLoader.setCrossOrigin( crossOrigin );
						texture = textureLoader.load( fullPath );
	
					}
	
					if ( repeat !== undefined ) {
	
						texture.repeat.fromArray( repeat );
	
						if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;
	
					}
	
					if ( offset !== undefined ) {
	
						texture.offset.fromArray( offset );
	
					}
	
					if ( wrap !== undefined ) {
	
						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;
	
						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;
	
					}
	
					if ( anisotropy !== undefined ) {
	
						texture.anisotropy = anisotropy;
	
					}
	
					var uuid = THREE.Math.generateUUID();
	
					textures[ uuid ] = texture;
	
					return uuid;
	
				}
	
				//
	
				var json = {
					uuid: THREE.Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};
	
				for ( var name in m ) {
	
					var value = m[ name ];
	
					switch ( name ) {
						case 'DbgColor':
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = THREE[ value ];
							break;
						case 'colorAmbient':
							console.warn( 'THREE.Loader.createMaterial: colorAmbient is no longer supported' );
							break;
						case 'colorDiffuse':
							json.color = color.fromArray( value ).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray( value ).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray( value ).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
							break;
						case 'mapNormalFactor':
							json.normalScale = [ value, value ];
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = THREE.BackSide;
							break;
						case 'doubleSided':
							json.side = THREE.DoubleSide;
							break;
						case 'transparency':
							console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'depthTest':
						case 'depthWrite':
						case 'colorWrite':
						case 'opacity':
						case 'reflectivity':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[ name ] = value;
							break;
						case 'vertexColors':
							if ( value === true ) json.vertexColors = THREE.VertexColors;
							if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
							break;
						default:
							console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
							break;
					}
	
				}
	
				if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
	
				if ( json.opacity < 1 ) json.transparent = true;
	
				materialLoader.setTextures( textures );
	
				return materialLoader.parse( json );
	
			};
	
		} )()
	
	};
	
	THREE.Loader.Handlers = {
	
		handlers: [],
	
		add: function ( regex, loader ) {
	
			this.handlers.push( regex, loader );
	
		},
	
		get: function ( file ) {
	
			var handlers = this.handlers;
	
			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {
	
				var regex = handlers[ i ];
				var loader  = handlers[ i + 1 ];
	
				if ( regex.test( file ) ) {
	
					return loader;
	
				}
	
			}
	
			return null;
	
		}
	
	};
	
	// File:src/loaders/XHRLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.XHRLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.XHRLoader.prototype = {
	
		constructor: THREE.XHRLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			if ( this.path !== undefined ) url = this.path + url;
	
			var scope = this;
	
			var cached = THREE.Cache.get( url );
	
			if ( cached !== undefined ) {
	
				if ( onLoad ) {
	
					setTimeout( function () {
	
						onLoad( cached );
	
					}, 0 );
	
				}
	
				return cached;
	
			}
	
			var request = new XMLHttpRequest();
			request.overrideMimeType( 'text/plain' );
			request.open( 'GET', url, true );
	
			request.addEventListener( 'load', function ( event ) {
	
				var response = event.target.response;
	
				THREE.Cache.add( url, response );
	
				if ( this.status === 200 ) {
	
					if ( onLoad ) onLoad( response );
	
					scope.manager.itemEnd( url );
	
				} else if ( this.status === 0 ) {
	
					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.
	
					console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );
	
					if ( onLoad ) onLoad( response );
	
					scope.manager.itemEnd( url );
	
				} else {
	
					if ( onError ) onError( event );
	
					scope.manager.itemError( url );
	
				}
	
			}, false );
	
			if ( onProgress !== undefined ) {
	
				request.addEventListener( 'progress', function ( event ) {
	
					onProgress( event );
	
				}, false );
	
			}
	
			request.addEventListener( 'error', function ( event ) {
	
				if ( onError ) onError( event );
	
				scope.manager.itemError( url );
	
			}, false );
	
			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;
	
			request.send( null );
	
			scope.manager.itemStart( url );
	
			return request;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
	
		},
	
		setResponseType: function ( value ) {
	
			this.responseType = value;
	
		},
	
		setWithCredentials: function ( value ) {
	
			this.withCredentials = value;
	
		}
	
	};
	
	// File:src/loaders/FontLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.FontLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.FontLoader.prototype = {
	
		constructor: THREE.FontLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.load( url, function ( text ) {
	
				onLoad( new THREE.Font( JSON.parse( text.substring( 65, text.length - 2 ) ) ) );
	
			}, onProgress, onError );
	
		}
	
	};
	
	// File:src/loaders/ImageLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ImageLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.ImageLoader.prototype = {
	
		constructor: THREE.ImageLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			if ( this.path !== undefined ) url = this.path + url;
	
			var scope = this;
	
			var cached = THREE.Cache.get( url );
	
			if ( cached !== undefined ) {
	
				scope.manager.itemStart( url );
	
				if ( onLoad ) {
	
					setTimeout( function () {
	
						onLoad( cached );
	
						scope.manager.itemEnd( url );
	
					}, 0 );
	
				} else {
	
					scope.manager.itemEnd( url );
	
				}
	
				return cached;
	
			}
	
			var image = document.createElement( 'img' );
	
			image.addEventListener( 'load', function ( event ) {
	
				THREE.Cache.add( url, this );
	
				if ( onLoad ) onLoad( this );
	
				scope.manager.itemEnd( url );
	
			}, false );
	
			if ( onProgress !== undefined ) {
	
				image.addEventListener( 'progress', function ( event ) {
	
					onProgress( event );
	
				}, false );
	
			}
	
			image.addEventListener( 'error', function ( event ) {
	
				if ( onError ) onError( event );
	
				scope.manager.itemError( url );
	
			}, false );
	
			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
	
			scope.manager.itemStart( url );
	
			image.src = url;
	
			return image;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
	
		}
	
	};
	
	// File:src/loaders/JSONLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.JSONLoader = function ( manager ) {
	
		if ( typeof manager === 'boolean' ) {
	
			console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
			manager = undefined;
	
		}
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
		this.withCredentials = false;
	
	};
	
	THREE.JSONLoader.prototype = {
	
		constructor: THREE.JSONLoader,
	
		// Deprecated
	
		get statusDomElement () {
	
			if ( this._statusDomElement === undefined ) {
	
				this._statusDomElement = document.createElement( 'div' );
	
			}
	
			console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
			return this._statusDomElement;
	
		},
	
		load: function( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {
	
				var json = JSON.parse( text );
				var metadata = json.metadata;
	
				if ( metadata !== undefined ) {
	
					var type = metadata.type;
	
					if ( type !== undefined ) {
	
						if ( type.toLowerCase() === 'object' ) {
	
							console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
							return;
	
						}
	
						if ( type.toLowerCase() === 'scene' ) {
	
							console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
							return;
	
						}
	
					}
	
				}
	
				var object = scope.parse( json, texturePath );
				onLoad( object.geometry, object.materials );
	
			}, onProgress, onError );
	
		},
	
		setTexturePath: function ( value ) {
	
			this.texturePath = value;
	
		},
	
		parse: function ( json, texturePath ) {
	
			var geometry = new THREE.Geometry(),
			scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;
	
			parseModel( scale );
	
			parseSkin();
			parseMorphing( scale );
			parseAnimations();
	
			geometry.computeFaceNormals();
			geometry.computeBoundingSphere();
	
			function parseModel( scale ) {
	
				function isBitSet( value, position ) {
	
					return value & ( 1 << position );
	
				}
	
				var i, j, fi,
	
				offset, zLength,
	
			colorIndex, normalIndex, uvIndex, materialIndex,
	
				type,
				isQuad,
				hasMaterial,
				hasFaceVertexUv,
				hasFaceNormal, hasFaceVertexNormal,
				hasFaceColor, hasFaceVertexColor,
	
			vertex, face, faceA, faceB, hex, normal,
	
				uvLayer, uv, u, v,
	
				faces = json.faces,
				vertices = json.vertices,
				normals = json.normals,
				colors = json.colors,
	
				nUvLayers = 0;
	
				if ( json.uvs !== undefined ) {
	
					// disregard empty arrays
	
					for ( i = 0; i < json.uvs.length; i ++ ) {
	
						if ( json.uvs[ i ].length ) nUvLayers ++;
	
					}
	
					for ( i = 0; i < nUvLayers; i ++ ) {
	
						geometry.faceVertexUvs[ i ] = [];
	
					}
	
				}
	
				offset = 0;
				zLength = vertices.length;
	
				while ( offset < zLength ) {
	
					vertex = new THREE.Vector3();
	
					vertex.x = vertices[ offset ++ ] * scale;
					vertex.y = vertices[ offset ++ ] * scale;
					vertex.z = vertices[ offset ++ ] * scale;
	
					geometry.vertices.push( vertex );
	
				}
	
				offset = 0;
				zLength = faces.length;
	
				while ( offset < zLength ) {
	
					type = faces[ offset ++ ];
	
	
					isQuad              = isBitSet( type, 0 );
					hasMaterial         = isBitSet( type, 1 );
					hasFaceVertexUv     = isBitSet( type, 3 );
					hasFaceNormal       = isBitSet( type, 4 );
					hasFaceVertexNormal = isBitSet( type, 5 );
					hasFaceColor	     = isBitSet( type, 6 );
					hasFaceVertexColor  = isBitSet( type, 7 );
	
					// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
	
					if ( isQuad ) {
	
						faceA = new THREE.Face3();
						faceA.a = faces[ offset ];
						faceA.b = faces[ offset + 1 ];
						faceA.c = faces[ offset + 3 ];
	
						faceB = new THREE.Face3();
						faceB.a = faces[ offset + 1 ];
						faceB.b = faces[ offset + 2 ];
						faceB.c = faces[ offset + 3 ];
	
						offset += 4;
	
						if ( hasMaterial ) {
	
							materialIndex = faces[ offset ++ ];
							faceA.materialIndex = materialIndex;
							faceB.materialIndex = materialIndex;
	
						}
	
						// to get face <=> uv index correspondence
	
						fi = geometry.faces.length;
	
						if ( hasFaceVertexUv ) {
	
							for ( i = 0; i < nUvLayers; i ++ ) {
	
								uvLayer = json.uvs[ i ];
	
								geometry.faceVertexUvs[ i ][ fi ] = [];
								geometry.faceVertexUvs[ i ][ fi + 1 ] = [];
	
								for ( j = 0; j < 4; j ++ ) {
	
									uvIndex = faces[ offset ++ ];
	
									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];
	
									uv = new THREE.Vector2( u, v );
	
									if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
									if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );
	
								}
	
							}
	
						}
	
						if ( hasFaceNormal ) {
	
							normalIndex = faces[ offset ++ ] * 3;
	
							faceA.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
	
							faceB.normal.copy( faceA.normal );
	
						}
	
						if ( hasFaceVertexNormal ) {
	
							for ( i = 0; i < 4; i ++ ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
	
								if ( i !== 2 ) faceA.vertexNormals.push( normal );
								if ( i !== 0 ) faceB.vertexNormals.push( normal );
	
							}
	
						}
	
	
						if ( hasFaceColor ) {
	
							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];
	
							faceA.color.setHex( hex );
							faceB.color.setHex( hex );
	
						}
	
	
						if ( hasFaceVertexColor ) {
	
							for ( i = 0; i < 4; i ++ ) {
	
								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];
	
								if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
								if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );
	
							}
	
						}
	
						geometry.faces.push( faceA );
						geometry.faces.push( faceB );
	
					} else {
	
						face = new THREE.Face3();
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];
	
						if ( hasMaterial ) {
	
							materialIndex = faces[ offset ++ ];
							face.materialIndex = materialIndex;
	
						}
	
						// to get face <=> uv index correspondence
	
						fi = geometry.faces.length;
	
						if ( hasFaceVertexUv ) {
	
							for ( i = 0; i < nUvLayers; i ++ ) {
	
								uvLayer = json.uvs[ i ];
	
								geometry.faceVertexUvs[ i ][ fi ] = [];
	
								for ( j = 0; j < 3; j ++ ) {
	
									uvIndex = faces[ offset ++ ];
	
									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];
	
									uv = new THREE.Vector2( u, v );
	
									geometry.faceVertexUvs[ i ][ fi ].push( uv );
	
								}
	
							}
	
						}
	
						if ( hasFaceNormal ) {
	
							normalIndex = faces[ offset ++ ] * 3;
	
							face.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
	
						}
	
						if ( hasFaceVertexNormal ) {
	
							for ( i = 0; i < 3; i ++ ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
								face.vertexNormals.push( normal );
	
							}
	
						}
	
	
						if ( hasFaceColor ) {
	
							colorIndex = faces[ offset ++ ];
							face.color.setHex( colors[ colorIndex ] );
	
						}
	
	
						if ( hasFaceVertexColor ) {
	
							for ( i = 0; i < 3; i ++ ) {
	
								colorIndex = faces[ offset ++ ];
								face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );
	
							}
	
						}
	
						geometry.faces.push( face );
	
					}
	
				}
	
			};
	
			function parseSkin() {
	
				var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;
	
				if ( json.skinWeights ) {
	
					for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {
	
						var x =                               json.skinWeights[ i ];
						var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
						var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
						var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;
	
						geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );
	
					}
	
				}
	
				if ( json.skinIndices ) {
	
					for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {
	
						var a =                               json.skinIndices[ i ];
						var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
						var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
						var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;
	
						geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );
	
					}
	
				}
	
				geometry.bones = json.bones;
	
				if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {
	
					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );
	
				}
	
			};
	
			function parseMorphing( scale ) {
	
				if ( json.morphTargets !== undefined ) {
	
					for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {
	
						geometry.morphTargets[ i ] = {};
						geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
						geometry.morphTargets[ i ].vertices = [];
	
						var dstVertices = geometry.morphTargets[ i ].vertices;
						var srcVertices = json.morphTargets[ i ].vertices;
	
						for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {
	
							var vertex = new THREE.Vector3();
							vertex.x = srcVertices[ v ] * scale;
							vertex.y = srcVertices[ v + 1 ] * scale;
							vertex.z = srcVertices[ v + 2 ] * scale;
	
							dstVertices.push( vertex );
	
						}
	
					}
	
				}
	
				if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {
	
					console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );
	
					var faces = geometry.faces;
					var morphColors = json.morphColors[ 0 ].colors;
	
					for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
						faces[ i ].color.fromArray( morphColors, i * 3 );
	
					}
	
				}
	
			}
	
			function parseAnimations() {
	
				var outputAnimations = [];
	
				// parse old style Bone/Hierarchy animations
				var animations = [];
	
				if ( json.animation !== undefined ) {
	
					animations.push( json.animation );
	
				}
	
				if ( json.animations !== undefined ) {
	
					if ( json.animations.length ) {
	
						animations = animations.concat( json.animations );
	
					} else {
	
						animations.push( json.animations );
	
					}
	
				}
	
				for ( var i = 0; i < animations.length; i ++ ) {
	
					var clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );
					if ( clip ) outputAnimations.push( clip );
	
				}
	
				// parse implicit morph animations
				if ( geometry.morphTargets ) {
	
					// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
					var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
					outputAnimations = outputAnimations.concat( morphAnimationClips );
	
				}
	
				if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;
	
			};
	
			if ( json.materials === undefined || json.materials.length === 0 ) {
	
				return { geometry: geometry };
	
			} else {
	
				var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );
	
				return { geometry: geometry, materials: materials };
	
			}
	
		}
	
	};
	
	// File:src/loaders/LoadingManager.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LoadingManager = function ( onLoad, onProgress, onError ) {
	
		var scope = this;
	
		var isLoading = false, itemsLoaded = 0, itemsTotal = 0;
	
		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;
	
		this.itemStart = function ( url ) {
	
			itemsTotal ++;
	
			if ( isLoading === false ) {
	
				if ( scope.onStart !== undefined ) {
	
					scope.onStart( url, itemsLoaded, itemsTotal );
	
				}
	
			}
	
			isLoading = true;
	
		};
	
		this.itemEnd = function ( url ) {
	
			itemsLoaded ++;
	
			if ( scope.onProgress !== undefined ) {
	
				scope.onProgress( url, itemsLoaded, itemsTotal );
	
			}
	
			if ( itemsLoaded === itemsTotal ) {
	
				isLoading = false;
	
				if ( scope.onLoad !== undefined ) {
	
					scope.onLoad();
	
				}
	
			}
	
		};
	
		this.itemError = function ( url ) {
	
			if ( scope.onError !== undefined ) {
	
				scope.onError( url );
	
			}
	
		};
	
	};
	
	THREE.DefaultLoadingManager = new THREE.LoadingManager();
	
	// File:src/loaders/BufferGeometryLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferGeometryLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.BufferGeometryLoader.prototype = {
	
		constructor: THREE.BufferGeometryLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			}, onProgress, onError );
	
		},
	
		parse: function ( json ) {
	
			var geometry = new THREE.BufferGeometry();
	
			var index = json.data.index;
	
			var TYPED_ARRAYS = {
				'Int8Array': Int8Array,
				'Uint8Array': Uint8Array,
				'Uint8ClampedArray': Uint8ClampedArray,
				'Int16Array': Int16Array,
				'Uint16Array': Uint16Array,
				'Int32Array': Int32Array,
				'Uint32Array': Uint32Array,
				'Float32Array': Float32Array,
				'Float64Array': Float64Array
			};
	
			if ( index !== undefined ) {
	
				var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
				geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );
	
			}
	
			var attributes = json.data.attributes;
	
			for ( var key in attributes ) {
	
				var attribute = attributes[ key ];
				var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
	
				geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );
	
			}
	
			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
	
			if ( groups !== undefined ) {
	
				for ( var i = 0, n = groups.length; i !== n; ++ i ) {
	
					var group = groups[ i ];
	
					geometry.addGroup( group.start, group.count, group.materialIndex );
	
				}
	
			}
	
			var boundingSphere = json.data.boundingSphere;
	
			if ( boundingSphere !== undefined ) {
	
				var center = new THREE.Vector3();
	
				if ( boundingSphere.center !== undefined ) {
	
					center.fromArray( boundingSphere.center );
	
				}
	
				geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );
	
			}
	
			return geometry;
	
		}
	
	};
	
	// File:src/loaders/MaterialLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.MaterialLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.textures = {};
	
	};
	
	THREE.MaterialLoader.prototype = {
	
		constructor: THREE.MaterialLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			}, onProgress, onError );
	
		},
	
		setTextures: function ( value ) {
	
			this.textures = value;
	
		},
	
		getTexture: function ( name ) {
	
			var textures = this.textures;
	
			if ( textures[ name ] === undefined ) {
	
				console.warn( 'THREE.MaterialLoader: Undefined texture', name );
	
			}
	
			return textures[ name ];
	
		},
	
		parse: function ( json ) {
	
			var material = new THREE[ json.type ];
	
			if ( json.uuid !== undefined ) material.uuid = json.uuid;
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.roughness !== undefined ) material.roughness = json.roughness;
			if ( json.metalness !== undefined ) material.metalness = json.metalness;
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.shading !== undefined ) material.shading = json.shading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
	
			// for PointsMaterial
			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
	
			// maps
	
			if ( json.map !== undefined ) material.map = this.getTexture( json.map );
	
			if ( json.alphaMap !== undefined ) {
	
				material.alphaMap = this.getTexture( json.alphaMap );
				material.transparent = true;
	
			}
	
			if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;
	
			if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
			if ( json.normalScale !== undefined ) {
	
				var normalScale = json.normalScale;
	
				if ( Array.isArray( normalScale ) === false ) {
	
					// Blender exporter used to export a scalar. See #7459
	
					normalScale = [ normalScale, normalScale ];
	
				}
	
				material.normalScale = new THREE.Vector2().fromArray( normalScale );
	
			}
	
			if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;
	
			if ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );
			if ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );
	
			if ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );
			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;
	
			if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );
	
			if ( json.envMap !== undefined ) {
	
				material.envMap = this.getTexture( json.envMap );
				material.combine = THREE.MultiplyOperation;
	
			}
	
			if ( json.reflectivity ) material.reflectivity = json.reflectivity;
	
			if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;
	
			if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;
	
			// MultiMaterial
	
			if ( json.materials !== undefined ) {
	
				for ( var i = 0, l = json.materials.length; i < l; i ++ ) {
	
					material.materials.push( this.parse( json.materials[ i ] ) );
	
				}
	
			}
	
			return material;
	
		}
	
	};
	
	// File:src/loaders/ObjectLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ObjectLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.texturePath = '';
	
	};
	
	THREE.ObjectLoader.prototype = {
	
		constructor: THREE.ObjectLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			if ( this.texturePath === '' ) {
	
				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );
	
			}
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.load( url, function ( text ) {
	
				scope.parse( JSON.parse( text ), onLoad );
	
			}, onProgress, onError );
	
		},
	
		setTexturePath: function ( value ) {
	
			this.texturePath = value;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		parse: function ( json, onLoad ) {
	
			var geometries = this.parseGeometries( json.geometries );
	
			var images = this.parseImages( json.images, function () {
	
				if ( onLoad !== undefined ) onLoad( object );
	
			} );
	
			var textures  = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );
	
			var object = this.parseObject( json.object, geometries, materials );
	
			if ( json.animations ) {
	
				object.animations = this.parseAnimations( json.animations );
	
			}
	
			if ( json.images === undefined || json.images.length === 0 ) {
	
				if ( onLoad !== undefined ) onLoad( object );
	
			}
	
			return object;
	
		},
	
		parseGeometries: function ( json ) {
	
			var geometries = {};
	
			if ( json !== undefined ) {
	
				var geometryLoader = new THREE.JSONLoader();
				var bufferGeometryLoader = new THREE.BufferGeometryLoader();
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var geometry;
					var data = json[ i ];
	
					switch ( data.type ) {
	
						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':
	
							geometry = new THREE[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);
	
							break;
	
						case 'BoxGeometry':
						case 'CubeGeometry': // backwards compatible
	
							geometry = new THREE.BoxGeometry(
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);
	
							break;
	
						case 'CircleBufferGeometry':
	
							geometry = new THREE.CircleBufferGeometry(
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'CircleGeometry':
	
							geometry = new THREE.CircleGeometry(
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'CylinderGeometry':
	
							geometry = new THREE.CylinderGeometry(
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'SphereGeometry':
	
							geometry = new THREE.SphereGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'SphereBufferGeometry':
	
							geometry = new THREE.SphereBufferGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'DodecahedronGeometry':
	
							geometry = new THREE.DodecahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'IcosahedronGeometry':
	
							geometry = new THREE.IcosahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'OctahedronGeometry':
	
							geometry = new THREE.OctahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'TetrahedronGeometry':
	
							geometry = new THREE.TetrahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'RingGeometry':
	
							geometry = new THREE.RingGeometry(
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'TorusGeometry':
	
							geometry = new THREE.TorusGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);
	
							break;
	
						case 'TorusKnotGeometry':
	
							geometry = new THREE.TorusKnotGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.p,
								data.q,
								data.heightScale
							);
	
							break;
	
						case 'LatheGeometry':
	
							geometry = new THREE.LatheGeometry(
								data.points,
								data.segments,
								data.phiStart,
								data.phiLength
							);
	
							break;
	
						case 'BufferGeometry':
	
							geometry = bufferGeometryLoader.parse( data );
	
							break;
	
						case 'Geometry':
	
							geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;
	
							break;
	
						default:
	
							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );
	
							continue;
	
					}
	
					geometry.uuid = data.uuid;
	
					if ( data.name !== undefined ) geometry.name = data.name;
	
					geometries[ data.uuid ] = geometry;
	
				}
	
			}
	
			return geometries;
	
		},
	
		parseMaterials: function ( json, textures ) {
	
			var materials = {};
	
			if ( json !== undefined ) {
	
				var loader = new THREE.MaterialLoader();
				loader.setTextures( textures );
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var material = loader.parse( json[ i ] );
					materials[ material.uuid ] = material;
	
				}
	
			}
	
			return materials;
	
		},
	
		parseAnimations: function ( json ) {
	
			var animations = [];
	
			for ( var i = 0; i < json.length; i ++ ) {
	
				var clip = THREE.AnimationClip.parse( json[ i ] );
	
				animations.push( clip );
	
			}
	
			return animations;
	
		},
	
		parseImages: function ( json, onLoad ) {
	
			var scope = this;
			var images = {};
	
			function loadImage( url ) {
	
				scope.manager.itemStart( url );
	
				return loader.load( url, function () {
	
					scope.manager.itemEnd( url );
	
				} );
	
			}
	
			if ( json !== undefined && json.length > 0 ) {
	
				var manager = new THREE.LoadingManager( onLoad );
	
				var loader = new THREE.ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var image = json[ i ];
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;
	
					images[ image.uuid ] = loadImage( path );
	
				}
	
			}
	
			return images;
	
		},
	
		parseTextures: function ( json, images ) {
	
			function parseConstant( value ) {
	
				if ( typeof( value ) === 'number' ) return value;
	
				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );
	
				return THREE[ value ];
	
			}
	
			var textures = {};
	
			if ( json !== undefined ) {
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var data = json[ i ];
	
					if ( data.image === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );
	
					}
	
					if ( images[ data.image ] === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );
	
					}
	
					var texture = new THREE.Texture( images[ data.image ] );
					texture.needsUpdate = true;
	
					texture.uuid = data.uuid;
	
					if ( data.name !== undefined ) texture.name = data.name;
					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
					if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
					if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
					if ( Array.isArray( data.wrap ) ) {
	
						texture.wrapS = parseConstant( data.wrap[ 0 ] );
						texture.wrapT = parseConstant( data.wrap[ 1 ] );
	
					}
	
					textures[ data.uuid ] = texture;
	
				}
	
			}
	
			return textures;
	
		},
	
		parseObject: function () {
	
			var matrix = new THREE.Matrix4();
	
			return function ( data, geometries, materials ) {
	
				var object;
	
				function getGeometry( name ) {
	
					if ( geometries[ name ] === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: Undefined geometry', name );
	
					}
	
					return geometries[ name ];
	
				}
	
				function getMaterial( name ) {
	
					if ( name === undefined ) return undefined;
	
					if ( materials[ name ] === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: Undefined material', name );
	
					}
	
					return materials[ name ];
	
				}
	
				switch ( data.type ) {
	
					case 'Scene':
	
						object = new THREE.Scene();
	
						break;
	
					case 'PerspectiveCamera':
	
						object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
	
						break;
	
					case 'OrthographicCamera':
	
						object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
	
						break;
	
					case 'AmbientLight':
	
						object = new THREE.AmbientLight( data.color, data.intensity );
	
						break;
	
					case 'DirectionalLight':
	
						object = new THREE.DirectionalLight( data.color, data.intensity );
	
						break;
	
					case 'PointLight':
	
						object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );
	
						break;
	
					case 'SpotLight':
	
						object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );
	
						break;
	
					case 'HemisphereLight':
	
						object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );
	
						break;
	
					case 'Mesh':
	
						var geometry = getGeometry( data.geometry );
						var material = getMaterial( data.material );
	
						if ( geometry.bones && geometry.bones.length > 0 ) {
	
							object = new THREE.SkinnedMesh( geometry, material );
	
						} else {
	
							object = new THREE.Mesh( geometry, material );
	
						}
	
						break;
	
					case 'LOD':
	
						object = new THREE.LOD();
	
						break;
	
					case 'Line':
	
						object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );
	
						break;
	
					case 'PointCloud':
					case 'Points':
	
						object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );
	
						break;
	
					case 'Sprite':
	
						object = new THREE.Sprite( getMaterial( data.material ) );
	
						break;
	
					case 'Group':
	
						object = new THREE.Group();
	
						break;
	
					default:
	
						object = new THREE.Object3D();
	
				}
	
				object.uuid = data.uuid;
	
				if ( data.name !== undefined ) object.name = data.name;
				if ( data.matrix !== undefined ) {
	
					matrix.fromArray( data.matrix );
					matrix.decompose( object.position, object.quaternion, object.scale );
	
				} else {
	
					if ( data.position !== undefined ) object.position.fromArray( data.position );
					if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
					if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
	
				}
	
				if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
				if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;
	
				if ( data.visible !== undefined ) object.visible = data.visible;
				if ( data.userData !== undefined ) object.userData = data.userData;
	
				if ( data.children !== undefined ) {
	
					for ( var child in data.children ) {
	
						object.add( this.parseObject( data.children[ child ], geometries, materials ) );
	
					}
	
				}
	
				if ( data.type === 'LOD' ) {
	
					var levels = data.levels;
	
					for ( var l = 0; l < levels.length; l ++ ) {
	
						var level = levels[ l ];
						var child = object.getObjectByProperty( 'uuid', level.object );
	
						if ( child !== undefined ) {
	
							object.addLevel( child, level.distance );
	
						}
	
					}
	
				}
	
				return object;
	
			}
	
		}()
	
	};
	
	// File:src/loaders/TextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.TextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.TextureLoader.prototype = {
	
		constructor: THREE.TextureLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var texture = new THREE.Texture();
	
			var loader = new THREE.ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );
			loader.load( url, function ( image ) {
	
				texture.image = image;
				texture.needsUpdate = true;
	
				if ( onLoad !== undefined ) {
	
					onLoad( texture );
	
				}
	
			}, onProgress, onError );
	
			return texture;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
	
		}
	
	};
	
	// File:src/loaders/CubeTextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CubeTextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.CubeTextureLoader.prototype = {
	
		constructor: THREE.CubeTextureLoader,
	
		load: function ( urls, onLoad, onProgress, onError ) {
	
			var texture = new THREE.CubeTexture( [] );
	
			var loader = new THREE.ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );
	
			var loaded = 0;
	
			function loadTexture( i ) {
	
				loader.load( urls[ i ], function ( image ) {
	
					texture.images[ i ] = image;
	
					loaded ++;
	
					if ( loaded === 6 ) {
	
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}
	
				}, undefined, onError );
	
			}
	
			for ( var i = 0; i < urls.length; ++ i ) {
	
				loadTexture( i );
	
			}
	
			return texture;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
	
		}
	
	};
	
	// File:src/loaders/BinaryTextureLoader.js
	
	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */
	
	THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
		// override in sub classes
		this._parser = null;
	
	};
	
	THREE.BinaryTextureLoader.prototype = {
	
		constructor: THREE.BinaryTextureLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var texture = new THREE.DataTexture();
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
	
			loader.load( url, function ( buffer ) {
	
				var texData = scope._parser( buffer );
	
				if ( ! texData ) return;
	
				if ( undefined !== texData.image ) {
	
					texture.image = texData.image;
	
				} else if ( undefined !== texData.data ) {
	
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
	
				}
	
				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;
	
				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;
	
				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
	
				if ( undefined !== texData.format ) {
	
					texture.format = texData.format;
	
				}
				if ( undefined !== texData.type ) {
	
					texture.type = texData.type;
	
				}
	
				if ( undefined !== texData.mipmaps ) {
	
					texture.mipmaps = texData.mipmaps;
	
				}
	
				if ( 1 === texData.mipmapCount ) {
	
					texture.minFilter = THREE.LinearFilter;
	
				}
	
				texture.needsUpdate = true;
	
				if ( onLoad ) onLoad( texture, texData );
	
			}, onProgress, onError );
	
	
			return texture;
	
		}
	
	};
	
	// File:src/loaders/CompressedTextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */
	
	THREE.CompressedTextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
		// override in sub classes
		this._parser = null;
	
	};
	
	
	THREE.CompressedTextureLoader.prototype = {
	
		constructor: THREE.CompressedTextureLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var images = [];
	
			var texture = new THREE.CompressedTexture();
			texture.image = images;
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
	
			function loadTexture( i ) {
	
				loader.load( url[ i ], function ( buffer ) {
	
					var texDatas = scope._parser( buffer, true );
	
					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};
	
					loaded += 1;
	
					if ( loaded === 6 ) {
	
						if ( texDatas.mipmapCount === 1 )
							texture.minFilter = THREE.LinearFilter;
	
						texture.format = texDatas.format;
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}
	
				}, onProgress, onError );
	
			}
	
			if ( Array.isArray( url ) ) {
	
				var loaded = 0;
	
				for ( var i = 0, il = url.length; i < il; ++ i ) {
	
					loadTexture( i );
	
				}
	
			} else {
	
				// compressed cubemap texture stored in a single DDS file
	
				loader.load( url, function ( buffer ) {
	
					var texDatas = scope._parser( buffer, true );
	
					if ( texDatas.isCubemap ) {
	
						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
	
						for ( var f = 0; f < faces; f ++ ) {
	
							images[ f ] = { mipmaps : [] };
	
							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {
	
								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;
	
							}
	
						}
	
					} else {
	
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
	
					}
	
					if ( texDatas.mipmapCount === 1 ) {
	
						texture.minFilter = THREE.LinearFilter;
	
					}
	
					texture.format = texDatas.format;
					texture.needsUpdate = true;
	
					if ( onLoad ) onLoad( texture );
	
				}, onProgress, onError );
	
			}
	
			return texture;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
	
		}
	
	};
	
	// File:src/materials/Material.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Material = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Material';
	
		this.side = THREE.FrontSide;
	
		this.opacity = 1;
		this.transparent = false;
	
		this.blending = THREE.NormalBlending;
	
		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
	
		this.depthFunc = THREE.LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;
	
		this.colorWrite = true;
	
		this.precision = null; // override the renderer's default precision for this material
	
		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;
	
		this.alphaTest = 0;
	
		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
	
		this.visible = true;
	
		this._needsUpdate = true;
	
	};
	
	THREE.Material.prototype = {
	
		constructor: THREE.Material,
	
		get needsUpdate () {
	
			return this._needsUpdate;
	
		},
	
		set needsUpdate ( value ) {
	
			if ( value === true ) this.update();
	
			this._needsUpdate = value;
	
		},
	
		setValues: function ( values ) {
	
			if ( values === undefined ) return;
	
			for ( var key in values ) {
	
				var newValue = values[ key ];
	
				if ( newValue === undefined ) {
	
					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;
	
				}
	
				var currentValue = this[ key ];
	
				if ( currentValue === undefined ) {
	
					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;
	
				}
	
				if ( currentValue instanceof THREE.Color ) {
	
					currentValue.set( newValue );
	
				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {
	
					currentValue.copy( newValue );
	
				} else if ( key === 'overdraw' ) {
	
					// ensure overdraw is backwards-compatible with legacy boolean type
					this[ key ] = Number( newValue );
	
				} else {
	
					this[ key ] = newValue;
	
				}
	
			}
	
		},
	
		toJSON: function ( meta ) {
	
			var isRoot = meta === undefined;
	
			if ( isRoot ) {
	
				meta = {
					textures: {},
					images: {}
				};
	
			}
	
			var data = {
				metadata: {
					version: 4.4,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};
	
			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
	
			if ( this.roughness !== 0.5 ) data.roughness = this.roughness;
			if ( this.metalness !== 0.5 ) data.metalness = this.metalness;
	
			if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
			if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
	
			if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
			if ( this.bumpMap instanceof THREE.Texture ) {
	
				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;
	
			}
			if ( this.normalMap instanceof THREE.Texture ) {
	
				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalScale = this.normalScale.toArray();
	
			}
			if ( this.displacementMap instanceof THREE.Texture ) {
	
				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
	
			}
			if ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;
	
			if ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
	
			if ( this.envMap instanceof THREE.Texture ) {
	
				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap
	
			}
	
			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;
	
			if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
			if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
			if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
			if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;
	
			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;
			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
	
			// TODO: Copied from Object3D.toJSON
	
			function extractFromCache ( cache ) {
	
				var values = [];
	
				for ( var key in cache ) {
	
					var data = cache[ key ];
					delete data.metadata;
					values.push( data );
	
				}
	
				return values;
	
			}
	
			if ( isRoot ) {
	
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
	
				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;
	
			}
	
			return data;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.name = source.name;
	
			this.side = source.side;
	
			this.opacity = source.opacity;
			this.transparent = source.transparent;
	
			this.blending = source.blending;
	
			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
	
			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;
	
			this.colorWrite = source.colorWrite;
	
			this.precision = source.precision;
	
			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;
	
			this.alphaTest = source.alphaTest;
	
			this.overdraw = source.overdraw;
	
			this.visible = source.visible;
	
			return this;
	
		},
	
		update: function () {
	
			this.dispatchEvent( { type: 'update' } );
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );
	
	THREE.MaterialIdCount = 0;
	
	// File:src/materials/LineBasicMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round",
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.LineBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'LineBasicMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
	
	THREE.LineBasicMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.fog = source.fog;
	
		return this;
	
	};
	
	// File:src/materials/LineDashedMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.FaceColors / THREE.VertexColors
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.LineDashedMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'LineDashedMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
	
		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;
	
		this.vertexColors = THREE.NoColors;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
	
	THREE.LineDashedMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		
		this.linewidth = source.linewidth;
	
		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;
	
		this.vertexColors = source.vertexColors;
	
		this.fog = source.fog;
	
		return this;
	
	};
	
	// File:src/materials/MeshBasicMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.MeshBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshBasicMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // emissive
	
		this.map = null;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
	
	THREE.MeshBasicMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.fog = source.fog;
	
		this.shading = source.shading;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
	
		return this;
	
	};
	
	// File:src/materials/MeshLambertMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshLambertMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshLambertMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
	
		this.map = null;
	
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.emissive = new THREE.Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
	
	THREE.MeshLambertMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.fog = source.fog;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	// File:src/materials/MeshPhongMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshPhongMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshPhongMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;
	
		this.map = null;
	
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.emissive = new THREE.Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
	
		this.bumpMap = null;
		this.bumpScale = 1;
	
		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );
	
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
	
	THREE.MeshPhongMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;
	
		this.map = source.map;
	
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
	
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
	
		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );
	
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.fog = source.fog;
	
		this.shading = source.shading;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	// File:src/materials/MeshStandardMaterial.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshStandardMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshStandardMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.roughness = 0.5;
		this.metalness = 0.5;
	
		this.map = null;
	
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.emissive = new THREE.Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
	
		this.bumpMap = null;
		this.bumpScale = 1;
	
		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );
	
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
	
		this.roughnessMap = null;
	
		this.metalnessMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.envMapIntensity = 1.0;
	
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;
	
	THREE.MeshStandardMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;
	
		this.map = source.map;
	
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
	
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
	
		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );
	
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
	
		this.roughnessMap = source.roughnessMap;
	
		this.metalnessMap = source.metalnessMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;
	
		this.refractionRatio = source.refractionRatio;
	
		this.fog = source.fog;
	
		this.shading = source.shading;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	// File:src/materials/MeshDepthMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshDepthMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshDepthMaterial';
	
		this.morphTargets = false;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
	
	THREE.MeshDepthMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		return this;
	
	};
	
	// File:src/materials/MeshNormalMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  shading: THREE.FlatShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshNormalMaterial = function ( parameters ) {
	
		THREE.Material.call( this, parameters );
	
		this.type = 'MeshNormalMaterial';
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.morphTargets = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
	
	THREE.MeshNormalMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		return this;
	
	};
	
	// File:src/materials/MultiMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.MultiMaterial = function ( materials ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.type = 'MultiMaterial';
	
		this.materials = materials instanceof Array ? materials : [];
	
		this.visible = true;
	
	};
	
	THREE.MultiMaterial.prototype = {
	
		constructor: THREE.MultiMaterial,
	
		toJSON: function ( meta ) {
	
			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type,
				materials: []
			};
	
			var materials = this.materials;
	
			for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
				var material = materials[ i ].toJSON( meta );
				delete material.metadata;
	
				output.materials.push( material );
	
			}
	
			output.visible = this.visible;
	
			return output;
	
		},
	
		clone: function () {
	
			var material = new this.constructor();
	
			for ( var i = 0; i < this.materials.length; i ++ ) {
	
				material.materials.push( this.materials[ i ].clone() );
	
			}
	
			material.visible = this.visible;
	
			return material;
	
		}
	
	};
	
	// File:src/materials/PointsMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  vertexColors: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.PointsMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'PointsMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.map = null;
	
		this.size = 1;
		this.sizeAttenuation = true;
	
		this.vertexColors = THREE.NoColors;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;
	
	THREE.PointsMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;
	
		this.vertexColors = source.vertexColors;
	
		this.fog = source.fog;
	
		return this;
	
	};
	
	// File:src/materials/ShaderMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.ShaderMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'ShaderMaterial';
	
		this.defines = {};
		this.uniforms = {};
	
		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
	
		this.shading = THREE.SmoothShading;
	
		this.linewidth = 1;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.fog = false; // set to use scene fog
	
		this.lights = false; // set to use scene lights
	
		this.vertexColors = THREE.NoColors; // set to use "color" attribute stream
	
		this.skinning = false; // set to use skinning attribute streams
	
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals
	
		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};
	
		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};
	
		this.index0AttributeName = undefined;
	
		if ( parameters !== undefined ) {
	
			if ( parameters.attributes !== undefined ) {
	
				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );
	
			}
	
			this.setValues( parameters );
	
		}
	
	};
	
	THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
	
	THREE.ShaderMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;
	
		this.uniforms = THREE.UniformsUtils.clone( source.uniforms );
	
		this.defines = source.defines;
	
		this.shading = source.shading;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		this.fog = source.fog;
	
		this.lights = source.lights;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
	
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		this.extensions = source.extensions;
	
		return this;
	
	};
	
	THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Material.prototype.toJSON.call( this, meta );
	
		data.uniforms = this.uniforms;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;
	
		return data;
	
	};
	
	// File:src/materials/RawShaderMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RawShaderMaterial = function ( parameters ) {
	
		THREE.ShaderMaterial.call( this, parameters );
	
		this.type = 'RawShaderMaterial';
	
	};
	
	THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
	THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
	
	// File:src/materials/SpriteMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2(),
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.SpriteMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'SpriteMaterial';
	
		this.color = new THREE.Color( 0xffffff );
		this.map = null;
	
		this.rotation = 0;
	
		this.fog = false;
	
		// set parameters
	
		this.setValues( parameters );
	
	};
	
	THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
	
	THREE.SpriteMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.map = source.map;
	
		this.rotation = source.rotation;
	
		this.fog = source.fog;
	
		return this;
	
	};
	
	// File:src/textures/Texture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.sourceFile = '';
	
		this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
		this.mipmaps = [];
	
		this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;
	
		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
	
		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
	
		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	
		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;
	
		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );
	
		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	
		this.version = 0;
		this.onUpdate = null;
	
	};
	
	THREE.Texture.DEFAULT_IMAGE = undefined;
	THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
	
	THREE.Texture.prototype = {
	
		constructor: THREE.Texture,
	
		set needsUpdate ( value ) {
	
			if ( value === true ) this.version ++;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );
	
			this.mapping = source.mapping;
	
			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;
	
			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;
	
			this.anisotropy = source.anisotropy;
	
			this.format = source.format;
			this.type = source.type;
	
			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
	
			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
	
			return this;
	
		},
	
		toJSON: function ( meta ) {
	
			if ( meta.textures[ this.uuid ] !== undefined ) {
	
				return meta.textures[ this.uuid ];
	
			}
	
			function getDataURL( image ) {
	
				var canvas;
	
				if ( image.toDataURL !== undefined ) {
	
					canvas = image;
	
				} else {
	
					canvas = document.createElement( 'canvas' );
					canvas.width = image.width;
					canvas.height = image.height;
	
					canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );
	
				}
	
				if ( canvas.width > 2048 || canvas.height > 2048 ) {
	
					return canvas.toDataURL( 'image/jpeg', 0.6 );
	
				} else {
	
					return canvas.toDataURL( 'image/png' );
	
				}
	
			}
	
			var output = {
				metadata: {
					version: 4.4,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},
	
				uuid: this.uuid,
				name: this.name,
	
				mapping: this.mapping,
	
				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				wrap: [ this.wrapS, this.wrapT ],
	
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy
			};
	
			if ( this.image !== undefined ) {
	
				// TODO: Move to THREE.Image
	
				var image = this.image;
	
				if ( image.uuid === undefined ) {
	
					image.uuid = THREE.Math.generateUUID(); // UGH
	
				}
	
				if ( meta.images[ image.uuid ] === undefined ) {
	
					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: getDataURL( image )
					};
	
				}
	
				output.image = image.uuid;
	
			}
	
			meta.textures[ this.uuid ] = output;
	
			return output;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		},
	
		transformUv: function ( uv ) {
	
			if ( this.mapping !== THREE.UVMapping )  return;
	
			uv.multiply( this.repeat );
			uv.add( this.offset );
	
			if ( uv.x < 0 || uv.x > 1 ) {
	
				switch ( this.wrapS ) {
	
					case THREE.RepeatWrapping:
	
						uv.x = uv.x - Math.floor( uv.x );
						break;
	
					case THREE.ClampToEdgeWrapping:
	
						uv.x = uv.x < 0 ? 0 : 1;
						break;
	
					case THREE.MirroredRepeatWrapping:
	
						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {
	
							uv.x = Math.ceil( uv.x ) - uv.x;
	
						} else {
	
							uv.x = uv.x - Math.floor( uv.x );
	
						}
						break;
	
				}
	
			}
	
			if ( uv.y < 0 || uv.y > 1 ) {
	
				switch ( this.wrapT ) {
	
					case THREE.RepeatWrapping:
	
						uv.y = uv.y - Math.floor( uv.y );
						break;
	
					case THREE.ClampToEdgeWrapping:
	
						uv.y = uv.y < 0 ? 0 : 1;
						break;
	
					case THREE.MirroredRepeatWrapping:
	
						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {
	
							uv.y = Math.ceil( uv.y ) - uv.y;
	
						} else {
	
							uv.y = uv.y - Math.floor( uv.y );
	
						}
						break;
	
				}
	
			}
	
			if ( this.flipY ) {
	
				uv.y = 1 - uv.y;
	
			}
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );
	
	THREE.TextureIdCount = 0;
	
	// File:src/textures/CanvasTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.needsUpdate = true;
	
	};
	
	THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;
	
	// File:src/textures/CubeTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
	
		THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.images = images;
		this.flipY = false;
	
	};
	
	THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
	
	THREE.CubeTexture.prototype.copy = function ( source ) {
	
		THREE.Texture.prototype.copy.call( this, source );
	
		this.images = source.images;
	
		return this;
	
	};
	
	// File:src/textures/CompressedTexture.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;
	
		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )
	
		this.flipY = false;
	
		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files
	
		this.generateMipmaps = false;
	
	};
	
	THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
	
	// File:src/textures/DataTexture.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.image = { data: data, width: width, height: height };
	
		this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
		
		this.flipY = false;
		this.generateMipmaps  = false;
	
	};
	
	THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.DataTexture.prototype.constructor = THREE.DataTexture;
	
	// File:src/textures/VideoTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.generateMipmaps = false;
	
		var scope = this;
	
		function update() {
	
			requestAnimationFrame( update );
	
			if ( video.readyState === video.HAVE_ENOUGH_DATA ) {
	
				scope.needsUpdate = true;
	
			}
	
		}
	
		update();
	
	};
	
	THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
	
	// File:src/objects/Group.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Group = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Group';
	
	};
	
	THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Group.prototype.constructor = THREE.Group;
	// File:src/objects/Points.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Points = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Points';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );
	
	};
	
	THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Points.prototype.constructor = THREE.Points;
	
	THREE.Points.prototype.raycast = ( function () {
	
		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();
	
		return function raycast( raycaster, intersects ) {
	
			var object = this;
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Points.threshold;
	
			// Checking boundingSphere distance to ray
	
			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
	
			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
			//
	
			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;
			var position = new THREE.Vector3();
	
			function testPoint( point, index ) {
	
				var rayPointDistanceSq = ray.distanceSqToPoint( point );
	
				if ( rayPointDistanceSq < localThresholdSq ) {
	
					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( matrixWorld );
	
					var distance = raycaster.ray.origin.distanceTo( intersectPoint );
	
					if ( distance < raycaster.near || distance > raycaster.far ) return;
	
					intersects.push( {
	
						distance: distance,
						distanceToRay: Math.sqrt( rayPointDistanceSq ),
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object
	
					} );
	
				}
	
			}
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;
	
				if ( index !== null ) {
	
					var indices = index.array;
	
					for ( var i = 0, il = indices.length; i < il; i ++ ) {
	
						var a = indices[ i ];
	
						position.fromArray( positions, a * 3 );
	
						testPoint( position, a );
	
					}
	
				} else {
	
					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {
	
						position.fromArray( positions, i * 3 );
	
						testPoint( position, i );
	
					}
	
				}
	
			} else {
	
				var vertices = geometry.vertices;
	
				for ( var i = 0, l = vertices.length; i < l; i ++ ) {
	
					testPoint( vertices[ i ], i );
	
				}
	
			}
	
		};
	
	}() );
	
	THREE.Points.prototype.clone = function () {
	
		return new this.constructor( this.geometry, this.material ).copy( this );
	
	};
	
	// File:src/objects/Line.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Line = function ( geometry, material, mode ) {
	
		if ( mode === 1 ) {
	
			console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
			return new THREE.LineSegments( geometry, material );
	
		}
	
		THREE.Object3D.call( this );
	
		this.type = 'Line';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );
	
	};
	
	THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Line.prototype.constructor = THREE.Line;
	
	THREE.Line.prototype.raycast = ( function () {
	
		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();
	
		return function raycast( raycaster, intersects ) {
	
			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;
	
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
	
			// Checking boundingSphere distance to ray
	
			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
	
			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
			//
	
			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
			var vStart = new THREE.Vector3();
			var vEnd = new THREE.Vector3();
			var interSegment = new THREE.Vector3();
			var interRay = new THREE.Vector3();
			var step = this instanceof THREE.LineSegments ? 2 : 1;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;
	
				if ( index !== null ) {
	
					var indices = index.array;
	
					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {
	
						var a = indices[ i ];
						var b = indices[ i + 1 ];
	
						vStart.fromArray( positions, a * 3 );
						vEnd.fromArray( positions, b * 3 );
	
						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
						if ( distSq > precisionSq ) continue;
	
						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
						var distance = raycaster.ray.origin.distanceTo( interRay );
	
						if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
						intersects.push( {
	
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this
	
						} );
	
					}
	
				} else {
	
					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {
	
						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );
	
						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
						if ( distSq > precisionSq ) continue;
	
						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
						var distance = raycaster.ray.origin.distanceTo( interRay );
	
						if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
						intersects.push( {
	
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this
	
						} );
	
					}
	
				}
	
			} else if ( geometry instanceof THREE.Geometry ) {
	
				var vertices = geometry.vertices;
				var nbVertices = vertices.length;
	
				for ( var i = 0; i < nbVertices - 1; i += step ) {
	
					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
	
					if ( distSq > precisionSq ) continue;
	
					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
					var distance = raycaster.ray.origin.distanceTo( interRay );
	
					if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
					intersects.push( {
	
						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this
	
					} );
	
				}
	
			}
	
		};
	
	}() );
	
	THREE.Line.prototype.clone = function () {
	
		return new this.constructor( this.geometry, this.material ).copy( this );
	
	};
	
	// DEPRECATED
	
	THREE.LineStrip = 0;
	THREE.LinePieces = 1;
	
	// File:src/objects/LineSegments.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LineSegments = function ( geometry, material ) {
	
		THREE.Line.call( this, geometry, material );
	
		this.type = 'LineSegments';
	
	};
	
	THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
	THREE.LineSegments.prototype.constructor = THREE.LineSegments;
	
	// File:src/objects/Mesh.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */
	
	THREE.Mesh = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Mesh';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );
	
		this.drawMode = THREE.TrianglesDrawMode;
	
		this.updateMorphTargets();
	
	};
	
	THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Mesh.prototype.constructor = THREE.Mesh;
	
	THREE.Mesh.prototype.setDrawMode = function ( value ) {
	
		this.drawMode = value;
	
	};
	
	THREE.Mesh.prototype.updateMorphTargets = function () {
	
		if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {
	
			this.morphTargetBase = - 1;
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};
	
			for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {
	
				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;
	
			}
	
		}
	
	};
	
	THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {
	
		if ( this.morphTargetDictionary[ name ] !== undefined ) {
	
			return this.morphTargetDictionary[ name ];
	
		}
	
		console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );
	
		return 0;
	
	};
	
	
	THREE.Mesh.prototype.raycast = ( function () {
	
		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();
	
		var vA = new THREE.Vector3();
		var vB = new THREE.Vector3();
		var vC = new THREE.Vector3();
	
		var tempA = new THREE.Vector3();
		var tempB = new THREE.Vector3();
		var tempC = new THREE.Vector3();
	
		var uvA = new THREE.Vector2();
		var uvB = new THREE.Vector2();
		var uvC = new THREE.Vector2();
	
		var barycoord = new THREE.Vector3();
	
		var intersectionPoint = new THREE.Vector3();
		var intersectionPointWorld = new THREE.Vector3();
	
		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {
	
			THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );
	
			uv1.multiplyScalar( barycoord.x );
			uv2.multiplyScalar( barycoord.y );
			uv3.multiplyScalar( barycoord.z );
	
			uv1.add( uv2 ).add( uv3 );
	
			return uv1.clone();
	
		}
	
		function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {
	
			var intersect;
			var material = object.material;
	
			if ( material.side === THREE.BackSide ) {
	
				intersect = ray.intersectTriangle( pC, pB, pA, true, point );
	
			} else {
	
				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );
	
			}
	
			if ( intersect === null ) return null;
	
			intersectionPointWorld.copy( point );
			intersectionPointWorld.applyMatrix4( object.matrixWorld );
	
			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );
	
			if ( distance < raycaster.near || distance > raycaster.far ) return null;
	
			return {
				distance: distance,
				point: intersectionPointWorld.clone(),
				object: object
			};
	
		}
	
		function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {
	
			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );
	
			var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );
	
			if ( intersection ) {
	
				if ( uvs ) {
	
					uvA.fromArray( uvs, a * 2 );
					uvB.fromArray( uvs, b * 2 );
					uvC.fromArray( uvs, c * 2 );
	
					intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );
	
				}
	
				intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
				intersection.faceIndex = a;
	
			}
	
			return intersection;
	
		}
	
		return function raycast( raycaster, intersects ) {
	
			var geometry = this.geometry;
			var material = this.material;
			var matrixWorld = this.matrixWorld;
	
			if ( material === undefined ) return;
	
			// Checking boundingSphere distance to ray
	
			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
	
			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
			//
	
			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
			// Check boundingBox before continuing
	
			if ( geometry.boundingBox !== null ) {
	
				if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;
	
			}
	
			var uvs, intersection;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var a, b, c;
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;
	
				if ( attributes.uv !== undefined ) {
	
					uvs = attributes.uv.array;
	
				}
	
				if ( index !== null ) {
	
					var indices = index.array;
	
					for ( var i = 0, l = indices.length; i < l; i += 3 ) {
	
						a = indices[ i ];
						b = indices[ i + 1 ];
						c = indices[ i + 2 ];
	
						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
	
						if ( intersection ) {
	
							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
							intersects.push( intersection );
	
						}
	
					}
	
				} else {
	
	
					for ( var i = 0, l = positions.length; i < l; i += 9 ) {
	
						a = i / 3;
						b = a + 1;
						c = a + 2;
	
						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
	
						if ( intersection ) {
	
							intersection.index = a; // triangle number in positions buffer semantics
							intersects.push( intersection );
	
						}
	
					}
	
				}
	
			} else if ( geometry instanceof THREE.Geometry ) {
	
				var fvA, fvB, fvC;
				var isFaceMaterial = material instanceof THREE.MultiMaterial;
				var materials = isFaceMaterial === true ? material.materials : null;
	
				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;
	
				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
	
					var face = faces[ f ];
					var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;
	
					if ( faceMaterial === undefined ) continue;
	
					fvA = vertices[ face.a ];
					fvB = vertices[ face.b ];
					fvC = vertices[ face.c ];
	
					if ( faceMaterial.morphTargets === true ) {
	
						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;
	
						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );
	
						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
	
							var influence = morphInfluences[ t ];
	
							if ( influence === 0 ) continue;
	
							var targets = morphTargets[ t ].vertices;
	
							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );
	
						}
	
						vA.add( fvA );
						vB.add( fvB );
						vC.add( fvC );
	
						fvA = vA;
						fvB = vB;
						fvC = vC;
	
					}
	
					intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );
	
					if ( intersection ) {
	
						if ( uvs ) {
	
							var uvs_f = uvs[ f ];
							uvA.copy( uvs_f[ 0 ] );
							uvB.copy( uvs_f[ 1 ] );
							uvC.copy( uvs_f[ 2 ] );
	
							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );
	
						}
	
						intersection.face = face;
						intersection.faceIndex = f;
						intersects.push( intersection );
	
					}
	
				}
	
			}
	
		};
	
	}() );
	
	THREE.Mesh.prototype.clone = function () {
	
		return new this.constructor( this.geometry, this.material ).copy( this );
	
	};
	
	// File:src/objects/Bone.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.Bone = function ( skin ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Bone';
	
		this.skin = skin;
	
	};
	
	THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Bone.prototype.constructor = THREE.Bone;
	
	THREE.Bone.prototype.copy = function ( source ) {
		
		THREE.Object3D.prototype.copy.call( this, source );
		
		this.skin = source.skin;
		
		return this;
	
	};
	
	// File:src/objects/Skeleton.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */
	
	THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {
	
		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
	
		this.identityMatrix = new THREE.Matrix4();
	
		// copy the bone array
	
		bones = bones || [];
	
		this.bones = bones.slice( 0 );
	
		// create a bone texture or an array of floats
	
		if ( this.useVertexTexture ) {
	
			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
			//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
			//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
			//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
	
			
			var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
			size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
			size = Math.max( size, 4 );
	
			this.boneTextureWidth = size;
			this.boneTextureHeight = size;
	
			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
	
		} else {
	
			this.boneMatrices = new Float32Array( 16 * this.bones.length );
	
		}
	
		// use the supplied bone inverses or calculate the inverses
	
		if ( boneInverses === undefined ) {
	
			this.calculateInverses();
	
		} else {
	
			if ( this.bones.length === boneInverses.length ) {
	
				this.boneInverses = boneInverses.slice( 0 );
	
			} else {
	
				console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );
	
				this.boneInverses = [];
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					this.boneInverses.push( new THREE.Matrix4() );
	
				}
	
			}
	
		}
	
	};
	
	THREE.Skeleton.prototype.calculateInverses = function () {
	
		this.boneInverses = [];
	
		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
			var inverse = new THREE.Matrix4();
	
			if ( this.bones[ b ] ) {
	
				inverse.getInverse( this.bones[ b ].matrixWorld );
	
			}
	
			this.boneInverses.push( inverse );
	
		}
	
	};
	
	THREE.Skeleton.prototype.pose = function () {
	
		var bone;
	
		// recover the bind-time world matrices
	
		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
			bone = this.bones[ b ];
	
			if ( bone ) {
	
				bone.matrixWorld.getInverse( this.boneInverses[ b ] );
	
			}
	
		}
	
		// compute the local matrices, positions, rotations and scales
	
		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
			bone = this.bones[ b ];
	
			if ( bone ) {
	
				if ( bone.parent ) {
	
					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );
	
				} else {
	
					bone.matrix.copy( bone.matrixWorld );
	
				}
	
				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
	
			}
	
		}
	
	};
	
	THREE.Skeleton.prototype.update = ( function () {
	
		var offsetMatrix = new THREE.Matrix4();
	
		return function update() {
	
			// flatten bone matrices to array
	
			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
				// compute the offset between the current and the original transform
	
				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;
	
				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
				offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );
	
			}
	
			if ( this.useVertexTexture ) {
	
				this.boneTexture.needsUpdate = true;
	
			}
	
		};
	
	} )();
	
	THREE.Skeleton.prototype.clone = function () {
	
		return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );
	
	};
	
	// File:src/objects/SkinnedMesh.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		this.type = 'SkinnedMesh';
	
		this.bindMode = "attached";
		this.bindMatrix = new THREE.Matrix4();
		this.bindMatrixInverse = new THREE.Matrix4();
	
		// init bones
	
		// TODO: remove bone creation as there is no reason (other than
		// convenience) for THREE.SkinnedMesh to do this.
	
		var bones = [];
	
		if ( this.geometry && this.geometry.bones !== undefined ) {
	
			var bone, gbone;
	
			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
				gbone = this.geometry.bones[ b ];
	
				bone = new THREE.Bone( this );
				bones.push( bone );
	
				bone.name = gbone.name;
				bone.position.fromArray( gbone.pos );
				bone.quaternion.fromArray( gbone.rotq );
				if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );
	
			}
	
			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
				gbone = this.geometry.bones[ b ];
	
				if ( gbone.parent !== - 1 && gbone.parent !== null ) {
	
					bones[ gbone.parent ].add( bones[ b ] );
	
				} else {
	
					this.add( bones[ b ] );
	
				}
	
			}
	
		}
	
		this.normalizeSkinWeights();
	
		this.updateMatrixWorld( true );
		this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );
	
	};
	
	
	THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
	
	THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {
	
		this.skeleton = skeleton;
	
		if ( bindMatrix === undefined ) {
	
			this.updateMatrixWorld( true );
	
			this.skeleton.calculateInverses();
	
			bindMatrix = this.matrixWorld;
	
		}
	
		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );
	
	};
	
	THREE.SkinnedMesh.prototype.pose = function () {
	
		this.skeleton.pose();
	
	};
	
	THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
	
		if ( this.geometry instanceof THREE.Geometry ) {
	
			for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {
	
				var sw = this.geometry.skinWeights[ i ];
	
				var scale = 1.0 / sw.lengthManhattan();
	
				if ( scale !== Infinity ) {
	
					sw.multiplyScalar( scale );
	
				} else {
	
					sw.set( 1, 0, 0, 0 ); // do something reasonable
	
				}
	
			}
	
		} else if ( this.geometry instanceof THREE.BufferGeometry ) {
	
			var vec = new THREE.Vector4();
	
			var skinWeight = this.geometry.attributes.skinWeight;
	
			for ( var i = 0; i < skinWeight.count; i ++ ) {
	
				vec.x = skinWeight.getX( i );
				vec.y = skinWeight.getY( i );
				vec.z = skinWeight.getZ( i );
				vec.w = skinWeight.getW( i );
	
				var scale = 1.0 / vec.lengthManhattan();
	
				if ( scale !== Infinity ) {
	
					vec.multiplyScalar( scale );
	
				} else {
	
					vec.set( 1, 0, 0, 0 ); // do something reasonable
	
				}
	
				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );
	
			}
	
		}
	
	};
	
	THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {
	
		THREE.Mesh.prototype.updateMatrixWorld.call( this, true );
	
		if ( this.bindMode === "attached" ) {
	
			this.bindMatrixInverse.getInverse( this.matrixWorld );
	
		} else if ( this.bindMode === "detached" ) {
	
			this.bindMatrixInverse.getInverse( this.bindMatrix );
	
		} else {
	
			console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );
	
		}
	
	};
	
	THREE.SkinnedMesh.prototype.clone = function() {
	
		return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );
	
	};
	
	// File:src/objects/LOD.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LOD = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'LOD';
	
		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			objects: {
				get: function () {
	
					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;
	
				}
			}
		} );
	
	};
	
	
	THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LOD.prototype.constructor = THREE.LOD;
	
	THREE.LOD.prototype.addLevel = function ( object, distance ) {
	
		if ( distance === undefined ) distance = 0;
	
		distance = Math.abs( distance );
	
		var levels = this.levels;
	
		for ( var l = 0; l < levels.length; l ++ ) {
	
			if ( distance < levels[ l ].distance ) {
	
				break;
	
			}
	
		}
	
		levels.splice( l, 0, { distance: distance, object: object } );
	
		this.add( object );
	
	};
	
	THREE.LOD.prototype.getObjectForDistance = function ( distance ) {
	
		var levels = this.levels;
	
		for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
			if ( distance < levels[ i ].distance ) {
	
				break;
	
			}
	
		}
	
		return levels[ i - 1 ].object;
	
	};
	
	THREE.LOD.prototype.raycast = ( function () {
	
		var matrixPosition = new THREE.Vector3();
	
		return function raycast( raycaster, intersects ) {
	
			matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
			var distance = raycaster.ray.origin.distanceTo( matrixPosition );
	
			this.getObjectForDistance( distance ).raycast( raycaster, intersects );
	
		};
	
	}() );
	
	THREE.LOD.prototype.update = function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
	
		return function update( camera ) {
	
			var levels = this.levels;
	
			if ( levels.length > 1 ) {
	
				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );
	
				var distance = v1.distanceTo( v2 );
	
				levels[ 0 ].object.visible = true;
	
				for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
					if ( distance >= levels[ i ].distance ) {
	
						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;
	
					} else {
	
						break;
	
					}
	
				}
	
				for ( ; i < l; i ++ ) {
	
					levels[ i ].object.visible = false;
	
				}
	
			}
	
		};
	
	}();
	
	THREE.LOD.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source, false );
	
		var levels = source.levels;
	
		for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
			var level = levels[ i ];
	
			this.addLevel( level.object.clone(), level.distance );
	
		}
	
		return this;
	
	};
	
	THREE.LOD.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
		data.object.levels = [];
	
		var levels = this.levels;
	
		for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
			var level = levels[ i ];
	
			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );
	
		}
	
		return data;
	
	};
	
	// File:src/objects/Sprite.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Sprite = ( function () {
	
		var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
		var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
		var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );
	
		var geometry = new THREE.BufferGeometry();
		geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
		return function Sprite( material ) {
	
			THREE.Object3D.call( this );
	
			this.type = 'Sprite';
	
			this.geometry = geometry;
			this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();
	
		};
	
	} )();
	
	THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Sprite.prototype.constructor = THREE.Sprite;
	
	THREE.Sprite.prototype.raycast = ( function () {
	
		var matrixPosition = new THREE.Vector3();
	
		return function raycast( raycaster, intersects ) {
	
			matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
			var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
			var guessSizeSq = this.scale.x * this.scale.y;
	
			if ( distanceSq > guessSizeSq ) {
	
				return;
	
			}
	
			intersects.push( {
	
				distance: Math.sqrt( distanceSq ),
				point: this.position,
				face: null,
				object: this
	
			} );
	
		};
	
	}() );
	
	THREE.Sprite.prototype.clone = function () {
	
		return new this.constructor( this.material ).copy( this );
	
	};
	
	// Backwards compatibility
	
	THREE.Particle = THREE.Sprite;
	
	// File:src/objects/LensFlare.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlare = function ( texture, size, distance, blending, color ) {
	
		THREE.Object3D.call( this );
	
		this.lensFlares = [];
	
		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;
	
		if ( texture !== undefined ) {
	
			this.add( texture, size, distance, blending, color );
	
		}
	
	};
	
	THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LensFlare.prototype.constructor = THREE.LensFlare;
	
	
	/*
	 * Add: adds another flare
	 */
	
	THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {
	
		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new THREE.Color( 0xffffff );
		if ( blending === undefined ) blending = THREE.NormalBlending;
	
		distance = Math.min( distance, Math.max( 0, distance ) );
	
		this.lensFlares.push( {
			texture: texture,	// THREE.Texture
			size: size, 		// size in pixels (-1 = use texture.width)
			distance: distance, 	// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
			scale: 1, 		// scale
			rotation: 0, 		// rotation
			opacity: opacity,	// opacity
			color: color,		// color
			blending: blending	// blending
		} );
	
	};
	
	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */
	
	THREE.LensFlare.prototype.updateLensFlares = function () {
	
		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;
	
		for ( f = 0; f < fl; f ++ ) {
	
			flare = this.lensFlares[ f ];
	
			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;
	
			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;
	
		}
	
	};
	
	THREE.LensFlare.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source );
	
		this.positionScreen.copy( source.positionScreen );
		this.customUpdateCallback = source.customUpdateCallback;
	
		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {
	
			this.lensFlares.push( source.lensFlares[ i ] );
	
		}
	
		return this;
	
	};
	
	// File:src/scenes/Scene.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Scene = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Scene';
	
		this.fog = null;
		this.overrideMaterial = null;
	
		this.autoUpdate = true; // checked by the renderer
	
	};
	
	THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Scene.prototype.constructor = THREE.Scene;
	
	THREE.Scene.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source );
	
		if ( source.fog !== null ) this.fog = source.fog.clone();
		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();
	
		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;
	
		return this;
	
	};
	
	// File:src/scenes/Fog.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Fog = function ( color, near, far ) {
	
		this.name = '';
	
		this.color = new THREE.Color( color );
	
		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;
	
	};
	
	THREE.Fog.prototype.clone = function () {
	
		return new THREE.Fog( this.color.getHex(), this.near, this.far );
	
	};
	
	// File:src/scenes/FogExp2.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.FogExp2 = function ( color, density ) {
	
		this.name = '';
	
		this.color = new THREE.Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;
	
	};
	
	THREE.FogExp2.prototype.clone = function () {
	
		return new THREE.FogExp2( this.color.getHex(), this.density );
	
	};
	
	// File:src/renderers/shaders/ShaderChunk.js
	
	THREE.ShaderChunk = {};
	
	// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl
	
	THREE.ShaderChunk[ 'alphamap_fragment' ] = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'alphamap_pars_fragment' ] = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl
	
	THREE.ShaderChunk[ 'alphatest_fragment' ] = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/ambient_pars.glsl
	
	THREE.ShaderChunk[ 'ambient_pars' ] = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	return PI * ambientLightColor;\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl
	
	THREE.ShaderChunk[ 'aomap_fragment' ] = "#ifdef USE_AOMAP\n	reflectedLight.indirectDiffuse *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'aomap_pars_fragment' ] = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl
	
	THREE.ShaderChunk[ 'begin_vertex' ] = "\nvec3 transformed = vec3( position );\n";
	
	// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'beginnormal_vertex' ] = "\nvec3 objectNormal = vec3( normal );\n";
	
	// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl
	
	THREE.ShaderChunk[ 'bsdfs' ] = "float calcLightAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	if ( decayExponent > 0.0 ) {\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = alpha * alpha;\n	float gl = dotNL + pow( a2 + ( 1.0 - a2 ) * dotNL * dotNL, 0.5 );\n	float gv = dotNV + pow( a2 + ( 1.0 - a2 ) * dotNV * dotNV, 0.5 );\n	return 1.0 / ( gl * gv );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = alpha * alpha;\n	float denom = dotNH * dotNH * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / ( denom * denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = roughness * roughness;\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_Smith( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / square( ggxRoughness + 0.0001 ) - 2.0 );\n}";
	
	// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl
	
	THREE.ShaderChunk[ 'color_fragment' ] = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'color_pars_fragment' ] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'color_pars_vertex' ] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl
	
	THREE.ShaderChunk[ 'color_vertex' ] = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/common.glsl
	
	THREE.ShaderChunk[ 'common' ] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat square( const in float x ) { return x*x; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nvec3 inputToLinear( in vec3 a ) {\n	#ifdef GAMMA_INPUT\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n	#else\n		return a;\n	#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n	#ifdef GAMMA_OUTPUT\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n	#else\n		return a;\n	#endif\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'defaultnormal_vertex' ] = "#ifdef FLIP_SIDED\n	objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
	
	// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl
	
	THREE.ShaderChunk[ 'displacementmap_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl
	
	THREE.ShaderChunk[ 'emissivemap_fragment' ] = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n	totalEmissiveLight *= emissiveColor.rgb;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl
	
	THREE.ShaderChunk[ 'envmap_fragment' ] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n	envColor.xyz = inputToLinear( envColor.xyz );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'envmap_pars_fragment' ] = "#if defined( USE_ENVMAP ) || defined( STANDARD )\n	uniform float reflectivity;\n	uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( STANDARD )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'envmap_pars_vertex' ] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n	varying vec3 vReflect;\n	uniform float refractionRatio;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl
	
	THREE.ShaderChunk[ 'envmap_vertex' ] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	#ifdef ENVMAP_MODE_REFLECTION\n		vReflect = reflect( cameraToVertex, worldNormal );\n	#else\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl
	
	THREE.ShaderChunk[ 'fog_fragment' ] = "#ifdef USE_FOG\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'fog_pars_fragment' ] = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl
	
	THREE.ShaderChunk[ 'lightmap_fragment' ] = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'lightmap_pars_fragment' ] = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_lambert_vertex' ] = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		directLight = getPointDirectLight( pointLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		directLight = getSpotDirectLight( spotLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directLight = getDirectionalDirectLight( directionalLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl
	
	THREE.ShaderChunk[ 'lights_pars' ] = "#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	IncidentLight getDirectionalDirectLight( const in DirectionalLight directionalLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		return directLight;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	IncidentLight getPointDirectLight( const in PointLight pointLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= calcLightAttenuation( length( lVector ), pointLight.distance, pointLight.decay );\n		return directLight;\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float angleCos;\n		float exponent;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	IncidentLight getSpotDirectLight( const in SpotLight spotLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float spotEffect = dot( directLight.direction, spotLight.direction );\n		if ( spotEffect > spotLight.angleCos ) {\n			float spotEffect = dot( spotLight.direction, directLight.direction );\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLight.exponent ) );\n			directLight.color = spotLight.color;\n			directLight.color *= ( spotEffect * calcLightAttenuation( length( lVector ), spotLight.distance, spotLight.decay ) );\n		} else {\n			directLight.color = vec3( 0.0 );\n		}\n		return directLight;\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		return PI * mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( STANDARD )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n		#else\n			vec3 envMapColor = vec3( 0.0 );\n		#endif\n		envMapColor.rgb = inputToLinear( envMapColor.rgb );\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( square( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n		#endif\n		envMapColor.rgb = inputToLinear( envMapColor.rgb );\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_phong_fragment' ] = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = "#ifdef USE_ENVMAP\n	varying vec3 vWorldPosition;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * PI * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_phong_pars_vertex' ] = "#ifdef USE_ENVMAP\n	varying vec3 vWorldPosition;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_phong_vertex' ] = "#ifdef USE_ENVMAP\n	vWorldPosition = worldPosition.xyz;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_standard_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_standard_fragment' ] = "StandardMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\nmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_standard_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_standard_pars_fragment' ] = "struct StandardMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n};\nvoid RE_Direct_Standard( const in IncidentLight directLight, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * PI * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Standard( const in vec3 irradiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Standard( const in vec3 radiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct				RE_Direct_Standard\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Standard\n#define RE_IndirectSpecular		RE_IndirectSpecular_Standard\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_template.glsl
	
	THREE.ShaderChunk[ 'lights_template' ] = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		directLight = getPointDirectLight( pointLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		directLight = getSpotDirectLight( spotLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		directLight = getDirectionalDirectLight( directionalLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		irradiance += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	RE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl
	
	THREE.ShaderChunk[ 'linear_to_gamma_fragment' ] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_fragment' ] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl
	
	THREE.ShaderChunk[ 'map_fragment' ] = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n	diffuseColor *= texelColor;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'map_pars_fragment' ] = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl
	
	THREE.ShaderChunk[ 'map_particle_fragment' ] = "#ifdef USE_MAP\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'map_particle_pars_fragment' ] = "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl
	
	THREE.ShaderChunk[ 'metalnessmap_fragment' ] = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.r;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'morphnormal_vertex' ] = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl
	
	THREE.ShaderChunk[ 'morphtarget_vertex' ] = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl
	
	THREE.ShaderChunk[ 'normal_fragment' ] = "#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#endif\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'normalmap_pars_fragment' ] = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl
	
	THREE.ShaderChunk[ 'project_vertex' ] = "#ifdef USE_SKINNING\n	vec4 mvPosition = modelViewMatrix * skinned;\n#else\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";
	
	// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl
	
	THREE.ShaderChunk[ 'roughnessmap_fragment' ] = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.r;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float unpackDepth( const in vec4 rgba_depth ) {\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		return dot( rgba_depth, bit_shift );\n	}\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return 1.0;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec3 offset = vec3( - 1, 0, 1 ) * shadowRadius * 2.0 * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zyz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yzz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yzx, texelSize.y ), dp )\n			) * ( 1.0 / 21.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl
	
	THREE.ShaderChunk[ 'shadowmap_vertex' ] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl
	
	THREE.ShaderChunk[ 'skinbase_vertex' ] = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'skinning_pars_vertex' ] = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl
	
	THREE.ShaderChunk[ 'skinning_vertex' ] = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'skinnormal_vertex' ] = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl
	
	THREE.ShaderChunk[ 'specularmap_fragment' ] = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'specularmap_pars_fragment' ] = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'uv2_pars_fragment' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'uv2_pars_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl
	
	THREE.ShaderChunk[ 'uv2_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'uv_pars_fragment' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'uv_pars_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl
	
	THREE.ShaderChunk[ 'uv_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl
	
	THREE.ShaderChunk[ 'worldpos_vertex' ] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( STANDARD ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	#ifdef USE_SKINNING\n		vec4 worldPosition = modelMatrix * skinned;\n	#else\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/UniformsUtils.js
	
	/**
	 * Uniform Utilities
	 */
	
	THREE.UniformsUtils = {
	
		merge: function ( uniforms ) {
	
			var merged = {};
	
			for ( var u = 0; u < uniforms.length; u ++ ) {
	
				var tmp = this.clone( uniforms[ u ] );
	
				for ( var p in tmp ) {
	
					merged[ p ] = tmp[ p ];
	
				}
	
			}
	
			return merged;
	
		},
	
		clone: function ( uniforms_src ) {
	
			var uniforms_dst = {};
	
			for ( var u in uniforms_src ) {
	
				uniforms_dst[ u ] = {};
	
				for ( var p in uniforms_src[ u ] ) {
	
					var parameter_src = uniforms_src[ u ][ p ];
	
					if ( parameter_src instanceof THREE.Color ||
						 parameter_src instanceof THREE.Vector2 ||
						 parameter_src instanceof THREE.Vector3 ||
						 parameter_src instanceof THREE.Vector4 ||
						 parameter_src instanceof THREE.Matrix3 ||
						 parameter_src instanceof THREE.Matrix4 ||
						 parameter_src instanceof THREE.Texture ) {
	
						uniforms_dst[ u ][ p ] = parameter_src.clone();
	
					} else if ( Array.isArray( parameter_src ) ) {
	
						uniforms_dst[ u ][ p ] = parameter_src.slice();
	
					} else {
	
						uniforms_dst[ u ][ p ] = parameter_src;
	
					}
	
				}
	
			}
	
			return uniforms_dst;
	
		}
	
	};
	
	// File:src/renderers/shaders/UniformsLib.js
	
	/**
	 * Uniforms library for shared webgl shaders
	 */
	
	THREE.UniformsLib = {
	
		common: {
	
			"diffuse": { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity": { type: "f", value: 1.0 },
	
			"map": { type: "t", value: null },
			"offsetRepeat": { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
	
			"specularMap": { type: "t", value: null },
			"alphaMap": { type: "t", value: null },
	
			"envMap": { type: "t", value: null },
			"flipEnvMap": { type: "f", value: - 1 },
			"reflectivity": { type: "f", value: 1.0 },
			"refractionRatio": { type: "f", value: 0.98 }
	
		},
	
		aomap: {
	
			"aoMap": { type: "t", value: null },
			"aoMapIntensity": { type: "f", value: 1 }
	
		},
	
		lightmap: {
	
			"lightMap": { type: "t", value: null },
			"lightMapIntensity": { type: "f", value: 1 }
	
		},
	
		emissivemap: {
	
			"emissiveMap": { type: "t", value: null }
	
		},
	
		bumpmap: {
	
			"bumpMap": { type: "t", value: null },
			"bumpScale": { type: "f", value: 1 }
	
		},
	
		normalmap: {
	
			"normalMap": { type: "t", value: null },
			"normalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) }
	
		},
	
		displacementmap: {
	
			"displacementMap": { type: "t", value: null },
			"displacementScale": { type: "f", value: 1 },
			"displacementBias": { type: "f", value: 0 }
	
		},
	
		roughnessmap: {
	
			"roughnessMap": { type: "t", value: null }
	
		},
	
		metalnessmap: {
	
			"metalnessMap": { type: "t", value: null }
	
		},
	
		fog: {
	
			"fogDensity": { type: "f", value: 0.00025 },
			"fogNear": { type: "f", value: 1 },
			"fogFar": { type: "f", value: 2000 },
			"fogColor": { type: "c", value: new THREE.Color( 0xffffff ) }
	
		},
	
		ambient: {
	
			"ambientLightColor": { type: "fv", value: [] }
	
		},
	
		lights: {
	
			"directionalLights": { type: "sa", value: [], properties: {
				"direction": { type: "v3" },
				"color": { type: "c" },
	
				"shadow": { type: "i" },
				"shadowBias": { type: "f" },
				"shadowRadius": { type: "f" },
				"shadowMapSize": { type: "v2" }
			} },
	
			"directionalShadowMap": { type: "tv", value: [] },
			"directionalShadowMatrix": { type: "m4v", value: [] },
	
			"spotLights": { type: "sa", value: [], properties: {
				"color": { type: "c" },
				"position": { type: "v3" },
				"direction": { type: "v3" },
				"distance": { type: "f" },
				"angleCos": { type: "f" },
				"exponent": { type: "f" },
				"decay": { type: "f" },
	
				"shadow": { type: "i" },
				"shadowBias": { type: "f" },
				"shadowRadius": { type: "f" },
				"shadowMapSize": { type: "v2" }
			} },
	
			"spotShadowMap": { type: "tv", value: [] },
			"spotShadowMatrix": { type: "m4v", value: [] },
	
			"pointLights": { type: "sa", value: [], properties: {
				"color": { type: "c" },
				"position": { type: "v3" },
				"decay": { type: "f" },
				"distance": { type: "f" },
	
				"shadow": { type: "i" },
				"shadowBias": { type: "f" },
				"shadowRadius": { type: "f" },
				"shadowMapSize": { type: "v2" }
			} },
	
			"pointShadowMap": { type: "tv", value: [] },
			"pointShadowMatrix": { type: "m4v", value: [] },
	
			"hemisphereLights": { type: "sa", value: [], properties: {
				"direction": { type: "v3" },
				"skyColor": { type: "c" },
				"groundColor": { type: "c" }
			} }
	
		},
	
		points: {
	
			"diffuse": { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity": { type: "f", value: 1.0 },
			"size": { type: "f", value: 1.0 },
			"scale": { type: "f", value: 1.0 },
			"map": { type: "t", value: null },
			"offsetRepeat": { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) }
	
		}
	
	};
	
	// File:src/renderers/shaders/ShaderLib.js
	
	/**
	 * Webgl Shader Library for three.js
	 *
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	
	THREE.ShaderLib = {
	
		'basic': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "fog" ]
	
			] ),
	
			vertexShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
	
				"	#ifdef USE_ENVMAP",
	
					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
				"	#endif",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				"#ifndef FLAT_SHADED",
	
				"	varying vec3 vNormal;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
	
				"	ReflectedLight reflectedLight;",
				"	reflectedLight.directDiffuse = vec3( 0.0 );",
				"	reflectedLight.directSpecular = vec3( 0.0 );",
				"	reflectedLight.indirectDiffuse = diffuseColor.rgb;",
				"	reflectedLight.indirectSpecular = vec3( 0.0 );",
	
					THREE.ShaderChunk[ "aomap_fragment" ],
	
				"	vec3 outgoingLight = reflectedLight.indirectDiffuse;",
	
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'lambert': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "lightmap" ],
				THREE.UniformsLib[ "emissivemap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "ambient" ],
				THREE.UniformsLib[ "lights" ],
	
				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
				}
	
			] ),
	
			vertexShader: [
	
				"#define LAMBERT",
	
				"varying vec3 vLightFront;",
	
				"#ifdef DOUBLE_SIDED",
	
				"	varying vec3 vLightBack;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "bsdfs" ],
				THREE.ShaderChunk[ "lights_pars" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform float opacity;",
	
				"varying vec3 vLightFront;",
	
				"#ifdef DOUBLE_SIDED",
	
				"	varying vec3 vLightBack;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "bsdfs" ],
				THREE.ShaderChunk[ "ambient_pars" ],
				THREE.ShaderChunk[ "lights_pars" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmask_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
				"	vec3 totalEmissiveLight = emissive;",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "emissivemap_fragment" ],
	
					// accumulation
				"	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );",
	
					THREE.ShaderChunk[ "lightmap_fragment" ],
	
				"	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );",
	
				"	#ifdef DOUBLE_SIDED",
	
				"		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;",
	
				"	#else",
	
				"		reflectedLight.directDiffuse = vLightFront;",
	
				"	#endif",
	
				"	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();",
	
					// modulation
					THREE.ShaderChunk[ "aomap_fragment" ],
	
				"	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveLight;",
	
					THREE.ShaderChunk[ "envmap_fragment" ],
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'phong': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "lightmap" ],
				THREE.UniformsLib[ "emissivemap" ],
				THREE.UniformsLib[ "bumpmap" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "displacementmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "ambient" ],
				THREE.UniformsLib[ "lights" ],
	
				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
					"shininess": { type: "f", value: 30 }
				}
	
			] ),
	
			vertexShader: [
	
				"#define PHONG",
	
				"varying vec3 vViewPosition;",
	
				"#ifndef FLAT_SHADED",
	
				"	varying vec3 vNormal;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
				"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED
	
				"	vNormal = normalize( transformedNormal );",
	
				"#endif",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "displacementmap_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"	vViewPosition = - mvPosition.xyz;",
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_phong_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"#define PHONG",
	
				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform vec3 specular;",
				"uniform float shininess;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "bsdfs" ],
				THREE.ShaderChunk[ "ambient_pars" ],
				THREE.ShaderChunk[ "lights_pars" ],
				THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
				"	vec3 totalEmissiveLight = emissive;",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "normal_fragment" ],
					THREE.ShaderChunk[ "emissivemap_fragment" ],
	
					// accumulation
					THREE.ShaderChunk[ "lights_phong_fragment" ],
					THREE.ShaderChunk[ "lights_template" ],
	
					// modulation
					THREE.ShaderChunk[ "aomap_fragment" ],
	
					"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
	
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'standard': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "lightmap" ],
				THREE.UniformsLib[ "emissivemap" ],
				THREE.UniformsLib[ "bumpmap" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "displacementmap" ],
				THREE.UniformsLib[ "roughnessmap" ],
				THREE.UniformsLib[ "metalnessmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "ambient" ],
				THREE.UniformsLib[ "lights" ],
	
				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"roughness": { type: "f", value: 0.5 },
					"metalness": { type: "f", value: 0 },
					"envMapIntensity" : { type: "f", value: 1 } // temporary
				}
	
			] ),
	
			vertexShader: [
	
				"#define STANDARD",
	
				"varying vec3 vViewPosition;",
	
				"#ifndef FLAT_SHADED",
	
				"	varying vec3 vNormal;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {", // STANDARD
	
					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
				"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED
	
				"	vNormal = normalize( transformedNormal );",
	
				"#endif",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "displacementmap_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"	vViewPosition = - mvPosition.xyz;",
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"#define STANDARD",
	
				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform float roughness;",
				"uniform float metalness;",
				"uniform float opacity;",
	
				"uniform float envMapIntensity;", // temporary
	
				"varying vec3 vViewPosition;",
	
				"#ifndef FLAT_SHADED",
	
				"	varying vec3 vNormal;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "bsdfs" ],
				THREE.ShaderChunk[ "ambient_pars" ],
				THREE.ShaderChunk[ "lights_pars" ],
				THREE.ShaderChunk[ "lights_standard_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "roughnessmap_pars_fragment" ],
				THREE.ShaderChunk[ "metalnessmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
				"	vec3 totalEmissiveLight = emissive;",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "roughnessmap_fragment" ],
					THREE.ShaderChunk[ "metalnessmap_fragment" ],
					THREE.ShaderChunk[ "normal_fragment" ],
					THREE.ShaderChunk[ "emissivemap_fragment" ],
	
					// accumulation
					THREE.ShaderChunk[ "lights_standard_fragment" ],
					THREE.ShaderChunk[ "lights_template" ],
	
					// modulation
					THREE.ShaderChunk[ "aomap_fragment" ],
	
					"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'points': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "points" ],
				THREE.UniformsLib[ "fog" ]
	
			] ),
	
			vertexShader: [
	
				"uniform float size;",
				"uniform float scale;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
	
				"	#ifdef USE_SIZEATTENUATION",
				"		gl_PointSize = size * ( scale / - mvPosition.z );",
				"	#else",
				"		gl_PointSize = size;",
				"	#endif",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_particle_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_particle_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
	
				"	outgoingLight = diffuseColor.rgb;",
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'dashed': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
	
				{
					"scale"    : { type: "f", value: 1 },
					"dashSize" : { type: "f", value: 1 },
					"totalSize": { type: "f", value: 2 }
				}
	
			] ),
	
			vertexShader: [
	
				"uniform float scale;",
				"attribute float lineDistance;",
	
				"varying float vLineDistance;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "color_vertex" ],
	
				"	vLineDistance = scale * lineDistance;",
	
				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"	gl_Position = projectionMatrix * mvPosition;",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				"uniform float dashSize;",
				"uniform float totalSize;",
	
				"varying float vLineDistance;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",
	
				"		discard;",
	
				"	}",
	
				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
	
				"	outgoingLight = diffuseColor.rgb;", // simple shader
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'depth': {
	
			uniforms: {
	
				"mNear": { type: "f", value: 1.0 },
				"mFar" : { type: "f", value: 2000.0 },
				"opacity" : { type: "f", value: 1.0 }
	
			},
	
			vertexShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform float mNear;",
				"uniform float mFar;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"	#ifdef USE_LOGDEPTHBUF_EXT",
	
				"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",
	
				"	#else",
	
				"		float depth = gl_FragCoord.z / gl_FragCoord.w;",
	
				"	#endif",
	
				"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"	gl_FragColor = vec4( vec3( color ), opacity );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'normal': {
	
			uniforms: {
	
				"opacity" : { type: "f", value: 1.0 }
	
			},
	
			vertexShader: [
	
				"varying vec3 vNormal;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
				"	vNormal = normalize( normalMatrix * normal );",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform float opacity;",
				"varying vec3 vNormal;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"}"
	
			].join( "\n" )
	
		},
	
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
	
		'cube': {
	
			uniforms: {
				"tCube": { type: "t", value: null },
				"tFlip": { type: "f", value: - 1 }
			},
	
			vertexShader: [
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
				"	vWorldPosition = transformDirection( position, modelMatrix );",
	
				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform samplerCube tCube;",
				"uniform float tFlip;",
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"}"
	
			].join( "\n" )
	
		},
	
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
	
		'equirect': {
	
			uniforms: {
				"tEquirect": { type: "t", value: null },
				"tFlip": { type: "f", value: - 1 }
			},
	
			vertexShader: [
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
				"	vWorldPosition = transformDirection( position, modelMatrix );",
	
				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform sampler2D tEquirect;",
				"uniform float tFlip;",
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
					// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
					"vec3 direction = normalize( vWorldPosition );",
					"vec2 sampleUV;",
					"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
					"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
					"gl_FragColor = texture2D( tEquirect, sampleUV );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"}"
	
			].join( "\n" )
	
		},
	
		/* Depth encoding into RGBA texture
		 *
		 * based on SpiderGL shadow map example
		 * http://spidergl.org/example.php?id=6
		 *
		 * originally from
		 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
		 *
		 * see also
		 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
		 */
	
		'depthRGBA': {
	
			uniforms: {},
	
			vertexShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "skinbase_vertex" ],
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"vec4 pack_depth( const in float depth ) {",
	
				"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );",
				"	res -= res.xxyz * bit_mask;",
				"	return res;",
	
				"}",
	
				"void main() {",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"	#ifdef USE_LOGDEPTHBUF_EXT",
	
				"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",
	
				"	#else",
	
				"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",
	
				"	#endif",
	
					//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
					//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
					//"gl_FragData[ 0 ] = pack_depth( z );",
					//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",
	
				"}"
	
			].join( "\n" )
	
		},
	
	
		'distanceRGBA': {
	
			uniforms: {
	
				"lightPos": { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) }
	
			},
	
			vertexShader: [
	
				"varying vec4 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],
	
					"vWorldPosition = worldPosition;",
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 lightPos;",
				"varying vec4 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
	
				"vec4 pack1K ( float depth ) {",
	
				"	depth /= 1000.0;",
				"	const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"	vec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );",
				"	res -= res.xxyz * bitMsk;",
				"	return res; ",
	
				"}",
	
				"float unpack1K ( vec4 color ) {",
	
				"	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
				"	return dot( color, bitSh ) * 1000.0;",
	
				"}",
	
				"void main () {",
	
				"	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );",
	
				"}"
	
			].join( "\n" )
	
		}
	
	};
	
	// File:src/renderers/WebGLRenderer.js
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	THREE.WebGLRenderer = function ( parameters ) {
	
		console.log( 'THREE.WebGLRenderer', THREE.REVISION );
	
		parameters = parameters || {};
	
		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,
	
		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
	
		var lights = [];
	
		var opaqueObjects = [];
		var opaqueObjectsLastIndex = - 1;
		var transparentObjects = [];
		var transparentObjectsLastIndex = - 1;
	
		var morphInfluences = new Float32Array( 8 );
	
		var sprites = [];
		var lensFlares = [];
	
		// public properties
	
		this.domElement = _canvas;
		this.context = null;
	
		// clearing
	
		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;
	
		// scene graph
	
		this.sortObjects = true;
	
		// physically based shading
	
		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;
	
		// morphs
	
		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;
	
		// flags
	
		this.autoScaleCubemaps = true;
	
		// internal properties
	
		var _this = this,
	
		// internal state cache
	
		_currentProgram = null,
		_currentRenderTarget = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',
		_currentCamera = null,
	
		_currentScissor = new THREE.Vector4(),
		_currentScissorTest = null,
	
		_currentViewport = new THREE.Vector4(),
	
		//
	
		_usedTextureUnits = 0,
	
		//
	
		_clearColor = new THREE.Color( 0x000000 ),
		_clearAlpha = 0,
	
		_width = _canvas.width,
		_height = _canvas.height,
	
		_pixelRatio = 1,
	
		_scissor = new THREE.Vector4( 0, 0, _width, _height ),
		_scissorTest = false,
	
		_viewport = new THREE.Vector4( 0, 0, _width, _height ),
	
		// frustum
	
		_frustum = new THREE.Frustum(),
	
		// camera matrices cache
	
		_projScreenMatrix = new THREE.Matrix4(),
	
		_vector3 = new THREE.Vector3(),
	
		// light arrays cache
	
		_lights = {
	
			hash: '',
	
			ambient: [ 0, 0, 0 ],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],
	
			shadows: [],
			shadowsPointLight: 0
	
		},
	
		// info
	
		_infoMemory = {
	
			geometries: 0,
			textures: 0
	
		},
	
		_infoRender = {
	
			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0
	
		};
	
		this.info = {
	
			render: _infoRender,
			memory: _infoMemory,
			programs: null
	
		};
	
	
		// initialize
	
		var _gl;
	
		try {
	
			var attributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};
	
			_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );
	
			if ( _gl === null ) {
	
				if ( _canvas.getContext( 'webgl' ) !== null ) {
	
					throw 'Error creating WebGL context with your selected attributes.';
	
				} else {
	
					throw 'Error creating WebGL context.';
	
				}
	
			}
	
			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
	
		} catch ( error ) {
	
			console.error( 'THREE.WebGLRenderer: ' + error );
	
		}
	
		var extensions = new THREE.WebGLExtensions( _gl );
	
		extensions.get( 'OES_texture_float' );
		extensions.get( 'OES_texture_float_linear' );
		extensions.get( 'OES_texture_half_float' );
		extensions.get( 'OES_texture_half_float_linear' );
		extensions.get( 'OES_standard_derivatives' );
		extensions.get( 'ANGLE_instanced_arrays' );
	
		if ( extensions.get( 'OES_element_index_uint' ) ) {
	
			THREE.BufferGeometry.MaxIndex = 4294967296;
	
		}
	
		var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );
	
		var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
		var properties = new THREE.WebGLProperties();
		var objects = new THREE.WebGLObjects( _gl, properties, this.info );
		var programCache = new THREE.WebGLPrograms( this, capabilities );
		var lightCache = new THREE.WebGLLights();
	
		this.info.programs = programCache.programs;
	
		var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
		var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );
	
		//
	
		function getTargetPixelRatio() {
	
			return _currentRenderTarget === null ? _pixelRatio : 1;
	
		}
	
		function glClearColor( r, g, b, a ) {
	
			if ( _premultipliedAlpha === true ) {
	
				r *= a; g *= a; b *= a;
	
			}
	
			state.clearColor( r, g, b, a );
	
		}
	
		function setDefaultGLState() {
	
			state.init();
	
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		}
	
		function resetGLState() {
	
			_currentProgram = null;
			_currentCamera = null;
	
			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
	
			state.reset();
	
		}
	
		setDefaultGLState();
	
		this.context = _gl;
		this.capabilities = capabilities;
		this.extensions = extensions;
		this.properties = properties;
		this.state = state;
	
		// shadow map
	
		var shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );
	
		this.shadowMap = shadowMap;
	
	
		// Plugins
	
		var spritePlugin = new THREE.SpritePlugin( this, sprites );
		var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );
	
		// API
	
		this.getContext = function () {
	
			return _gl;
	
		};
	
		this.getContextAttributes = function () {
	
			return _gl.getContextAttributes();
	
		};
	
		this.forceContextLoss = function () {
	
			extensions.get( 'WEBGL_lose_context' ).loseContext();
	
		};
	
		this.getMaxAnisotropy = ( function () {
	
			var value;
	
			return function getMaxAnisotropy() {
	
				if ( value !== undefined ) return value;
	
				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
				if ( extension !== null ) {
	
					value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
	
				} else {
	
					value = 0;
	
				}
	
				return value;
	
			};
	
		} )();
	
		this.getPrecision = function () {
	
			return capabilities.precision;
	
		};
	
		this.getPixelRatio = function () {
	
			return _pixelRatio;
	
		};
	
		this.setPixelRatio = function ( value ) {
	
			if ( value === undefined ) return;
	
			_pixelRatio = value;
	
			this.setSize( _viewport.z, _viewport.w, false );
	
		};
	
		this.getSize = function () {
	
			return {
				width: _width,
				height: _height
			};
	
		};
	
		this.setSize = function ( width, height, updateStyle ) {
	
			_width = width;
			_height = height;
	
			_canvas.width = width * _pixelRatio;
			_canvas.height = height * _pixelRatio;
	
			if ( updateStyle !== false ) {
	
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
	
			}
	
			this.setViewport( 0, 0, width, height );
	
		};
	
		this.setViewport = function ( x, y, width, height ) {
	
			state.viewport( _viewport.set( x, y, width, height ) );
	
		};
	
		this.setScissor = function ( x, y, width, height ) {
	
			state.scissor( _scissor.set( x, y, width, height ) );
	
		};
	
		this.setScissorTest = function ( boolean ) {
	
			state.setScissorTest( _scissorTest = boolean );
	
		};
	
		// Clearing
	
		this.getClearColor = function () {
	
			return _clearColor;
	
		};
	
		this.setClearColor = function ( color, alpha ) {
	
			_clearColor.set( color );
	
			_clearAlpha = alpha !== undefined ? alpha : 1;
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		this.getClearAlpha = function () {
	
			return _clearAlpha;
	
		};
	
		this.setClearAlpha = function ( alpha ) {
	
			_clearAlpha = alpha;
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		this.clear = function ( color, depth, stencil ) {
	
			var bits = 0;
	
			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;
	
			_gl.clear( bits );
	
		};
	
		this.clearColor = function () {
	
			this.clear( true, false, false );
	
		};
	
		this.clearDepth = function () {
	
			this.clear( false, true, false );
	
		};
	
		this.clearStencil = function () {
	
			this.clear( false, false, true );
	
		};
	
		this.clearTarget = function ( renderTarget, color, depth, stencil ) {
	
			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );
	
		};
	
		// Reset
	
		this.resetGLState = resetGLState;
	
		this.dispose = function() {
	
			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
	
		};
	
		// Events
	
		function onContextLost( event ) {
	
			event.preventDefault();
	
			resetGLState();
			setDefaultGLState();
	
			properties.clear();
	
		}
	
		function onTextureDispose( event ) {
	
			var texture = event.target;
	
			texture.removeEventListener( 'dispose', onTextureDispose );
	
			deallocateTexture( texture );
	
			_infoMemory.textures --;
	
	
		}
	
		function onRenderTargetDispose( event ) {
	
			var renderTarget = event.target;
	
			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
	
			deallocateRenderTarget( renderTarget );
	
			_infoMemory.textures --;
	
		}
	
		function onMaterialDispose( event ) {
	
			var material = event.target;
	
			material.removeEventListener( 'dispose', onMaterialDispose );
	
			deallocateMaterial( material );
	
		}
	
		// Buffer deallocation
	
		function deallocateTexture( texture ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.image && textureProperties.__image__webglTextureCube ) {
	
				// cube texture
	
				_gl.deleteTexture( textureProperties.__image__webglTextureCube );
	
			} else {
	
				// 2D texture
	
				if ( textureProperties.__webglInit === undefined ) return;
	
				_gl.deleteTexture( textureProperties.__webglTexture );
	
			}
	
			// remove all webgl properties
			properties.delete( texture );
	
		}
	
		function deallocateRenderTarget( renderTarget ) {
	
			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );
	
			if ( ! renderTarget || textureProperties.__webglTexture === undefined ) return;
	
			_gl.deleteTexture( textureProperties.__webglTexture );
	
			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {
	
				for ( var i = 0; i < 6; i ++ ) {
	
					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					_gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );
	
				}
	
			} else {
	
				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				_gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
	
			}
	
			properties.delete( renderTarget.texture );
			properties.delete( renderTarget );
	
		}
	
		function deallocateMaterial( material ) {
	
			releaseMaterialProgramReference( material );
	
			properties.delete( material );
	
		}
	
	
		function releaseMaterialProgramReference( material ) {
	
			var programInfo = properties.get( material ).program;
	
			material.program = undefined;
	
			if ( programInfo !== undefined ) {
	
				programCache.releaseProgram( programInfo );
	
			}
	
		}
	
		// Buffer rendering
	
		this.renderBufferImmediate = function ( object, program, material ) {
	
			state.initAttributes();
	
			var buffers = properties.get( object );
	
			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();
	
			var attributes = program.getAttributes();
	
			if ( object.hasPositions ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasNormals ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
	
				if ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.shading === THREE.FlatShading ) {
	
					for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {
	
						var array = object.normalArray;
	
						var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
						var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
						var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;
	
						array[ i + 0 ] = nx;
						array[ i + 1 ] = ny;
						array[ i + 2 ] = nz;
	
						array[ i + 3 ] = nx;
						array[ i + 4 ] = ny;
						array[ i + 5 ] = nz;
	
						array[ i + 6 ] = nx;
						array[ i + 7 ] = ny;
						array[ i + 8 ] = nz;
	
					}
	
				}
	
				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.normal );
	
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasUvs && material.map ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.uv );
	
				_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.color );
	
				_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			state.disableUnusedAttributes();
	
			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );
	
			object.count = 0;
	
		};
	
		this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {
	
			setMaterial( material );
	
			var program = setProgram( camera, fog, material, object );
	
			var updateBuffers = false;
			var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
	
			if ( geometryProgram !== _currentGeometryProgram ) {
	
				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;
	
			}
	
			// morph targets
	
			var morphTargetInfluences = object.morphTargetInfluences;
	
			if ( morphTargetInfluences !== undefined ) {
	
				var activeInfluences = [];
	
				for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {
	
					var influence = morphTargetInfluences[ i ];
					activeInfluences.push( [ influence, i ] );
	
				}
	
				activeInfluences.sort( absNumericalSort );
	
				if ( activeInfluences.length > 8 ) {
	
					activeInfluences.length = 8;
	
				}
	
				var morphAttributes = geometry.morphAttributes;
	
				for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {
	
					var influence = activeInfluences[ i ];
					morphInfluences[ i ] = influence[ 0 ];
	
					if ( influence[ 0 ] !== 0 ) {
	
						var index = influence[ 1 ];
	
						if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
						if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );
	
					} else {
	
						if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
						if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );
	
					}
	
				}
	
				var uniforms = program.getUniforms();
	
				if ( uniforms.morphTargetInfluences !== null ) {
	
					_gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );
	
				}
	
				updateBuffers = true;
	
			}
	
			//
	
			var index = geometry.index;
			var position = geometry.attributes.position;
	
			if ( material.wireframe === true ) {
	
				index = objects.getWireframeAttribute( geometry );
	
			}
	
			var renderer;
	
			if ( index !== null ) {
	
				renderer = indexedBufferRenderer;
				renderer.setIndex( index );
	
			} else {
	
				renderer = bufferRenderer;
	
			}
	
			if ( updateBuffers ) {
	
				setupVertexAttributes( material, program, geometry );
	
				if ( index !== null ) {
	
					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );
	
				}
	
			}
	
			//
	
			var dataStart = 0;
			var dataCount = Infinity;
	
			if ( index !== null ) {
	
				dataCount = index.count;
	
			} else if ( position !== undefined ) {
	
				dataCount = position.count;
	
			}
	
			var rangeStart = geometry.drawRange.start;
			var rangeCount = geometry.drawRange.count;
	
			var groupStart = group !== null ? group.start : 0;
			var groupCount = group !== null ? group.count : Infinity;
	
			var drawStart = Math.max( dataStart, rangeStart, groupStart );
			var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;
	
			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );
	
			//
	
			if ( object instanceof THREE.Mesh ) {
	
				if ( material.wireframe === true ) {
	
					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( _gl.LINES );
	
				} else {
	
					switch ( object.drawMode ) {
	
						case THREE.TrianglesDrawMode:
							renderer.setMode( _gl.TRIANGLES );
							break;
	
						case THREE.TriangleStripDrawMode:
							renderer.setMode( _gl.TRIANGLE_STRIP );
							break;
	
						case THREE.TriangleFanDrawMode:
							renderer.setMode( _gl.TRIANGLE_FAN );
							break;
	
					}
	
				}
	
	
			} else if ( object instanceof THREE.Line ) {
	
				var lineWidth = material.linewidth;
	
				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material
	
				state.setLineWidth( lineWidth * getTargetPixelRatio() );
	
				if ( object instanceof THREE.LineSegments ) {
	
					renderer.setMode( _gl.LINES );
	
				} else {
	
					renderer.setMode( _gl.LINE_STRIP );
	
				}
	
			} else if ( object instanceof THREE.Points ) {
	
				renderer.setMode( _gl.POINTS );
	
			}
	
			if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {
	
				renderer.renderInstances( geometry, drawStart, drawCount );
	
			} else {
	
				renderer.render( drawStart, drawCount );
	
			}
	
		};
	
		function setupVertexAttributes( material, program, geometry, startIndex ) {
	
			var extension;
	
			if ( geometry instanceof THREE.InstancedBufferGeometry ) {
	
				extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
			}
	
			if ( startIndex === undefined ) startIndex = 0;
	
			state.initAttributes();
	
			var geometryAttributes = geometry.attributes;
	
			var programAttributes = program.getAttributes();
	
			var materialDefaultAttributeValues = material.defaultAttributeValues;
	
			for ( var name in programAttributes ) {
	
				var programAttribute = programAttributes[ name ];
	
				if ( programAttribute >= 0 ) {
	
					var geometryAttribute = geometryAttributes[ name ];
	
					if ( geometryAttribute !== undefined ) {
	
						var size = geometryAttribute.itemSize;
						var buffer = objects.getAttributeBuffer( geometryAttribute );
	
						if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {
	
							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;
	
							if ( data instanceof THREE.InstancedInterleavedBuffer ) {
	
								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );
	
								if ( geometry.maxInstancedCount === undefined ) {
	
									geometry.maxInstancedCount = data.meshPerAttribute * data.count;
	
								}
	
							} else {
	
								state.enableAttribute( programAttribute );
	
							}
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );
	
						} else {
	
							if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {
	
								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );
	
								if ( geometry.maxInstancedCount === undefined ) {
	
									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
	
								}
	
							} else {
	
								state.enableAttribute( programAttribute );
	
							}
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32
	
						}
	
					} else if ( materialDefaultAttributeValues !== undefined ) {
	
						var value = materialDefaultAttributeValues[ name ];
	
						if ( value !== undefined ) {
	
							switch ( value.length ) {
	
								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;
	
								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;
	
								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;
	
								default:
									_gl.vertexAttrib1fv( programAttribute, value );
	
							}
	
						}
	
					}
	
				}
	
			}
	
			state.disableUnusedAttributes();
	
		}
	
		// Sorting
	
		function absNumericalSort( a, b ) {
	
			return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );
	
		}
	
		function painterSortStable ( a, b ) {
	
			if ( a.object.renderOrder !== b.object.renderOrder ) {
	
				return a.object.renderOrder - b.object.renderOrder;
	
			} else if ( a.material.id !== b.material.id ) {
	
				return a.material.id - b.material.id;
	
			} else if ( a.z !== b.z ) {
	
				return a.z - b.z;
	
			} else {
	
				return a.id - b.id;
	
			}
	
		}
	
		function reversePainterSortStable ( a, b ) {
	
			if ( a.object.renderOrder !== b.object.renderOrder ) {
	
				return a.object.renderOrder - b.object.renderOrder;
	
			} if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return a.id - b.id;
	
			}
	
		}
	
		// Rendering
	
		this.render = function ( scene, camera, renderTarget, forceClear ) {
	
			if ( camera instanceof THREE.Camera === false ) {
	
				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;
	
			}
	
			var fog = scene.fog;
	
			// reset caching for this frame
	
			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;
	
			// update scene graph
	
			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
			// update camera matrices and frustum
	
			if ( camera.parent === null ) camera.updateMatrixWorld();
	
			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );
	
			lights.length = 0;
	
			opaqueObjectsLastIndex = - 1;
			transparentObjectsLastIndex = - 1;
	
			sprites.length = 0;
			lensFlares.length = 0;
	
			projectObject( scene, camera );
	
			opaqueObjects.length = opaqueObjectsLastIndex + 1;
			transparentObjects.length = transparentObjectsLastIndex + 1;
	
			if ( _this.sortObjects === true ) {
	
				opaqueObjects.sort( painterSortStable );
				transparentObjects.sort( reversePainterSortStable );
	
			}
	
			setupLights( lights, camera );
	
			//
	
			shadowMap.render( scene, camera );
	
			//
	
			_infoRender.calls = 0;
			_infoRender.vertices = 0;
			_infoRender.faces = 0;
			_infoRender.points = 0;
	
			if ( renderTarget === undefined ) {
	
				renderTarget = null;
	
			}
	
			this.setRenderTarget( renderTarget );
	
			if ( this.autoClear || forceClear ) {
	
				this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );
	
			}
	
			//
	
			if ( scene.overrideMaterial ) {
	
				var overrideMaterial = scene.overrideMaterial;
	
				renderObjects( opaqueObjects, camera, fog, overrideMaterial );
				renderObjects( transparentObjects, camera, fog, overrideMaterial );
	
			} else {
	
				// opaque pass (front-to-back order)
	
				state.setBlending( THREE.NoBlending );
				renderObjects( opaqueObjects, camera, fog );
	
				// transparent pass (back-to-front order)
	
				renderObjects( transparentObjects, camera, fog );
	
			}
	
			// custom render plugins (post pass)
	
			spritePlugin.render( scene, camera );
			lensFlarePlugin.render( scene, camera, _currentViewport );
	
			// Generate mipmap if we're using any kind of mipmap filtering
	
			if ( renderTarget ) {
	
				var texture = renderTarget.texture;
	
				if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
						texture.minFilter !== THREE.NearestFilter &&
						texture.minFilter !== THREE.LinearFilter ) {
	
					updateRenderTargetMipmap( renderTarget );
	
				}
	
			}
	
			// Ensure depth buffer writing is enabled so it can be cleared on next render
	
			state.setDepthTest( true );
			state.setDepthWrite( true );
			state.setColorWrite( true );
	
			// _gl.finish();
	
		};
	
		function pushRenderItem( object, geometry, material, z, group ) {
	
			var array, index;
	
			// allocate the next position in the appropriate array
	
			if ( material.transparent ) {
	
				array = transparentObjects;
				index = ++ transparentObjectsLastIndex;
	
			} else {
	
				array = opaqueObjects;
				index = ++ opaqueObjectsLastIndex;
	
			}
	
			// recycle existing render item or grow the array
	
			var renderItem = array[ index ];
	
			if ( renderItem !== undefined ) {
	
				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.z = _vector3.z;
				renderItem.group = group;
	
			} else {
	
				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					z: _vector3.z,
					group: group
				};
	
				// assert( index === array.length );
				array.push( renderItem );
	
			}
	
		}
	
		function projectObject( object, camera ) {
	
			if ( object.visible === false ) return;
	
			if ( object.layers.test( camera.layers ) ) {
	
				if ( object instanceof THREE.Light ) {
	
					lights.push( object );
	
				} else if ( object instanceof THREE.Sprite ) {
	
					if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {
	
						sprites.push( object );
	
					}
	
				} else if ( object instanceof THREE.LensFlare ) {
	
					lensFlares.push( object );
	
				} else if ( object instanceof THREE.ImmediateRenderObject ) {
	
					if ( _this.sortObjects === true ) {
	
						_vector3.setFromMatrixPosition( object.matrixWorld );
						_vector3.applyProjection( _projScreenMatrix );
	
					}
	
					pushRenderItem( object, null, object.material, _vector3.z, null );
	
				} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {
	
					if ( object instanceof THREE.SkinnedMesh ) {
	
						object.skeleton.update();
	
					}
	
					if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {
	
						var material = object.material;
	
						if ( material.visible === true ) {
	
							if ( _this.sortObjects === true ) {
	
								_vector3.setFromMatrixPosition( object.matrixWorld );
								_vector3.applyProjection( _projScreenMatrix );
	
							}
	
							var geometry = objects.update( object );
	
							if ( material instanceof THREE.MultiMaterial ) {
	
								var groups = geometry.groups;
								var materials = material.materials;
	
								for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
									var group = groups[ i ];
									var groupMaterial = materials[ group.materialIndex ];
	
									if ( groupMaterial.visible === true ) {
	
										pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );
	
									}
	
								}
	
							} else {
	
								pushRenderItem( object, geometry, material, _vector3.z, null );
	
							}
	
						}
	
					}
	
				}
	
			}
	
			var children = object.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				projectObject( children[ i ], camera );
	
			}
	
		}
	
		function renderObjects( renderList, camera, fog, overrideMaterial ) {
	
			for ( var i = 0, l = renderList.length; i < l; i ++ ) {
	
				var renderItem = renderList[ i ];
	
				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;
	
				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
	
				if ( object instanceof THREE.ImmediateRenderObject ) {
	
					setMaterial( material );
	
					var program = setProgram( camera, fog, material, object );
	
					_currentGeometryProgram = '';
	
					object.render( function ( object ) {
	
						_this.renderBufferImmediate( object, program, material );
	
					} );
	
				} else {
	
					_this.renderBufferDirect( camera, fog, geometry, material, object, group );
	
				}
	
			}
	
		}
	
		function initMaterial( material, fog, object ) {
	
			var materialProperties = properties.get( material );
	
			var parameters = programCache.getParameters( material, _lights, fog, object );
			var code = programCache.getProgramCode( material, parameters );
	
			var program = materialProperties.program;
			var programChange = true;
	
			if ( program === undefined ) {
	
				// new material
				material.addEventListener( 'dispose', onMaterialDispose );
	
			} else if ( program.code !== code ) {
	
				// changed glsl or parameters
				releaseMaterialProgramReference( material );
	
			} else if ( parameters.shaderID !== undefined ) {
	
				// same glsl and uniform list
				return;
	
			} else {
	
				// only rebuild uniform list
				programChange = false;
	
			}
	
			if ( programChange ) {
	
				if ( parameters.shaderID ) {
	
					var shader = THREE.ShaderLib[ parameters.shaderID ];
	
					materialProperties.__webglShader = {
						name: material.type,
						uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};
	
				} else {
	
					materialProperties.__webglShader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};
	
				}
	
				material.__webglShader = materialProperties.__webglShader;
	
				program = programCache.acquireProgram( material, parameters, code );
	
				materialProperties.program = program;
				material.program = program;
	
			}
	
			var attributes = program.getAttributes();
	
			if ( material.morphTargets ) {
	
				material.numSupportedMorphTargets = 0;
	
				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {
	
					if ( attributes[ 'morphTarget' + i ] >= 0 ) {
	
						material.numSupportedMorphTargets ++;
	
					}
	
				}
	
			}
	
			if ( material.morphNormals ) {
	
				material.numSupportedMorphNormals = 0;
	
				for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {
	
					if ( attributes[ 'morphNormal' + i ] >= 0 ) {
	
						material.numSupportedMorphNormals ++;
	
					}
	
				}
	
			}
	
			materialProperties.uniformsList = [];
	
			var uniforms = materialProperties.__webglShader.uniforms,
				uniformLocations = materialProperties.program.getUniforms();
	
			for ( var u in uniforms ) {
	
				var location = uniformLocations[ u ];
	
				if ( location ) {
	
					materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );
	
				}
	
			}
	
			if ( material instanceof THREE.MeshPhongMaterial ||
					material instanceof THREE.MeshLambertMaterial ||
					material instanceof THREE.MeshStandardMaterial ||
					material.lights ) {
	
				// store the light setup it was created for
	
				materialProperties.lightsHash = _lights.hash;
	
				// wire up the material to this renderer's lighting state
	
				uniforms.ambientLightColor.value = _lights.ambient;
				uniforms.directionalLights.value = _lights.directional;
				uniforms.spotLights.value = _lights.spot;
				uniforms.pointLights.value = _lights.point;
				uniforms.hemisphereLights.value = _lights.hemi;
	
				uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
				uniforms.spotShadowMap.value = _lights.spotShadowMap;
				uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
				uniforms.pointShadowMap.value = _lights.pointShadowMap;
				uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
	
			}
	
			// detect dynamic uniforms
	
			materialProperties.hasDynamicUniforms = false;
	
			for ( var j = 0, jl = materialProperties.uniformsList.length; j < jl; j ++ ) {
	
				var uniform = materialProperties.uniformsList[ j ][ 0 ];
	
				if ( uniform.dynamic === true ) {
	
					materialProperties.hasDynamicUniforms = true;
					break;
	
				}
	
			}
	
		}
	
		function setMaterial( material ) {
	
			setMaterialFaces( material );
	
			if ( material.transparent === true ) {
	
				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );
	
			} else {
	
				state.setBlending( THREE.NoBlending );
	
			}
	
			state.setDepthFunc( material.depthFunc );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );
			state.setColorWrite( material.colorWrite );
			state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
		}
	
		function setMaterialFaces( material ) {
	
			material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
			state.setFlipSided( material.side === THREE.BackSide );
	
		}
	
		function setProgram( camera, fog, material, object ) {
	
			_usedTextureUnits = 0;
	
			var materialProperties = properties.get( material );
	
			if ( materialProperties.program === undefined ) {
	
				material.needsUpdate = true;
	
			}
	
			if ( materialProperties.lightsHash !== undefined &&
				materialProperties.lightsHash !== _lights.hash ) {
	
				material.needsUpdate = true;
	
			}
	
			if ( material.needsUpdate ) {
	
				initMaterial( material, fog, object );
				material.needsUpdate = false;
	
			}
	
			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;
	
			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.__webglShader.uniforms;
	
			if ( program.id !== _currentProgram ) {
	
				_gl.useProgram( program.program );
				_currentProgram = program.id;
	
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
	
			}
	
			if ( material.id !== _currentMaterialId ) {
	
				_currentMaterialId = material.id;
	
				refreshMaterial = true;
	
			}
	
			if ( refreshProgram || camera !== _currentCamera ) {
	
				_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
				if ( capabilities.logarithmicDepthBuffer ) {
	
					_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
	
				}
	
	
				if ( camera !== _currentCamera ) {
	
					_currentCamera = camera;
	
					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:
	
					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done
	
				}
	
				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)
	
				if ( material instanceof THREE.ShaderMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshStandardMaterial ||
					 material.envMap ) {
	
					if ( p_uniforms.cameraPosition !== undefined ) {
	
						_vector3.setFromMatrixPosition( camera.matrixWorld );
						_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );
	
					}
	
				}
	
				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshStandardMaterial ||
					 material instanceof THREE.ShaderMaterial ||
					 material.skinning ) {
	
					if ( p_uniforms.viewMatrix !== undefined ) {
	
						_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );
	
					}
	
				}
	
			}
	
			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen
	
			if ( material.skinning ) {
	
				if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {
	
					_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );
	
				}
	
				if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {
	
					_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );
	
				}
	
				if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {
	
					if ( p_uniforms.boneTexture !== undefined ) {
	
						var textureUnit = getTextureUnit();
	
						_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
						_this.setTexture( object.skeleton.boneTexture, textureUnit );
	
					}
	
					if ( p_uniforms.boneTextureWidth !== undefined ) {
	
						_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );
	
					}
	
					if ( p_uniforms.boneTextureHeight !== undefined ) {
	
						_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );
	
					}
	
				} else if ( object.skeleton && object.skeleton.boneMatrices ) {
	
					if ( p_uniforms.boneGlobalMatrices !== undefined ) {
	
						_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );
	
					}
	
				}
	
			}
	
			if ( refreshMaterial ) {
	
				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshStandardMaterial ||
					 material.lights ) {
	
					// the current material requires lighting info
	
					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required
	
					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );
	
				}
	
				// refresh uniforms common to several materials
	
				if ( fog && material.fog ) {
	
					refreshUniformsFog( m_uniforms, fog );
	
				}
	
				if ( material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshStandardMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
	
				}
	
				// refresh single material specific uniforms
	
				if ( material instanceof THREE.LineBasicMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
	
				} else if ( material instanceof THREE.LineDashedMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
					refreshUniformsDash( m_uniforms, material );
	
				} else if ( material instanceof THREE.PointsMaterial ) {
	
					refreshUniformsPoints( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshLambertMaterial ) {
	
					refreshUniformsLambert( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshPhongMaterial ) {
	
					refreshUniformsPhong( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshStandardMaterial ) {
	
					refreshUniformsStandard( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshDepthMaterial ) {
	
					m_uniforms.mNear.value = camera.near;
					m_uniforms.mFar.value = camera.far;
					m_uniforms.opacity.value = material.opacity;
	
				} else if ( material instanceof THREE.MeshNormalMaterial ) {
	
					m_uniforms.opacity.value = material.opacity;
	
				}
	
				// load common uniforms
	
				loadUniformsGeneric( materialProperties.uniformsList );
	
			}
	
			loadUniformsMatrices( p_uniforms, object );
	
			if ( p_uniforms.modelMatrix !== undefined ) {
	
				_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );
	
			}
	
			if ( materialProperties.hasDynamicUniforms === true ) {
	
				updateDynamicUniforms( materialProperties.uniformsList, object, camera );
	
			}
	
			return program;
	
		}
	
		function updateDynamicUniforms ( uniforms, object, camera ) {
	
			var dynamicUniforms = [];
	
			for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {
	
				var uniform = uniforms[ j ][ 0 ];
				var onUpdateCallback = uniform.onUpdateCallback;
	
				if ( onUpdateCallback !== undefined ) {
	
					onUpdateCallback.bind( uniform )( object, camera );
					dynamicUniforms.push( uniforms[ j ] );
	
				}
	
			}
	
			loadUniformsGeneric( dynamicUniforms );
	
		}
	
		// Uniforms (refresh uniforms objects)
	
		function refreshUniformsCommon ( uniforms, material ) {
	
			uniforms.opacity.value = material.opacity;
	
			uniforms.diffuse.value = material.color;
	
			if ( material.emissive ) {
	
				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );
	
			}
	
			uniforms.map.value = material.map;
			uniforms.specularMap.value = material.specularMap;
			uniforms.alphaMap.value = material.alphaMap;
	
			if ( material.aoMap ) {
	
				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
	
			}
	
			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map
	
			var uvScaleMap;
	
			if ( material.map ) {
	
				uvScaleMap = material.map;
	
			} else if ( material.specularMap ) {
	
				uvScaleMap = material.specularMap;
	
			} else if ( material.displacementMap ) {
	
				uvScaleMap = material.displacementMap;
	
			} else if ( material.normalMap ) {
	
				uvScaleMap = material.normalMap;
	
			} else if ( material.bumpMap ) {
	
				uvScaleMap = material.bumpMap;
	
			} else if ( material.roughnessMap ) {
	
				uvScaleMap = material.roughnessMap;
	
			} else if ( material.metalnessMap ) {
	
				uvScaleMap = material.metalnessMap;
	
			} else if ( material.alphaMap ) {
	
				uvScaleMap = material.alphaMap;
	
			} else if ( material.emissiveMap ) {
	
				uvScaleMap = material.emissiveMap;
	
			}
	
			if ( uvScaleMap !== undefined ) {
	
				if ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {
	
					uvScaleMap = uvScaleMap.texture;
	
				}
	
				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;
	
				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
			}
	
			uniforms.envMap.value = material.envMap;
			uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;
	
			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;
	
		}
	
		function refreshUniformsLine ( uniforms, material ) {
	
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
	
		}
	
		function refreshUniformsDash ( uniforms, material ) {
	
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
	
		}
	
		function refreshUniformsPoints ( uniforms, material ) {
	
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _canvas.clientHeight / 2.0; // TODO: Cache this.
	
			uniforms.map.value = material.map;
	
			if ( material.map !== null ) {
	
				var offset = material.map.offset;
				var repeat = material.map.repeat;
	
				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
			}
	
		}
	
		function refreshUniformsFog ( uniforms, fog ) {
	
			uniforms.fogColor.value = fog.color;
	
			if ( fog instanceof THREE.Fog ) {
	
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
	
			} else if ( fog instanceof THREE.FogExp2 ) {
	
				uniforms.fogDensity.value = fog.density;
	
			}
	
		}
	
		function refreshUniformsLambert ( uniforms, material ) {
	
			if ( material.lightMap ) {
	
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
			}
	
			if ( material.emissiveMap ) {
	
				uniforms.emissiveMap.value = material.emissiveMap;
	
			}
	
		}
	
		function refreshUniformsPhong ( uniforms, material ) {
	
			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
	
			if ( material.lightMap ) {
	
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
			}
	
			if ( material.emissiveMap ) {
	
				uniforms.emissiveMap.value = material.emissiveMap;
	
			}
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
	
			}
	
			if ( material.displacementMap ) {
	
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
	
			}
	
		}
	
		function refreshUniformsStandard ( uniforms, material ) {
	
			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;
	
			if ( material.roughnessMap ) {
	
				uniforms.roughnessMap.value = material.roughnessMap;
	
			}
	
			if ( material.metalnessMap ) {
	
				uniforms.metalnessMap.value = material.metalnessMap;
	
			}
	
			if ( material.lightMap ) {
	
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
			}
	
			if ( material.emissiveMap ) {
	
				uniforms.emissiveMap.value = material.emissiveMap;
	
			}
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
	
			}
	
			if ( material.displacementMap ) {
	
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
	
			}
	
			if ( material.envMap ) {
	
				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;
	
			}
	
		}
	
		// If uniforms are marked as clean, they don't need to be loaded to the GPU.
	
		function markUniformsLightsNeedsUpdate ( uniforms, value ) {
	
			uniforms.ambientLightColor.needsUpdate = value;
	
			uniforms.directionalLights.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
	
		}
	
		// Uniforms (load to GPU)
	
		function loadUniformsMatrices ( uniforms, object ) {
	
			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );
	
			if ( uniforms.normalMatrix ) {
	
				_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );
	
			}
	
		}
	
		function getTextureUnit() {
	
			var textureUnit = _usedTextureUnits;
	
			if ( textureUnit >= capabilities.maxTextures ) {
	
				console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );
	
			}
	
			_usedTextureUnits += 1;
	
			return textureUnit;
	
		}
	
		function loadUniformsGeneric ( uniforms ) {
	
			var texture, textureUnit;
	
			for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {
	
				var uniform = uniforms[ j ][ 0 ];
	
				// needsUpdate property is not added to all uniforms.
				if ( uniform.needsUpdate === false ) continue;
	
				var type = uniform.type;
				var value = uniform.value;
				var location = uniforms[ j ][ 1 ];
	
				switch ( type ) {
	
					case '1i':
						_gl.uniform1i( location, value );
						break;
	
					case '1f':
						_gl.uniform1f( location, value );
						break;
	
					case '2f':
						_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
						break;
	
					case '3f':
						_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
						break;
	
					case '4f':
						_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
						break;
	
					case '1iv':
						_gl.uniform1iv( location, value );
						break;
	
					case '3iv':
						_gl.uniform3iv( location, value );
						break;
	
					case '1fv':
						_gl.uniform1fv( location, value );
						break;
	
					case '2fv':
						_gl.uniform2fv( location, value );
						break;
	
					case '3fv':
						_gl.uniform3fv( location, value );
						break;
	
					case '4fv':
						_gl.uniform4fv( location, value );
						break;
	
					case 'Matrix2fv':
						_gl.uniformMatrix2fv( location, false, value );
						break;
	
					case 'Matrix3fv':
						_gl.uniformMatrix3fv( location, false, value );
						break;
	
					case 'Matrix4fv':
						_gl.uniformMatrix4fv( location, false, value );
						break;
	
					//
	
					case 'i':
	
						// single integer
						_gl.uniform1i( location, value );
	
						break;
	
					case 'f':
	
						// single float
						_gl.uniform1f( location, value );
	
						break;
	
					case 'v2':
	
						// single THREE.Vector2
						_gl.uniform2f( location, value.x, value.y );
	
						break;
	
					case 'v3':
	
						// single THREE.Vector3
						_gl.uniform3f( location, value.x, value.y, value.z );
	
						break;
	
					case 'v4':
	
						// single THREE.Vector4
						_gl.uniform4f( location, value.x, value.y, value.z, value.w );
	
						break;
	
					case 'c':
	
						// single THREE.Color
						_gl.uniform3f( location, value.r, value.g, value.b );
	
						break;
	
					/*
					case 's':
	
						// TODO: Optimize this.
						for( var propertyName in uniform.properties ) {
	
							var property = uniform.properties[ propertyName ];
							var locationProperty =  location[ propertyName ];
							var valueProperty = value[ propertyName ];
	
							switch( property.type ) {
								case 'i':
									_gl.uniform1i( locationProperty, valueProperty );
									break;
								case 'f':
									_gl.uniform1f( locationProperty, valueProperty );
									break;
								case 'v2':
									_gl.uniform2f( locationProperty, valueProperty.x, valueProperty.y );
									break;
								case 'v3':
									_gl.uniform3f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z );
									break;
								case 'v4':
									_gl.uniform4f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z, valueProperty.w );
									break;
								case 'c':
									_gl.uniform3f( locationProperty, valueProperty.r, valueProperty.g, valueProperty.b );
									break;
							};
	
						}
	
						break;
					*/
	
					case 'sa':
	
						// TODO: Optimize this.
						for ( var i = 0; i < value.length; i ++ ) {
	
							for ( var propertyName in uniform.properties ) {
	
								var property = uniform.properties[ propertyName ];
								var locationProperty =  location[ i ][ propertyName ];
								var valueProperty = value[ i ][ propertyName ];
	
								switch ( property.type ) {
									case 'i':
										_gl.uniform1i( locationProperty, valueProperty );
										break;
									case 'f':
										_gl.uniform1f( locationProperty, valueProperty );
										break;
									case 'v2':
										_gl.uniform2f( locationProperty, valueProperty.x, valueProperty.y );
										break;
									case 'v3':
										_gl.uniform3f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z );
										break;
									case 'v4':
										_gl.uniform4f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z, valueProperty.w );
										break;
									case 'c':
										_gl.uniform3f( locationProperty, valueProperty.r, valueProperty.g, valueProperty.b );
										break;
									case 'm4':
										_gl.uniformMatrix4fv( locationProperty, false, valueProperty.elements );
										break;
								}
	
							}
	
						}
	
						break;
	
					case 'iv1':
	
						// flat array of integers (JS or typed array)
						_gl.uniform1iv( location, value );
	
						break;
	
					case 'iv':
	
						// flat array of integers with 3 x N size (JS or typed array)
						_gl.uniform3iv( location, value );
	
						break;
	
					case 'fv1':
	
						// flat array of floats (JS or typed array)
						_gl.uniform1fv( location, value );
	
						break;
	
					case 'fv':
	
						// flat array of floats with 3 x N size (JS or typed array)
						_gl.uniform3fv( location, value );
	
						break;
	
					case 'v2v':
	
						// array of THREE.Vector2
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 2 * value.length );
	
						}
	
						for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {
	
							uniform._array[ i2 + 0 ] = value[ i ].x;
							uniform._array[ i2 + 1 ] = value[ i ].y;
	
						}
	
						_gl.uniform2fv( location, uniform._array );
	
						break;
	
					case 'v3v':
	
						// array of THREE.Vector3
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 3 * value.length );
	
						}
	
						for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {
	
							uniform._array[ i3 + 0 ] = value[ i ].x;
							uniform._array[ i3 + 1 ] = value[ i ].y;
							uniform._array[ i3 + 2 ] = value[ i ].z;
	
						}
	
						_gl.uniform3fv( location, uniform._array );
	
						break;
	
					case 'v4v':
	
						// array of THREE.Vector4
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 4 * value.length );
	
						}
	
						for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {
	
							uniform._array[ i4 + 0 ] = value[ i ].x;
							uniform._array[ i4 + 1 ] = value[ i ].y;
							uniform._array[ i4 + 2 ] = value[ i ].z;
							uniform._array[ i4 + 3 ] = value[ i ].w;
	
						}
	
						_gl.uniform4fv( location, uniform._array );
	
						break;
	
					case 'm2':
	
						// single THREE.Matrix2
						_gl.uniformMatrix2fv( location, false, value.elements );
	
						break;
	
					case 'm3':
	
						// single THREE.Matrix3
						_gl.uniformMatrix3fv( location, false, value.elements );
	
						break;
	
					case 'm3v':
	
						// array of THREE.Matrix3
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 9 * value.length );
	
						}
	
						for ( var i = 0, il = value.length; i < il; i ++ ) {
	
							value[ i ].flattenToArrayOffset( uniform._array, i * 9 );
	
						}
	
						_gl.uniformMatrix3fv( location, false, uniform._array );
	
						break;
	
					case 'm4':
	
						// single THREE.Matrix4
						_gl.uniformMatrix4fv( location, false, value.elements );
	
						break;
	
					case 'm4v':
	
						// array of THREE.Matrix4
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 16 * value.length );
	
						}
	
						for ( var i = 0, il = value.length; i < il; i ++ ) {
	
							value[ i ].flattenToArrayOffset( uniform._array, i * 16 );
	
						}
	
						_gl.uniformMatrix4fv( location, false, uniform._array );
	
						break;
	
					case 't':
	
						// single THREE.Texture (2d or cube)
	
						texture = value;
						textureUnit = getTextureUnit();
	
						_gl.uniform1i( location, textureUnit );
	
						if ( ! texture ) continue;
	
						if ( texture instanceof THREE.CubeTexture ||
							 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {
	
							// CompressedTexture can have Array in image :/
	
							setCubeTexture( texture, textureUnit );
	
						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {
	
							setCubeTextureDynamic( texture.texture, textureUnit );
	
						} else if ( texture instanceof THREE.WebGLRenderTarget ) {
	
							_this.setTexture( texture.texture, textureUnit );
	
						} else {
	
							_this.setTexture( texture, textureUnit );
	
						}
	
						break;
	
					case 'tv':
	
						// array of THREE.Texture (2d or cube)
	
						if ( uniform._array === undefined ) {
	
							uniform._array = [];
	
						}
	
						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {
	
							uniform._array[ i ] = getTextureUnit();
	
						}
	
						_gl.uniform1iv( location, uniform._array );
	
						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {
	
							texture = uniform.value[ i ];
							textureUnit = uniform._array[ i ];
	
							if ( ! texture ) continue;
	
							if ( texture instanceof THREE.CubeTexture ||
								 ( texture.image instanceof Array && texture.image.length === 6 ) ) {
	
								// CompressedTexture can have Array in image :/
	
								setCubeTexture( texture, textureUnit );
	
							} else if ( texture instanceof THREE.WebGLRenderTarget ) {
	
								_this.setTexture( texture.texture, textureUnit );
	
							} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {
	
								setCubeTextureDynamic( texture.texture, textureUnit );
	
							} else {
	
								_this.setTexture( texture, textureUnit );
	
							}
	
						}
	
						break;
	
					default:
	
						console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );
	
				}
	
			}
	
		}
	
		function setupLights ( lights, camera ) {
	
			var l, ll, light,
			r = 0, g = 0, b = 0,
			color,
			intensity,
			distance,
	
			viewMatrix = camera.matrixWorldInverse,
	
			directionalLength = 0,
			pointLength = 0,
			spotLength = 0,
			hemiLength = 0,
	
			shadowsLength = 0;
	
			_lights.shadowsPointLight = 0;
	
			for ( l = 0, ll = lights.length; l < ll; l ++ ) {
	
				light = lights[ l ];
	
				color = light.color;
				intensity = light.intensity;
				distance = light.distance;
	
				if ( light instanceof THREE.AmbientLight ) {
	
					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;
	
				} else if ( light instanceof THREE.DirectionalLight ) {
	
					var uniforms = lightCache.get( light );
	
					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( _vector3 );
					uniforms.direction.transformDirection( viewMatrix );
	
					uniforms.shadow = light.castShadow;
	
					if ( light.castShadow ) {
	
						uniforms.shadowBias = light.shadow.bias;
						uniforms.shadowRadius = light.shadow.radius;
						uniforms.shadowMapSize = light.shadow.mapSize;
	
						_lights.shadows[ shadowsLength ++ ] = light;
	
					}
	
					_lights.directionalShadowMap[ directionalLength ] = light.shadow.map;
					_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
					_lights.directional[ directionalLength ++ ] = uniforms;
	
				} else if ( light instanceof THREE.SpotLight ) {
	
					var uniforms = lightCache.get( light );
	
					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );
	
					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;
	
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( _vector3 );
					uniforms.direction.transformDirection( viewMatrix );
	
					uniforms.angleCos = Math.cos( light.angle );
					uniforms.exponent = light.exponent;
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
					uniforms.shadow = light.castShadow;
	
					if ( light.castShadow ) {
	
						uniforms.shadowBias = light.shadow.bias;
						uniforms.shadowRadius = light.shadow.radius;
						uniforms.shadowMapSize = light.shadow.mapSize;
	
						_lights.shadows[ shadowsLength ++ ] = light;
	
					}
	
					_lights.spotShadowMap[ spotLength ] = light.shadow.map;
					_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
					_lights.spot[ spotLength ++ ] = uniforms;
	
				} else if ( light instanceof THREE.PointLight ) {
	
					var uniforms = lightCache.get( light );
	
					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );
	
					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
					uniforms.shadow = light.castShadow;
	
					if ( light.castShadow ) {
	
						uniforms.shadowBias = light.shadow.bias;
						uniforms.shadowRadius = light.shadow.radius;
						uniforms.shadowMapSize = light.shadow.mapSize;
	
						_lights.shadows[ shadowsLength ++ ] = light;
	
					}
	
					_lights.pointShadowMap[ pointLength ] = light.shadow.map;
	
					if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {
	
						_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();
	
					}
	
					// for point lights we set the shadow matrix to be a translation-only matrix
					// equal to inverse of the light's position
					_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
					_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );
	
					_lights.point[ pointLength ++ ] = uniforms;
	
				} else if ( light instanceof THREE.HemisphereLight ) {
	
					var uniforms = lightCache.get( light );
	
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();
	
					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );
	
					_lights.hemi[ hemiLength ++ ] = uniforms;
	
				}
	
			}
	
			_lights.ambient[ 0 ] = r;
			_lights.ambient[ 1 ] = g;
			_lights.ambient[ 2 ] = b;
	
			_lights.directional.length = directionalLength;
			_lights.spot.length = spotLength;
			_lights.point.length = pointLength;
			_lights.hemi.length = hemiLength;
	
			_lights.shadows.length = shadowsLength;
	
			_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + shadowsLength;
	
		}
	
		// GL state setting
	
		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {
	
			if ( cullFace === THREE.CullFaceNone ) {
	
				state.disable( _gl.CULL_FACE );
	
			} else {
	
				if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {
	
					_gl.frontFace( _gl.CW );
	
				} else {
	
					_gl.frontFace( _gl.CCW );
	
				}
	
				if ( cullFace === THREE.CullFaceBack ) {
	
					_gl.cullFace( _gl.BACK );
	
				} else if ( cullFace === THREE.CullFaceFront ) {
	
					_gl.cullFace( _gl.FRONT );
	
				} else {
	
					_gl.cullFace( _gl.FRONT_AND_BACK );
	
				}
	
				state.enable( _gl.CULL_FACE );
	
			}
	
		};
	
		// Textures
	
		function setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {
	
			var extension;
	
			if ( isPowerOfTwoImage ) {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );
	
			} else {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
	
				if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );
	
				}
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );
	
				if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );
	
				}
	
			}
	
			extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
			if ( extension ) {
	
				if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;
	
				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {
	
					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;
	
				}
	
			}
	
		}
	
		function uploadTexture( textureProperties, texture, slot ) {
	
			if ( textureProperties.__webglInit === undefined ) {
	
				textureProperties.__webglInit = true;
	
				texture.addEventListener( 'dispose', onTextureDispose );
	
				textureProperties.__webglTexture = _gl.createTexture();
	
				_infoMemory.textures ++;
	
			}
	
			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
	
			var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );
	
			if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {
	
				image = makePowerOfTwo( image );
	
			}
	
			var isPowerOfTwoImage = isPowerOfTwo( image ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );
	
			setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );
	
			var mipmap, mipmaps = texture.mipmaps;
	
			if ( texture instanceof THREE.DataTexture ) {
	
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
	
				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
					}
	
					texture.generateMipmaps = false;
	
				} else {
	
					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );
	
				}
	
			} else if ( texture instanceof THREE.CompressedTexture ) {
	
				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
					mipmap = mipmaps[ i ];
	
					if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {
	
						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
						} else {
	
							console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );
	
						}
	
					} else {
	
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
					}
	
				}
	
			} else {
	
				// regular Texture (image, video, canvas)
	
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
	
				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );
	
					}
	
					texture.generateMipmaps = false;
	
				} else {
	
					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );
	
				}
	
			}
	
			if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
			textureProperties.__version = texture.version;
	
			if ( texture.onUpdate ) texture.onUpdate( texture );
	
		}
	
		this.setTexture = function ( texture, slot ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
				var image = texture.image;
	
				if ( image === undefined ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
					return;
	
				}
	
				if ( image.complete === false ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
					return;
	
				}
	
				uploadTexture( textureProperties, texture, slot );
	
				return;
	
			}
	
			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
		};
	
		function clampToMaxSize ( image, maxSize ) {
	
			if ( image.width > maxSize || image.height > maxSize ) {
	
				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.
	
				var scale = maxSize / Math.max( image.width, image.height );
	
				var canvas = document.createElement( 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );
	
				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );
	
				console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
				return canvas;
	
			}
	
			return image;
	
		}
	
		function isPowerOfTwo( image ) {
	
			return THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );
	
		}
	
		function textureNeedsPowerOfTwo( texture ) {
	
			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;
			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;
	
			return false;
	
		}
	
		function makePowerOfTwo( image ) {
	
			if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {
	
				var canvas = document.createElement( 'canvas' );
				canvas.width = THREE.Math.nearestPowerOfTwo( image.width );
				canvas.height = THREE.Math.nearestPowerOfTwo( image.height );
	
				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, canvas.width, canvas.height );
	
				console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
				return canvas;
	
			}
	
			return image;
	
		}
	
		function setCubeTexture ( texture, slot ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.image.length === 6 ) {
	
				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
					if ( ! textureProperties.__image__webglTextureCube ) {
	
						texture.addEventListener( 'dispose', onTextureDispose );
	
						textureProperties.__image__webglTextureCube = _gl.createTexture();
	
						_infoMemory.textures ++;
	
					}
	
					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
	
					var isCompressed = texture instanceof THREE.CompressedTexture;
					var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;
	
					var cubeImage = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {
	
							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );
	
						} else {
	
							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];
	
						}
	
					}
	
					var image = cubeImage[ 0 ],
					isPowerOfTwoImage = isPowerOfTwo( image ),
					glFormat = paramThreeToGL( texture.format ),
					glType = paramThreeToGL( texture.type );
	
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( ! isCompressed ) {
	
							if ( isDataTexture ) {
	
								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );
	
							} else {
	
								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );
	
							}
	
						} else {
	
							var mipmap, mipmaps = cubeImage[ i ].mipmaps;
	
							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {
	
								mipmap = mipmaps[ j ];
	
								if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {
	
									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
									} else {
	
										console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );
	
									}
	
								} else {
	
									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
								}
	
							}
	
						}
	
					}
	
					if ( texture.generateMipmaps && isPowerOfTwoImage ) {
	
						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
					}
	
					textureProperties.__version = texture.version;
	
					if ( texture.onUpdate ) texture.onUpdate( texture );
	
				} else {
	
					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
				}
	
			}
	
		}
	
		function setCubeTextureDynamic ( texture, slot ) {
	
			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );
	
		}
	
		// Render targets
	
		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {
	
			var glFormat = paramThreeToGL( renderTarget.texture.format );
			var glType = paramThreeToGL( renderTarget.texture.type );
			state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
		}
	
		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage ( renderbuffer, renderTarget ) {
	
			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
	
			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			} else {
	
				// FIXME: We don't support !depth !stencil
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );
	
			}
	
			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
	
		}
	
		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {
	
			var renderTargetProperties = properties.get( renderTarget );
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
	
			if ( isCube ) {
	
				renderTargetProperties.__webglDepthbuffer = [];
	
				for ( var i = 0; i < 6; i ++ ) {
	
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );
	
				}
	
			} else {
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );
	
			}
	
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
		}
	
		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {
	
			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );
	
			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
	
			textureProperties.__webglTexture = _gl.createTexture();
	
			_infoMemory.textures ++;
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
			var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height );
	
			// Setup framebuffer
	
			if ( isCube ) {
	
				renderTargetProperties.__webglFramebuffer = [];
	
				for ( var i = 0; i < 6; i ++ ) {
	
					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
	
				}
	
			} else {
	
				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
	
			}
	
			// Setup color buffer
	
			if ( isCube ) {
	
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );
	
				for ( var i = 0; i < 6; i ++ ) {
	
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
	
				}
	
				if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
			} else {
	
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );
	
				if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
				state.bindTexture( _gl.TEXTURE_2D, null );
	
			}
	
			// Setup depth and stencil buffers
	
			if ( renderTarget.depthBuffer ) {
	
				setupDepthRenderbuffer( renderTarget );
	
			}
	
		}
	
		this.setRenderTarget = function ( renderTarget ) {
	
			_currentRenderTarget = renderTarget;
	
			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {
	
				setupRenderTarget( renderTarget );
	
			}
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
			var framebuffer;
	
			if ( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
	
				if ( isCube ) {
	
					framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];
	
				} else {
	
					framebuffer = renderTargetProperties.__webglFramebuffer;
	
				}
	
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;
	
				_currentViewport.copy( renderTarget.viewport );
	
			} else {
	
				framebuffer = null;
	
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
				_currentScissorTest = _scissorTest;
	
				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
	
			}
	
			if ( _currentFramebuffer !== framebuffer ) {
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_currentFramebuffer = framebuffer;
	
			}
	
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );
	
			state.viewport( _currentViewport );
	
			if ( isCube ) {
	
				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0 );
	
			}
	
		};
	
		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {
	
			if ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {
	
				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;
	
			}
	
			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;
	
			if ( framebuffer ) {
	
				var restore = false;
	
				if ( framebuffer !== _currentFramebuffer ) {
	
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
	
					restore = true;
	
				}
	
				try {
	
					var texture = renderTarget.texture;
	
					if ( texture.format !== THREE.RGBAFormat
						&& paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;
	
					}
	
					if ( texture.type !== THREE.UnsignedByteType
						&& paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE )
						&& ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) )
						&& ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;
	
					}
	
					if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {
	
						_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );
	
					} else {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );
	
					}
	
				} finally {
	
					if ( restore ) {
	
						_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );
	
					}
	
				}
	
			}
	
		};
	
		function updateRenderTargetMipmap( renderTarget ) {
	
			var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
			var texture = properties.get( renderTarget.texture ).__webglTexture;
	
			state.bindTexture( target, texture );
			_gl.generateMipmap( target );
			state.bindTexture( target, null );
	
		}
	
		// Fallback filters for non-power-of-2 textures
	
		function filterFallback ( f ) {
	
			if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {
	
				return _gl.NEAREST;
	
			}
	
			return _gl.LINEAR;
	
		}
	
		// Map three.js constants to WebGL constants
	
		function paramThreeToGL ( p ) {
	
			var extension;
	
			if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
			if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
			if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;
	
			if ( p === THREE.NearestFilter ) return _gl.NEAREST;
			if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
			if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;
	
			if ( p === THREE.LinearFilter ) return _gl.LINEAR;
			if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
			if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;
	
			if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
			if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;
	
			if ( p === THREE.ByteType ) return _gl.BYTE;
			if ( p === THREE.ShortType ) return _gl.SHORT;
			if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
			if ( p === THREE.IntType ) return _gl.INT;
			if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
			if ( p === THREE.FloatType ) return _gl.FLOAT;
	
			extension = extensions.get( 'OES_texture_half_float' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;
	
			}
	
			if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
			if ( p === THREE.RGBFormat ) return _gl.RGB;
			if ( p === THREE.RGBAFormat ) return _gl.RGBA;
			if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
			if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
	
			if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
			if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
			if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;
	
			if ( p === THREE.ZeroFactor ) return _gl.ZERO;
			if ( p === THREE.OneFactor ) return _gl.ONE;
			if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
			if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
			if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
			if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
			if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
			if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;
	
			if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
			if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
			if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;
	
			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	
			}
	
			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	
			}
	
			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;
	
			}
	
			extension = extensions.get( 'EXT_blend_minmax' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.MinEquation ) return extension.MIN_EXT;
				if ( p === THREE.MaxEquation ) return extension.MAX_EXT;
	
			}
	
			return 0;
	
		}
	
	};
	
	// File:src/renderers/WebGLRenderTarget.js
	
	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */
	
	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	THREE.WebGLRenderTarget = function ( width, height, options ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.width = width;
		this.height = height;
	
		this.scissor = new THREE.Vector4( 0, 0, width, height );
		this.scissorTest = false;
	
		this.viewport = new THREE.Vector4( 0, 0, width, height );
	
		options = options || {};
	
		if ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;
	
		this.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy );
	
		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	
	};
	
	THREE.WebGLRenderTarget.prototype = {
	
		constructor: THREE.WebGLRenderTarget,
	
		setSize: function ( width, height ) {
	
			if ( this.width !== width || this.height !== height ) {
	
				this.width = width;
				this.height = height;
	
				this.dispose();
	
			}
	
			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.width = source.width;
			this.height = source.height;
	
			this.viewport.copy( source.viewport );
	
			this.texture = source.texture.clone();
	
			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
	
			this.shareDepthFrom = source.shareDepthFrom;
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );
	
	// File:src/renderers/WebGLRenderTargetCube.js
	
	/**
	 * @author alteredq / http://alteredqualia.com
	 */
	
	THREE.WebGLRenderTargetCube = function ( width, height, options ) {
	
		THREE.WebGLRenderTarget.call( this, width, height, options );
	
		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
	
	};
	
	THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
	THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
	
	// File:src/renderers/webgl/WebGLBufferRenderer.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {
	
		var mode;
	
		function setMode( value ) {
	
			mode = value;
	
		}
	
		function render( start, count ) {
	
			_gl.drawArrays( mode, start, count );
	
			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;
	
		}
	
		function renderInstances( geometry ) {
	
			var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
			if ( extension === null ) {
	
				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;
	
			}
	
			var position = geometry.attributes.position;
	
			var count = 0;
	
			if ( position instanceof THREE.InterleavedBufferAttribute ) {
	
				count = position.data.count;
	
				extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
	
			} else {
	
				count = position.count;
	
				extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
	
			}
	
			_infoRender.calls ++;
			_infoRender.vertices += count * geometry.maxInstancedCount;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;
	
		}
	
		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
	
	};
	
	// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {
	
		var mode;
	
		function setMode( value ) {
	
			mode = value;
	
		}
	
		var type, size;
	
		function setIndex( index ) {
	
			if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {
	
				type = _gl.UNSIGNED_INT;
				size = 4;
	
			} else {
	
				type = _gl.UNSIGNED_SHORT;
				size = 2;
	
			}
	
		}
	
		function render( start, count ) {
	
			_gl.drawElements( mode, count, type, start * size );
	
			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;
	
		}
	
		function renderInstances( geometry, start, count ) {
	
			var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
			if ( extension === null ) {
	
				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;
	
			}
	
			extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );
	
			_infoRender.calls ++;
			_infoRender.vertices += count * geometry.maxInstancedCount;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;
		}
	
		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
	
	};
	
	// File:src/renderers/webgl/WebGLExtensions.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLExtensions = function ( gl ) {
	
		var extensions = {};
	
		this.get = function ( name ) {
	
			if ( extensions[ name ] !== undefined ) {
	
				return extensions[ name ];
	
			}
	
			var extension;
	
			switch ( name ) {
	
				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;
	
				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;
	
				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;
	
				case 'WEBGL_compressed_texture_etc1':
					extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
					break;
	
				default:
					extension = gl.getExtension( name );
	
			}
	
			if ( extension === null ) {
	
				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
	
			}
	
			extensions[ name ] = extension;
	
			return extension;
	
		};
	
	};
	
	// File:src/renderers/webgl/WebGLCapabilities.js
	
	THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {
	
		function getMaxPrecision( precision ) {
	
			if ( precision === 'highp' ) {
	
				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {
	
					return 'highp';
	
				}
	
				precision = 'mediump';
	
			}
	
			if ( precision === 'mediump' ) {
	
				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {
	
					return 'mediump';
	
				}
	
			}
	
			return 'lowp';
	
		}
	
		this.getMaxPrecision = getMaxPrecision;
	
		this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
		this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;
	
		this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );
	
		this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );
	
		this.vertexTextures = this.maxVertexTextures > 0;
		this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
		this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
	
		var _maxPrecision = getMaxPrecision( this.precision );
	
		if ( _maxPrecision !== this.precision ) {
	
			console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
			this.precision = _maxPrecision;
	
		}
	
		if ( this.logarithmicDepthBuffer ) {
	
			this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );
	
		}
	
	};
	
	// File:src/renderers/webgl/WebGLGeometries.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLGeometries = function ( gl, properties, info ) {
	
		var geometries = {};
	
		function get( object ) {
	
			var geometry = object.geometry;
	
			if ( geometries[ geometry.id ] !== undefined ) {
	
				return geometries[ geometry.id ];
	
			}
	
			geometry.addEventListener( 'dispose', onGeometryDispose );
	
			var buffergeometry;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				buffergeometry = geometry;
	
			} else if ( geometry instanceof THREE.Geometry ) {
	
				if ( geometry._bufferGeometry === undefined ) {
	
					geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );
	
				}
	
				buffergeometry = geometry._bufferGeometry;
	
			}
	
			geometries[ geometry.id ] = buffergeometry;
	
			info.memory.geometries ++;
	
			return buffergeometry;
	
		}
	
		function onGeometryDispose( event ) {
	
			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];
	
			if ( buffergeometry.index !== null ) {
	
				deleteAttribute( buffergeometry.index );
	
			}
	
			deleteAttributes( buffergeometry.attributes );
	
			geometry.removeEventListener( 'dispose', onGeometryDispose );
	
			delete geometries[ geometry.id ];
	
			// TODO
	
			var property = properties.get( geometry );
	
			if ( property.wireframe ) {
	
				deleteAttribute( property.wireframe );
	
			}
	
			properties.delete( geometry );
	
			var bufferproperty = properties.get( buffergeometry );
	
			if ( bufferproperty.wireframe ) {
	
				deleteAttribute( bufferproperty.wireframe );
	
			}
	
			properties.delete( buffergeometry );
	
			//
	
			info.memory.geometries --;
	
		}
	
		function getAttributeBuffer( attribute ) {
	
			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {
	
				return properties.get( attribute.data ).__webglBuffer;
	
			}
	
			return properties.get( attribute ).__webglBuffer;
	
		}
	
		function deleteAttribute( attribute ) {
	
			var buffer = getAttributeBuffer( attribute );
	
			if ( buffer !== undefined ) {
	
				gl.deleteBuffer( buffer );
				removeAttributeBuffer( attribute );
	
			}
	
		}
	
		function deleteAttributes( attributes ) {
	
			for ( var name in attributes ) {
	
				deleteAttribute( attributes[ name ] );
	
			}
	
		}
	
		function removeAttributeBuffer( attribute ) {
	
			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {
	
				properties.delete( attribute.data );
	
			} else {
	
				properties.delete( attribute );
	
			}
	
		}
	
		this.get = get;
	
	};
	
	// File:src/renderers/webgl/WebGLLights.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLLights = function () {
	
		var lights = {};
	
		this.get = function ( light ) {
	
			if ( lights[ light.id ] !== undefined ) {
	
				return lights[ light.id ];
	
			}
	
			var uniforms;
	
			switch ( light.type ) {
	
				case 'DirectionalLight':
					uniforms = {
						direction: new THREE.Vector3(),
						color: new THREE.Color(),
	
						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new THREE.Vector2()
					};
					break;
	
				case 'SpotLight':
					uniforms = {
						position: new THREE.Vector3(),
						direction: new THREE.Vector3(),
						color: new THREE.Color(),
						distance: 0,
						angleCos: 0,
						exponent: 0,
						decay: 0,
	
						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new THREE.Vector2()
					};
					break;
	
				case 'PointLight':
					uniforms = {
						position: new THREE.Vector3(),
						color: new THREE.Color(),
						distance: 0,
						decay: 0,
	
						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new THREE.Vector2()
					};
					break;
	
				case 'HemisphereLight':
					uniforms = {
						direction: new THREE.Vector3(),
						skyColor: new THREE.Color(),
						groundColor: new THREE.Color()
					};
					break;
	
			}
	
			lights[ light.id ] = uniforms;
	
			return uniforms;
	
		};
	
	};
	
	// File:src/renderers/webgl/WebGLObjects.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLObjects = function ( gl, properties, info ) {
	
		var geometries = new THREE.WebGLGeometries( gl, properties, info );
	
		//
	
		function update( object ) {
	
			// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.
	
			var geometry = geometries.get( object );
	
			if ( object.geometry instanceof THREE.Geometry ) {
	
				geometry.updateFromObject( object );
	
			}
	
			var index = geometry.index;
			var attributes = geometry.attributes;
	
			if ( index !== null ) {
	
				updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );
	
			}
	
			for ( var name in attributes ) {
	
				updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );
	
			}
	
			// morph targets
	
			var morphAttributes = geometry.morphAttributes;
	
			for ( var name in morphAttributes ) {
	
				var array = morphAttributes[ name ];
	
				for ( var i = 0, l = array.length; i < l; i ++ ) {
	
					updateAttribute( array[ i ], gl.ARRAY_BUFFER );
	
				}
	
			}
	
			return geometry;
	
		}
	
		function updateAttribute( attribute, bufferType ) {
	
			var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;
	
			var attributeProperties = properties.get( data );
	
			if ( attributeProperties.__webglBuffer === undefined ) {
	
				createBuffer( attributeProperties, data, bufferType );
	
			} else if ( attributeProperties.version !== data.version ) {
	
				updateBuffer( attributeProperties, data, bufferType );
	
			}
	
		}
	
		function createBuffer( attributeProperties, data, bufferType ) {
	
			attributeProperties.__webglBuffer = gl.createBuffer();
			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
			var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
	
			gl.bufferData( bufferType, data.array, usage );
	
			attributeProperties.version = data.version;
	
		}
	
		function updateBuffer( attributeProperties, data, bufferType ) {
	
			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
			if ( data.dynamic === false || data.updateRange.count === - 1 ) {
	
				// Not using update ranges
	
				gl.bufferSubData( bufferType, 0, data.array );
	
			} else if ( data.updateRange.count === 0 ) {
	
				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );
	
			} else {
	
				gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
								  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );
	
				data.updateRange.count = 0; // reset range
	
			}
	
			attributeProperties.version = data.version;
	
		}
	
		function getAttributeBuffer( attribute ) {
	
			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {
	
				return properties.get( attribute.data ).__webglBuffer;
	
			}
	
			return properties.get( attribute ).__webglBuffer;
	
		}
	
		function getWireframeAttribute( geometry ) {
	
			var property = properties.get( geometry );
	
			if ( property.wireframe !== undefined ) {
	
				return property.wireframe;
	
			}
	
			var indices = [];
	
			var index = geometry.index;
			var attributes = geometry.attributes;
			var position = attributes.position;
	
			// console.time( 'wireframe' );
	
			if ( index !== null ) {
	
				var edges = {};
				var array = index.array;
	
				for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];
	
					if ( checkEdge( edges, a, b ) ) indices.push( a, b );
					if ( checkEdge( edges, b, c ) ) indices.push( b, c );
					if ( checkEdge( edges, c, a ) ) indices.push( c, a );
	
				}
	
			} else {
	
				var array = attributes.position.array;
	
				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {
	
					var a = i + 0;
					var b = i + 1;
					var c = i + 2;
	
					indices.push( a, b, b, c, c, a );
	
				}
	
			}
	
			// console.timeEnd( 'wireframe' );
	
			var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
			var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );
	
			updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );
	
			property.wireframe = attribute;
	
			return attribute;
	
		}
	
		function checkEdge( edges, a, b ) {
	
			if ( a > b ) {
	
				var tmp = a;
				a = b;
				b = tmp;
	
			}
	
			var list = edges[ a ];
	
			if ( list === undefined ) {
	
				edges[ a ] = [ b ];
				return true;
	
			} else if ( list.indexOf( b ) === -1 ) {
	
				list.push( b );
				return true;
	
			}
	
			return false;
	
		}
	
		this.getAttributeBuffer = getAttributeBuffer;
		this.getWireframeAttribute = getWireframeAttribute;
	
		this.update = update;
	
	};
	
	// File:src/renderers/webgl/WebGLProgram.js
	
	THREE.WebGLProgram = ( function () {
	
		var programIdCount = 0;
	
		// TODO: Combine the regex
		var structRe = /^([\w\d_]+)\.([\w\d_]+)$/;
		var arrayStructRe = /^([\w\d_]+)\[(\d+)\]\.([\w\d_]+)$/;
		var arrayRe = /^([\w\d_]+)\[0\]$/;
	
		function generateExtensions( extensions, parameters, rendererExtensions ) {
	
			extensions = extensions || {};
	
			var chunks = [
				( extensions.derivatives || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
				( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
				( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
				( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',
			];
	
			return chunks.filter( filterEmptyLine ).join( '\n' );
	
		}
	
		function generateDefines( defines ) {
	
			var chunks = [];
	
			for ( var name in defines ) {
	
				var value = defines[ name ];
	
				if ( value === false ) continue;
	
				chunks.push( '#define ' + name + ' ' + value );
	
			}
	
			return chunks.join( '\n' );
	
		}
	
		function fetchUniformLocations( gl, program, identifiers ) {
	
			var uniforms = {};
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );
	
			for ( var i = 0; i < n; i ++ ) {
	
				var info = gl.getActiveUniform( program, i );
				var name = info.name;
				var location = gl.getUniformLocation( program, name );
	
				//console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);
	
				var matches = structRe.exec( name );
				if ( matches ) {
	
					var structName = matches[ 1 ];
					var structProperty = matches[ 2 ];
	
					var uniformsStruct = uniforms[ structName ];
	
					if ( ! uniformsStruct ) {
	
						uniformsStruct = uniforms[ structName ] = {};
	
					}
	
					uniformsStruct[ structProperty ] = location;
	
					continue;
	
				}
	
				matches = arrayStructRe.exec( name );
	
				if ( matches ) {
	
					var arrayName = matches[ 1 ];
					var arrayIndex = matches[ 2 ];
					var arrayProperty = matches[ 3 ];
	
					var uniformsArray = uniforms[ arrayName ];
	
					if ( ! uniformsArray ) {
	
						uniformsArray = uniforms[ arrayName ] = [];
	
					}
	
					var uniformsArrayIndex = uniformsArray[ arrayIndex ];
	
					if ( ! uniformsArrayIndex ) {
	
						uniformsArrayIndex = uniformsArray[ arrayIndex ] = {};
	
					}
	
					uniformsArrayIndex[ arrayProperty ] = location;
	
					continue;
	
				}
	
				matches = arrayRe.exec( name );
	
				if ( matches ) {
	
					var arrayName = matches[ 1 ];
	
					uniforms[ arrayName ] = location;
	
					continue;
	
				}
	
				uniforms[ name ] = location;
	
			}
	
			return uniforms;
	
		}
	
		function fetchAttributeLocations( gl, program, identifiers ) {
	
			var attributes = {};
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );
	
			for ( var i = 0; i < n; i ++ ) {
	
				var info = gl.getActiveAttrib( program, i );
				var name = info.name;
	
				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );
	
				attributes[ name ] = gl.getAttribLocation( program, name );
	
			}
	
			return attributes;
	
		}
	
		function filterEmptyLine( string ) {
	
			return string !== '';
	
		}
	
		function replaceLightNums( string, parameters ) {
	
			return string
				.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
				.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
				.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
				.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );
	
		}
	
		function unrollLoops( string ) {
	
			var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	
			function replace( match, start, end, snippet ) {
	
				var unroll = '';
	
				for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {
	
					unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );
	
				}
	
				return unroll;
	
			}
	
			return string.replace( pattern, replace );
	
		}
	
		return function WebGLProgram( renderer, code, material, parameters ) {
	
			var gl = renderer.context;
	
			var extensions = material.extensions;
			var defines = material.defines;
	
			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;
	
			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	
			if ( parameters.shadowMapType === THREE.PCFShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	
			} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	
			}
	
			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
	
			if ( parameters.envMap ) {
	
				switch ( material.envMap.mapping ) {
	
					case THREE.CubeReflectionMapping:
					case THREE.CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;
	
					case THREE.EquirectangularReflectionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;
	
					case THREE.SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;
	
				}
	
				switch ( material.envMap.mapping ) {
	
					case THREE.CubeRefractionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;
	
				}
	
				switch ( material.combine ) {
	
					case THREE.MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;
	
					case THREE.MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;
	
					case THREE.AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;
	
				}
	
			}
	
			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;
	
			// console.log( 'building new program ' );
	
			//
	
			var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );
	
			var customDefines = generateDefines( defines );
	
			//
	
			var program = gl.createProgram();
	
			var prefixVertex, prefixFragment;
	
			if ( material instanceof THREE.RawShaderMaterial ) {
	
				prefixVertex = '';
				prefixFragment = '';
	
			} else {
	
				prefixVertex = [
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
	
					renderer.gammaInput ? '#define GAMMA_INPUT' : '',
					renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					'#define MAX_BONES ' + parameters.maxBones,
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
	
					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',
	
					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
	
					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',
	
					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',
	
					'#ifdef USE_COLOR',
	
					'	attribute vec3 color;',
	
					'#endif',
	
					'#ifdef USE_MORPHTARGETS',
	
					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',
	
					'	#ifdef USE_MORPHNORMALS',
	
					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',
	
					'	#else',
	
					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',
	
					'	#endif',
	
					'#endif',
	
					'#ifdef USE_SKINNING',
	
					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',
	
					'#endif',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
	
				prefixFragment = [
	
					customExtensions,
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
	
					renderer.gammaInput ? '#define GAMMA_INPUT' : '',
					renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',
	
					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
			}
	
			vertexShader = replaceLightNums( vertexShader, parameters );
			fragmentShader = replaceLightNums( fragmentShader, parameters );
	
			if ( material instanceof THREE.ShaderMaterial === false ) {
	
				vertexShader = unrollLoops( vertexShader );
				fragmentShader = unrollLoops( fragmentShader );
	
			}
	
			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;
	
			// console.log( '*VERTEX*', vertexGlsl );
			// console.log( '*FRAGMENT*', fragmentGlsl );
	
			var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );
	
			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );
	
			// Force a particular attribute to index 0.
	
			if ( material.index0AttributeName !== undefined ) {
	
				gl.bindAttribLocation( program, 0, material.index0AttributeName );
	
			} else if ( parameters.morphTargets === true ) {
	
				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );
	
			}
	
			gl.linkProgram( program );
	
			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );
	
			var runnable = true;
			var haveDiagnostics = true;
	
			// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
			// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
	
			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {
	
				runnable = false;
	
				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );
	
			} else if ( programLog !== '' ) {
	
				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );
	
			} else if ( vertexLog === '' || fragmentLog === '' ) {
	
				haveDiagnostics = false;
	
			}
	
			if ( haveDiagnostics ) {
	
				this.diagnostics = {
	
					runnable: runnable,
					material: material,
	
					programLog: programLog,
	
					vertexShader: {
	
						log: vertexLog,
						prefix: prefixVertex
	
					},
	
					fragmentShader: {
	
						log: fragmentLog,
						prefix: prefixFragment
	
					}
	
				};
	
			}
	
			// clean up
	
			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );
	
			// set up caching for uniform locations
	
			var cachedUniforms;
	
			this.getUniforms = function() {
	
				if ( cachedUniforms === undefined ) {
	
					cachedUniforms = fetchUniformLocations( gl, program );
	
				}
	
				return cachedUniforms;
	
			};
	
			// set up caching for attribute locations
	
			var cachedAttributes;
	
			this.getAttributes = function() {
	
				if ( cachedAttributes === undefined ) {
	
					cachedAttributes = fetchAttributeLocations( gl, program );
	
				}
	
				return cachedAttributes;
	
			};
	
			// free resource
	
			this.destroy = function() {
	
				gl.deleteProgram( program );
				this.program = undefined;
	
			};
	
			// DEPRECATED
	
			Object.defineProperties( this, {
	
				uniforms: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();
	
					}
				},
	
				attributes: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();
	
					}
				}
	
			} );
	
	
			//
	
			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;
	
			return this;
	
		};
	
	} )();
	
	// File:src/renderers/webgl/WebGLPrograms.js
	
	THREE.WebGLPrograms = function ( renderer, capabilities ) {
	
		var programs = [];
	
		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshStandardMaterial: 'standard',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points'
		};
	
		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
			"lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap",
			"roughnessMap", "metalnessMap",
			"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals",
			"numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
			"shadowMapEnabled", "pointLightShadows",
			"shadowMapType",
			"alphaTest", "doubleSided", "flipSided"
		];
	
	
		function allocateBones ( object ) {
	
			if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {
	
				return 1024;
	
			} else {
	
				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)
	
				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
	
				var maxBones = nVertexMatrices;
	
				if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {
	
					maxBones = Math.min( object.skeleton.bones.length, maxBones );
	
					if ( maxBones < object.skeleton.bones.length ) {
	
						console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );
	
					}
	
				}
	
				return maxBones;
	
			}
	
		}
	
		this.getParameters = function ( material, lights, fog, object ) {
	
			var shaderID = shaderIDs[ material.type ];
			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)
	
			var maxBones = allocateBones( object );
			var precision = renderer.getPrecision();
	
			if ( material.precision !== null ) {
	
				precision = capabilities.getMaxPrecision( material.precision );
	
				if ( precision !== material.precision ) {
	
					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );
	
				}
	
			}
	
			var parameters = {
	
				shaderID: shaderID,
	
				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,
	
				map: !! material.map,
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,
	
				combine: material.combine,
	
				vertexColors: material.vertexColors,
	
				fog: fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,
	
				flatShading: material.shading === THREE.FlatShading,
	
				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
	
				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
	
				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,
	
				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numHemiLights: lights.hemi.length,
	
				pointLightShadows: lights.shadowsPointLight,
	
				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,
	
				alphaTest: material.alphaTest,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide
	
			};
	
			return parameters;
	
		};
	
		this.getProgramCode = function ( material, parameters ) {
	
			var chunks = [];
	
			if ( parameters.shaderID ) {
	
				chunks.push( parameters.shaderID );
	
			} else {
	
				chunks.push( material.fragmentShader );
				chunks.push( material.vertexShader );
	
			}
	
			if ( material.defines !== undefined ) {
	
				for ( var name in material.defines ) {
	
					chunks.push( name );
					chunks.push( material.defines[ name ] );
	
				}
	
			}
	
			for ( var i = 0; i < parameterNames.length; i ++ ) {
	
				var parameterName = parameterNames[ i ];
				chunks.push( parameterName );
				chunks.push( parameters[ parameterName ] );
	
			}
	
			return chunks.join();
	
		};
	
		this.acquireProgram = function ( material, parameters, code ) {
	
			var program;
	
			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {
	
				var programInfo = programs[ p ];
	
				if ( programInfo.code === code ) {
	
					program = programInfo;
					++ program.usedTimes;
	
					break;
	
				}
	
			}
	
			if ( program === undefined ) {
	
				program = new THREE.WebGLProgram( renderer, code, material, parameters );
				programs.push( program );
	
			}
	
			return program;
	
		};
	
		this.releaseProgram = function( program ) {
	
			if ( -- program.usedTimes === 0 ) {
	
				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();
	
				// Free WebGL resources
				program.destroy();
	
			}
	
		};
	
		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;
	
	};
	
	// File:src/renderers/webgl/WebGLProperties.js
	
	/**
	* @author fordacious / fordacious.github.io
	*/
	
	THREE.WebGLProperties = function () {
	
		var properties = {};
	
		this.get = function ( object ) {
	
			var uuid = object.uuid;
			var map = properties[ uuid ];
	
			if ( map === undefined ) {
	
				map = {};
				properties[ uuid ] = map;
	
			}
	
			return map;
	
		};
	
		this.delete = function ( object ) {
	
			delete properties[ object.uuid ];
	
		};
	
		this.clear = function () {
	
			properties = {};
	
		};
	
	};
	
	// File:src/renderers/webgl/WebGLShader.js
	
	THREE.WebGLShader = ( function () {
	
		function addLineNumbers( string ) {
	
			var lines = string.split( '\n' );
	
			for ( var i = 0; i < lines.length; i ++ ) {
	
				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];
	
			}
	
			return lines.join( '\n' );
	
		}
	
		return function WebGLShader( gl, type, string ) {
	
			var shader = gl.createShader( type );
	
			gl.shaderSource( shader, string );
			gl.compileShader( shader );
	
			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {
	
				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );
	
			}
	
			if ( gl.getShaderInfoLog( shader ) !== '' ) {
	
				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );
	
			}
	
			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
	
			return shader;
	
		};
	
	} )();
	
	// File:src/renderers/webgl/WebGLShadowMap.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {
	
		var _gl = _renderer.context,
		_state = _renderer.state,
		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4(),
	
		_lookTarget = new THREE.Vector3(),
		_lightPositionWorld = new THREE.Vector3(),
	
		_renderList = [],
	
		_MorphingFlag = 1,
		_SkinningFlag = 2,
	
		_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,
	
		_depthMaterials = new Array( _NumberOfMaterialVariants ),
		_distanceMaterials = new Array( _NumberOfMaterialVariants );
	
		var cubeDirections = [
			new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),
			new THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )
		];
	
		var cubeUps = [
			new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),
			new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),	new THREE.Vector3( 0, 0, - 1 )
		];
	
		var cube2DViewPorts = [
			new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
			new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
		];
	
		// init
	
		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
	
		var distanceShader = THREE.ShaderLib[ "distanceRGBA" ];
		var distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );
	
		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {
	
			var useMorphing = ( i & _MorphingFlag ) !== 0;
			var useSkinning = ( i & _SkinningFlag ) !== 0;
	
			var depthMaterial = new THREE.ShaderMaterial( {
				uniforms: depthUniforms,
				vertexShader: depthShader.vertexShader,
				fragmentShader: depthShader.fragmentShader,
				morphTargets: useMorphing,
				skinning: useSkinning
			} );
	
			depthMaterial._shadowPass = true;
	
			_depthMaterials[ i ] = depthMaterial;
	
			var distanceMaterial = new THREE.ShaderMaterial( {
				uniforms: distanceUniforms,
				vertexShader: distanceShader.vertexShader,
				fragmentShader: distanceShader.fragmentShader,
				morphTargets: useMorphing,
				skinning: useSkinning
			} );
	
			distanceMaterial._shadowPass = true;
	
			_distanceMaterials[ i ] = distanceMaterial;
	
		}
	
		//
	
		var scope = this;
	
		this.enabled = false;
	
		this.autoUpdate = true;
		this.needsUpdate = false;
	
		this.type = THREE.PCFShadowMap;
		this.cullFace = THREE.CullFaceFront;
	
		this.render = function ( scene, camera ) {
	
			var faceCount, isPointLight;
	
			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;
	
			// Set GL state for depth map.
			_state.clearColor( 1, 1, 1, 1 );
			_state.disable( _gl.BLEND );
			_state.enable( _gl.CULL_FACE );
			_gl.frontFace( _gl.CCW );
			_gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );
			_state.setDepthTest( true );
			_state.setScissorTest( false );
	
			// render depth map
	
			var shadows = _lights.shadows;
	
			for ( var i = 0, il = shadows.length; i < il; i ++ ) {
	
				var light = shadows[ i ];
	
				var shadow = light.shadow;
				var shadowCamera = shadow.camera;
				var shadowMapSize = shadow.mapSize;
	
				if ( light instanceof THREE.PointLight ) {
	
					faceCount = 6;
					isPointLight = true;
	
					var vpWidth = shadowMapSize.x / 4.0;
					var vpHeight = shadowMapSize.y / 2.0;
	
					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction
	
					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );
	
				} else {
	
					faceCount = 1;
					isPointLight = false;
	
				}
	
				if ( shadow.map === null ) {
	
					var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };
	
					shadow.map = new THREE.WebGLRenderTarget( shadowMapSize.x, shadowMapSize.y, pars );
	
					//
	
					if ( light instanceof THREE.SpotLight ) {
	
						shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;
	
					}
	
					shadowCamera.updateProjectionMatrix();
	
				}
	
				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;
	
				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );
	
				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();
	
				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not
	
				for ( var face = 0; face < faceCount; face ++ ) {
	
					if ( isPointLight ) {
	
						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
	
						var vpDimensions = cube2DViewPorts[ face ];
						_state.viewport( vpDimensions );
	
					} else {
	
						_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
						shadowCamera.lookAt( _lookTarget );
	
					}
	
					shadowCamera.updateMatrixWorld();
					shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );
	
					// compute shadow matrix
	
					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);
	
					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
	
					// update camera matrices and frustum
	
					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );
	
					// set object matrices & frustum culling
	
					_renderList.length = 0;
	
					projectObject( scene, camera, shadowCamera );
	
					// render shadow map
					// render regular objects
	
					for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {
	
						var object = _renderList[ j ];
						var geometry = _objects.update( object );
						var material = object.material;
	
						if ( material instanceof THREE.MultiMaterial ) {
	
							var groups = geometry.groups;
							var materials = material.materials;
	
							for ( var k = 0, kl = groups.length; k < kl; k ++ ) {
	
								var group = groups[ k ];
								var groupMaterial = materials[ group.materialIndex ];
	
								if ( groupMaterial.visible === true ) {
	
									var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
									_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );
	
								}
	
							}
	
						} else {
	
							var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );
	
						}
	
					}
	
				}
	
				// We must call _renderer.resetGLState() at the end of each iteration of
				// the light loop in order to force material updates for each light.
				_renderer.resetGLState();
	
			}
	
			// Restore GL state.
			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();
			_renderer.setClearColor( clearColor, clearAlpha );
	
			_state.enable( _gl.BLEND );
	
			if ( scope.cullFace === THREE.CullFaceFront ) {
	
				_gl.cullFace( _gl.BACK );
	
			}
	
			_renderer.resetGLState();
	
			scope.needsUpdate = false;
	
		};
	
		function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {
	
			var geometry = object.geometry;
	
			var newMaterial = null;
	
			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;
	
			if ( isPointLight ) {
	
				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;
	
			}
	
			if ( ! customMaterial ) {
	
				var useMorphing = geometry.morphTargets !== undefined &&
						geometry.morphTargets.length > 0 && material.morphTargets;
	
				var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;
	
				var variantIndex = 0;
	
				if ( useMorphing ) variantIndex |= _MorphingFlag;
				if ( useSkinning ) variantIndex |= _SkinningFlag;
	
				newMaterial = materialVariants[ variantIndex ];
	
			} else {
	
				newMaterial = customMaterial;
	
			}
	
			newMaterial.visible = material.visible;
			newMaterial.wireframe = material.wireframe;
			newMaterial.wireframeLinewidth = material.wireframeLinewidth;
	
			if ( isPointLight && newMaterial.uniforms.lightPos !== undefined ) {
	
				newMaterial.uniforms.lightPos.value.copy( lightPositionWorld );
	
			}
	
			return newMaterial;
	
		}
	
		function projectObject( object, camera, shadowCamera ) {
	
			if ( object.visible === false ) return;
	
			if ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {
	
				if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {
	
					var material = object.material;
	
					if ( material.visible === true ) {
	
						object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
						_renderList.push( object );
	
					}
	
				}
	
			}
	
			var children = object.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				projectObject( children[ i ], camera, shadowCamera );
	
			}
	
		}
	
	};
	
	// File:src/renderers/webgl/WebGLState.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {
	
		var _this = this;
	
		var color = new THREE.Vector4();
	
		var newAttributes = new Uint8Array( 16 );
		var enabledAttributes = new Uint8Array( 16 );
		var attributeDivisors = new Uint8Array( 16 );
	
		var capabilities = {};
	
		var compressedTextureFormats = null;
	
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
	
		var currentDepthFunc = null;
		var currentDepthWrite = null;
	
		var currentColorWrite = null;
	
		var currentStencilWrite = null;
		var currentStencilFunc = null;
		var currentStencilRef = null;
		var currentStencilMask = null;
		var currentStencilFail  = null;
		var currentStencilZFail = null;
		var currentStencilZPass = null;
	
		var currentFlipSided = null;
	
		var currentLineWidth = null;
	
		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;
	
		var currentScissorTest = null;
	
		var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	
		var currentTextureSlot = undefined;
		var currentBoundTextures = {};
	
		var currentClearColor = new THREE.Vector4();
		var currentClearDepth = null;
		var currentClearStencil = null;
	
		var currentScissor = new THREE.Vector4();
		var currentViewport = new THREE.Vector4();
	
		this.init = function () {
	
			this.clearColor( 0, 0, 0, 1 );
			this.clearDepth( 1 );
			this.clearStencil( 0 );
	
			this.enable( gl.DEPTH_TEST );
			gl.depthFunc( gl.LEQUAL );
	
			gl.frontFace( gl.CCW );
			gl.cullFace( gl.BACK );
			this.enable( gl.CULL_FACE );
	
			this.enable( gl.BLEND );
			gl.blendEquation( gl.FUNC_ADD );
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
	
		};
	
		this.initAttributes = function () {
	
			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {
	
				newAttributes[ i ] = 0;
	
			}
	
		};
	
		this.enableAttribute = function ( attribute ) {
	
			newAttributes[ attribute ] = 1;
	
			if ( enabledAttributes[ attribute ] === 0 ) {
	
				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;
	
			}
	
			if ( attributeDivisors[ attribute ] !== 0 ) {
	
				var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				extension.vertexAttribDivisorANGLE( attribute, 0 );
				attributeDivisors[ attribute ] = 0;
	
			}
	
		};
	
		this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {
	
			newAttributes[ attribute ] = 1;
	
			if ( enabledAttributes[ attribute ] === 0 ) {
	
				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;
	
			}
	
			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {
	
				extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;
	
			}
	
		};
	
		this.disableUnusedAttributes = function () {
	
			for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {
	
				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {
	
					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;
	
				}
	
			}
	
		};
	
		this.enable = function ( id ) {
	
			if ( capabilities[ id ] !== true ) {
	
				gl.enable( id );
				capabilities[ id ] = true;
	
			}
	
		};
	
		this.disable = function ( id ) {
	
			if ( capabilities[ id ] !== false ) {
	
				gl.disable( id );
				capabilities[ id ] = false;
	
			}
	
		};
	
		this.getCompressedTextureFormats = function () {
	
			if ( compressedTextureFormats === null ) {
	
				compressedTextureFormats = [];
	
				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_etc1' )) {
	
					var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );
	
					for ( var i = 0; i < formats.length; i ++ ) {
	
						compressedTextureFormats.push( formats[ i ] );
	
					}
	
				}
	
			}
	
			return compressedTextureFormats;
	
		};
	
		this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {
	
			if ( blending === THREE.NoBlending ) {
	
				this.disable( gl.BLEND );
	
			} else {
	
				this.enable( gl.BLEND );
	
			}
	
			if ( blending !== currentBlending ) {
	
				if ( blending === THREE.AdditiveBlending ) {
	
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
	
				} else if ( blending === THREE.SubtractiveBlending ) {
	
					// TODO: Find blendFuncSeparate() combination
	
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
	
				} else if ( blending === THREE.MultiplyBlending ) {
	
					// TODO: Find blendFuncSeparate() combination
	
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
	
				} else {
	
					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
				}
	
				currentBlending = blending;
	
			}
	
			if ( blending === THREE.CustomBlending ) {
	
				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;
	
				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
	
					gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );
	
					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;
	
				}
	
				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
	
					gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );
	
					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;
	
				}
	
			} else {
	
				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;
	
			}
	
		};
	
		this.setDepthFunc = function ( depthFunc ) {
	
			if ( currentDepthFunc !== depthFunc ) {
	
				if ( depthFunc ) {
	
					switch ( depthFunc ) {
	
						case THREE.NeverDepth:
	
							gl.depthFunc( gl.NEVER );
							break;
	
						case THREE.AlwaysDepth:
	
							gl.depthFunc( gl.ALWAYS );
							break;
	
						case THREE.LessDepth:
	
							gl.depthFunc( gl.LESS );
							break;
	
						case THREE.LessEqualDepth:
	
							gl.depthFunc( gl.LEQUAL );
							break;
	
						case THREE.EqualDepth:
	
							gl.depthFunc( gl.EQUAL );
							break;
	
						case THREE.GreaterEqualDepth:
	
							gl.depthFunc( gl.GEQUAL );
							break;
	
						case THREE.GreaterDepth:
	
							gl.depthFunc( gl.GREATER );
							break;
	
						case THREE.NotEqualDepth:
	
							gl.depthFunc( gl.NOTEQUAL );
							break;
	
						default:
	
							gl.depthFunc( gl.LEQUAL );
	
					}
	
				} else {
	
					gl.depthFunc( gl.LEQUAL );
	
				}
	
				currentDepthFunc = depthFunc;
	
			}
	
		};
	
		this.setDepthTest = function ( depthTest ) {
	
			if ( depthTest ) {
	
				this.enable( gl.DEPTH_TEST );
	
			} else {
	
				this.disable( gl.DEPTH_TEST );
	
			}
	
		};
	
		this.setDepthWrite = function ( depthWrite ) {
	
			// TODO: Rename to setDepthMask
	
			if ( currentDepthWrite !== depthWrite ) {
	
				gl.depthMask( depthWrite );
				currentDepthWrite = depthWrite;
	
			}
	
		};
	
		this.setColorWrite = function ( colorWrite ) {
	
			// TODO: Rename to setColorMask
	
			if ( currentColorWrite !== colorWrite ) {
	
				gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
				currentColorWrite = colorWrite;
	
			}
	
		};
	
		this.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {
	
			if ( currentStencilFunc !== stencilFunc ||
					 currentStencilRef 	!== stencilRef 	||
					 currentStencilMask !== stencilMask ) {
	
				gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );
	
				currentStencilFunc = stencilFunc;
				currentStencilRef  = stencilRef;
				currentStencilMask = stencilMask;
	
			}
	
		};
	
		this.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {
	
			if ( currentStencilFail	 !== stencilFail 	||
					 currentStencilZFail !== stencilZFail ||
					 currentStencilZPass !== stencilZPass ) {
	
				gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );
	
				currentStencilFail  = stencilFail;
				currentStencilZFail = stencilZFail;
				currentStencilZPass = stencilZPass;
	
			}
	
		};
	
		this.setStencilTest = function ( stencilTest ) {
	
			if ( stencilTest ) {
	
				this.enable( gl.STENCIL_TEST );
	
			} else {
	
				this.disable( gl.STENCIL_TEST );
	
			}
	
		};
	
		this.setStencilWrite = function ( stencilWrite ) {
	
			// TODO: Rename to setStencilMask
	
			if ( currentStencilWrite !== stencilWrite ) {
	
				gl.stencilMask( stencilWrite );
				currentStencilWrite = stencilWrite;
	
			}
	
		};
	
		this.setFlipSided = function ( flipSided ) {
	
			if ( currentFlipSided !== flipSided ) {
	
				if ( flipSided ) {
	
					gl.frontFace( gl.CW );
	
				} else {
	
					gl.frontFace( gl.CCW );
	
				}
	
				currentFlipSided = flipSided;
	
			}
	
		};
	
		this.setLineWidth = function ( width ) {
	
			if ( width !== currentLineWidth ) {
	
				gl.lineWidth( width );
	
				currentLineWidth = width;
	
			}
	
		};
	
		this.setPolygonOffset = function ( polygonOffset, factor, units ) {
	
			if ( polygonOffset ) {
	
				this.enable( gl.POLYGON_OFFSET_FILL );
	
			} else {
	
				this.disable( gl.POLYGON_OFFSET_FILL );
	
			}
	
			if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {
	
				gl.polygonOffset( factor, units );
	
				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;
	
			}
	
		};
	
		this.getScissorTest = function () {
	
			return currentScissorTest;
	
		};
	
		this.setScissorTest = function ( scissorTest ) {
	
			currentScissorTest = scissorTest;
	
			if ( scissorTest ) {
	
				this.enable( gl.SCISSOR_TEST );
	
			} else {
	
				this.disable( gl.SCISSOR_TEST );
	
			}
	
		};
	
		// texture
	
		this.activeTexture = function ( webglSlot ) {
	
			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;
	
			if ( currentTextureSlot !== webglSlot ) {
	
				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;
	
			}
	
		};
	
		this.bindTexture = function ( webglType, webglTexture ) {
	
			if ( currentTextureSlot === undefined ) {
	
				_this.activeTexture();
	
			}
	
			var boundTexture = currentBoundTextures[ currentTextureSlot ];
	
			if ( boundTexture === undefined ) {
	
				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;
	
			}
	
			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {
	
				gl.bindTexture( webglType, webglTexture );
	
				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
	
			}
	
		};
	
		this.compressedTexImage2D = function () {
	
			try {
	
				gl.compressedTexImage2D.apply( gl, arguments );
	
			} catch ( error ) {
	
				console.error( error );
	
			}
	
		};
	
		this.texImage2D = function () {
	
			try {
	
				gl.texImage2D.apply( gl, arguments );
	
			} catch ( error ) {
	
				console.error( error );
	
			}
	
		};
	
		// clear values
	
		this.clearColor = function ( r, g, b, a ) {
	
			color.set( r, g, b, a );
	
			if ( currentClearColor.equals( color ) === false ) {
	
				gl.clearColor( r, g, b, a );
				currentClearColor.copy( color );
	
			}
	
		};
	
		this.clearDepth = function ( depth ) {
	
			if ( currentClearDepth !== depth ) {
	
				gl.clearDepth( depth );
				currentClearDepth = depth;
	
			}
	
		};
	
		this.clearStencil = function ( stencil ) {
	
			if ( currentClearStencil !== stencil ) {
	
				gl.clearStencil( stencil );
				currentClearStencil = stencil;
	
			}
	
		};
	
		//
	
		this.scissor = function ( scissor ) {
	
			if ( currentScissor.equals( scissor ) === false ) {
	
				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );
	
			}
	
		};
	
		this.viewport = function ( viewport ) {
	
			if ( currentViewport.equals( viewport ) === false ) {
	
				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );
	
			}
	
		};
	
		//
	
		this.reset = function () {
	
			for ( var i = 0; i < enabledAttributes.length; i ++ ) {
	
				if ( enabledAttributes[ i ] === 1 ) {
	
					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;
	
				}
	
			}
	
			capabilities = {};
	
			compressedTextureFormats = null;
	
			currentBlending = null;
	
			currentColorWrite = null;
			currentDepthWrite = null;
			currentStencilWrite = null;
	
			currentFlipSided = null;
	
		};
	
	};
	
	// File:src/renderers/webgl/plugins/LensFlarePlugin.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlarePlugin = function ( renderer, flares ) {
	
		var gl = renderer.context;
		var state = renderer.state;
	
		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
		var hasVertexTexture;
	
		var tempTexture, occlusionTexture;
	
		function init() {
	
			var vertices = new Float32Array( [
				- 1, - 1,  0, 0,
				 1, - 1,  1, 0,
				 1,  1,  1, 1,
				- 1,  1,  0, 1
			] );
	
			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );
	
			// buffers
	
			vertexBuffer     = gl.createBuffer();
			elementBuffer    = gl.createBuffer();
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
			// textures
	
			tempTexture      = gl.createTexture();
			occlusionTexture = gl.createTexture();
	
			state.bindTexture( gl.TEXTURE_2D, tempTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
			state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
			hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;
	
			var shader;
	
			if ( hasVertexTexture ) {
	
				shader = {
	
					vertexShader: [
	
						"uniform lowp int renderType;",
	
						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",
	
						"uniform sampler2D occlusionMap;",
	
						"attribute vec2 position;",
						"attribute vec2 uv;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							"vUV = uv;",
	
							"vec2 pos = position;",
	
							"if ( renderType == 2 ) {",
	
								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
	
								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",
	
								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
							"}",
	
							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
						"}"
	
					].join( "\n" ),
	
					fragmentShader: [
	
						"uniform lowp int renderType;",
	
						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							// pink square
	
							"if ( renderType == 0 ) {",
	
								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
	
							// restore
	
							"} else if ( renderType == 1 ) {",
	
								"gl_FragColor = texture2D( map, vUV );",
	
							// flare
	
							"} else {",
	
								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",
	
							"}",
	
						"}"
	
					].join( "\n" )
	
				};
	
			} else {
	
				shader = {
	
					vertexShader: [
	
						"uniform lowp int renderType;",
	
						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",
	
						"attribute vec2 position;",
						"attribute vec2 uv;",
	
						"varying vec2 vUV;",
	
						"void main() {",
	
							"vUV = uv;",
	
							"vec2 pos = position;",
	
							"if ( renderType == 2 ) {",
	
								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
							"}",
	
							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
						"}"
	
					].join( "\n" ),
	
					fragmentShader: [
	
						"precision mediump float;",
	
						"uniform lowp int renderType;",
	
						"uniform sampler2D map;",
						"uniform sampler2D occlusionMap;",
						"uniform float opacity;",
						"uniform vec3 color;",
	
						"varying vec2 vUV;",
	
						"void main() {",
	
							// pink square
	
							"if ( renderType == 0 ) {",
	
								"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",
	
							// restore
	
							"} else if ( renderType == 1 ) {",
	
								"gl_FragColor = texture2D( map, vUV );",
	
							// flare
	
							"} else {",
	
								"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
								"visibility = ( 1.0 - visibility / 4.0 );",
	
								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * visibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",
	
							"}",
	
						"}"
	
					].join( "\n" )
	
				};
	
			}
	
			program = createProgram( shader );
	
			attributes = {
				vertex: gl.getAttribLocation ( program, "position" ),
				uv:     gl.getAttribLocation ( program, "uv" )
			};
	
			uniforms = {
				renderType:     gl.getUniformLocation( program, "renderType" ),
				map:            gl.getUniformLocation( program, "map" ),
				occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
				opacity:        gl.getUniformLocation( program, "opacity" ),
				color:          gl.getUniformLocation( program, "color" ),
				scale:          gl.getUniformLocation( program, "scale" ),
				rotation:       gl.getUniformLocation( program, "rotation" ),
				screenPosition: gl.getUniformLocation( program, "screenPosition" )
			};
	
		}
	
		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */
	
		this.render = function ( scene, camera, viewport ) {
	
			if ( flares.length === 0 ) return;
	
			var tempPosition = new THREE.Vector3();
	
			var invAspect = viewport.w / viewport.z,
				halfViewportWidth = viewport.z * 0.5,
				halfViewportHeight = viewport.w * 0.5;
	
			var size = 16 / viewport.w,
				scale = new THREE.Vector2( size * invAspect, size );
	
			var screenPosition = new THREE.Vector3( 1, 1, 0 ),
				screenPositionPixels = new THREE.Vector2( 1, 1 );
	
			if ( program === undefined ) {
	
				init();
	
			}
	
			gl.useProgram( program );
	
			state.initAttributes();
			state.enableAttribute( attributes.vertex );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();
	
			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/uniforms
	
			gl.uniform1i( uniforms.occlusionMap, 0 );
			gl.uniform1i( uniforms.map, 1 );
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
			state.disable( gl.CULL_FACE );
			state.setDepthWrite( false );
	
			for ( var i = 0, l = flares.length; i < l; i ++ ) {
	
				size = 16 / viewport.w;
				scale.set( size * invAspect, size );
	
				// calc object screen position
	
				var flare = flares[ i ];
	
				tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );
	
				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyProjection( camera.projectionMatrix );
	
				// setup arrays for gl programs
	
				screenPosition.copy( tempPosition );
	
				screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
				screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
	
				// screen cull
	
				if ( hasVertexTexture || (
					screenPositionPixels.x > 0 &&
					screenPositionPixels.x < viewport.z &&
					screenPositionPixels.y > 0 &&
					screenPositionPixels.y < viewport.w ) ) {
	
					// save current RGB to temp texture
	
					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, null );
					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0 );
	
	
					// render pink quad
	
					gl.uniform1i( uniforms.renderType, 0 );
					gl.uniform2f( uniforms.scale, scale.x, scale.y );
					gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
	
					state.disable( gl.BLEND );
					state.enable( gl.DEPTH_TEST );
	
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
					// copy result to occlusionMap
	
					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0 );
	
	
					// restore graphics
	
					gl.uniform1i( uniforms.renderType, 1 );
					state.disable( gl.DEPTH_TEST );
	
					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
					// update object positions
	
					flare.positionScreen.copy( screenPosition );
	
					if ( flare.customUpdateCallback ) {
	
						flare.customUpdateCallback( flare );
	
					} else {
	
						flare.updateLensFlares();
	
					}
	
					// render flares
	
					gl.uniform1i( uniforms.renderType, 2 );
					state.enable( gl.BLEND );
	
					for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {
	
						var sprite = flare.lensFlares[ j ];
	
						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {
	
							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;
	
							size = sprite.size * sprite.scale / viewport.w;
	
							scale.x = size * invAspect;
							scale.y = size;
	
							gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							gl.uniform2f( uniforms.scale, scale.x, scale.y );
							gl.uniform1f( uniforms.rotation, sprite.rotation );
	
							gl.uniform1f( uniforms.opacity, sprite.opacity );
							gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );
	
							state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
							renderer.setTexture( sprite.texture, 1 );
	
							gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
						}
	
					}
	
				}
	
			}
	
			// restore gl
	
			state.enable( gl.CULL_FACE );
			state.enable( gl.DEPTH_TEST );
			state.setDepthWrite( true );
	
			renderer.resetGLState();
	
		};
	
		function createProgram ( shader ) {
	
			var program = gl.createProgram();
	
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
	
			var prefix = "precision " + renderer.getPrecision() + " float;\n";
	
			gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			gl.shaderSource( vertexShader, prefix + shader.vertexShader );
	
			gl.compileShader( fragmentShader );
			gl.compileShader( vertexShader );
	
			gl.attachShader( program, fragmentShader );
			gl.attachShader( program, vertexShader );
	
			gl.linkProgram( program );
	
			return program;
	
		}
	
	};
	
	// File:src/renderers/webgl/plugins/SpritePlugin.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpritePlugin = function ( renderer, sprites ) {
	
		var gl = renderer.context;
		var state = renderer.state;
	
		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
	
		var texture;
	
		// decompose matrixWorld
	
		var spritePosition = new THREE.Vector3();
		var spriteRotation = new THREE.Quaternion();
		var spriteScale = new THREE.Vector3();
	
		function init() {
	
			var vertices = new Float32Array( [
				- 0.5, - 0.5,  0, 0,
				  0.5, - 0.5,  1, 0,
				  0.5,   0.5,  1, 1,
				- 0.5,   0.5,  0, 1
			] );
	
			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );
	
			vertexBuffer  = gl.createBuffer();
			elementBuffer = gl.createBuffer();
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
			program = createProgram();
	
			attributes = {
				position:			gl.getAttribLocation ( program, 'position' ),
				uv:					gl.getAttribLocation ( program, 'uv' )
			};
	
			uniforms = {
				uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
				uvScale:			gl.getUniformLocation( program, 'uvScale' ),
	
				rotation:			gl.getUniformLocation( program, 'rotation' ),
				scale:				gl.getUniformLocation( program, 'scale' ),
	
				color:				gl.getUniformLocation( program, 'color' ),
				map:				gl.getUniformLocation( program, 'map' ),
				opacity:			gl.getUniformLocation( program, 'opacity' ),
	
				modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),
	
				fogType:			gl.getUniformLocation( program, 'fogType' ),
				fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
				fogNear:			gl.getUniformLocation( program, 'fogNear' ),
				fogFar:				gl.getUniformLocation( program, 'fogFar' ),
				fogColor:			gl.getUniformLocation( program, 'fogColor' ),
	
				alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
			};
	
			var canvas = document.createElement( 'canvas' );
			canvas.width = 8;
			canvas.height = 8;
	
			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );
	
			texture = new THREE.Texture( canvas );
			texture.needsUpdate = true;
	
		}
	
		this.render = function ( scene, camera ) {
	
			if ( sprites.length === 0 ) return;
	
			// setup gl
	
			if ( program === undefined ) {
	
				init();
	
			}
	
			gl.useProgram( program );
	
			state.initAttributes();
			state.enableAttribute( attributes.position );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();
	
			state.disable( gl.CULL_FACE );
			state.enable( gl.BLEND );
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
			state.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );
	
			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;
	
			if ( fog ) {
	
				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );
	
				if ( fog instanceof THREE.Fog ) {
	
					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );
	
					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;
	
				} else if ( fog instanceof THREE.FogExp2 ) {
	
					gl.uniform1f( uniforms.fogDensity, fog.density );
	
					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;
	
				}
	
			} else {
	
				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;
	
			}
	
	
			// update positions and sort
	
			for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
				var sprite = sprites[ i ];
	
				sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite.modelViewMatrix.elements[ 14 ];
	
			}
	
			sprites.sort( painterSortStable );
	
			// render all sprites
	
			var scale = [];
	
			for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
				var sprite = sprites[ i ];
				var material = sprite.material;
	
				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );
	
				sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );
	
				scale[ 0 ] = spriteScale.x;
				scale[ 1 ] = spriteScale.y;
	
				var fogType = 0;
	
				if ( scene.fog && material.fog ) {
	
					fogType = sceneFogType;
	
				}
	
				if ( oldFogType !== fogType ) {
	
					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;
	
				}
	
				if ( material.map !== null ) {
	
					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );
	
				} else {
	
					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );
	
				}
	
				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );
	
				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.scale, scale );
	
				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				state.setDepthTest( material.depthTest );
				state.setDepthWrite( material.depthWrite );
	
				if ( material.map && material.map.image && material.map.image.width ) {
	
					renderer.setTexture( material.map, 0 );
	
				} else {
	
					renderer.setTexture( texture, 0 );
	
				}
	
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
			}
	
			// restore gl
	
			state.enable( gl.CULL_FACE );
	
			renderer.resetGLState();
	
		};
	
		function createProgram () {
	
			var program = gl.createProgram();
	
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
	
			gl.shaderSource( vertexShader, [
	
				'precision ' + renderer.getPrecision() + ' float;',
	
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',
	
				'attribute vec2 position;',
				'attribute vec2 uv;',
	
				'varying vec2 vUV;',
	
				'void main() {',
	
					'vUV = uvOffset + uv * uvScale;',
	
					'vec2 alignedPosition = position * scale;',
	
					'vec2 rotatedPosition;',
					'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
					'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
	
					'vec4 finalPosition;',
	
					'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
					'finalPosition.xy += rotatedPosition;',
					'finalPosition = projectionMatrix * finalPosition;',
	
					'gl_Position = finalPosition;',
	
				'}'
	
			].join( '\n' ) );
	
			gl.shaderSource( fragmentShader, [
	
				'precision ' + renderer.getPrecision() + ' float;',
	
				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',
	
				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',
	
				'varying vec2 vUV;',
	
				'void main() {',
	
					'vec4 texture = texture2D( map, vUV );',
	
					'if ( texture.a < alphaTest ) discard;',
	
					'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
	
					'if ( fogType > 0 ) {',
	
						'float depth = gl_FragCoord.z / gl_FragCoord.w;',
						'float fogFactor = 0.0;',
	
						'if ( fogType == 1 ) {',
	
							'fogFactor = smoothstep( fogNear, fogFar, depth );',
	
						'} else {',
	
							'const float LOG2 = 1.442695;',
							'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
							'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
	
						'}',
	
						'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
	
					'}',
	
				'}'
	
			].join( '\n' ) );
	
			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );
	
			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );
	
			gl.linkProgram( program );
	
			return program;
	
		}
	
		function painterSortStable ( a, b ) {
			
			if ( a.renderOrder !== b.renderOrder ) {
	
				return a.renderOrder - b.renderOrder;
	
			} else if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return b.id - a.id;
	
			}
	
		}
	
	};
	
	// File:src/Three.Legacy.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	Object.defineProperties( THREE.Box2.prototype, {
		empty: {
			value: function () {
				console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
			}
		},
		isIntersectionBox: {
			value: function ( box ) {
				console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			}
		}
	} );
	
	Object.defineProperties( THREE.Box3.prototype, {
		empty: {
			value: function () {
				console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
			}
		},
		isIntersectionBox: {
			value: function ( box ) {
				console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			}
		},
		isIntersectionSphere: {
			value: function ( sphere ) {
				console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
			}
		}
	} );
	
	Object.defineProperties( THREE.Matrix3.prototype, {
		multiplyVector3: {
			value: function ( vector ) {
				console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
				return vector.applyMatrix3( this );
			}
		},
		multiplyVector3Array: {
			value: function ( a ) {
				console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
			}
		}
	} );
	
	Object.defineProperties( THREE.Matrix4.prototype, {
		extractPosition: {
			value: function ( m ) {
				console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
				return this.copyPosition( m );
			}
		},
		setRotationFromQuaternion: {
			value: function ( q ) {
				console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
				return this.makeRotationFromQuaternion( q );
			}
		},
		multiplyVector3: {
			value: function ( vector ) {
				console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
				return vector.applyProjection( this );
			}
		},
		multiplyVector4: {
			value: function ( vector ) {
				console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
			}
		},
		multiplyVector3Array: {
			value: function ( a ) {
				console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
			}
		},
		rotateAxis: {
			value: function ( v ) {
				console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
				v.transformDirection( this );
			}
		},
		crossVector: {
			value: function ( vector ) {
				console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
			}
		},
		translate: {
			value: function ( v ) {
				console.error( 'THREE.Matrix4: .translate() has been removed.' );
			}
		},
		rotateX: {
			value: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
			}
		},
		rotateY: {
			value: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
			}
		},
		rotateZ: {
			value: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
			}
		},
		rotateByAxis: {
			value: function ( axis, angle ) {
				console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
			}
		}
	} );
	
	Object.defineProperties( THREE.Plane.prototype, {
		isIntersectionLine: {
			value: function ( line ) {
				console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
				return this.intersectsLine( line );
			}
		}
	} );
	
	Object.defineProperties( THREE.Quaternion.prototype, {
		multiplyVector3: {
			value: function ( vector ) {
				console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
				return vector.applyQuaternion( this );
			}
		}
	} );
	
	Object.defineProperties( THREE.Ray.prototype, {
		isIntersectionBox: {
			value: function ( box ) {
				console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			}
		},
		isIntersectionPlane: {
			value: function ( plane ) {
				console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
				return this.intersectsPlane( plane );
			}
		},
		isIntersectionSphere: {
			value: function ( sphere ) {
				console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
			}
		}
	} );
	
	Object.defineProperties( THREE.Vector3.prototype, {
		setEulerFromRotationMatrix: {
			value: function () {
				console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
			}
		},
		setEulerFromQuaternion: {
			value: function () {
				console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
			}
		},
		getPositionFromMatrix: {
			value: function ( m ) {
				console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
				return this.setFromMatrixPosition( m );
			}
		},
		getScaleFromMatrix: {
			value: function ( m ) {
				console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
				return this.setFromMatrixScale( m );
			}
		},
		getColumnFromMatrix: {
			value: function ( index, matrix ) {
				console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
				return this.setFromMatrixColumn( index, matrix );
			}
		}
	} );
	
	//
	
	THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {
	
		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new THREE.Face3( a, b, c, normal, color, materialIndex );
	
	};
	
	//
	
	Object.defineProperties( THREE.Object3D.prototype, {
		eulerOrder: {
			get: function () {
				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;
			},
			set: function ( value ) {
				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;
			}
		},
		getChildByName: {
			value: function ( name ) {
				console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
				return this.getObjectByName( name );
			}
		},
		renderDepth: {
			set: function ( value ) {
				console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
			}
		},
		translate: {
			value: function ( distance, axis ) {
				console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
				return this.translateOnAxis( axis, distance );
			}
		},
		useQuaternion: {
			get: function () {
				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
			},
			set: function ( value ) {
				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE, {
		PointCloud: {
			value: function ( geometry, material ) {
				console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
				return new THREE.Points( geometry, material );
			}
		},
		ParticleSystem: {
			value: function ( geometry, material ) {
				console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
				return new THREE.Points( geometry, material );
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE.Light.prototype, {
		onlyShadow: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .onlyShadow has been removed.' );
			}
		},
		shadowCameraFov: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;
			}
		},
		shadowCameraLeft: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;
			}
		},
		shadowCameraRight: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;
			}
		},
		shadowCameraTop: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;
			}
		},
		shadowCameraBottom: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;
			}
		},
		shadowCameraNear: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;
			}
		},
		shadowCameraFar: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;
			}
		},
		shadowCameraVisible: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
			}
		},
		shadowBias: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;
			}
		},
		shadowDarkness: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
			}
		},
		shadowMapWidth: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;
			}
		},
		shadowMapHeight: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE.BufferAttribute.prototype, {
		length: {
			get: function () {
				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
				return this.array.length;
			}
		}
	} );
	
	Object.defineProperties( THREE.BufferGeometry.prototype, {
		drawcalls: {
			get: function () {
				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;
			}
		},
		offsets: {
			get: function () {
				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;
			}
		},
		addIndex: {
			value: function ( index ) {
				console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
				this.setIndex( index );
			}
		},
		addDrawCall: {
			value: function ( start, count, indexOffset ) {
				if ( indexOffset !== undefined ) {
					console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
				}
				console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
				this.addGroup( start, count );
			}
		},
		clearDrawCalls: {
			value: function () {
				console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
				this.clearGroups();
			}
		},
		computeTangents: {
			value: function () {
				console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
			}
		},
		computeOffsets: {
			value: function () {
				console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE.Material.prototype, {
		wrapAround: {
			get: function () {
				console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
			},
			set: function ( value ) {
				console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
			}
		},
		wrapRGB: {
			get: function () {
				console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
				return new THREE.Color();
			}
		}
	} );
	
	Object.defineProperties( THREE, {
		PointCloudMaterial: {
			value: function ( parameters ) {
				console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
				return new THREE.PointsMaterial( parameters );
			}
		},
		ParticleBasicMaterial: {
			value: function ( parameters ) {
				console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
				return new THREE.PointsMaterial( parameters );
			}
		},
		ParticleSystemMaterial:{
			value: function ( parameters ) {
				console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
				return new THREE.PointsMaterial( parameters );
			}
		}
	} );
	
	Object.defineProperties( THREE.MeshPhongMaterial.prototype, {
		metal: {
			get: function () {
				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
				return false;
			},
			set: function ( value ) {
				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
			}
		}
	} );
	
	Object.defineProperties( THREE.ShaderMaterial.prototype, {
		derivatives: {
			get: function () {
				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;
			},
			set: function ( value ) {
				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE.WebGLRenderer.prototype, {
		supportsFloatTextures: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
				return this.extensions.get( 'OES_texture_float' );
			}
		},
		supportsHalfFloatTextures: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
				return this.extensions.get( 'OES_texture_half_float' );
			}
		},
		supportsStandardDerivatives: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
				return this.extensions.get( 'OES_standard_derivatives' );
			}
		},
		supportsCompressedTextureS3TC: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
			}
		},
		supportsCompressedTexturePVRTC: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
			}
		},
		supportsBlendMinMax: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
				return this.extensions.get( 'EXT_blend_minmax' );
			}
		},
		supportsVertexTextures: {
			value: function () {
				return this.capabilities.vertexTextures;
			}
		},
		supportsInstancedArrays: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
				return this.extensions.get( 'ANGLE_instanced_arrays' );
			}
		},
		enableScissorTest: {
			value: function ( boolean ) {
				console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
				this.setScissorTest( boolean );
			}
		},
		initMaterial: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
			}
		},
		addPrePlugin: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
			}
		},
		addPostPlugin: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
			}
		},
		updateShadowMap: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
			}
		},
		shadowMapEnabled: {
			get: function () {
				return this.shadowMap.enabled;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;
			}
		},
		shadowMapType: {
			get: function () {
				return this.shadowMap.type;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;
			}
		},
		shadowMapCullFace: {
			get: function () {
				return this.shadowMap.cullFace;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
				this.shadowMap.cullFace = value;
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE.WebGLRenderTarget.prototype, {
		wrapS: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;
			}
		},
		wrapT: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;
			}
		},
		magFilter: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;
			}
		},
		minFilter: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;
			}
		},
		anisotropy: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;
			}
		},
		offset: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;
			}
		},
		repeat: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;
			}
		},
		format: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;
			}
		},
		type: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;
			}
		},
		generateMipmaps: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;
			}
		}
	} );
	
	//
	
	THREE.GeometryUtils = {
	
		merge: function ( geometry1, geometry2, materialIndexOffset ) {
	
			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
	
			var matrix;
	
			if ( geometry2 instanceof THREE.Mesh ) {
	
				geometry2.matrixAutoUpdate && geometry2.updateMatrix();
	
				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;
	
			}
	
			geometry1.merge( geometry2, matrix, materialIndexOffset );
	
		},
	
		center: function ( geometry ) {
	
			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();
	
		}
	
	};
	
	THREE.ImageUtils = {
	
		crossOrigin: undefined,
	
		loadTexture: function ( url, mapping, onLoad, onError ) {
	
			console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );
	
			var loader = new THREE.TextureLoader();
			loader.setCrossOrigin( this.crossOrigin );
	
			var texture = loader.load( url, onLoad, undefined, onError );
	
			if ( mapping ) texture.mapping = mapping;
	
			return texture;
	
		},
	
		loadTextureCube: function ( urls, mapping, onLoad, onError ) {
	
			console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );
	
			var loader = new THREE.CubeTextureLoader();
			loader.setCrossOrigin( this.crossOrigin );
	
			var texture = loader.load( urls, onLoad, undefined, onError );
	
			if ( mapping ) texture.mapping = mapping;
	
			return texture;
	
		},
	
		loadCompressedTexture: function () {
	
			console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );
	
		},
	
		loadCompressedTextureCube: function () {
	
			console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );
	
		}
	
	};
	
	//
	
	THREE.Projector = function () {
	
		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );
	
		this.projectVector = function ( vector, camera ) {
	
			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );
	
		};
	
		this.unprojectVector = function ( vector, camera ) {
	
			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );
	
		};
	
		this.pickingRay = function ( vector, camera ) {
	
			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );
	
		};
	
	};
	
	//
	
	THREE.CanvasRenderer = function () {
	
		console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );
	
		this.domElement = document.createElement( 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};
	
	};
	
	//
	
	THREE.MeshFaceMaterial = THREE.MultiMaterial;
	
	// File:src/extras/CurveUtils.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.CurveUtils = {
	
		tangentQuadraticBezier: function ( t, p0, p1, p2 ) {
	
			return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );
	
		},
	
		// Puay Bing, thanks for helping with this derivative!
	
		tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {
	
			return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
				3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
				6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
				3 * t * t * p3;
	
		},
	
		tangentSpline: function ( t, p0, p1, p2, p3 ) {
	
			// To check if my formulas are correct
	
			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
			var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3 − t2
	
			return h00 + h10 + h01 + h11;
	
		},
	
		// Catmull-Rom
	
		interpolate: function( p0, p1, p2, p3, t ) {
	
			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
	};
	
	// File:src/extras/SceneUtils.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SceneUtils = {
	
		createMultiMaterialObject: function ( geometry, materials ) {
	
			var group = new THREE.Group();
	
			for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
				group.add( new THREE.Mesh( geometry, materials[ i ] ) );
	
			}
	
			return group;
	
		},
	
		detach: function ( child, parent, scene ) {
	
			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );
	
		},
	
		attach: function ( child, scene, parent ) {
	
			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse( parent.matrixWorld );
			child.applyMatrix( matrixWorldInverse );
	
			scene.remove( child );
			parent.add( child );
	
		}
	
	};
	
	// File:src/extras/ShapeUtils.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.ShapeUtils = {
	
		// calculate area of the contour polygon
	
		area: function ( contour ) {
	
			var n = contour.length;
			var a = 0.0;
	
			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
	
				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
	
			}
	
			return a * 0.5;
	
		},
	
		triangulate: ( function () {
	
			/**
			 * This code is a quick port of code written in C++ which was submitted to
			 * flipcode.com by John W. Ratcliff  // July 22, 2000
			 * See original code and more information here:
			 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
			 *
			 * ported to actionscript by Zevan Rosser
			 * www.actionsnippet.com
			 *
			 * ported to javascript by Joshua Koo
			 * http://www.lab4games.net/zz85/blog
			 *
			 */
	
			function snip( contour, u, v, w, n, verts ) {
	
				var p;
				var ax, ay, bx, by;
				var cx, cy, px, py;
	
				ax = contour[ verts[ u ] ].x;
				ay = contour[ verts[ u ] ].y;
	
				bx = contour[ verts[ v ] ].x;
				by = contour[ verts[ v ] ].y;
	
				cx = contour[ verts[ w ] ].x;
				cy = contour[ verts[ w ] ].y;
	
				if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;
	
				var aX, aY, bX, bY, cX, cY;
				var apx, apy, bpx, bpy, cpx, cpy;
				var cCROSSap, bCROSScp, aCROSSbp;
	
				aX = cx - bx;  aY = cy - by;
				bX = ax - cx;  bY = ay - cy;
				cX = bx - ax;  cY = by - ay;
	
				for ( p = 0; p < n; p ++ ) {
	
					px = contour[ verts[ p ] ].x;
					py = contour[ verts[ p ] ].y;
	
					if ( ( ( px === ax ) && ( py === ay ) ) ||
						 ( ( px === bx ) && ( py === by ) ) ||
						 ( ( px === cx ) && ( py === cy ) ) )	continue;
	
					apx = px - ax;  apy = py - ay;
					bpx = px - bx;  bpy = py - by;
					cpx = px - cx;  cpy = py - cy;
	
					// see if p is inside triangle abc
	
					aCROSSbp = aX * bpy - aY * bpx;
					cCROSSap = cX * apy - cY * apx;
					bCROSScp = bX * cpy - bY * cpx;
	
					if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;
	
				}
	
				return true;
	
			}
	
			// takes in an contour array and returns
	
			return function ( contour, indices ) {
	
				var n = contour.length;
	
				if ( n < 3 ) return null;
	
				var result = [],
					verts = [],
					vertIndices = [];
	
				/* we want a counter-clockwise polygon in verts */
	
				var u, v, w;
	
				if ( THREE.ShapeUtils.area( contour ) > 0.0 ) {
	
					for ( v = 0; v < n; v ++ ) verts[ v ] = v;
	
				} else {
	
					for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;
	
				}
	
				var nv = n;
	
				/*  remove nv - 2 vertices, creating 1 triangle every time */
	
				var count = 2 * nv;   /* error detection */
	
				for ( v = nv - 1; nv > 2; ) {
	
					/* if we loop, it is probably a non-simple polygon */
	
					if ( ( count -- ) <= 0 ) {
	
						//** Triangulate: ERROR - probable bad polygon!
	
						//throw ( "Warning, unable to triangulate polygon!" );
						//return null;
						// Sometimes warning is fine, especially polygons are triangulated in reverse.
						console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );
	
						if ( indices ) return vertIndices;
						return result;
	
					}
	
					/* three consecutive vertices in current polygon, <u,v,w> */
	
					u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
					v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
					w = v + 1;  if ( nv <= w ) w = 0;     /* next     */
	
					if ( snip( contour, u, v, w, nv, verts ) ) {
	
						var a, b, c, s, t;
	
						/* true names of the vertices */
	
						a = verts[ u ];
						b = verts[ v ];
						c = verts[ w ];
	
						/* output Triangle */
	
						result.push( [ contour[ a ],
							contour[ b ],
							contour[ c ] ] );
	
	
						vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );
	
						/* remove v from the remaining polygon */
	
						for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {
	
							verts[ s ] = verts[ t ];
	
						}
	
						nv --;
	
						/* reset error detection counter */
	
						count = 2 * nv;
	
					}
	
				}
	
				if ( indices ) return vertIndices;
				return result;
	
			}
	
		} )(),
	
		triangulateShape: function ( contour, holes ) {
	
			function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
	
				// inOtherPt needs to be collinear to the inSegment
				if ( inSegPt1.x !== inSegPt2.x ) {
	
					if ( inSegPt1.x < inSegPt2.x ) {
	
						return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
	
					} else {
	
						return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
	
					}
	
				} else {
	
					if ( inSegPt1.y < inSegPt2.y ) {
	
						return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
	
					} else {
	
						return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
	
					}
	
				}
	
			}
	
			function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
	
				var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
				var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
	
				var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
				var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
	
				var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
				var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
	
				if ( Math.abs( limit ) > Number.EPSILON ) {
	
					// not parallel
	
					var perpSeg2;
					if ( limit > 0 ) {
	
						if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
	
					} else {
	
						if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
	
					}
	
					// i.e. to reduce rounding errors
					// intersection at endpoint of segment#1?
					if ( perpSeg2 === 0 ) {
	
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt1 ];
	
					}
					if ( perpSeg2 === limit ) {
	
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt2 ];
	
					}
					// intersection at endpoint of segment#2?
					if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
					if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];
	
					// return real intersection point
					var factorSeg1 = perpSeg2 / limit;
					return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
								y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];
	
				} else {
	
					// parallel or collinear
					if ( ( perpSeg1 !== 0 ) ||
						 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];
	
					// they are collinear or degenerate
					var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
					var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
					// both segments are points
					if ( seg1Pt && seg2Pt ) {
	
						if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
							 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
						return [ inSeg1Pt1 ];                 						// they are the same point
	
					}
					// segment#1  is a single point
					if ( seg1Pt ) {
	
						if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
						return [ inSeg1Pt1 ];
	
					}
					// segment#2  is a single point
					if ( seg2Pt ) {
	
						if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
						return [ inSeg2Pt1 ];
	
					}
	
					// they are collinear segments, which might overlap
					var seg1min, seg1max, seg1minVal, seg1maxVal;
					var seg2min, seg2max, seg2minVal, seg2maxVal;
					if ( seg1dx !== 0 ) {
	
						// the segments are NOT on a vertical line
						if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
	
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
	
						} else {
	
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
	
						}
						if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
	
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
	
						} else {
	
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
	
						}
	
					} else {
	
						// the segments are on a vertical line
						if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
	
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
	
						} else {
	
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
	
						}
						if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
	
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
	
						} else {
	
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
	
						}
	
					}
					if ( seg1minVal <= seg2minVal ) {
	
						if ( seg1maxVal <  seg2minVal )	return [];
						if ( seg1maxVal === seg2minVal )	{
	
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg2min ];
	
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
						return	[ seg2min, seg2max ];
	
					} else {
	
						if ( seg1minVal >  seg2maxVal )	return [];
						if ( seg1minVal === seg2maxVal )	{
	
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg1min ];
	
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
						return	[ seg1min, seg2max ];
	
					}
	
				}
	
			}
	
			function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
	
				// The order of legs is important
	
				// translation of all points, so that Vertex is at (0,0)
				var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
				var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
				var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;
	
				// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
				var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
				var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;
	
				if ( Math.abs( from2toAngle ) > Number.EPSILON ) {
	
					// angle != 180 deg.
	
					var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
					// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
	
					if ( from2toAngle > 0 ) {
	
						// main angle < 180 deg.
						return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
	
					} else {
	
						// main angle > 180 deg.
						return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
	
					}
	
				} else {
	
					// angle == 180 deg.
					// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
					return	( from2otherAngle > 0 );
	
				}
	
			}
	
	
			function removeHoles( contour, holes ) {
	
				var shape = contour.concat(); // work on this shape
				var hole;
	
				function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
	
					// Check if hole point lies within angle around shape point
					var lastShapeIdx = shape.length - 1;
	
					var prevShapeIdx = inShapeIdx - 1;
					if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;
	
					var nextShapeIdx = inShapeIdx + 1;
					if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;
	
					var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
					if ( ! insideAngle ) {
	
						// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
						return	false;
	
					}
	
					// Check if shape point lies within angle around hole point
					var lastHoleIdx = hole.length - 1;
	
					var prevHoleIdx = inHoleIdx - 1;
					if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;
	
					var nextHoleIdx = inHoleIdx + 1;
					if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;
	
					insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
					if ( ! insideAngle ) {
	
						// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
						return	false;
	
					}
	
					return	true;
	
				}
	
				function intersectsShapeEdge( inShapePt, inHolePt ) {
	
					// checks for intersections with shape edges
					var sIdx, nextIdx, intersection;
					for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
	
						nextIdx = sIdx + 1; nextIdx %= shape.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;
	
					}
	
					return	false;
	
				}
	
				var indepHoles = [];
	
				function intersectsHoleEdge( inShapePt, inHolePt ) {
	
					// checks for intersections with hole edges
					var ihIdx, chkHole,
						hIdx, nextIdx, intersection;
					for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
	
						chkHole = holes[ indepHoles[ ihIdx ]];
						for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
	
							nextIdx = hIdx + 1; nextIdx %= chkHole.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;
	
						}
	
					}
					return	false;
	
				}
	
				var holeIndex, shapeIndex,
					shapePt, holePt,
					holeIdx, cutKey, failedCuts = [],
					tmpShape1, tmpShape2,
					tmpHole1, tmpHole2;
	
				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
					indepHoles.push( h );
	
				}
	
				var minShapeIndex = 0;
				var counter = indepHoles.length * 2;
				while ( indepHoles.length > 0 ) {
	
					counter --;
					if ( counter < 0 ) {
	
						console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
						break;
	
					}
	
					// search for shape-vertex and hole-vertex,
					// which can be connected without intersections
					for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {
	
						shapePt = shape[ shapeIndex ];
						holeIndex	= - 1;
	
						// search for hole which can be reached without intersections
						for ( var h = 0; h < indepHoles.length; h ++ ) {
	
							holeIdx = indepHoles[ h ];
	
							// prevent multiple checks
							cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
							if ( failedCuts[ cutKey ] !== undefined )			continue;
	
							hole = holes[ holeIdx ];
							for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
	
								holePt = hole[ h2 ];
								if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
								if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
								if ( intersectsHoleEdge( shapePt, holePt ) )		continue;
	
								holeIndex = h2;
								indepHoles.splice( h, 1 );
	
								tmpShape1 = shape.slice( 0, shapeIndex + 1 );
								tmpShape2 = shape.slice( shapeIndex );
								tmpHole1 = hole.slice( holeIndex );
								tmpHole2 = hole.slice( 0, holeIndex + 1 );
	
								shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );
	
								minShapeIndex = shapeIndex;
	
								// Debug only, to show the selected cuts
								// glob_CutLines.push( [ shapePt, holePt ] );
	
								break;
	
							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found
	
							failedCuts[ cutKey ] = true;			// remember failure
	
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found
	
					}
	
				}
	
				return shape; 			/* shape with no holes */
	
			}
	
	
			var i, il, f, face,
				key, index,
				allPointsMap = {};
	
			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
	
			var allpoints = contour.concat();
	
			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
				Array.prototype.push.apply( allpoints, holes[ h ] );
	
			}
	
			//console.log( "allpoints",allpoints, allpoints.length );
	
			// prepare all points map
	
			for ( i = 0, il = allpoints.length; i < il; i ++ ) {
	
				key = allpoints[ i ].x + ":" + allpoints[ i ].y;
	
				if ( allPointsMap[ key ] !== undefined ) {
	
					console.warn( "THREE.Shape: Duplicate point", key );
	
				}
	
				allPointsMap[ key ] = i;
	
			}
	
			// remove holes by cutting paths to holes and adding them to the shape
			var shapeWithoutHoles = removeHoles( contour, holes );
	
			var triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
			//console.log( "triangles",triangles, triangles.length );
	
			// check all face vertices against all points map
	
			for ( i = 0, il = triangles.length; i < il; i ++ ) {
	
				face = triangles[ i ];
	
				for ( f = 0; f < 3; f ++ ) {
	
					key = face[ f ].x + ":" + face[ f ].y;
	
					index = allPointsMap[ key ];
	
					if ( index !== undefined ) {
	
						face[ f ] = index;
	
					}
	
				}
	
			}
	
			return triangles.concat();
	
		},
	
		isClockWise: function ( pts ) {
	
			return THREE.ShapeUtils.area( pts ) < 0;
	
		},
	
		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve
	
		// Quad Bezier Functions
	
		b2: ( function () {
	
			function b2p0( t, p ) {
	
				var k = 1 - t;
				return k * k * p;
	
			}
	
			function b2p1( t, p ) {
	
				return 2 * ( 1 - t ) * t * p;
	
			}
	
			function b2p2( t, p ) {
	
				return t * t * p;
	
			}
	
			return function ( t, p0, p1, p2 ) {
	
				return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );
	
			};
	
		} )(),
	
		// Cubic Bezier Functions
	
		b3: ( function () {
	
			function b3p0( t, p ) {
	
				var k = 1 - t;
				return k * k * k * p;
	
			}
	
			function b3p1( t, p ) {
	
				var k = 1 - t;
				return 3 * k * k * t * p;
	
			}
	
			function b3p2( t, p ) {
	
				var k = 1 - t;
				return 3 * k * t * t * p;
	
			}
	
			function b3p3( t, p ) {
	
				return t * t * t * p;
	
			}
	
			return function ( t, p0, p1, p2, p3 ) {
	
				return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );
	
			};
	
		} )()
	
	};
	
	// File:src/extras/core/Curve.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 * THREE.ClosedSplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/
	
	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/
	
	THREE.Curve = function () {
	
	};
	
	THREE.Curve.prototype = {
	
		constructor: THREE.Curve,
	
		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]
	
		getPoint: function ( t ) {
	
			console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
			return null;
	
		},
	
		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]
	
		getPointAt: function ( u ) {
	
			var t = this.getUtoTmapping( u );
			return this.getPoint( t );
	
		},
	
		// Get sequence of points using getPoint( t )
	
		getPoints: function ( divisions ) {
	
			if ( ! divisions ) divisions = 5;
	
			var d, pts = [];
	
			for ( d = 0; d <= divisions; d ++ ) {
	
				pts.push( this.getPoint( d / divisions ) );
	
			}
	
			return pts;
	
		},
	
		// Get sequence of points using getPointAt( u )
	
		getSpacedPoints: function ( divisions ) {
	
			if ( ! divisions ) divisions = 5;
	
			var d, pts = [];
	
			for ( d = 0; d <= divisions; d ++ ) {
	
				pts.push( this.getPointAt( d / divisions ) );
	
			}
	
			return pts;
	
		},
	
		// Get total curve arc length
	
		getLength: function () {
	
			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];
	
		},
	
		// Get list of cumulative segment lengths
	
		getLengths: function ( divisions ) {
	
			if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;
	
			if ( this.cacheArcLengths
				&& ( this.cacheArcLengths.length === divisions + 1 )
				&& ! this.needsUpdate ) {
	
				//console.log( "cached", this.cacheArcLengths );
				return this.cacheArcLengths;
	
			}
	
			this.needsUpdate = false;
	
			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;
	
			cache.push( 0 );
	
			for ( p = 1; p <= divisions; p ++ ) {
	
				current = this.getPoint ( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;
	
			}
	
			this.cacheArcLengths = cache;
	
			return cache; // { sums: cache, sum:sum }; Sum is in the last element.
	
		},
	
		updateArcLengths: function() {
	
			this.needsUpdate = true;
			this.getLengths();
	
		},
	
		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
	
		getUtoTmapping: function ( u, distance ) {
	
			var arcLengths = this.getLengths();
	
			var i = 0, il = arcLengths.length;
	
			var targetArcLength; // The targeted u distance value to get
	
			if ( distance ) {
	
				targetArcLength = distance;
	
			} else {
	
				targetArcLength = u * arcLengths[ il - 1 ];
	
			}
	
			//var time = Date.now();
	
			// binary search for the index with largest value smaller than target u distance
	
			var low = 0, high = il - 1, comparison;
	
			while ( low <= high ) {
	
				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	
				comparison = arcLengths[ i ] - targetArcLength;
	
				if ( comparison < 0 ) {
	
					low = i + 1;
	
				} else if ( comparison > 0 ) {
	
					high = i - 1;
	
				} else {
	
					high = i;
					break;
	
					// DONE
	
				}
	
			}
	
			i = high;
	
			//console.log('b' , i, low, high, Date.now()- time);
	
			if ( arcLengths[ i ] === targetArcLength ) {
	
				var t = i / ( il - 1 );
				return t;
	
			}
	
			// we could get finer grain at lengths, or use simple interpolation between two points
	
			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];
	
			var segmentLength = lengthAfter - lengthBefore;
	
			// determine where we are between the 'before' and 'after' points
	
			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
	
			// add that fractional amount to t
	
			var t = ( i + segmentFraction ) / ( il - 1 );
	
			return t;
	
		},
	
		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation
	
		getTangent: function( t ) {
	
			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;
	
			// Capping in case of danger
	
			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;
	
			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );
	
			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();
	
		},
	
		getTangentAt: function ( u ) {
	
			var t = this.getUtoTmapping( u );
			return this.getTangent( t );
	
		}
	
	};
	
	// TODO: Transformation for Curves?
	
	/**************************************************************
	 *	3D Curves
	 **************************************************************/
	
	// A Factory method for creating new curve subclasses
	
	THREE.Curve.create = function ( constructor, getPointFunc ) {
	
		constructor.prototype = Object.create( THREE.Curve.prototype );
		constructor.prototype.constructor = constructor;
		constructor.prototype.getPoint = getPointFunc;
	
		return constructor;
	
	};
	
	// File:src/extras/core/CurvePath.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/
	
	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/
	
	THREE.CurvePath = function () {
	
		this.curves = [];
	
		this.autoClose = false; // Automatically closes the path
	
	};
	
	THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
	THREE.CurvePath.prototype.constructor = THREE.CurvePath;
	
	THREE.CurvePath.prototype.add = function ( curve ) {
	
		this.curves.push( curve );
	
	};
	
	/*
	THREE.CurvePath.prototype.checkConnection = function() {
		// TODO
		// If the ending of curve is not connected to the starting
		// or the next curve, then, this is not a real path
	};
	*/
	
	THREE.CurvePath.prototype.closePath = function() {
	
		// TODO Test
		// and verify for vector3 (needs to implement equals)
		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[ 0 ].getPoint( 0 );
		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );
	
		if ( ! startPoint.equals( endPoint ) ) {
	
			this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );
	
		}
	
	};
	
	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:
	
	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')
	
	THREE.CurvePath.prototype.getPoint = function( t ) {
	
		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0;
	
		// To think about boundaries points.
	
		while ( i < curveLengths.length ) {
	
			if ( curveLengths[ i ] >= d ) {
	
				var diff = curveLengths[ i ] - d;
				var curve = this.curves[ i ];
	
				var u = 1 - diff / curve.getLength();
	
				return curve.getPointAt( u );
	
			}
	
			i ++;
	
		}
	
		return null;
	
		// loop where sum != 0, sum > d , sum+1 <d
	
	};
	
	/*
	THREE.CurvePath.prototype.getTangent = function( t ) {
	};
	*/
	
	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength
	
	THREE.CurvePath.prototype.getLength = function() {
	
		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];
	
	};
	
	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.
	
	THREE.CurvePath.prototype.getCurveLengths = function() {
	
		// We use cache values if curves and cache array are same length
	
		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {
	
			return this.cacheLengths;
	
		}
	
		// Get length of sub-curve
		// Push sums into cached array
	
		var lengths = [], sums = 0;
	
		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {
	
			sums += this.curves[ i ].getLength();
			lengths.push( sums );
	
		}
	
		this.cacheLengths = lengths;
	
		return lengths;
	
	};
	
	
	
	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/
	
	/// Generate geometry from path points (for Line or Points objects)
	
	THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {
	
		var pts = this.getPoints( divisions );
		return this.createGeometry( pts );
	
	};
	
	// Generate geometry from equidistant sampling along the path
	
	THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {
	
		var pts = this.getSpacedPoints( divisions );
		return this.createGeometry( pts );
	
	};
	
	THREE.CurvePath.prototype.createGeometry = function( points ) {
	
		var geometry = new THREE.Geometry();
	
		for ( var i = 0, l = points.length; i < l; i ++ ) {
	
			var point = points[ i ];
			geometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );
	
		}
	
		return geometry;
	
	};
	
	// File:src/extras/core/Font.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Font = function ( data ) {
	
		this.data = data;
	
	};
	
	THREE.Font.prototype = {
	
		constructor: THREE.Font,
	
		generateShapes: function ( text, size, divisions ) {
	
			function createPaths( text ) {
	
				var chars = String( text ).split( '' );
				var scale = size / data.resolution;
				var offset = 0;
	
				var paths = [];
	
				for ( var i = 0; i < chars.length; i ++ ) {
	
					var ret = createPath( chars[ i ], scale, offset );
					offset += ret.offset;
	
					paths.push( ret.path );
	
				}
	
				return paths;
	
			}
	
			function createPath( c, scale, offset ) {
	
				var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];
	
				if ( ! glyph ) return;
	
				var path = new THREE.Path();
	
				var pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;
				var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
	
				if ( glyph.o ) {
	
					var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
	
					for ( var i = 0, l = outline.length; i < l; ) {
	
						var action = outline[ i ++ ];
	
						switch ( action ) {
	
							case 'm': // moveTo
	
								x = outline[ i ++ ] * scale + offset;
								y = outline[ i ++ ] * scale;
	
								path.moveTo( x, y );
	
								break;
	
							case 'l': // lineTo
	
								x = outline[ i ++ ] * scale + offset;
								y = outline[ i ++ ] * scale;
	
								path.lineTo( x, y );
	
								break;
	
							case 'q': // quadraticCurveTo
	
								cpx  = outline[ i ++ ] * scale + offset;
								cpy  = outline[ i ++ ] * scale;
								cpx1 = outline[ i ++ ] * scale + offset;
								cpy1 = outline[ i ++ ] * scale;
	
								path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );
	
								laste = pts[ pts.length - 1 ];
	
								if ( laste ) {
	
									cpx0 = laste.x;
									cpy0 = laste.y;
	
									for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
										var t = i2 / divisions;
										b2( t, cpx0, cpx1, cpx );
										b2( t, cpy0, cpy1, cpy );
	
									}
	
								}
	
								break;
	
							case 'b': // bezierCurveTo
	
								cpx  = outline[ i ++ ] * scale + offset;
								cpy  = outline[ i ++ ] * scale;
								cpx1 = outline[ i ++ ] * scale + offset;
								cpy1 = outline[ i ++ ] * scale;
								cpx2 = outline[ i ++ ] * scale + offset;
								cpy2 = outline[ i ++ ] * scale;
	
								path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );
	
								laste = pts[ pts.length - 1 ];
	
								if ( laste ) {
	
									cpx0 = laste.x;
									cpy0 = laste.y;
	
									for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
										var t = i2 / divisions;
										b3( t, cpx0, cpx1, cpx2, cpx );
										b3( t, cpy0, cpy1, cpy2, cpy );
	
									}
	
								}
	
								break;
	
						}
	
					}
	
				}
	
				return { offset: glyph.ha * scale, path: path };
	
			}
	
			//
	
			if ( size === undefined ) size = 100;
			if ( divisions === undefined ) divisions = 4;
	
			var data = this.data;
	
			var paths = createPaths( text );
			var shapes = [];
	
			for ( var p = 0, pl = paths.length; p < pl; p ++ ) {
	
				Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
	
			}
	
			return shapes;
	
		}
	
	};
	
	// File:src/extras/core/Path.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/
	
	THREE.Path = function ( points ) {
	
		THREE.CurvePath.call( this );
	
		this.actions = [];
	
		if ( points ) {
	
			this.fromPoints( points );
	
		}
	
	};
	
	THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
	THREE.Path.prototype.constructor = THREE.Path;
	
	// TODO Clean up PATH API
	
	// Create path using straight lines to connect all points
	// - vectors: array of Vector2
	
	THREE.Path.prototype.fromPoints = function ( vectors ) {
	
		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );
	
		for ( var i = 1, l = vectors.length; i < l; i ++ ) {
	
			this.lineTo( vectors[ i ].x, vectors[ i ].y );
	
		}
	
	};
	
	// startPath() endPath()?
	
	THREE.Path.prototype.moveTo = function ( x, y ) {
	
		this.actions.push( { action: 'moveTo', args: [ x, y ] } );
	
	};
	
	THREE.Path.prototype.lineTo = function ( x, y ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
		this.curves.push( curve );
	
		this.actions.push( { action: 'lineTo', args: [ x, y ] } );
	
	};
	
	THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.QuadraticBezierCurve(
			new THREE.Vector2( x0, y0 ),
			new THREE.Vector2( aCPx, aCPy ),
			new THREE.Vector2( aX, aY )
		);
	
		this.curves.push( curve );
	
		this.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );
	
	};
	
	THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.CubicBezierCurve(
			new THREE.Vector2( x0, y0 ),
			new THREE.Vector2( aCP1x, aCP1y ),
			new THREE.Vector2( aCP2x, aCP2y ),
			new THREE.Vector2( aX, aY )
		);
	
		this.curves.push( curve );
	
		this.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );
	
	};
	
	THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {
	
		var args = Array.prototype.slice.call( arguments );
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var npts = [ new THREE.Vector2( x0, y0 ) ];
		Array.prototype.push.apply( npts, pts );
	
		var curve = new THREE.SplineCurve( npts );
		this.curves.push( curve );
	
		this.actions.push( { action: 'splineThru', args: args } );
	
	};
	
	// FUTURE: Change the API or follow canvas API?
	
	THREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );
	
	 };
	
	 THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
	 };
	
	THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
	 };
	
	
	THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
		var args = [
			aX, aY,
			xRadius, yRadius,
			aStartAngle, aEndAngle,
			aClockwise,
			aRotation || 0 // aRotation is optional.
		];
	
		var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
		this.curves.push( curve );
	
		var lastPoint = curve.getPoint( 1 );
		args.push( lastPoint.x );
		args.push( lastPoint.y );
	
		this.actions.push( { action: 'ellipse', args: args } );
	
	 };
	
	THREE.Path.prototype.getSpacedPoints = function ( divisions ) {
	
		if ( ! divisions ) divisions = 40;
	
		var points = [];
	
		for ( var i = 0; i < divisions; i ++ ) {
	
			points.push( this.getPoint( i / divisions ) );
	
			//if ( !this.getPoint( i / divisions ) ) throw "DIE";
	
		}
	
		if ( this.autoClose ) {
	
			points.push( points[ 0 ] );
	
		}
	
		return points;
	
	};
	
	/* Return an array of vectors based on contour of the path */
	
	THREE.Path.prototype.getPoints = function( divisions ) {
	
		divisions = divisions || 12;
	
		var b2 = THREE.ShapeUtils.b2;
		var b3 = THREE.ShapeUtils.b3;
	
		var points = [];
	
		var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
			laste, tx, ty;
	
		for ( var i = 0, l = this.actions.length; i < l; i ++ ) {
	
			var item = this.actions[ i ];
	
			var action = item.action;
			var args = item.args;
	
			switch ( action ) {
	
			case 'moveTo':
	
				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );
	
				break;
	
			case 'lineTo':
	
				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );
	
				break;
	
			case 'quadraticCurveTo':
	
				cpx  = args[ 2 ];
				cpy  = args[ 3 ];
	
				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];
	
				if ( points.length > 0 ) {
	
					laste = points[ points.length - 1 ];
	
					cpx0 = laste.x;
					cpy0 = laste.y;
	
				} else {
	
					laste = this.actions[ i - 1 ].args;
	
					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];
	
				}
	
				for ( var j = 1; j <= divisions; j ++ ) {
	
					var t = j / divisions;
	
					tx = b2( t, cpx0, cpx1, cpx );
					ty = b2( t, cpy0, cpy1, cpy );
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				break;
	
			case 'bezierCurveTo':
	
				cpx  = args[ 4 ];
				cpy  = args[ 5 ];
	
				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];
	
				cpx2 = args[ 2 ];
				cpy2 = args[ 3 ];
	
				if ( points.length > 0 ) {
	
					laste = points[ points.length - 1 ];
	
					cpx0 = laste.x;
					cpy0 = laste.y;
	
				} else {
	
					laste = this.actions[ i - 1 ].args;
	
					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];
	
				}
	
	
				for ( var j = 1; j <= divisions; j ++ ) {
	
					var t = j / divisions;
	
					tx = b3( t, cpx0, cpx1, cpx2, cpx );
					ty = b3( t, cpy0, cpy1, cpy2, cpy );
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				break;
	
			case 'splineThru':
	
				laste = this.actions[ i - 1 ].args;
	
				var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
				var spts = [ last ];
	
				var n = divisions * args[ 0 ].length;
	
				spts = spts.concat( args[ 0 ] );
	
				var spline = new THREE.SplineCurve( spts );
	
				for ( var j = 1; j <= n; j ++ ) {
	
					points.push( spline.getPointAt( j / n ) );
	
				}
	
				break;
	
			case 'arc':
	
				var aX = args[ 0 ], aY = args[ 1 ],
					aRadius = args[ 2 ],
					aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
					aClockwise = !! args[ 5 ];
	
				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;
	
				for ( var j = 1; j <= tdivisions; j ++ ) {
	
					var t = j / tdivisions;
	
					if ( ! aClockwise ) {
	
						t = 1 - t;
	
					}
	
					angle = aStartAngle + t * deltaAngle;
	
					tx = aX + aRadius * Math.cos( angle );
					ty = aY + aRadius * Math.sin( angle );
	
					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				//console.log(points);
	
				break;
	
			case 'ellipse':
	
				var aX = args[ 0 ], aY = args[ 1 ],
					xRadius = args[ 2 ],
					yRadius = args[ 3 ],
					aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
					aClockwise = !! args[ 6 ],
					aRotation = args[ 7 ];
	
	
				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;
	
				var cos, sin;
				if ( aRotation !== 0 ) {
	
					cos = Math.cos( aRotation );
					sin = Math.sin( aRotation );
	
				}
	
				for ( var j = 1; j <= tdivisions; j ++ ) {
	
					var t = j / tdivisions;
	
					if ( ! aClockwise ) {
	
						t = 1 - t;
	
					}
	
					angle = aStartAngle + t * deltaAngle;
	
					tx = aX + xRadius * Math.cos( angle );
					ty = aY + yRadius * Math.sin( angle );
	
					if ( aRotation !== 0 ) {
	
						var x = tx, y = ty;
	
						// Rotate the point about the center of the ellipse.
						tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
						ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;
	
					}
	
					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				//console.log(points);
	
				break;
	
			} // end switch
	
		}
	
	
	
		// Normalize to remove the closing point by default.
		var lastPoint = points[ points.length - 1 ];
		if ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&
				 Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )
			points.splice( points.length - 1, 1 );
	
		if ( this.autoClose ) {
	
			points.push( points[ 0 ] );
	
		}
	
		return points;
	
	};
	
	//
	// Breaks path into shapes
	//
	//	Assumptions (if parameter isCCW==true the opposite holds):
	//	- solid shapes are defined clockwise (CW)
	//	- holes are defined counterclockwise (CCW)
	//
	//	If parameter noHoles==true:
	//  - all subPaths are regarded as solid shapes
	//  - definition order CW/CCW has no relevance
	//
	
	THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {
	
		function extractSubpaths( inActions ) {
	
			var subPaths = [], lastPath = new THREE.Path();
	
			for ( var i = 0, l = inActions.length; i < l; i ++ ) {
	
				var item = inActions[ i ];
	
				var args = item.args;
				var action = item.action;
	
				if ( action === 'moveTo' ) {
	
					if ( lastPath.actions.length !== 0 ) {
	
						subPaths.push( lastPath );
						lastPath = new THREE.Path();
	
					}
	
				}
	
				lastPath[ action ].apply( lastPath, args );
	
			}
	
			if ( lastPath.actions.length !== 0 ) {
	
				subPaths.push( lastPath );
	
			}
	
			// console.log(subPaths);
	
			return	subPaths;
	
		}
	
		function toShapesNoHoles( inSubpaths ) {
	
			var shapes = [];
	
			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {
	
				var tmpPath = inSubpaths[ i ];
	
				var tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;
	
				shapes.push( tmpShape );
	
			}
	
			//console.log("shape", shapes);
	
			return shapes;
	
		}
	
		function isPointInsidePolygon( inPt, inPolygon ) {
	
			var polyLen = inPolygon.length;
	
			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
	
				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];
	
				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;
	
				if ( Math.abs( edgeDy ) > Number.EPSILON ) {
	
					// not parallel
					if ( edgeDy < 0 ) {
	
						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
	
					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;
	
					if ( inPt.y === edgeLowPt.y ) {
	
						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!
	
					} else {
	
						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt
	
					}
	
				} else {
	
					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;
	
				}
	
			}
	
			return	inside;
	
		}
	
		var isClockWise = THREE.ShapeUtils.isClockWise;
	
		var subPaths = extractSubpaths( this.actions );
		if ( subPaths.length === 0 ) return [];
	
		if ( noHoles === true )	return	toShapesNoHoles( subPaths );
	
	
		var solid, tmpPath, tmpShape, shapes = [];
	
		if ( subPaths.length === 1 ) {
	
			tmpPath = subPaths[ 0 ];
			tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;
	
		}
	
		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;
	
		// console.log("Holes first", holesFirst);
	
		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;
	
		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];
	
		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {
	
			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;
	
			if ( solid ) {
	
				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;
	
				newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.actions = tmpPath.actions;
				newShapes[ mainIdx ].s.curves = tmpPath.curves;
	
				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];
	
				//console.log('cw', i);
	
			} else {
	
				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );
	
				//console.log('ccw', i);
	
			}
	
		}
	
		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );
	
	
		if ( newShapes.length > 1 ) {
	
			var ambiguous = false;
			var toChange = [];
	
			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
				betterShapeHoles[ sIdx ] = [];
	
			}
	
			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
				var sho = newShapeHoles[ sIdx ];
	
				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
	
					var ho = sho[ hIdx ];
					var hole_unassigned = true;
	
					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
	
						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {
	
							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {
	
								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );
	
							} else {
	
								ambiguous = true;
	
							}
	
						}
	
					}
					if ( hole_unassigned ) {
	
						betterShapeHoles[ sIdx ].push( ho );
	
					}
	
				}
	
			}
			// console.log("ambiguous: ", ambiguous);
			if ( toChange.length > 0 ) {
	
				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;
	
			}
	
		}
	
		var tmpHoles;
	
		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {
	
			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];
	
			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
	
				tmpShape.holes.push( tmpHoles[ j ].h );
	
			}
	
		}
	
		//console.log("shape", shapes);
	
		return shapes;
	
	};
	
	// File:src/extras/core/Shape.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/
	
	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.
	
	THREE.Shape = function () {
	
		THREE.Path.apply( this, arguments );
	
		this.holes = [];
	
	};
	
	THREE.Shape.prototype = Object.create( THREE.Path.prototype );
	THREE.Shape.prototype.constructor = THREE.Shape;
	
	// Convenience method to return ExtrudeGeometry
	
	THREE.Shape.prototype.extrude = function ( options ) {
	
		return new THREE.ExtrudeGeometry( this, options );
	
	};
	
	// Convenience method to return ShapeGeometry
	
	THREE.Shape.prototype.makeGeometry = function ( options ) {
	
		return new THREE.ShapeGeometry( this, options );
	
	};
	
	// Get points of holes
	
	THREE.Shape.prototype.getPointsHoles = function ( divisions ) {
	
		var holesPts = [];
	
		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {
	
			holesPts[ i ] = this.holes[ i ].getPoints( divisions );
	
		}
	
		return holesPts;
	
	};
	
	
	// Get points of shape and holes (keypoints based on segments parameter)
	
	THREE.Shape.prototype.extractAllPoints = function ( divisions ) {
	
		return {
	
			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )
	
		};
	
	};
	
	THREE.Shape.prototype.extractPoints = function ( divisions ) {
	
		return this.extractAllPoints( divisions );
	
	};
	
	// File:src/extras/curves/LineCurve.js
	
	/**************************************************************
	 *	Line
	 **************************************************************/
	
	THREE.LineCurve = function ( v1, v2 ) {
	
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.LineCurve.prototype.constructor = THREE.LineCurve;
	
	THREE.LineCurve.prototype.getPoint = function ( t ) {
	
		var point = this.v2.clone().sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );
	
		return point;
	
	};
	
	// Line curve is linear, so we can overwrite default getPointAt
	
	THREE.LineCurve.prototype.getPointAt = function ( u ) {
	
		return this.getPoint( u );
	
	};
	
	THREE.LineCurve.prototype.getTangent = function( t ) {
	
		var tangent = this.v2.clone().sub( this.v1 );
	
		return tangent.normalize();
	
	};
	
	// File:src/extras/curves/QuadraticBezierCurve.js
	
	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/
	
	
	THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
	
	
	THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {
	
		var b2 = THREE.ShapeUtils.b2;
	
		return new THREE.Vector2(
			b2( t, this.v0.x, this.v1.x, this.v2.x ),
			b2( t, this.v0.y, this.v1.y, this.v2.y )
		);
	
	};
	
	
	THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {
	
		var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;
	
		return new THREE.Vector2(
			tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
			tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
		).normalize();
	
	};
	
	// File:src/extras/curves/CubicBezierCurve.js
	
	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/
	
	THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;
	
	};
	
	THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
	
	THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {
	
		var b3 = THREE.ShapeUtils.b3;
	
		return new THREE.Vector2( 
			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
		);
	
	};
	
	THREE.CubicBezierCurve.prototype.getTangent = function( t ) {
	
		var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;
	
		return new THREE.Vector2( 
			tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
		).normalize();
	
	};
	
	// File:src/extras/curves/SplineCurve.js
	
	/**************************************************************
	 *	Spline curve
	 **************************************************************/
	
	THREE.SplineCurve = function ( points /* array of Vector2 */ ) {
	
		this.points = ( points == undefined ) ? [] : points;
	
	};
	
	THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
	
	THREE.SplineCurve.prototype.getPoint = function ( t ) {
	
		var points = this.points;
		var point = ( points.length - 1 ) * t;
	
		var intPoint = Math.floor( point );
		var weight = point - intPoint;
	
		var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
		var interpolate = THREE.CurveUtils.interpolate;
	
		return new THREE.Vector2(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight )
		);
	
	};
	
	// File:src/extras/curves/EllipseCurve.js
	
	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/
	
	THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
		this.aX = aX;
		this.aY = aY;
	
		this.xRadius = xRadius;
		this.yRadius = yRadius;
	
		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;
	
		this.aClockwise = aClockwise;
		
		this.aRotation = aRotation || 0;
	
	};
	
	THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
	
	THREE.EllipseCurve.prototype.getPoint = function ( t ) {
	
		var deltaAngle = this.aEndAngle - this.aStartAngle;
	
		if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
		if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;
	
		var angle;
	
		if ( this.aClockwise === true ) {
	
			angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );
	
		} else {
	
			angle = this.aStartAngle + t * deltaAngle;
	
		}
		
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );
	
		if ( this.aRotation !== 0 ) {
	
			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );
	
			var tx = x, ty = y;
	
			// Rotate the point about the center of the ellipse.
			x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
			y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;
	
		}
	
		return new THREE.Vector2( x, y );
	
	};
	
	// File:src/extras/curves/ArcCurve.js
	
	/**************************************************************
	 *	Arc curve
	 **************************************************************/
	
	THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
	};
	
	THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
	THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
	
	// File:src/extras/curves/LineCurve3.js
	
	/**************************************************************
	 *	Line3D
	 **************************************************************/
	
	THREE.LineCurve3 = THREE.Curve.create(
	
		function ( v1, v2 ) {
	
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			var vector = new THREE.Vector3();
	
			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );
	
			return vector;
	
		}
	
	);
	
	// File:src/extras/curves/QuadraticBezierCurve3.js
	
	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/
	
	THREE.QuadraticBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			var b2 = THREE.ShapeUtils.b2;		
	
			return new THREE.Vector3(
				b2( t, this.v0.x, this.v1.x, this.v2.x ),
				b2( t, this.v0.y, this.v1.y, this.v2.y ),
				b2( t, this.v0.z, this.v1.z, this.v2.z )
			);
	
		}
	
	);
	
	// File:src/extras/curves/CubicBezierCurve3.js
	
	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/
	
	THREE.CubicBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2, v3 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		},
	
		function ( t ) {
	
			var b3 = THREE.ShapeUtils.b3;
	
			return new THREE.Vector3(
				b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
				b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
				b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
			);
	
		}
	
	);
	
	// File:src/extras/curves/SplineCurve3.js
	
	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/
	
	
	THREE.SplineCurve3 = THREE.Curve.create(
	
		function ( points /* array of Vector3 */ ) {
	
			console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
			this.points = ( points == undefined ) ? [] : points;
	
		},
	
		function ( t ) {
	
			var points = this.points;
			var point = ( points.length - 1 ) * t;
	
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
			var interpolate = THREE.CurveUtils.interpolate;
	
			return new THREE.Vector3(
				interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
				interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
				interpolate( point0.z, point1.z, point2.z, point3.z, weight )
			);
	
		}
	
	);
	
	// File:src/extras/curves/CatmullRomCurve3.js
	
	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */
	
	THREE.CatmullRomCurve3 = ( function() {
	
		var
			tmp = new THREE.Vector3(),
			px = new CubicPoly(),
			py = new CubicPoly(),
			pz = new CubicPoly();
	
		/*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM
	
		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/
	
		function CubicPoly() {
	
		}
	
		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {
	
			this.c0 = x0;
			this.c1 = t0;
			this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
	
		};
	
		CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {
	
			// compute tangents when parameterized in [t1,t2]
			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;
	
			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;
	
			// initCubicPoly
			this.init( x1, x2, t1, t2 );
	
		};
	
		// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
		CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {
	
			this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
	
		};
	
		CubicPoly.prototype.calc = function( t ) {
	
			var t2 = t * t;
			var t3 = t2 * t;
			return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
	
		};
	
		// Subclass Three.js curve
		return THREE.Curve.create(
	
			function ( p /* array of Vector3 */ ) {
	
				this.points = p || [];
				this.closed = false;
	
			},
	
			function ( t ) {
	
				var points = this.points,
					point, intPoint, weight, l;
	
				l = points.length;
	
				if ( l < 2 ) console.log( 'duh, you need at least 2 points' );
	
				point = ( l - ( this.closed ? 0 : 1 ) ) * t;
				intPoint = Math.floor( point );
				weight = point - intPoint;
	
				if ( this.closed ) {
	
					intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
	
				} else if ( weight === 0 && intPoint === l - 1 ) {
	
					intPoint = l - 2;
					weight = 1;
	
				}
	
				var p0, p1, p2, p3; // 4 points
	
				if ( this.closed || intPoint > 0 ) {
	
					p0 = points[ ( intPoint - 1 ) % l ];
	
				} else {
	
					// extrapolate first point
					tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
					p0 = tmp;
	
				}
	
				p1 = points[ intPoint % l ];
				p2 = points[ ( intPoint + 1 ) % l ];
	
				if ( this.closed || intPoint + 2 < l ) {
	
					p3 = points[ ( intPoint + 2 ) % l ];
	
				} else {
	
					// extrapolate last point
					tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
					p3 = tmp;
	
				}
	
				if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {
	
					// init Centripetal / Chordal Catmull-Rom
					var pow = this.type === 'chordal' ? 0.5 : 0.25;
					var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
					var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
					var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );
	
					// safety check for repeated points
					if ( dt1 < 1e-4 ) dt1 = 1.0;
					if ( dt0 < 1e-4 ) dt0 = dt1;
					if ( dt2 < 1e-4 ) dt2 = dt1;
	
					px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
					py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
					pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );
	
				} else if ( this.type === 'catmullrom' ) {
	
					var tension = this.tension !== undefined ? this.tension : 0.5;
					px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
					py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
					pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );
	
				}
	
				var v = new THREE.Vector3(
					px.calc( weight ),
					py.calc( weight ),
					pz.calc( weight )
				);
	
				return v;
	
			}
	
		);
	
	} )();
	
	// File:src/extras/curves/ClosedSplineCurve3.js
	
	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/
	
	
	THREE.ClosedSplineCurve3 = function ( points ) {
	
		console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );
	
		THREE.CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
		this.closed = true;
	
	};
	
	THREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );
	
	// File:src/extras/geometries/BoxGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */
	
	THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'BoxGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};
	
		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
		this.depthSegments = depthSegments || 1;
	
		var scope = this;
	
		var width_half = width / 2;
		var height_half = height / 2;
		var depth_half = depth / 2;
	
		buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
		buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
		buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
		buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
		buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
		buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz
	
		function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {
	
			var w, ix, iy,
			gridX = scope.widthSegments,
			gridY = scope.heightSegments,
			width_half = width / 2,
			height_half = height / 2,
			offset = scope.vertices.length;
	
			if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {
	
				w = 'z';
	
			} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {
	
				w = 'y';
				gridY = scope.depthSegments;
	
			} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {
	
				w = 'x';
				gridX = scope.depthSegments;
	
			}
	
			var gridX1 = gridX + 1,
			gridY1 = gridY + 1,
			segment_width = width / gridX,
			segment_height = height / gridY,
			normal = new THREE.Vector3();
	
			normal[ w ] = depth > 0 ? 1 : - 1;
	
			for ( iy = 0; iy < gridY1; iy ++ ) {
	
				for ( ix = 0; ix < gridX1; ix ++ ) {
	
					var vector = new THREE.Vector3();
					vector[ u ] = ( ix * segment_width - width_half ) * udir;
					vector[ v ] = ( iy * segment_height - height_half ) * vdir;
					vector[ w ] = depth;
	
					scope.vertices.push( vector );
	
				}
	
			}
	
			for ( iy = 0; iy < gridY; iy ++ ) {
	
				for ( ix = 0; ix < gridX; ix ++ ) {
	
					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;
	
					var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
					var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
					var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
					var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );
	
					var face = new THREE.Face3( a + offset, b + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;
	
					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
					face = new THREE.Face3( b + offset, c + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;
	
					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
				}
	
			}
	
		}
	
		this.mergeVertices();
	
	};
	
	THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
	
	THREE.CubeGeometry = THREE.BoxGeometry;
	
	// File:src/extras/geometries/CircleGeometry.js
	
	/**
	 * @author hughes
	 */
	
	THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'CircleGeometry';
	
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
	
	};
	
	THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
	
	// File:src/extras/geometries/CircleBufferGeometry.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'CircleBufferGeometry';
	
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radius = radius || 50;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		var vertices = segments + 2;
	
		var positions = new Float32Array( vertices * 3 );
		var normals = new Float32Array( vertices * 3 );
		var uvs = new Float32Array( vertices * 2 );
	
		// center data is already zero, but need to set a few extras
		normals[ 2 ] = 1.0;
		uvs[ 0 ] = 0.5;
		uvs[ 1 ] = 0.5;
	
		for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {
	
			var segment = thetaStart + s / segments * thetaLength;
	
			positions[ i ] = radius * Math.cos( segment );
			positions[ i + 1 ] = radius * Math.sin( segment );
	
			normals[ i + 2 ] = 1; // normal z
	
			uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
			uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;
	
		}
	
		var indices = [];
	
		for ( var i = 1; i <= segments; i ++ ) {
	
			indices.push( i, i + 1, 0 );
	
		}
	
		this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;
	
	// File:src/extras/geometries/CylinderGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'CylinderGeometry';
	
		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radiusTop = radiusTop !== undefined ? radiusTop : 20;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		height = height !== undefined ? height : 100;
	
		radialSegments = radialSegments || 8;
		heightSegments = heightSegments || 1;
	
		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
	
		var heightHalf = height / 2;
	
		var x, y, vertices = [], uvs = [];
	
		for ( y = 0; y <= heightSegments; y ++ ) {
	
			var verticesRow = [];
			var uvsRow = [];
	
			var v = y / heightSegments;
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
	
			for ( x = 0; x <= radialSegments; x ++ ) {
	
				var u = x / radialSegments;
	
				var vertex = new THREE.Vector3();
				vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
				vertex.y = - v * height + heightHalf;
				vertex.z = radius * Math.cos( u * thetaLength + thetaStart );
	
				this.vertices.push( vertex );
	
				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );
	
			}
	
			vertices.push( verticesRow );
			uvs.push( uvsRow );
	
		}
	
		var tanTheta = ( radiusBottom - radiusTop ) / height;
		var na, nb;
	
		for ( x = 0; x < radialSegments; x ++ ) {
	
			if ( radiusTop !== 0 ) {
	
				na = this.vertices[ vertices[ 0 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();
	
			} else {
	
				na = this.vertices[ vertices[ 1 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();
	
			}
	
			na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
			nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();
	
			for ( y = 0; y < heightSegments; y ++ ) {
	
				var v1 = vertices[ y ][ x ];
				var v2 = vertices[ y + 1 ][ x ];
				var v3 = vertices[ y + 1 ][ x + 1 ];
				var v4 = vertices[ y ][ x + 1 ];
	
				var n1 = na.clone();
				var n2 = na.clone();
				var n3 = nb.clone();
				var n4 = nb.clone();
	
				var uv1 = uvs[ y ][ x ].clone();
				var uv2 = uvs[ y + 1 ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
				var uv4 = uvs[ y ][ x + 1 ].clone();
	
				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );
	
				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );
	
			}
	
		}
	
		// top cap
	
		if ( openEnded === false && radiusTop > 0 ) {
	
			this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				var v1 = vertices[ 0 ][ x ];
				var v2 = vertices[ 0 ][ x + 1 ];
				var v3 = this.vertices.length - 1;
	
				var n1 = new THREE.Vector3( 0, 1, 0 );
				var n2 = new THREE.Vector3( 0, 1, 0 );
				var n3 = new THREE.Vector3( 0, 1, 0 );
	
				var uv1 = uvs[ 0 ][ x ].clone();
				var uv2 = uvs[ 0 ][ x + 1 ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 0 );
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
			}
	
		}
	
		// bottom cap
	
		if ( openEnded === false && radiusBottom > 0 ) {
	
			this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				var v1 = vertices[ heightSegments ][ x + 1 ];
				var v2 = vertices[ heightSegments ][ x ];
				var v3 = this.vertices.length - 1;
	
				var n1 = new THREE.Vector3( 0, - 1, 0 );
				var n2 = new THREE.Vector3( 0, - 1, 0 );
				var n3 = new THREE.Vector3( 0, - 1, 0 );
	
				var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
				var uv2 = uvs[ heightSegments ][ x ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 1 );
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
			}
	
		}
	
		this.computeFaceNormals();
	
	};
	
	THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
	
	// File:src/extras/geometries/EdgesGeometry.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {
	
		THREE.BufferGeometry.call( this );
	
		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;
	
		var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );
	
		var edge = [ 0, 0 ], hash = {};
	
		function sortFunction( a, b ) {
	
			return a - b;
	
		}
	
		var keys = [ 'a', 'b', 'c' ];
	
		var geometry2;
	
		if ( geometry instanceof THREE.BufferGeometry ) {
	
			geometry2 = new THREE.Geometry();
			geometry2.fromBufferGeometry( geometry );
	
		} else {
	
			geometry2 = geometry.clone();
	
		}
	
		geometry2.mergeVertices();
		geometry2.computeFaceNormals();
	
		var vertices = geometry2.vertices;
		var faces = geometry2.faces;
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			var face = faces[ i ];
	
			for ( var j = 0; j < 3; j ++ ) {
	
				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );
	
				var key = edge.toString();
	
				if ( hash[ key ] === undefined ) {
	
					hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
	
				} else {
	
					hash[ key ].face2 = i;
	
				}
	
			}
	
		}
	
		var coords = [];
	
		for ( var key in hash ) {
	
			var h = hash[ key ];
	
			if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {
	
				var vertex = vertices[ h.vert1 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );
	
				vertex = vertices[ h.vert2 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );
	
			}
	
		}
	
		this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );
	
	};
	
	THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;
	
	// File:src/extras/geometries/ExtrudeGeometry.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ExtrudeGeometry = function ( shapes, options ) {
	
		if ( typeof( shapes ) === "undefined" ) {
	
			shapes = [];
			return;
	
		}
	
		THREE.Geometry.call( this );
	
		this.type = 'ExtrudeGeometry';
	
		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];
	
		this.addShapeList( shapes, options );
	
		this.computeFaceNormals();
	
		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides
	
		//this.computeVertexNormals();
	
		//console.log( "took", ( Date.now() - startTime ) );
	
	};
	
	THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
	
	THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
		var sl = shapes.length;
	
		for ( var s = 0; s < sl; s ++ ) {
	
			var shape = shapes[ s ];
			this.addShape( shape, options );
	
		}
	
	};
	
	THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {
	
		var amount = options.amount !== undefined ? options.amount : 100;
	
		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	
		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false
	
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var steps = options.steps !== undefined ? options.steps : 1;
	
		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;
	
		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
	
		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {
	
			extrudePts = extrudePath.getSpacedPoints( steps );
	
			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion
	
			// SETUP TNB variables
	
			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?
	
			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );
	
			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	
			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();
	
		}
	
		// Safeguards if bevels are not enabled
	
		if ( ! bevelEnabled ) {
	
			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;
	
		}
	
		// Variables initialization
	
		var ahole, h, hl; // looping of holes
		var scope = this;
	
		var shapesOffset = this.vertices.length;
	
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = ! THREE.ShapeUtils.isClockWise( vertices );
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe ...
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				if ( THREE.ShapeUtils.isClockWise( ahole ) ) {
	
					holes[ h ] = ahole.reverse();
	
				}
	
			}
	
			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
	
		}
	
	
		var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );
	
		/* Vertices */
	
		var contour = vertices; // vertices has all points but contour has only points of circumference
	
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			vertices = vertices.concat( ahole );
	
		}
	
	
		function scalePt2 ( pt, vec, size ) {
	
			if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );
	
			return vec.clone().multiplyScalar( size ).add( pt );
	
		}
	
		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;
	
	
		// Find directions for point movement
	
	
		function getBevelVec( inPt, inPrev, inNext ) {
	
			// computes for inPt the corresponding point inPt' on a new contour
			//   shifted by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.
	
			var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt
	
			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html
	
			var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
	
			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
	
			// check for collinear edges
			var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
			if ( Math.abs( collinear0 ) > Number.EPSILON ) {
	
				// not collinear
	
				// length of vectors for normalizing
	
				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
	
				// shift adjacent points by unit vectors to the left
	
				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
	
				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
				// scaling factor for v_prev to intersection point
	
				var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
						  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
				// vector from inPt to intersection point
	
				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
				if ( v_trans_lensq <= 2 ) {
	
					return	new THREE.Vector2( v_trans_x, v_trans_y );
	
				} else {
	
					shrink_by = Math.sqrt( v_trans_lensq / 2 );
	
				}
	
			} else {
	
				// handle special case of collinear edges
	
				var direction_eq = false;		// assumes: opposite
				if ( v_prev_x > Number.EPSILON ) {
	
					if ( v_next_x > Number.EPSILON ) {
	
						direction_eq = true;
	
					}
	
				} else {
	
					if ( v_prev_x < - Number.EPSILON ) {
	
						if ( v_next_x < - Number.EPSILON ) {
	
							direction_eq = true;
	
						}
	
					} else {
	
						if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {
	
							direction_eq = true;
	
						}
	
					}
	
				}
	
				if ( direction_eq ) {
	
					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y =  v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );
	
				} else {
	
					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );
	
				}
	
			}
	
			return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );
	
		}
	
	
		var contourMovements = [];
	
		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
			if ( j === il ) j = 0;
			if ( k === il ) k = 0;
	
			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)
	
			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
	
		}
	
		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
	
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			oneHoleMovements = [];
	
			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
				if ( j === il ) j = 0;
				if ( k === il ) k = 0;
	
				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
	
			}
	
			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );
	
		}
	
	
		// Loop bevelSegments, 1 for the front, 1 for the back
	
		for ( b = 0; b < bevelSegments; b ++ ) {
	
			//for ( b = bevelSegments; b > 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
	
			//z = bevelThickness * t;
			bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
			//bs = bevelSize * t; // linear
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
	
				v( vert.x, vert.y,  - z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
					v( vert.x, vert.y,  - z );
	
				}
	
			}
	
		}
	
		bs = bevelSize;
	
		// Back facing vertices
	
		for ( i = 0; i < vlen; i ++ ) {
	
			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
			if ( ! extrudeByPath ) {
	
				v( vert.x, vert.y, 0 );
	
			} else {
	
				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
	
				normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );
	
				position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );
	
				v( position2.x, position2.y, position2.z );
	
			}
	
		}
	
		// Add stepped vertices...
		// Including front facing vertices
	
		var s;
	
		for ( s = 1; s <= steps; s ++ ) {
	
			for ( i = 0; i < vlen; i ++ ) {
	
				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
				if ( ! extrudeByPath ) {
	
					v( vert.x, vert.y, amount / steps * s );
	
				} else {
	
					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
	
					normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );
	
					position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );
	
					v( position2.x, position2.y, position2.z );
	
				}
	
			}
	
		}
	
	
		// Add bevel segments planes
	
		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin ( t * Math.PI / 2 );
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y,  amount + z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
					if ( ! extrudeByPath ) {
	
						v( vert.x, vert.y,  amount + z );
	
					} else {
	
						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
	
					}
	
				}
	
			}
	
		}
	
		/* Faces */
	
		// Top and bottom faces
	
		buildLidFaces();
	
		// Sides faces
	
		buildSideFaces();
	
	
		/////  Internal functions
	
		function buildLidFaces() {
	
			if ( bevelEnabled ) {
	
				var layer = 0; // steps + 1
				var offset = vlen * layer;
	
				// Bottom faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );
	
				}
	
				layer = steps + bevelSegments * 2;
				offset = vlen * layer;
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );
	
				}
	
			} else {
	
				// Bottom faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );
	
				}
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );
	
				}
	
			}
	
		}
	
		// Create faces for the z-sides of the shape
	
		function buildSideFaces() {
	
			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );
	
				//, true
				layeroffset += ahole.length;
	
			}
	
		}
	
		function sidewalls( contour, layeroffset ) {
	
			var j, k;
			i = contour.length;
	
			while ( -- i >= 0 ) {
	
				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;
	
				//console.log('b', i,j, i-1, k,vertices.length);
	
				var s = 0, sl = steps  + bevelSegments * 2;
	
				for ( s = 0; s < sl; s ++ ) {
	
					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );
	
					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;
	
					f4( a, b, c, d, contour, s, sl, j, k );
	
				}
	
			}
	
		}
	
	
		function v( x, y, z ) {
	
			scope.vertices.push( new THREE.Vector3( x, y, z ) );
	
		}
	
		function f3( a, b, c ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
	
			scope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );
	
			var uvs = uvgen.generateTopUV( scope, a, b, c );
	
			scope.faceVertexUvs[ 0 ].push( uvs );
	
		}
	
		function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;
	
			scope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );
			scope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );
	
			var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );
	
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );
	
		}
	
	};
	
	THREE.ExtrudeGeometry.WorldUVGenerator = {
	
		generateTopUV: function ( geometry, indexA, indexB, indexC ) {
	
			var vertices = geometry.vertices;
	
			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
	
			return [
				new THREE.Vector2( a.x, a.y ),
				new THREE.Vector2( b.x, b.y ),
				new THREE.Vector2( c.x, c.y )
			];
	
		},
	
		generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {
	
			var vertices = geometry.vertices;
	
			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
			var d = vertices[ indexD ];
	
			if ( Math.abs( a.y - b.y ) < 0.01 ) {
	
				return [
					new THREE.Vector2( a.x, 1 - a.z ),
					new THREE.Vector2( b.x, 1 - b.z ),
					new THREE.Vector2( c.x, 1 - c.z ),
					new THREE.Vector2( d.x, 1 - d.z )
				];
	
			} else {
	
				return [
					new THREE.Vector2( a.y, 1 - a.z ),
					new THREE.Vector2( b.y, 1 - b.z ),
					new THREE.Vector2( c.y, 1 - c.z ),
					new THREE.Vector2( d.y, 1 - d.z )
				];
	
			}
	
		}
	};
	
	// File:src/extras/geometries/ShapeGeometry.js
	
	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ShapeGeometry = function ( shapes, options ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'ShapeGeometry';
	
		if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];
	
		this.addShapeList( shapes, options );
	
		this.computeFaceNormals();
	
	};
	
	THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
	
	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
		for ( var i = 0, l = shapes.length; i < l; i ++ ) {
	
			this.addShape( shapes[ i ], options );
	
		}
	
		return this;
	
	};
	
	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {
	
		if ( options === undefined ) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
	
		//
	
		var i, l, hole;
	
		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = ! THREE.ShapeUtils.isClockWise( vertices );
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe...
	
			for ( i = 0, l = holes.length; i < l; i ++ ) {
	
				hole = holes[ i ];
	
				if ( THREE.ShapeUtils.isClockWise( hole ) ) {
	
					holes[ i ] = hole.reverse();
	
				}
	
			}
	
			reverse = false;
	
		}
	
		var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );
	
		// Vertices
	
		for ( i = 0, l = holes.length; i < l; i ++ ) {
	
			hole = holes[ i ];
			vertices = vertices.concat( hole );
	
		}
	
		//
	
		var vert, vlen = vertices.length;
		var face, flen = faces.length;
	
		for ( i = 0; i < vlen; i ++ ) {
	
			vert = vertices[ i ];
	
			this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );
	
		}
	
		for ( i = 0; i < flen; i ++ ) {
	
			face = faces[ i ];
	
			var a = face[ 0 ] + shapesOffset;
			var b = face[ 1 ] + shapesOffset;
			var c = face[ 2 ] + shapesOffset;
	
			this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
			this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );
	
		}
	
	};
	
	// File:src/extras/geometries/LatheGeometry.js
	
	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 */
	
	// points - to create a closed torus, one must use a set of points
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2*PI) range of the lathed section
	//    2*pi is a closed lathe, less than 2PI is a portion.
	
	THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'LatheGeometry';
	
		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};
	
		segments = segments || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || 2 * Math.PI;
	
		var inversePointLength = 1.0 / ( points.length - 1 );
		var inverseSegments = 1.0 / segments;
	
		for ( var i = 0, il = segments; i <= il; i ++ ) {
	
			var phi = phiStart + i * inverseSegments * phiLength;
	
			var sin = Math.sin( phi );
			var cos = Math.cos( phi );
	
			for ( var j = 0, jl = points.length; j < jl; j ++ ) {
	
				var point = points[ j ];
	
				var vertex = new THREE.Vector3();
	
				vertex.x = point.x * sin;
				vertex.y = point.y;
				vertex.z = point.x * cos;
	
				this.vertices.push( vertex );
	
			}
	
		}
	
		var np = points.length;
	
		for ( var i = 0, il = segments; i < il; i ++ ) {
	
			for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {
	
				var base = j + np * i;
				var a = base;
				var b = base + np;
				var c = base + 1 + np;
				var d = base + 1;
	
				var u0 = i * inverseSegments;
				var v0 = j * inversePointLength;
				var u1 = u0 + inverseSegments;
				var v1 = v0 + inversePointLength;
	
				this.faces.push( new THREE.Face3( a, b, d ) );
	
				this.faceVertexUvs[ 0 ].push( [
	
					new THREE.Vector2( u0, v0 ),
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u0, v1 )
	
				] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
	
				this.faceVertexUvs[ 0 ].push( [
	
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u1, v1 ),
					new THREE.Vector2( u0, v1 )
	
				] );
	
	
			}
	
		}
	
		this.mergeVertices();
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
	
	// File:src/extras/geometries/PlaneGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	
	THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'PlaneGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
	
		this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
	
	};
	
	THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
	
	// File:src/extras/geometries/PlaneBufferGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	
	THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'PlaneBufferGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
	
		var width_half = width / 2;
		var height_half = height / 2;
	
		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;
	
		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;
	
		var segment_width = width / gridX;
		var segment_height = height / gridY;
	
		var vertices = new Float32Array( gridX1 * gridY1 * 3 );
		var normals = new Float32Array( gridX1 * gridY1 * 3 );
		var uvs = new Float32Array( gridX1 * gridY1 * 2 );
	
		var offset = 0;
		var offset2 = 0;
	
		for ( var iy = 0; iy < gridY1; iy ++ ) {
	
			var y = iy * segment_height - height_half;
	
			for ( var ix = 0; ix < gridX1; ix ++ ) {
	
				var x = ix * segment_width - width_half;
	
				vertices[ offset ] = x;
				vertices[ offset + 1 ] = - y;
	
				normals[ offset + 2 ] = 1;
	
				uvs[ offset2 ] = ix / gridX;
				uvs[ offset2 + 1 ] = 1 - ( iy / gridY );
	
				offset += 3;
				offset2 += 2;
	
			}
	
		}
	
		offset = 0;
	
		var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );
	
		for ( var iy = 0; iy < gridY; iy ++ ) {
	
			for ( var ix = 0; ix < gridX; ix ++ ) {
	
				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;
	
				indices[ offset ] = a;
				indices[ offset + 1 ] = b;
				indices[ offset + 2 ] = d;
	
				indices[ offset + 3 ] = b;
				indices[ offset + 4 ] = c;
				indices[ offset + 5 ] = d;
	
				offset += 6;
	
			}
	
		}
	
		this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
	};
	
	THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
	
	// File:src/extras/geometries/RingGeometry.js
	
	/**
	 * @author Kaleb Murphy
	 */
	
	THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'RingGeometry';
	
		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		innerRadius = innerRadius || 0;
		outerRadius = outerRadius || 50;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;
	
		var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
	
		for ( i = 0; i < phiSegments + 1; i ++ ) {
	
			// concentric circles inside ring
	
			for ( o = 0; o < thetaSegments + 1; o ++ ) {
	
				// number of segments per circle
	
				var vertex = new THREE.Vector3();
				var segment = thetaStart + o / thetaSegments * thetaLength;
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );
	
				this.vertices.push( vertex );
				uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
	
			}
	
			radius += radiusStep;
	
		}
	
		var n = new THREE.Vector3( 0, 0, 1 );
	
		for ( i = 0; i < phiSegments; i ++ ) {
	
			// concentric circles inside ring
	
			var thetaSegment = i * ( thetaSegments + 1 );
	
			for ( o = 0; o < thetaSegments ; o ++ ) {
	
				// number of segments per circle
	
				var segment = o + thetaSegment;
	
				var v1 = segment;
				var v2 = segment + thetaSegments + 1;
				var v3 = segment + thetaSegments + 2;
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );
	
				v1 = segment;
				v2 = segment + thetaSegments + 2;
				v3 = segment + 1;
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
	
	// File:src/extras/geometries/SphereGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'SphereGeometry';
	
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
	
	};
	
	THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
	
	// File:src/extras/geometries/SphereBufferGeometry.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * based on THREE.SphereGeometry
	 */
	
	THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'SphereBufferGeometry';
	
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radius = radius || 50;
	
		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
	
		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	
		var thetaEnd = thetaStart + thetaLength;
	
		var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );
	
		var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );
	
		var index = 0, vertices = [], normal = new THREE.Vector3();
	
		for ( var y = 0; y <= heightSegments; y ++ ) {
	
			var verticesRow = [];
	
			var v = y / heightSegments;
	
			for ( var x = 0; x <= widthSegments; x ++ ) {
	
				var u = x / widthSegments;
	
				var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				var py = radius * Math.cos( thetaStart + v * thetaLength );
				var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	
				normal.set( px, py, pz ).normalize();
	
				positions.setXYZ( index, px, py, pz );
				normals.setXYZ( index, normal.x, normal.y, normal.z );
				uvs.setXY( index, u, 1 - v );
	
				verticesRow.push( index );
	
				index ++;
	
			}
	
			vertices.push( verticesRow );
	
		}
	
		var indices = [];
	
		for ( var y = 0; y < heightSegments; y ++ ) {
	
			for ( var x = 0; x < widthSegments; x ++ ) {
	
				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = vertices[ y + 1 ][ x ];
				var v4 = vertices[ y + 1 ][ x + 1 ];
	
				if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
				if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );
	
			}
	
		}
	
		this.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );
		this.addAttribute( 'position', positions );
		this.addAttribute( 'normal', normals );
		this.addAttribute( 'uv', uvs );
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;
	
	// File:src/extras/geometries/TextGeometry.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */
	
	THREE.TextGeometry = function ( text, parameters ) {
	
		parameters = parameters || {};
	
		var font = parameters.font;
	
		if ( font instanceof THREE.Font === false ) {
	
			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new THREE.Geometry();
	
		}
	
		var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );
	
		// translate parameters to ExtrudeGeometry API
	
		parameters.amount = parameters.height !== undefined ? parameters.height : 50;
	
		// defaults
	
		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
	
		THREE.ExtrudeGeometry.call( this, shapes, parameters );
	
		this.type = 'TextGeometry';
	
	};
	
	THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
	THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;
	
	// File:src/extras/geometries/TorusGeometry.js
	
	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */
	
	THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TorusGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};
	
		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 8;
		tubularSegments = tubularSegments || 6;
		arc = arc || Math.PI * 2;
	
		var center = new THREE.Vector3(), uvs = [], normals = [];
	
		for ( var j = 0; j <= radialSegments; j ++ ) {
	
			for ( var i = 0; i <= tubularSegments; i ++ ) {
	
				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;
	
				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
	
				var vertex = new THREE.Vector3();
				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );
	
				this.vertices.push( vertex );
	
				uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
				normals.push( vertex.clone().sub( center ).normalize() );
	
			}
	
		}
	
		for ( var j = 1; j <= radialSegments; j ++ ) {
	
			for ( var i = 1; i <= tubularSegments; i ++ ) {
	
				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;
	
				var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );
	
				face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
	
	};
	
	THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
	
	// File:src/extras/geometries/TorusKnotGeometry.js
	
	/**
	 * @author oosmoxiecode
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
	 */
	
	THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TorusKnotGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			p: p,
			q: q,
			heightScale: heightScale
		};
	
		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 64;
		tubularSegments = tubularSegments || 8;
		p = p || 2;
		q = q || 3;
		heightScale = heightScale || 1;
	
		var grid = new Array( radialSegments );
		var tang = new THREE.Vector3();
		var n = new THREE.Vector3();
		var bitan = new THREE.Vector3();
	
		for ( var i = 0; i < radialSegments; ++ i ) {
	
			grid[ i ] = new Array( tubularSegments );
			var u = i / radialSegments * 2 * p * Math.PI;
			var p1 = getPos( u, q, p, radius, heightScale );
			var p2 = getPos( u + 0.01, q, p, radius, heightScale );
			tang.subVectors( p2, p1 );
			n.addVectors( p2, p1 );
	
			bitan.crossVectors( tang, n );
			n.crossVectors( bitan, tang );
			bitan.normalize();
			n.normalize();
	
			for ( var j = 0; j < tubularSegments; ++ j ) {
	
				var v = j / tubularSegments * 2 * Math.PI;
				var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				var cy = tube * Math.sin( v );
	
				var pos = new THREE.Vector3();
				pos.x = p1.x + cx * n.x + cy * bitan.x;
				pos.y = p1.y + cx * n.y + cy * bitan.y;
				pos.z = p1.z + cx * n.z + cy * bitan.z;
	
				grid[ i ][ j ] = this.vertices.push( pos ) - 1;
	
			}
	
		}
	
		for ( var i = 0; i < radialSegments; ++ i ) {
	
			for ( var j = 0; j < tubularSegments; ++ j ) {
	
				var ip = ( i + 1 ) % radialSegments;
				var jp = ( j + 1 ) % tubularSegments;
	
				var a = grid[ i ][ j ];
				var b = grid[ ip ][ j ];
				var c = grid[ ip ][ jp ];
				var d = grid[ i ][ jp ];
	
				var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
				var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
				var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
				var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );
	
				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
		function getPos( u, in_q, in_p, radius, heightScale ) {
	
			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = in_q / in_p * u;
			var cs = Math.cos( quOverP );
	
			var tx = radius * ( 2 + cs ) * 0.5 * cu;
			var ty = radius * ( 2 + cs ) * su * 0.5;
			var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;
	
			return new THREE.Vector3( tx, ty, tz );
	
		}
	
	};
	
	THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
	
	// File:src/extras/geometries/TubeGeometry.js
	
	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */
	
	THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TubeGeometry';
	
		this.parameters = {
			path: path,
			segments: segments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed,
			taper: taper
		};
	
		segments = segments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;
		taper = taper || THREE.TubeGeometry.NoTaper;
	
		var grid = [];
	
		var scope = this,
	
			tangent,
			normal,
			binormal,
	
			numpoints = segments + 1,
	
			u, v, r,
	
			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;
	
		var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;
	
		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		function vert( x, y, z ) {
	
			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;
	
		}
	
		// construct the grid
	
		for ( i = 0; i < numpoints; i ++ ) {
	
			grid[ i ] = [];
	
			u = i / ( numpoints - 1 );
	
			pos = path.getPointAt( u );
	
			tangent = tangents[ i ];
			normal = normals[ i ];
			binormal = binormals[ i ];
	
			r = radius * taper( u );
	
			for ( j = 0; j < radialSegments; j ++ ) {
	
				v = j / radialSegments * 2 * Math.PI;
	
				cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = r * Math.sin( v );
	
				pos2.copy( pos );
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;
	
				grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );
	
			}
	
		}
	
	
		// construct the mesh
	
		for ( i = 0; i < segments; i ++ ) {
	
			for ( j = 0; j < radialSegments; j ++ ) {
	
				ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
				jp = ( j + 1 ) % radialSegments;
	
				a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
				b = grid[ ip ][ j ];
				c = grid[ ip ][ jp ];
				d = grid[ i ][ jp ];
	
				uva = new THREE.Vector2( i / segments, j / radialSegments );
				uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
				uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
				uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );
	
				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
	
	THREE.TubeGeometry.NoTaper = function ( u ) {
	
		return 1;
	
	};
	
	THREE.TubeGeometry.SinusoidalTaper = function ( u ) {
	
		return Math.sin( Math.PI * u );
	
	};
	
	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {
	
		var	normal = new THREE.Vector3(),
	
			tangents = [],
			normals = [],
			binormals = [],
	
			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),
	
			numpoints = segments + 1,
			theta,
			smallest,
	
			tx, ty, tz,
			i, u;
	
	
		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		// compute the tangent vectors for each segment on the path
	
		for ( i = 0; i < numpoints; i ++ ) {
	
			u = i / ( numpoints - 1 );
	
			tangents[ i ] = path.getTangentAt( u );
			tangents[ i ].normalize();
	
		}
	
		initialNormal3();
	
		/*
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}
	
		function initialNormal2() {
	
			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );
	
			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );
	
			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	
		}
		*/
	
		function initialNormal3() {
	
			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component
	
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs( tangents[ 0 ].x );
			ty = Math.abs( tangents[ 0 ].y );
			tz = Math.abs( tangents[ 0 ].z );
	
			if ( tx <= smallest ) {
	
				smallest = tx;
				normal.set( 1, 0, 0 );
	
			}
	
			if ( ty <= smallest ) {
	
				smallest = ty;
				normal.set( 0, 1, 0 );
	
			}
	
			if ( tz <= smallest ) {
	
				normal.set( 0, 0, 1 );
	
			}
	
			vec.crossVectors( tangents[ 0 ], normal ).normalize();
	
			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	
		}
	
	
		// compute the slowly-varying normal and binormal vectors for each segment on the path
	
		for ( i = 1; i < numpoints; i ++ ) {
	
			normals[ i ] = normals[ i - 1 ].clone();
	
			binormals[ i ] = binormals[ i - 1 ].clone();
	
			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );
	
			if ( vec.length() > Number.EPSILON ) {
	
				vec.normalize();
	
				theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors
	
				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
	
			}
	
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
		}
	
	
		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	
		if ( closed ) {
	
			theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
			theta /= ( numpoints - 1 );
	
			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {
	
				theta = - theta;
	
			}
	
			for ( i = 1; i < numpoints; i ++ ) {
	
				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
			}
	
		}
	
	};
	
	// File:src/extras/geometries/PolyhedronGeometry.js
	
	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'PolyhedronGeometry';
	
		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};
	
		radius = radius || 1;
		detail = detail || 0;
	
		var that = this;
	
		for ( var i = 0, l = vertices.length; i < l; i += 3 ) {
	
			prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );
	
		}
	
		var p = this.vertices;
	
		var faces = [];
	
		for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {
	
			var v1 = p[ indices[ i ] ];
			var v2 = p[ indices[ i + 1 ] ];
			var v3 = p[ indices[ i + 2 ] ];
	
			faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );
	
		}
	
		var centroid = new THREE.Vector3();
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			subdivide( faces[ i ], detail );
	
		}
	
	
		// Handle case when face straddles the seam
	
		for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {
	
			var uvs = this.faceVertexUvs[ 0 ][ i ];
	
			var x0 = uvs[ 0 ].x;
			var x1 = uvs[ 1 ].x;
			var x2 = uvs[ 2 ].x;
	
			var max = Math.max( x0, x1, x2 );
			var min = Math.min( x0, x1, x2 );
	
			if ( max > 0.9 && min < 0.1 ) {
	
				// 0.9 is somewhat arbitrary
	
				if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
				if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
				if ( x2 < 0.2 ) uvs[ 2 ].x += 1;
	
			}
	
		}
	
	
		// Apply radius
	
		for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {
	
			this.vertices[ i ].multiplyScalar( radius );
	
		}
	
	
		// Merge vertices
	
		this.mergeVertices();
	
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	
		// Project vector onto sphere's surface
	
		function prepare( vector ) {
	
			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push( vertex ) - 1;
	
			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.
	
			var u = azimuth( vector ) / 2 / Math.PI + 0.5;
			var v = inclination( vector ) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2( u, 1 - v );
	
			return vertex;
	
		}
	
	
		// Approximate a curved face with recursively sub-divided triangles.
	
		function make( v1, v2, v3, materialIndex ) {
	
			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
			that.faces.push( face );
	
			centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );
	
			var azi = azimuth( centroid );
	
			that.faceVertexUvs[ 0 ].push( [
				correctUV( v1.uv, v1, azi ),
				correctUV( v2.uv, v2, azi ),
				correctUV( v3.uv, v3, azi )
			] );
	
		}
	
	
		// Analytically subdivide a face to the required detail level.
	
		function subdivide( face, detail ) {
	
			var cols = Math.pow( 2, detail );
			var a = prepare( that.vertices[ face.a ] );
			var b = prepare( that.vertices[ face.b ] );
			var c = prepare( that.vertices[ face.c ] );
			var v = [];
	
			var materialIndex = face.materialIndex;
	
			// Construct all of the vertices for this subdivision.
	
			for ( var i = 0 ; i <= cols; i ++ ) {
	
				v[ i ] = [];
	
				var aj = prepare( a.clone().lerp( c, i / cols ) );
				var bj = prepare( b.clone().lerp( c, i / cols ) );
				var rows = cols - i;
	
				for ( var j = 0; j <= rows; j ++ ) {
	
					if ( j === 0 && i === cols ) {
	
						v[ i ][ j ] = aj;
	
					} else {
	
						v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );
	
					}
	
				}
	
			}
	
			// Construct all of the faces.
	
			for ( var i = 0; i < cols ; i ++ ) {
	
				for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {
	
					var k = Math.floor( j / 2 );
	
					if ( j % 2 === 0 ) {
	
						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k ],
							v[ i ][ k ],
							materialIndex
						);
	
					} else {
	
						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k + 1 ],
							v[ i + 1 ][ k ],
							materialIndex
						);
	
					}
	
				}
	
			}
	
		}
	
	
		// Angle around the Y axis, counter-clockwise when looking from above.
	
		function azimuth( vector ) {
	
			return Math.atan2( vector.z, - vector.x );
	
		}
	
	
		// Angle above the XZ plane.
	
		function inclination( vector ) {
	
			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
	
		}
	
	
		// Texture fixing helper. Spheres have some odd behaviours.
	
		function correctUV( uv, vector, azimuth ) {
	
			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
			return uv.clone();
	
		}
	
	
	};
	
	THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
	
	// File:src/extras/geometries/DodecahedronGeometry.js
	
	/**
	 * @author Abe Pazos / https://hamoid.com
	 */
	
	THREE.DodecahedronGeometry = function ( radius, detail ) {
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;
	
		var vertices = [
	
			// (±1, ±1, ±1)
			- 1, - 1, - 1,    - 1, - 1,  1,
			- 1,  1, - 1,    - 1,  1,  1,
			 1, - 1, - 1,     1, - 1,  1,
			 1,  1, - 1,     1,  1,  1,
	
			// (0, ±1/φ, ±φ)
			 0, - r, - t,     0, - r,  t,
			 0,  r, - t,     0,  r,  t,
	
			// (±1/φ, ±φ, 0)
			- r, - t,  0,    - r,  t,  0,
			 r, - t,  0,     r,  t,  0,
	
			// (±φ, 0, ±1/φ)
			- t,  0, - r,     t,  0, - r,
			- t,  0,  r,     t,  0,  r
		];
	
		var indices = [
			 3, 11,  7,      3,  7, 15,      3, 15, 13,
			 7, 19, 17,      7, 17,  6,      7,  6, 15,
			17,  4,  8,     17,  8, 10,     17, 10,  6,
			 8,  0, 16,      8, 16,  2,      8,  2, 10,
			 0, 12,  1,      0,  1, 18,      0, 18, 16,
			 6, 10,  2,      6,  2, 13,      6, 13, 15,
			 2, 16, 18,      2, 18,  3,      2,  3, 13,
			18,  1,  9,     18,  9, 11,     18, 11,  3,
			 4, 14, 12,      4, 12,  0,      4,  0,  8,
			11,  9,  5,     11,  5, 19,     11, 19,  7,
			19,  5, 14,     19, 14,  4,     19,  4, 17,
			 1, 12, 14,      1, 14,  5,      1,  5,  9
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'DodecahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
	
	// File:src/extras/geometries/IcosahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.IcosahedronGeometry = function ( radius, detail ) {
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	
		var vertices = [
			- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
			 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
			 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
		];
	
		var indices = [
			 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
			 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
			 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
			 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'IcosahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
	
	// File:src/extras/geometries/OctahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.OctahedronGeometry = function ( radius, detail ) {
	
		var vertices = [
			1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
		];
	
		var indices = [
			0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'OctahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
	
	// File:src/extras/geometries/TetrahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.TetrahedronGeometry = function ( radius, detail ) {
	
		var vertices = [
			 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
		];
	
		var indices = [
			 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'TetrahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
	
	// File:src/extras/geometries/ParametricGeometry.js
	
	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
	 *
	 */
	
	THREE.ParametricGeometry = function ( func, slices, stacks ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'ParametricGeometry';
	
		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};
	
		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[ 0 ];
	
		var i, j, p;
		var u, v;
	
		var sliceCount = slices + 1;
	
		for ( i = 0; i <= stacks; i ++ ) {
	
			v = i / stacks;
	
			for ( j = 0; j <= slices; j ++ ) {
	
				u = j / slices;
	
				p = func( u, v );
				verts.push( p );
	
			}
	
		}
	
		var a, b, c, d;
		var uva, uvb, uvc, uvd;
	
		for ( i = 0; i < stacks; i ++ ) {
	
			for ( j = 0; j < slices; j ++ ) {
	
				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = ( i + 1 ) * sliceCount + j + 1;
				d = ( i + 1 ) * sliceCount + j;
	
				uva = new THREE.Vector2( j / slices, i / stacks );
				uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
				uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
				uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );
	
				faces.push( new THREE.Face3( a, b, d ) );
				uvs.push( [ uva, uvb, uvd ] );
	
				faces.push( new THREE.Face3( b, c, d ) );
				uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		// console.log(this);
	
		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
	
	// File:src/extras/geometries/WireframeGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WireframeGeometry = function ( geometry ) {
	
		THREE.BufferGeometry.call( this );
	
		var edge = [ 0, 0 ], hash = {};
	
		function sortFunction( a, b ) {
	
			return a - b;
	
		}
	
		var keys = [ 'a', 'b', 'c' ];
	
		if ( geometry instanceof THREE.Geometry ) {
	
			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var numEdges = 0;
	
			// allocate maximal size
			var edges = new Uint32Array( 6 * faces.length );
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0; j < 3; j ++ ) {
	
					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );
	
					var key = edge.toString();
	
					if ( hash[ key ] === undefined ) {
	
						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;
	
					}
	
				}
	
			}
	
			var coords = new Float32Array( numEdges * 2 * 3 );
	
			for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
				for ( var j = 0; j < 2; j ++ ) {
	
					var vertex = vertices[ edges [ 2 * i + j ] ];
	
					var index = 6 * i + 3 * j;
					coords[ index + 0 ] = vertex.x;
					coords[ index + 1 ] = vertex.y;
					coords[ index + 2 ] = vertex.z;
	
				}
	
			}
	
			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
		} else if ( geometry instanceof THREE.BufferGeometry ) {
	
			if ( geometry.index !== null ) {
	
				// Indexed BufferGeometry
	
				var indices = geometry.index.array;
				var vertices = geometry.attributes.position;
				var groups = geometry.groups;
				var numEdges = 0;
	
				if ( groups.length === 0 ) {
	
					geometry.addGroup( 0, indices.length );
	
				}
	
				// allocate maximal size
				var edges = new Uint32Array( 2 * indices.length );
	
				for ( var o = 0, ol = groups.length; o < ol; ++ o ) {
	
					var group = groups[ o ];
	
					var start = group.start;
					var count = group.count;
	
					for ( var i = start, il = start + count; i < il; i += 3 ) {
	
						for ( var j = 0; j < 3; j ++ ) {
	
							edge[ 0 ] = indices[ i + j ];
							edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
							edge.sort( sortFunction );
	
							var key = edge.toString();
	
							if ( hash[ key ] === undefined ) {
	
								edges[ 2 * numEdges ] = edge[ 0 ];
								edges[ 2 * numEdges + 1 ] = edge[ 1 ];
								hash[ key ] = true;
								numEdges ++;
	
							}
	
						}
	
					}
	
				}
	
				var coords = new Float32Array( numEdges * 2 * 3 );
	
				for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
					for ( var j = 0; j < 2; j ++ ) {
	
						var index = 6 * i + 3 * j;
						var index2 = edges[ 2 * i + j ];
	
						coords[ index + 0 ] = vertices.getX( index2 );
						coords[ index + 1 ] = vertices.getY( index2 );
						coords[ index + 2 ] = vertices.getZ( index2 );
	
					}
	
				}
	
				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
			} else {
	
				// non-indexed BufferGeometry
	
				var vertices = geometry.attributes.position.array;
				var numEdges = vertices.length / 3;
				var numTris = numEdges / 3;
	
				var coords = new Float32Array( numEdges * 2 * 3 );
	
				for ( var i = 0, l = numTris; i < l; i ++ ) {
	
					for ( var j = 0; j < 3; j ++ ) {
	
						var index = 18 * i + 6 * j;
	
						var index1 = 9 * i + 3 * j;
						coords[ index + 0 ] = vertices[ index1 ];
						coords[ index + 1 ] = vertices[ index1 + 1 ];
						coords[ index + 2 ] = vertices[ index1 + 2 ];
	
						var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
						coords[ index + 3 ] = vertices[ index2 ];
						coords[ index + 4 ] = vertices[ index2 + 1 ];
						coords[ index + 5 ] = vertices[ index2 + 2 ];
	
					}
	
				}
	
				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
			}
	
		}
	
	};
	
	THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;
	
	// File:src/extras/helpers/AxisHelper.js
	
	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AxisHelper = function ( size ) {
	
		size = size || 1;
	
		var vertices = new Float32Array( [
			0, 0, 0,  size, 0, 0,
			0, 0, 0,  0, size, 0,
			0, 0, 0,  0, 0, size
		] );
	
		var colors = new Float32Array( [
			1, 0, 0,  1, 0.6, 0,
			0, 1, 0,  0.6, 1, 0,
			0, 0, 1,  0, 0.6, 1
		] );
	
		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
	
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	
		THREE.LineSegments.call( this, geometry, material );
	
	};
	
	THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
	
	// File:src/extras/helpers/ArrowHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */
	
	THREE.ArrowHelper = ( function () {
	
		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );
	
		var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );
	
		return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {
	
			// dir is assumed to be normalized
	
			THREE.Object3D.call( this );
	
			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
			this.position.copy( origin );
			
			this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );
	
			this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );
	
			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );
	
		}
	
	}() );
	
	THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
	
	THREE.ArrowHelper.prototype.setDirection = ( function () {
	
		var axis = new THREE.Vector3();
		var radians;
	
		return function setDirection( dir ) {
	
			// dir is assumed to be normalized
	
			if ( dir.y > 0.99999 ) {
	
				this.quaternion.set( 0, 0, 0, 1 );
	
			} else if ( dir.y < - 0.99999 ) {
	
				this.quaternion.set( 1, 0, 0, 0 );
	
			} else {
	
				axis.set( dir.z, 0, - dir.x ).normalize();
	
				radians = Math.acos( dir.y );
	
				this.quaternion.setFromAxisAngle( axis, radians );
	
			}
	
		};
	
	}() );
	
	THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
	
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
		this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
		this.line.updateMatrix();
	
		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();
	
	};
	
	THREE.ArrowHelper.prototype.setColor = function ( color ) {
	
		this.line.material.color.set( color );
		this.cone.material.color.set( color );
	
	};
	
	// File:src/extras/helpers/BoxHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BoxHelper = function ( object ) {
	
		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );
	
		var geometry = new THREE.BufferGeometry();
		geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	
		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );
	
		if ( object !== undefined ) {
	
			this.update( object );
	
		}
	
	};
	
	THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
	
	THREE.BoxHelper.prototype.update = ( function () {
	
		var box = new THREE.Box3();
	
		return function ( object ) {
	
			box.setFromObject( object );
	
			if ( box.isEmpty() ) return;
	
			var min = box.min;
			var max = box.max;
	
			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/
	
			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/
	
			var position = this.geometry.attributes.position;
			var array = position.array;
	
			array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
			array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
			array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
			array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;
	
			position.needsUpdate = true;
	
			this.geometry.computeBoundingSphere();
	
		};
	
	} )();
	
	// File:src/extras/helpers/BoundingBoxHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	// a helper to show the world-axis-aligned bounding box for an object
	
	THREE.BoundingBoxHelper = function ( object, hex ) {
	
		var color = ( hex !== undefined ) ? hex : 0x888888;
	
		this.object = object;
	
		this.box = new THREE.Box3();
	
		THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );
	
	};
	
	THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
	
	THREE.BoundingBoxHelper.prototype.update = function () {
	
		this.box.setFromObject( this.object );
	
		this.box.size( this.scale );
	
		this.box.center( this.position );
	
	};
	
	// File:src/extras/helpers/CameraHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */
	
	THREE.CameraHelper = function ( camera ) {
	
		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );
	
		var pointMap = {};
	
		// colors
	
		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;
	
		// near
	
		addLine( "n1", "n2", hexFrustum );
		addLine( "n2", "n4", hexFrustum );
		addLine( "n4", "n3", hexFrustum );
		addLine( "n3", "n1", hexFrustum );
	
		// far
	
		addLine( "f1", "f2", hexFrustum );
		addLine( "f2", "f4", hexFrustum );
		addLine( "f4", "f3", hexFrustum );
		addLine( "f3", "f1", hexFrustum );
	
		// sides
	
		addLine( "n1", "f1", hexFrustum );
		addLine( "n2", "f2", hexFrustum );
		addLine( "n3", "f3", hexFrustum );
		addLine( "n4", "f4", hexFrustum );
	
		// cone
	
		addLine( "p", "n1", hexCone );
		addLine( "p", "n2", hexCone );
		addLine( "p", "n3", hexCone );
		addLine( "p", "n4", hexCone );
	
		// up
	
		addLine( "u1", "u2", hexUp );
		addLine( "u2", "u3", hexUp );
		addLine( "u3", "u1", hexUp );
	
		// target
	
		addLine( "c", "t", hexTarget );
		addLine( "p", "c", hexCross );
	
		// cross
	
		addLine( "cn1", "cn2", hexCross );
		addLine( "cn3", "cn4", hexCross );
	
		addLine( "cf1", "cf2", hexCross );
		addLine( "cf3", "cf4", hexCross );
	
		function addLine( a, b, hex ) {
	
			addPoint( a, hex );
			addPoint( b, hex );
	
		}
	
		function addPoint( id, hex ) {
	
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( hex ) );
	
			if ( pointMap[ id ] === undefined ) {
	
				pointMap[ id ] = [];
	
			}
	
			pointMap[ id ].push( geometry.vertices.length - 1 );
	
		}
	
		THREE.LineSegments.call( this, geometry, material );
	
		this.camera = camera;
		this.camera.updateProjectionMatrix();
	
		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.pointMap = pointMap;
	
		this.update();
	
	};
	
	THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
	
	THREE.CameraHelper.prototype.update = function () {
	
		var geometry, pointMap;
	
		var vector = new THREE.Vector3();
		var camera = new THREE.Camera();
	
		function setPoint( point, x, y, z ) {
	
			vector.set( x, y, z ).unproject( camera );
	
			var points = pointMap[ point ];
	
			if ( points !== undefined ) {
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					geometry.vertices[ points[ i ] ].copy( vector );
	
				}
	
			}
	
		}
	
		return function () {
	
			geometry = this.geometry;
			pointMap = this.pointMap;
	
			var w = 1, h = 1;
	
			// we need just camera projection matrix
			// world matrix must be identity
	
			camera.projectionMatrix.copy( this.camera.projectionMatrix );
	
			// center / target
	
			setPoint( "c", 0, 0, - 1 );
			setPoint( "t", 0, 0,  1 );
	
			// near
	
			setPoint( "n1", - w, - h, - 1 );
			setPoint( "n2",   w, - h, - 1 );
			setPoint( "n3", - w,   h, - 1 );
			setPoint( "n4",   w,   h, - 1 );
	
			// far
	
			setPoint( "f1", - w, - h, 1 );
			setPoint( "f2",   w, - h, 1 );
			setPoint( "f3", - w,   h, 1 );
			setPoint( "f4",   w,   h, 1 );
	
			// up
	
			setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
			setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
			setPoint( "u3",         0, h * 2,   - 1 );
	
			// cross
	
			setPoint( "cf1", - w,   0, 1 );
			setPoint( "cf2",   w,   0, 1 );
			setPoint( "cf3",   0, - h, 1 );
			setPoint( "cf4",   0,   h, 1 );
	
			setPoint( "cn1", - w,   0, - 1 );
			setPoint( "cn2",   w,   0, - 1 );
			setPoint( "cn3",   0, - h, - 1 );
			setPoint( "cn4",   0,   h, - 1 );
	
			geometry.verticesNeedUpdate = true;
	
		};
	
	}();
	
	// File:src/extras/helpers/DirectionalLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.DirectionalLightHelper = function ( light, size ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		size = size || 1;
	
		var geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3( - size,   size, 0 ),
			new THREE.Vector3(   size,   size, 0 ),
			new THREE.Vector3(   size, - size, 0 ),
			new THREE.Vector3( - size, - size, 0 ),
			new THREE.Vector3( - size,   size, 0 )
		);
	
		var material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		this.lightPlane = new THREE.Line( geometry, material );
		this.add( this.lightPlane );
	
		geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3(),
			new THREE.Vector3()
		);
	
		material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		this.targetLine = new THREE.Line( geometry, material );
		this.add( this.targetLine );
	
		this.update();
	
	};
	
	THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
	
	THREE.DirectionalLightHelper.prototype.dispose = function () {
	
		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();
	
	};
	
	THREE.DirectionalLightHelper.prototype.update = function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var v3 = new THREE.Vector3();
	
		return function () {
	
			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );
	
			this.lightPlane.lookAt( v3 );
			this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			this.targetLine.geometry.vertices[ 1 ].copy( v3 );
			this.targetLine.geometry.verticesNeedUpdate = true;
			this.targetLine.material.color.copy( this.lightPlane.material.color );
	
		};
	
	}();
	
	// File:src/extras/helpers/EdgesHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @param object THREE.Mesh whose geometry will be used
	 * @param hex line color
	 * @param thresholdAngle the minimum angle (in degrees),
	 * between the face normals of adjacent faces,
	 * that is required to render an edge. A value of 10 means
	 * an edge is only rendered if the angle is at least 10 degrees.
	 */
	
	THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {
	
		var color = ( hex !== undefined ) ? hex : 0xffffff;
	
		THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
	};
	
	THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
	
	// File:src/extras/helpers/FaceNormalsHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {
	
		// FaceNormalsHelper only supports THREE.Geometry
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xffff00;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		//
	
		var nNormals = 0;
	
		var objGeometry = this.object.geometry;
	
		if ( objGeometry instanceof THREE.Geometry ) {
	
			nNormals = objGeometry.faces.length;
	
		} else {
	
			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );
	
		}
	
		//
	
		var geometry = new THREE.BufferGeometry();
	
		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );
	
		geometry.addAttribute( 'position', positions );
	
		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );
	
		//
	
		this.matrixAutoUpdate = false;
		this.update();
	
	};
	
	THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
	
	THREE.FaceNormalsHelper.prototype.update = ( function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();
	
		return function update() {
	
			this.object.updateMatrixWorld( true );
	
			normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
			var matrixWorld = this.object.matrixWorld;
	
			var position = this.geometry.attributes.position;
	
			//
	
			var objGeometry = this.object.geometry;
	
			var vertices = objGeometry.vertices;
	
			var faces = objGeometry.faces;
	
			var idx = 0;
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				var normal = face.normal;
	
				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );
	
				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
				position.setXYZ( idx, v1.x, v1.y, v1.z );
	
				idx = idx + 1;
	
				position.setXYZ( idx, v2.x, v2.y, v2.z );
	
				idx = idx + 1;
	
			}
	
			position.needsUpdate = true;
	
			return this;
	
		}
	
	}() );
	
	// File:src/extras/helpers/GridHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.GridHelper = function ( size, step ) {
	
		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	
		this.color1 = new THREE.Color( 0x444444 );
		this.color2 = new THREE.Color( 0x888888 );
	
		for ( var i = - size; i <= size; i += step ) {
	
			geometry.vertices.push(
				new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
				new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
			);
	
			var color = i === 0 ? this.color1 : this.color2;
	
			geometry.colors.push( color, color, color, color );
	
		}
	
		THREE.LineSegments.call( this, geometry, material );
	
	};
	
	THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.GridHelper.prototype.constructor = THREE.GridHelper;
	
	THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {
	
		this.color1.set( colorCenterLine );
		this.color2.set( colorGrid );
	
		this.geometry.colorsNeedUpdate = true;
	
	};
	
	// File:src/extras/helpers/HemisphereLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.HemisphereLightHelper = function ( light, sphereSize ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.colors = [ new THREE.Color(), new THREE.Color() ];
	
		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		geometry.rotateX( - Math.PI / 2 );
	
		for ( var i = 0, il = 8; i < il; i ++ ) {
	
			geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];
	
		}
	
		var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );
	
		this.lightSphere = new THREE.Mesh( geometry, material );
		this.add( this.lightSphere );
	
		this.update();
	
	};
	
	THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
	
	THREE.HemisphereLightHelper.prototype.dispose = function () {
	
		this.lightSphere.geometry.dispose();
		this.lightSphere.material.dispose();
	
	};
	
	THREE.HemisphereLightHelper.prototype.update = function () {
	
		var vector = new THREE.Vector3();
	
		return function () {
	
			this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
			this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );
	
			this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
			this.lightSphere.geometry.colorsNeedUpdate = true;
	
		}
	
	}();
	
	// File:src/extras/helpers/PointLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.PointLightHelper = function ( light, sphereSize ) {
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		THREE.Mesh.call( this, geometry, material );
	
		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
	
		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
	
		var d = light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.scale.set( d, d, d );
	
		}
	
		this.add( this.lightDistance );
		*/
	
	};
	
	THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
	
	THREE.PointLightHelper.prototype.dispose = function () {
	
		this.geometry.dispose();
		this.material.dispose();
	
	};
	
	THREE.PointLightHelper.prototype.update = function () {
	
		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		/*
		var d = this.light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );
	
		}
		*/
	
	};
	
	// File:src/extras/helpers/SkeletonHelper.js
	
	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.SkeletonHelper = function ( object ) {
	
		this.bones = this.getBoneList( object );
	
		var geometry = new THREE.Geometry();
	
		for ( var i = 0; i < this.bones.length; i ++ ) {
	
			var bone = this.bones[ i ];
	
			if ( bone.parent instanceof THREE.Bone ) {
	
				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
				geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
				geometry.colors.push( new THREE.Color( 0, 1, 0 ) );
	
			}
	
		}
	
		geometry.dynamic = true;
	
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );
	
		THREE.LineSegments.call( this, geometry, material );
	
		this.root = object;
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.update();
	
	};
	
	
	THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
	
	THREE.SkeletonHelper.prototype.getBoneList = function( object ) {
	
		var boneList = [];
	
		if ( object instanceof THREE.Bone ) {
	
			boneList.push( object );
	
		}
	
		for ( var i = 0; i < object.children.length; i ++ ) {
	
			boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );
	
		}
	
		return boneList;
	
	};
	
	THREE.SkeletonHelper.prototype.update = function () {
	
		var geometry = this.geometry;
	
		var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );
	
		var boneMatrix = new THREE.Matrix4();
	
		var j = 0;
	
		for ( var i = 0; i < this.bones.length; i ++ ) {
	
			var bone = this.bones[ i ];
	
			if ( bone.parent instanceof THREE.Bone ) {
	
				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );
	
				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );
	
				j += 2;
	
			}
	
		}
	
		geometry.verticesNeedUpdate = true;
	
		geometry.computeBoundingSphere();
	
	};
	
	// File:src/extras/helpers/SpotLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.SpotLightHelper = function ( light ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );
	
		geometry.translate( 0, - 0.5, 0 );
		geometry.rotateX( - Math.PI / 2 );
	
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	
		this.cone = new THREE.Mesh( geometry, material );
		this.add( this.cone );
	
		this.update();
	
	};
	
	THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
	
	THREE.SpotLightHelper.prototype.dispose = function () {
	
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	
	};
	
	THREE.SpotLightHelper.prototype.update = function () {
	
		var vector = new THREE.Vector3();
		var vector2 = new THREE.Vector3();
	
		return function () {
	
			var coneLength = this.light.distance ? this.light.distance : 10000;
			var coneWidth = coneLength * Math.tan( this.light.angle );
	
			this.cone.scale.set( coneWidth, coneWidth, coneLength );
	
			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );
	
			this.cone.lookAt( vector2.sub( vector ) );
	
			this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		};
	
	}();
	
	// File:src/extras/helpers/VertexNormalsHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xff0000;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		//
	
		var nNormals = 0;
	
		var objGeometry = this.object.geometry;
	
		if ( objGeometry instanceof THREE.Geometry ) {
	
			nNormals = objGeometry.faces.length * 3;
	
		} else if ( objGeometry instanceof THREE.BufferGeometry ) {
	
			nNormals = objGeometry.attributes.normal.count
	
		}
	
		//
	
		var geometry = new THREE.BufferGeometry();
	
		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );
	
		geometry.addAttribute( 'position', positions );
	
		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );
	
		//
	
		this.matrixAutoUpdate = false;
	
		this.update();
	
	};
	
	THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
	
	THREE.VertexNormalsHelper.prototype.update = ( function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();
	
		return function update() {
	
			var keys = [ 'a', 'b', 'c' ];
	
			this.object.updateMatrixWorld( true );
	
			normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
			var matrixWorld = this.object.matrixWorld;
	
			var position = this.geometry.attributes.position;
	
			//
	
			var objGeometry = this.object.geometry;
	
			if ( objGeometry instanceof THREE.Geometry ) {
	
				var vertices = objGeometry.vertices;
	
				var faces = objGeometry.faces;
	
				var idx = 0;
	
				for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
						var vertex = vertices[ face[ keys[ j ] ] ];
	
						var normal = face.vertexNormals[ j ];
	
						v1.copy( vertex ).applyMatrix4( matrixWorld );
	
						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
						position.setXYZ( idx, v1.x, v1.y, v1.z );
	
						idx = idx + 1;
	
						position.setXYZ( idx, v2.x, v2.y, v2.z );
	
						idx = idx + 1;
	
					}
	
				}
	
			} else if ( objGeometry instanceof THREE.BufferGeometry ) {
	
				var objPos = objGeometry.attributes.position;
	
				var objNorm = objGeometry.attributes.normal;
	
				var idx = 0;
	
				// for simplicity, ignore index and drawcalls, and render every normal
	
				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {
	
					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );
	
					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );
	
					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
					position.setXYZ( idx, v1.x, v1.y, v1.z );
	
					idx = idx + 1;
	
					position.setXYZ( idx, v2.x, v2.y, v2.z );
	
					idx = idx + 1;
	
				}
	
			}
	
			position.needsUpdate = true;
	
			return this;
	
		}
	
	}() );
	
	// File:src/extras/helpers/WireframeHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WireframeHelper = function ( object, hex ) {
	
		var color = ( hex !== undefined ) ? hex : 0xffffff;
	
		THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
	};
	
	THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
	
	// File:src/extras/objects/ImmediateRenderObject.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ImmediateRenderObject = function ( material ) {
	
		THREE.Object3D.call( this );
	
		this.material = material;
		this.render = function ( renderCallback ) {};
	
	};
	
	THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
	
	// File:src/extras/objects/MorphBlendMesh.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.MorphBlendMesh = function( geometry, material ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		this.animationsMap = {};
		this.animationsList = [];
	
		// prepare default animation
		// (all frames played together in 1 second)
	
		var numFrames = this.geometry.morphTargets.length;
	
		var name = "__default";
	
		var startFrame = 0;
		var endFrame = numFrames - 1;
	
		var fps = numFrames / 1;
	
		this.createAnimation( name, startFrame, endFrame, fps );
		this.setAnimationWeight( name, 1 );
	
	};
	
	THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
	
	THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {
	
		var animation = {
	
			start: start,
			end: end,
	
			length: end - start + 1,
	
			fps: fps,
			duration: ( end - start ) / fps,
	
			lastFrame: 0,
			currentFrame: 0,
	
			active: false,
	
			time: 0,
			direction: 1,
			weight: 1,
	
			directionBackwards: false,
			mirroredLoop: false
	
		};
	
		this.animationsMap[ name ] = animation;
		this.animationsList.push( animation );
	
	};
	
	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {
	
		var pattern = /([a-z]+)_?(\d+)/i;
	
		var firstAnimation, frameRanges = {};
	
		var geometry = this.geometry;
	
		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
			var morph = geometry.morphTargets[ i ];
			var chunks = morph.name.match( pattern );
	
			if ( chunks && chunks.length > 1 ) {
	
				var name = chunks[ 1 ];
	
				if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };
	
				var range = frameRanges[ name ];
	
				if ( i < range.start ) range.start = i;
				if ( i > range.end ) range.end = i;
	
				if ( ! firstAnimation ) firstAnimation = name;
	
			}
	
		}
	
		for ( var name in frameRanges ) {
	
			var range = frameRanges[ name ];
			this.createAnimation( name, range.start, range.end, fps );
	
		}
	
		this.firstAnimation = firstAnimation;
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = 1;
			animation.directionBackwards = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = - 1;
			animation.directionBackwards = true;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.fps = fps;
			animation.duration = ( animation.end - animation.start ) / animation.fps;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.duration = duration;
			animation.fps = ( animation.end - animation.start ) / animation.duration;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.weight = weight;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = time;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {
	
		var time = 0;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			time = animation.time;
	
		}
	
		return time;
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {
	
		var duration = - 1;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			duration = animation.duration;
	
		}
	
		return duration;
	
	};
	
	THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = 0;
			animation.active = true;
	
		} else {
	
			console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.active = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.update = function ( delta ) {
	
		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {
	
			var animation = this.animationsList[ i ];
	
			if ( ! animation.active ) continue;
	
			var frameTime = animation.duration / animation.length;
	
			animation.time += animation.direction * delta;
	
			if ( animation.mirroredLoop ) {
	
				if ( animation.time > animation.duration || animation.time < 0 ) {
	
					animation.direction *= - 1;
	
					if ( animation.time > animation.duration ) {
	
						animation.time = animation.duration;
						animation.directionBackwards = true;
	
					}
	
					if ( animation.time < 0 ) {
	
						animation.time = 0;
						animation.directionBackwards = false;
	
					}
	
				}
	
			} else {
	
				animation.time = animation.time % animation.duration;
	
				if ( animation.time < 0 ) animation.time += animation.duration;
	
			}
	
			var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
			var weight = animation.weight;
	
			if ( keyframe !== animation.currentFrame ) {
	
				this.morphTargetInfluences[ animation.lastFrame ] = 0;
				this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;
	
				this.morphTargetInfluences[ keyframe ] = 0;
	
				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;
	
			}
	
			var mix = ( animation.time % frameTime ) / frameTime;
	
			if ( animation.directionBackwards ) mix = 1 - mix;
	
			if ( animation.currentFrame !== animation.lastFrame ) {
	
				this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
				this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;
	
			} else {
	
				this.morphTargetInfluences[ animation.currentFrame ] = weight;
	
			}
	
		}
	
	};
	
	
	// Export the THREE object for **Node.js**, with
	// backwards-compatibility for the old `require()` API. If we're in
	// the browser, add `_` as a global object via a string identifier,
	// for Closure Compiler "advanced" mode.
	if (true) {
	  if (typeof module !== 'undefined' && module.exports) {
	    exports = module.exports = THREE;
	  }
	  exports.THREE = THREE;
	} else {
	  this['THREE'] = THREE;
	}


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ShaderPass = function ( shader, textureID ) {
	
		this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";
	
		this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );
	
		this.material = new THREE.ShaderMaterial( {
	
			defines: shader.defines || {},
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader
	
		} );
	
		this.renderToScreen = false;
	
		this.enabled = true;
		this.needsSwap = true;
		this.clear = false;
	
	
		this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
		this.scene  = new THREE.Scene();
	
		this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
		this.scene.add( this.quad );
	
	};
	
	THREE.ShaderPass.prototype = {
	
		render: function ( renderer, writeBuffer, readBuffer, delta ) {
	
			if ( this.uniforms[ this.textureID ] ) {
	
				this.uniforms[ this.textureID ].value = readBuffer;
	
			}
	
			this.quad.material = this.material;
	
			if ( this.renderToScreen ) {
	
				renderer.render( this.scene, this.camera );
	
			} else {
	
				renderer.render( this.scene, this.camera, writeBuffer, this.clear );
	
			}
	
		}
	
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.MaskPass = function ( scene, camera ) {
	
		this.scene = scene;
		this.camera = camera;
	
		this.enabled = true;
		this.clear = true;
		this.needsSwap = false;
	
		this.inverse = false;
	
	};
	
	THREE.MaskPass.prototype = {
	
		render: function ( renderer, writeBuffer, readBuffer, delta ) {
	
			var context = renderer.context;
	
			// don't update color or depth
	
			context.colorMask( false, false, false, false );
			context.depthMask( false );
	
			// set up stencil
	
			var writeValue, clearValue;
	
			if ( this.inverse ) {
	
				writeValue = 0;
				clearValue = 1;
	
			} else {
	
				writeValue = 1;
				clearValue = 0;
	
			}
	
			context.enable( context.STENCIL_TEST );
			context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
			context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
			context.clearStencil( clearValue );
	
			// draw into the stencil buffer
	
			renderer.render( this.scene, this.camera, readBuffer, this.clear );
			renderer.render( this.scene, this.camera, writeBuffer, this.clear );
	
			// re-enable update of color and depth
	
			context.colorMask( true, true, true, true );
			context.depthMask( true );
	
			// only render where stencil is set to 1
	
			context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
			context.stencilOp( context.KEEP, context.KEEP, context.KEEP );
	
		}
	
	};
	
	
	THREE.ClearMaskPass = function () {
	
		this.enabled = true;
	
	};
	
	THREE.ClearMaskPass.prototype = {
	
		render: function ( renderer, writeBuffer, readBuffer, delta ) {
	
			var context = renderer.context;
	
			context.disable( context.STENCIL_TEST );
	
		}
	
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {
	
		this.scene = scene;
		this.camera = camera;
	
		this.overrideMaterial = overrideMaterial;
	
		this.clearColor = clearColor;
		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;
	
		this.oldClearColor = new THREE.Color();
		this.oldClearAlpha = 1;
	
		this.enabled = true;
		this.clear = true;
		this.needsSwap = false;
	
	};
	
	THREE.RenderPass.prototype = {
	
		render: function ( renderer, writeBuffer, readBuffer, delta ) {
	
			this.scene.overrideMaterial = this.overrideMaterial;
	
			if ( this.clearColor ) {
	
				this.oldClearColor.copy( renderer.getClearColor() );
				this.oldClearAlpha = renderer.getClearAlpha();
	
				renderer.setClearColor( this.clearColor, this.clearAlpha );
	
			}
	
			renderer.render( this.scene, this.camera, readBuffer, this.clear );
	
			if ( this.clearColor ) {
	
				renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );
	
			}
	
			this.scene.overrideMaterial = null;
	
		}
	
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.EffectComposer = function ( renderer, renderTarget ) {
	
		this.renderer = renderer;
	
		if ( renderTarget === undefined ) {
	
			var pixelRatio = renderer.getPixelRatio();
	
			var width  = Math.floor( renderer.context.canvas.width  / pixelRatio ) || 1;
			var height = Math.floor( renderer.context.canvas.height / pixelRatio ) || 1;
			var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };
	
			renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
	
		}
	
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();
	
		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;
	
		this.passes = [];
	
		if ( THREE.CopyShader === undefined )
			console.error( "THREE.EffectComposer relies on THREE.CopyShader" );
	
		this.copyPass = new THREE.ShaderPass( THREE.CopyShader );
	
	};
	
	THREE.EffectComposer.prototype = {
	
		swapBuffers: function() {
	
			var tmp = this.readBuffer;
			this.readBuffer = this.writeBuffer;
			this.writeBuffer = tmp;
	
		},
	
		addPass: function ( pass ) {
	
			this.passes.push( pass );
	
		},
	
		insertPass: function ( pass, index ) {
	
			this.passes.splice( index, 0, pass );
	
		},
	
		render: function ( delta ) {
	
			this.writeBuffer = this.renderTarget1;
			this.readBuffer = this.renderTarget2;
	
			var maskActive = false;
	
			var pass, i, il = this.passes.length;
	
			for ( i = 0; i < il; i ++ ) {
	
				pass = this.passes[ i ];
	
				if ( ! pass.enabled ) continue;
	
				pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );
	
				if ( pass.needsSwap ) {
	
					if ( maskActive ) {
	
						var context = this.renderer.context;
	
						context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
	
						this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );
	
						context.stencilFunc( context.EQUAL, 1, 0xffffffff );
	
					}
	
					this.swapBuffers();
	
				}
	
				if ( pass instanceof THREE.MaskPass ) {
	
					maskActive = true;
	
				} else if ( pass instanceof THREE.ClearMaskPass ) {
	
					maskActive = false;
	
				}
	
			}
	
		},
	
		reset: function ( renderTarget ) {
	
			if ( renderTarget === undefined ) {
	
				renderTarget = this.renderTarget1.clone();
	
				var pixelRatio = this.renderer.getPixelRatio();
	
				renderTarget.width  = Math.floor( this.renderer.context.canvas.width  / pixelRatio );
				renderTarget.height = Math.floor( this.renderer.context.canvas.height / pixelRatio );
	
			}
	
			this.renderTarget1.dispose();
			this.renderTarget1 = renderTarget;
			this.renderTarget2.dispose();
			this.renderTarget2 = renderTarget.clone();
	
			this.writeBuffer = this.renderTarget1;
			this.readBuffer = this.renderTarget2;
	
		},
	
		setSize: function ( width, height ) {
	
			this.renderTarget1.setSize( width, height );
			this.renderTarget2.setSize( width, height );
	
		}
	
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _basePass = __webpack_require__(8);
	
	var _basePass2 = _interopRequireDefault(_basePass);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MIN_FLOW = 0.06;
	
	var BrushPass = function (_BasePass) {
		_inherits(BrushPass, _BasePass);
	
		function BrushPass(renderer, w, h) {
			_classCallCheck(this, BrushPass);
	
			var uniforms = {
				aspect: { type: 'f', value: h / w },
				prev: { type: 't', value: null },
				image: { type: 't', value: window.kumiko },
				cursor: { type: 'v2', value: new THREE.Vector2() },
				imageOpacity: { type: 'f', value: 0 },
				frequency: { type: 'f', value: 2 },
				speed: { type: 'f', value: MIN_FLOW },
				speedAmp: { type: 'f', value: 0.002 },
				seed: { type: 'f', value: 0 }
			};
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BrushPass).call(this, renderer, {
				fragmentShader: __webpack_require__(10),
				uniforms: uniforms
			}));
	
			var targetOption = {
				// wrapS: THREE.MirroredRepeatWrapping,
				// wrapT: THREE.MirroredRepeatWrapping
			};
	
			_this.renderer = renderer;
	
			_this.prevTexture = new THREE.WebGLRenderTarget(w, h, targetOption);
			_this.texture = new THREE.WebGLRenderTarget(w, h, targetOption);
	
			_this.uniforms.prev.value = _this.texture;
	
			// this.pass = new BasePass(this.renderer, {
			// 	fragmentShader: require('./shaders/brush-pass.frag'),
			// 	uniforms: this.uniforms
			// })
	
			// event
			window.Interface.on('change-flow', _this.onChangeFlow.bind(_this));
			window.Interface.on('overcoat', _this.onOvercoat.bind(_this));
			window.Interface.on('volume', _this.onChangeVolume.bind(_this));
			window.Interface.on('flow-speed', _this.onChangeFlowSpeed.bind(_this));
			return _this;
		}
	
		_createClass(BrushPass, [{
			key: 'onChangeFlowSpeed',
			value: function onChangeFlowSpeed(value) {
	
				this.uniforms.speedAmp.value = value * 0.05;
			}
		}, {
			key: 'onChangeFlow',
			value: function onChangeFlow(value) {
	
				this.uniforms.seed.value = Math.random();
			}
		}, {
			key: 'onOvercoat',
			value: function onOvercoat(value) {
				// this.uniforms.cursor.value.set(e.offsetX, e.offsetY)
	
				this.uniforms.imageOpacity.value = 1;
			}
		}, {
			key: 'onChangeVolume',
			value: function onChangeVolume(value) {
				// console.log(value)
				this.uniforms.speed.value = Math.pow(value, 3) * (1 - MIN_FLOW) + MIN_FLOW;
			}
		}, {
			key: 'render',
			value: function render() {
	
				var swap = this.prevTexture;
				this.prevTexture = this.texture;
				this.texture = swap;
	
				this.uniforms.prev.value = this.prevTexture;
	
				_get(Object.getPrototypeOf(BrushPass.prototype), 'render', this).call(this, this.texture);
	
				this.uniforms.imageOpacity.value = 0;
			}
		}, {
			key: 'setSize',
			value: function setSize(w, h) {
				_get(Object.getPrototypeOf(BrushPass.prototype), 'setSize', this).call(this, w, h);
				this.uniforms.aspect.value = h / w;
				this.prevTexture.setSize(w, h);
				this.texture.setSize(w, h);
			}
		}]);
	
		return BrushPass;
	}(_basePass2.default);

	exports.default = BrushPass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var BasePass = function () {
		function BasePass(renderer, option) {
			_classCallCheck(this, BasePass);
	
			this.scene = new THREE.Scene();
	
			this.renderer = renderer;
	
			// camera
			this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 1000);
			this.camera.position.set(0, 0, 10);
			this.scene.add(this.camera);
	
			this.uniforms = option.uniforms;
	
			var mat = new THREE.ShaderMaterial({
				uniforms: this.uniforms,
				vertexShader: option.vertexShader || __webpack_require__(9),
				fragmentShader: option.fragmentShader
			});
	
			var plane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat);
	
			this.scene.add(plane);
		}
	
		_createClass(BasePass, [{
			key: 'setSize',
			value: function setSize(width, height) {
				this.renderer.setSize(width, height);
			}
		}, {
			key: 'render',
			value: function render(targetRenderer) {
				this.renderer.render(this.scene, this.camera, targetRenderer);
			}
		}]);
	
		return BasePass;
	}();

	exports.default = BasePass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = "#define GLSLIFY 1\nvarying vec2 pos;\n\nvoid main(void) {\n\tpos = vec2(uv.x, uv.y);\n\tgl_Position = vec4(position, 1.0);\n}\n"

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\n#define GLSLIFY 1\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_1_0(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_1_1(vec3 x) {\n  return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nfloat snoise_1_2(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_1_0(i); // Avoid truncation effects in permutation\n  vec3 p = permute_1_1( permute_1_1( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n\nconst float PI_2_3 = 3.14159265359;\n\n\n\n\nuniform sampler2D prev;\nuniform sampler2D image;\nuniform float aspect;\nuniform vec2 cursor;\nuniform float imageOpacity;\nuniform float frequency;\nuniform float speed;\nuniform float speedAmp;\nuniform float seed;\n\n\nvarying vec2 pos;\n\nvoid main() {\n\n\t// uneune\n\t// float angle = snoise2((pos + cursor / resolution) * frequency) * 2.0 * PI + (pos.x + pos.y - 1.0) * 40.0;\n\t// vec2 vel = vec2(cos(angle), sin(angle)) * speed;\n\n\t// uneune\n\tfloat angle = snoise_1_2((pos + vec2(seed * 20.0, seed * 10.0)) * frequency) * 2.0 * PI_2_3;\n\tvec2 vel = vec2(cos(angle), sin(angle) / aspect) * speed * speedAmp;\n\n\t// vec2 vel = vec2(0.0, 0.0);\n\n\tvec2 originPos = pos + vel;//fract(pos + vel);\n\n\tvec3 imageColor = texture2D(image, pos).rgb;\n\tvec3 prevColor = texture2D(prev, originPos).rgb;\n\n\tvec3 color = mix(prevColor, imageColor, imageOpacity);\n\n\tgl_FragColor = vec4(color, 1.0);\n\n}\n"

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n// uniform sampler2D texture;\n\nvarying vec2 pos;\n\nvoid main() {\n\n\tvec4 color = texture2D(texture, pos);\n\tgl_FragColor = color;\n\n}\n"

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventemitter = __webpack_require__(13);
	
	var _eventemitter2 = _interopRequireDefault(_eventemitter);
	
	var _nodeOsc = __webpack_require__(15);
	
	var _nodeOsc2 = _interopRequireDefault(_nodeOsc);
	
	var _audioAnalyser = __webpack_require__(28);
	
	var _audioAnalyser2 = _interopRequireDefault(_audioAnalyser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TYPE = {
		every: 1,
		on: 2
	};
	
	var OSCList = {
		'/volume': TYPE.every,
		'/flow-speed': TYPE.every,
		'/overcoat': TYPE.on,
		'/change-flow': TYPE.on
	};
	
	var VJInterface = function (_EventEmitter) {
		_inherits(VJInterface, _EventEmitter);
	
		function VJInterface() {
			_classCallCheck(this, VJInterface);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(VJInterface).call(this));
	
			_this.oscServer = new _nodeOsc2.default.Server(1234, '0.0.0.0');
	
			_this.oscServer.on('message', _this.onReceiveOSC.bind(_this));
	
			// this.audioAnalyzer = new AudioAnalyzer()
	
			return _this;
		}
	
		_createClass(VJInterface, [{
			key: 'update',
			value: function update() {
				// this.audioAnalyzer.update()
				// this.emit('volume', this.audioAnalyzer.volume)
			}
		}, {
			key: 'onReceiveOSC',
			value: function onReceiveOSC(msg, rinfo) {
	
				var name = msg[0];
				var value = msg[1];
	
				if (OSCList[name] == TYPE.every) {
					this.emit(name.substr(1), value);
				} else if (OSCList[name] == TYPE.on && value == 1) {
					this.emit(name.substr(1), value);
				}
			}
		}]);
	
		return VJInterface;
	}(_eventemitter2.default);
	
	exports.default = new VJInterface();

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	//
	// We store our EE objects in a plain object whose properties are event names.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// `~` to make sure that the built-in object properties are not overridden or
	// used as an attack vector.
	// We also assume that `Object.create(null)` is available when the event name
	// is an ES6 Symbol.
	//
	var prefix = typeof Object.create !== 'function' ? '~' : false;
	
	/**
	 * Representation of a single EventEmitter function.
	 *
	 * @param {Function} fn Event handler to be called.
	 * @param {Mixed} context Context for function execution.
	 * @param {Boolean} once Only emit once
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}
	
	/**
	 * Minimal EventEmitter interface that is molded against the Node.js
	 * EventEmitter interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() { /* Nothing to set */ }
	
	/**
	 * Holds the assigned EventEmitters by name.
	 *
	 * @type {Object}
	 * @private
	 */
	EventEmitter.prototype._events = undefined;
	
	/**
	 * Return a list of assigned event listeners.
	 *
	 * @param {String} event The events that should be listed.
	 * @param {Boolean} exists We only need to know if there are listeners.
	 * @returns {Array|Boolean}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event, exists) {
	  var evt = prefix ? prefix + event : event
	    , available = this._events && this._events[evt];
	
	  if (exists) return !!available;
	  if (!available) return [];
	  if (available.fn) return [available.fn];
	
	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	    ee[i] = available[i].fn;
	  }
	
	  return ee;
	};
	
	/**
	 * Emit an event to all registered event listeners.
	 *
	 * @param {String} event The name of the event.
	 * @returns {Boolean} Indication if we've emitted an event.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;
	
	  if (!this._events || !this._events[evt]) return false;
	
	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;
	
	  if ('function' === typeof listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
	
	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }
	
	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }
	
	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;
	
	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
	
	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }
	
	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }
	
	  return true;
	};
	
	/**
	 * Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {Functon} fn Callback function.
	 * @param {Mixed} context The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this)
	    , evt = prefix ? prefix + event : event;
	
	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }
	
	  return this;
	};
	
	/**
	 * Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} context The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true)
	    , evt = prefix ? prefix + event : event;
	
	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }
	
	  return this;
	};
	
	/**
	 * Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {Function} fn The listener that we need to find.
	 * @param {Mixed} context Only remove listeners matching this context.
	 * @param {Boolean} once Only remove once listeners.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;
	
	  if (!this._events || !this._events[evt]) return this;
	
	  var listeners = this._events[evt]
	    , events = [];
	
	  if (fn) {
	    if (listeners.fn) {
	      if (
	           listeners.fn !== fn
	        || (once && !listeners.once)
	        || (context && listeners.context !== context)
	      ) {
	        events.push(listeners);
	      }
	    } else {
	      for (var i = 0, length = listeners.length; i < length; i++) {
	        if (
	             listeners[i].fn !== fn
	          || (once && !listeners[i].once)
	          || (context && listeners[i].context !== context)
	        ) {
	          events.push(listeners[i]);
	        }
	      }
	    }
	  }
	
	  //
	  // Reset the array, or remove it completely if we have no more listeners.
	  //
	  if (events.length) {
	    this._events[evt] = events.length === 1 ? events[0] : events;
	  } else {
	    delete this._events[evt];
	  }
	
	  return this;
	};
	
	/**
	 * Remove all listeners or only the listeners for the specified event.
	 *
	 * @param {String} event The event want to remove all listeners for.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  if (!this._events) return this;
	
	  if (event) delete this._events[prefix ? prefix + event : event];
	  else this._events = prefix ? {} : Object.create(null);
	
	  return this;
	};
	
	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;
	
	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};
	
	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;
	
	//
	// Expose the module.
	//
	if (true) {
	  module.exports = EventEmitter;
	}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventemitter = __webpack_require__(13);
	
	var _eventemitter2 = _interopRequireDefault(_eventemitter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Ticker = function (_EventEmitter) {
		_inherits(Ticker, _EventEmitter);
	
		function Ticker() {
			_classCallCheck(this, Ticker);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Ticker).call(this));
	
			_this.update = _this.update.bind(_this);
			_this.previousTime = 0;
			return _this;
		}
	
		_createClass(Ticker, [{
			key: 'start',
			value: function start() {
				console.log('start ticker');
				this.update();
			}
		}, {
			key: 'stop',
			value: function stop() {
				cancelAnimationFrame(this.requiestId);
			}
		}, {
			key: 'update',
			value: function update(t) {
				this.requestId = requestAnimationFrame(this.update);
				var elapsed = t - this.previousTime;
				this.previousTime = t;
				if (elapsed) {
					this.emit('update', elapsed);
				}
			}
		}]);
	
		return Ticker;
	}(_eventemitter2.default);
	
	exports.default = new Ticker();

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = {
	  Message: __webpack_require__(16),
	  Client: __webpack_require__(17),
	  Server: __webpack_require__(22)
	};


/***/ },
/* 16 */
/***/ function(module, exports) {

	'use strict';
	
	function Message(address) {
	    this.oscType = 'message';
	    this.address = address;
	    this.args = [];
	
	    for (var i = 1; i < arguments.length; i++) {
	        this.append(arguments[i]);
	    }
	}
	
	function Argument(type, value){
	    this.type = type;
	    this.value = value;
	}
	
	Message.prototype = {
	    append: function (arg) {
	        var argOut;
	        switch (typeof arg) {
	        case 'object':
	            if (arg instanceof Array) {
	                for (var i = 0; i < arg.length; i++) {
	                    this.append(arg[i]);
	                }
	            } else if (arg.type) {
	                this.args.push(arg);
	            } else {
	                throw new Error('don\'t know how to encode object ' + arg);
	            }
	            break;
	        case 'number':
	            if (Math.floor(arg) === arg) {
	                argOut = new Argument('integer', arg);
	                this.args.push(argOut);
	            } else {
	                argOut = new Argument('float', arg);
	                this.args.push(argOut);
	            }
	            break;
	        case 'string':
	            argOut = new Argument('string', arg);
	            this.args.push(argOut);
	            break;
	        default:
	            throw new Error('don\'t know how to encode ' + arg);
	        }
	    }
	};
	
	module.exports = Message;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var dgram = __webpack_require__(18);
	
	var min = __webpack_require__(19);
	
	var Message = __webpack_require__(16);
	
	var Client = function (host, port) {
	    this.host = host;
	    this.port = port;
	    this._sock = dgram.createSocket({
	      type: 'udp4',
	      reuseAddr: true
	    });
	    this.kill = function() {
	        this._sock.close();
	    };
	};
	
	Client.prototype = {
	    send: function (message) {
	        var mes;
	        var buf;
	        var callback;
	        var args = Array.prototype.slice.call(arguments);
	        var last = args[args.length - 1];
	
	        if (typeof last === 'function') {
	          callback = args.pop();
	        }
	        else {
	          callback = function () {};
	        }
	
	
	        switch (typeof message) {
	            case 'object':
	                buf = min.toBuffer(message);
	                this._sock.send(buf, 0, buf.length, this.port, this.host, callback);
	                break;
	            case 'string':
	                mes = new Message(args[0]);
	                for (var i = 1; i < args.length; i++) {
	                    mes.append(args[i]);
	                }
	                buf = min.toBuffer(mes);
	                this._sock.send(buf, 0, buf.length, this.port, this.host, callback);
	                break;
	            default:
	                throw new Error('That Message Just Doesn\'t Seem Right');
	        }
	    }
	};
	
	module.exports = Client;


/***/ },
/* 18 */
/***/ function(module, exports) {

	module.exports = require("dgram");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  
	//~readme.out~
	//[![build status](https://secure.travis-ci.org/russellmcc/node-osc-min.png)](http://travis-ci.org/russellmcc/node-osc-min)
	//# osc-min
	// 
	// _simple utilities for open sound control in node.js_
	//
	// This package provides some node.js utilities for working with 
	// [OSC](http://opensoundcontrol.org/), a format for sound and systems control.  
	// Here we implement the [OSC 1.1][spec11] specification.  OSC is a transport-independent
	// protocol, so we don't provide any server objects, as you should be able to 
	// use OSC over any transport you like.  The most common is probably udp, but tcp
	// is not unheard of.
	//
	// [spec11]: http://opensoundcontrol.org/spec-1_1
	//
	//----
	//## Installation
	//~installation~
	//----
	//## Examples
	//~examples~
	//
	// more examples are available in the `examples/` directory.
	//
	//----
	//~api~
	//----
	//~representation~
	
	//~representation~
	//## Javascript representations of the OSC types.  
	// See the [spec][spec] for more information on the OSC types.
	//
	// + An _OSC Packet_ is an _OSC Message_ or an _OSC Bundle_.
	//
	// + An _OSC Message_:
	//
	//           {
	//               oscType : "message"
	//               address : "/address/pattern/might/have/wildcards"
	//               args : [arg1,arg2]
	//           }
	//
	//    Where args is an array of _OSC Arguments_.  `oscType` is optional.
	//    `args` can be a single element.
	//
	// + An _OSC Argument_ is represented as a javascript object with the following layout:
	//
	//           {
	//               type : "string"
	//               value : "value"
	//           }
	//
	//    Where the `type` is one of the following:
	//    + `string` - string value
	//    + `float` - numeric value
	//    + `integer` - numeric value
	//    + `blob` - node.js Buffer value
	//    + `true` - value is boolean true
	//    + `false` - value is boolean false
	//    + `null` - no value
	//    + `bang` - no value (this is the `I` type tag)
	//    + `timetag` - numeric value
	//    + `array` - array of _OSC Arguments_
	// 
	//    Note that `type` is always a string - i.e. `"true"` rather than `true`.
	//   
	//    The following non-standard types are also supported:
	//    + `double` - numeric value (encodes to a float64 value)
	//
	//    
	//    For messages sent to the `toBuffer` function, `type` is optional.
	//    If the argument is not an object, it will be interpreted as either
	//    `string`, `float`, `array` or `blob`, depending on its javascript type
	//    (String, Number, Array, Buffer, respectively)
	//
	// + An _OSC Bundle_ is represented as a javascript object with the following layout
	//
	//           {
	//               oscType : "bundle"
	//               timetag : 7
	//               elements : [element1, element]
	//           }
	//
	//   Where the timetag is a javascript-native numeric value of the timetag,
	//   and elements is an array of either an _OSC Bundle_ or an _OSC Message_
	//   The `oscType` field is optional, but is always returned by api functions.
	//
	// [spec]: http://opensoundcontrol.org/spec-1_0
	  
	  var utils, coffee;
	  utils = __webpack_require__(20);
	// ~api~
	//## Exported functions
	//
	//------
	//### .fromBuffer(buffer, [strict])
	// takes a node.js Buffer of a complete _OSC Packet_ and 
	// outputs the javascript representation, or throws if the buffer is ill-formed.
	//
	// `strict` is an optional parameter that makes the function fail more often.
	  exports.fromBuffer = function(buffer, strict) {
	    if (buffer instanceof ArrayBuffer) {
	      buffer = new Buffer(new Uint8Array(buffer));
	    } else if (buffer instanceof Uint8Array) {
	      buffer = new Buffer(buffer);
	    }
	    return utils.fromOscPacket(buffer, strict);
	  };
	
	//~api~
	//----
	//### .toBuffer(object, [strict])
	// takes a _OSC packet_ javascript representation as defined below and returns
	// a node.js Buffer, or throws if the representation is ill-formed.
	//
	//----
	//### .toBuffer(address, args[], [strict])
	// alternative syntax for above.  Assumes this is an _OSC Message_ as defined below, 
	// and `args` is an array of _OSC Arguments_ or single _OSC Argument_
	  exports.toBuffer = function(object, strict, opt) {
	    if(typeof object === "string")
	      return utils.toOscPacket({'address' : object, 'args' : strict}, opt);
	    return utils.toOscPacket(object, strict);
	  };
	
	//~api~
	//----
	//### .applyAddressTransform(buffer, transform)
	// takes a callback that takes a string and outputs a string,
	// and applies that to the address of the message encoded in the buffer,
	// and outputs an encoded buffer.
	//
	// If the buffer encodes an _OSC Bundle_, this applies the function to each address 
	// in the bundle.
	//
	// There's two subtle reasons you'd want to use this function rather than 
	// composing `fromBuffer` and `toBuffer`:
	//   - Future-proofing - if the OSC message uses an argument typecode that
	//     we don't understand, calling `fromBuffer` will throw.  The only time
	//     when `applyAddressTranform` might fail is if the address is malformed.
	//   - Accuracy - javascript represents numbers as 64-bit floats, so some
	//     OSC types will not be able to be represented accurately.  If accuracy
	//     is important to you, then, you should never convert the OSC message to a
	//     javascript representation.
	  exports.applyAddressTransform = function(buffer, transform) {
	    return utils.applyTransform(buffer, utils.addressTransform(transform));
	  };
	  
	//~api~
	//----
	//### .applyMessageTransform(buffer, transform)
	// takes a function that takes and returns a javascript _OSC Message_ representation,
	// and applies that to each message encoded in the buffer,
	// and outputs a new buffer with the new address.
	//
	// If the buffer encodes an osc-bundle, this applies the function to each message 
	// in the bundle.
	//
	// See notes above for applyAddressTransform for why you might want to use this.
	// While this does parse and re-pack the messages, the bundle timetags are left
	// in their accurate and prestine state.
	  exports.applyMessageTransform = function(buffer, transform) {
	    return utils.applyTransform(buffer, utils.messageTransform(transform));
	  };
	
	}).call(this);


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.8.0
	(function() {
	  var IsArray, StrictError, binpack, getArrayArg, isOscBundleBuffer, mapBundleList, oscTypeCodes, padding, toOscTypeAndArgs,
	    __hasProp = {}.hasOwnProperty;
	
	  binpack = __webpack_require__(21);
	
	  exports.concat = function(buffers) {
	    var buffer, copyTo, destBuffer, sumLength, _i, _j, _k, _len, _len1, _len2;
	    if (!IsArray(buffers)) {
	      throw new Error("concat must take an array of buffers");
	    }
	    for (_i = 0, _len = buffers.length; _i < _len; _i++) {
	      buffer = buffers[_i];
	      if (!Buffer.isBuffer(buffer)) {
	        throw new Error("concat must take an array of buffers");
	      }
	    }
	    sumLength = 0;
	    for (_j = 0, _len1 = buffers.length; _j < _len1; _j++) {
	      buffer = buffers[_j];
	      sumLength += buffer.length;
	    }
	    destBuffer = new Buffer(sumLength);
	    copyTo = 0;
	    for (_k = 0, _len2 = buffers.length; _k < _len2; _k++) {
	      buffer = buffers[_k];
	      buffer.copy(destBuffer, copyTo);
	      copyTo += buffer.length;
	    }
	    return destBuffer;
	  };
	
	  exports.toOscString = function(str, strict) {
	    var i, nullIndex, _i, _ref;
	    if (!(typeof str === "string")) {
	      throw new Error("can't pack a non-string into an osc-string");
	    }
	    nullIndex = str.indexOf("\u0000");
	    if (nullIndex !== -1 && strict) {
	      throw StrictError("Can't pack an osc-string that contains NULL characters");
	    }
	    if (nullIndex !== -1) {
	      str = str.slice(0, nullIndex);
	    }
	    for (i = _i = 0, _ref = padding(str); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	      str += "\u0000";
	    }
	    return new Buffer(str);
	  };
	
	  exports.splitOscString = function(buffer, strict) {
	    var i, nullIndex, rawStr, rest, splitPoint, str, _i, _ref;
	    if (!Buffer.isBuffer(buffer)) {
	      throw StrictError("Can't split something that isn't a buffer");
	    }
	    rawStr = buffer.toString("utf8");
	    nullIndex = rawStr.indexOf("\u0000");
	    if (nullIndex === -1) {
	      if (strict) {
	        throw new Error("All osc-strings must contain a null character");
	      }
	      return {
	        string: rawStr,
	        rest: new Buffer(0)
	      };
	    }
	    str = rawStr.slice(0, nullIndex);
	    splitPoint = Buffer.byteLength(str) + padding(str);
	    if (strict && splitPoint > buffer.length) {
	      throw StrictError("Not enough padding for osc-string");
	    }
	    if (strict) {
	      for (i = _i = _ref = Buffer.byteLength(str); _ref <= splitPoint ? _i < splitPoint : _i > splitPoint; i = _ref <= splitPoint ? ++_i : --_i) {
	        if (buffer[i] !== 0) {
	          throw StrictError("Not enough or incorrect padding for osc-string");
	        }
	      }
	    }
	    rest = buffer.slice(splitPoint, buffer.length);
	    return {
	      string: str,
	      rest: rest
	    };
	  };
	
	  exports.splitInteger = function(buffer, type) {
	    var bytes, num, rest, value;
	    if (type == null) {
	      type = "Int32";
	    }
	    bytes = (binpack["pack" + type](0)).length;
	    if (buffer.length < bytes) {
	      throw new Error("buffer is not big enough for integer type");
	    }
	    num = 0;
	    value = binpack["unpack" + type](buffer.slice(0, bytes), "big");
	    rest = buffer.slice(bytes, buffer.length);
	    return {
	      integer: value,
	      rest: rest
	    };
	  };
	
	  exports.toIntegerBuffer = function(number, type) {
	    if (type == null) {
	      type = "Int32";
	    }
	    if (typeof number !== "number") {
	      throw new Error("cannot pack a non-number into an integer buffer");
	    }
	    return binpack["pack" + type](number, "big");
	  };
	
	  oscTypeCodes = {
	    s: {
	      representation: "string",
	      split: function(buffer, strict) {
	        var split;
	        split = exports.splitOscString(buffer, strict);
	        return {
	          value: split.string,
	          rest: split.rest
	        };
	      },
	      toArg: function(value, strict) {
	        if (typeof value !== "string") {
	          throw new Error("expected string");
	        }
	        return exports.toOscString(value, strict);
	      }
	    },
	    i: {
	      representation: "integer",
	      split: function(buffer, strict) {
	        var split;
	        split = exports.splitInteger(buffer);
	        return {
	          value: split.integer,
	          rest: split.rest
	        };
	      },
	      toArg: function(value, strict) {
	        if (typeof value !== "number") {
	          throw new Error("expected number");
	        }
	        return exports.toIntegerBuffer(value);
	      }
	    },
	    t: {
	      representation: "timetag",
	      split: function(buffer, strict) {
	        var split;
	        split = exports.splitInteger(buffer, "UInt64");
	        return {
	          value: split.integer,
	          rest: split.rest
	        };
	      },
	      toArg: function(value, strict) {
	        if (typeof value !== "number") {
	          throw new Error("expected number");
	        }
	        return exports.toIntegerBuffer(value, "UInt64");
	      }
	    },
	    f: {
	      representation: "float",
	      split: function(buffer, strict) {
	        return {
	          value: binpack.unpackFloat32(buffer.slice(0, 4), "big"),
	          rest: buffer.slice(4, buffer.length)
	        };
	      },
	      toArg: function(value, strict) {
	        if (typeof value !== "number") {
	          throw new Error("expected number");
	        }
	        return binpack.packFloat32(value, "big");
	      }
	    },
	    d: {
	      representation: "double",
	      split: function(buffer, strict) {
	        return {
	          value: binpack.unpackFloat64(buffer.slice(0, 8), "big"),
	          rest: buffer.slice(8, buffer.length)
	        };
	      },
	      toArg: function(value, strict) {
	        if (typeof value !== "number") {
	          throw new Error("expected number");
	        }
	        return binpack.packFloat64(value, "big");
	      }
	    },
	    b: {
	      representation: "blob",
	      split: function(buffer, strict) {
	        var length, _ref;
	        _ref = exports.splitInteger(buffer), length = _ref.integer, buffer = _ref.rest;
	        return {
	          value: buffer.slice(0, length),
	          rest: buffer.slice(length, buffer.length)
	        };
	      },
	      toArg: function(value, strict) {
	        var size;
	        if (!Buffer.isBuffer(value)) {
	          throw new Error("expected node.js Buffer");
	        }
	        size = exports.toIntegerBuffer(value.length);
	        return exports.concat([size, value]);
	      }
	    },
	    T: {
	      representation: "true",
	      split: function(buffer, strict) {
	        return {
	          rest: buffer,
	          value: true
	        };
	      },
	      toArg: function(value, strict) {
	        if (!value && strict) {
	          throw new Error("true must be true");
	        }
	        return new Buffer(0);
	      }
	    },
	    F: {
	      representation: "false",
	      split: function(buffer, strict) {
	        return {
	          rest: buffer,
	          value: false
	        };
	      },
	      toArg: function(value, strict) {
	        if (value && strict) {
	          throw new Error("false must be false");
	        }
	        return new Buffer(0);
	      }
	    },
	    N: {
	      representation: "null",
	      split: function(buffer, strict) {
	        return {
	          rest: buffer,
	          value: null
	        };
	      },
	      toArg: function(value, strict) {
	        if (value && strict) {
	          throw new Error("null must be false");
	        }
	        return new Buffer(0);
	      }
	    },
	    I: {
	      representation: "bang",
	      split: function(buffer, strict) {
	        return {
	          rest: buffer,
	          value: "bang"
	        };
	      },
	      toArg: function(value, strict) {
	        return new Buffer(0);
	      }
	    }
	  };
	
	  exports.oscTypeCodeToTypeString = function(code) {
	    var _ref;
	    return (_ref = oscTypeCodes[code]) != null ? _ref.representation : void 0;
	  };
	
	  exports.typeStringToOscTypeCode = function(rep) {
	    var code, str;
	    for (code in oscTypeCodes) {
	      if (!__hasProp.call(oscTypeCodes, code)) continue;
	      str = oscTypeCodes[code].representation;
	      if (str === rep) {
	        return code;
	      }
	    }
	    return null;
	  };
	
	  exports.argToTypeCode = function(arg, strict) {
	    var code, value;
	    if (((arg != null ? arg.type : void 0) != null) && (typeof arg.type === 'string') && ((code = exports.typeStringToOscTypeCode(arg.type)) != null)) {
	      return code;
	    }
	    value = (arg != null ? arg.value : void 0) != null ? arg.value : arg;
	    if (strict && (value == null)) {
	      throw new Error('Argument has no value');
	    }
	    if (typeof value === 'string') {
	      return 's';
	    }
	    if (typeof value === 'number') {
	      return 'f';
	    }
	    if (Buffer.isBuffer(value)) {
	      return 'b';
	    }
	    if (typeof value === 'boolean') {
	      if (value) {
	        return 'T';
	      } else {
	        return 'F';
	      }
	    }
	    if (value === null) {
	      return 'N';
	    }
	    throw new Error("I don't know what type this is supposed to be.");
	  };
	
	  exports.splitOscArgument = function(buffer, type, strict) {
	    var osctype;
	    osctype = exports.typeStringToOscTypeCode(type);
	    if (osctype != null) {
	      return oscTypeCodes[osctype].split(buffer, strict);
	    } else {
	      throw new Error("I don't understand how I'm supposed to unpack " + type);
	    }
	  };
	
	  exports.toOscArgument = function(value, type, strict) {
	    var osctype;
	    osctype = exports.typeStringToOscTypeCode(type);
	    if (osctype != null) {
	      return oscTypeCodes[osctype].toArg(value, strict);
	    } else {
	      throw new Error("I don't know how to pack " + type);
	    }
	  };
	
	  exports.fromOscMessage = function(buffer, strict) {
	    var address, arg, args, arrayStack, built, type, typeString, types, _i, _len, _ref, _ref1;
	    _ref = exports.splitOscString(buffer, strict), address = _ref.string, buffer = _ref.rest;
	    if (strict && address[0] !== '/') {
	      throw StrictError('addresses must start with /');
	    }
	    if (!buffer.length) {
	      return {
	        address: address,
	        args: []
	      };
	    }
	    _ref1 = exports.splitOscString(buffer, strict), types = _ref1.string, buffer = _ref1.rest;
	    if (types[0] !== ',') {
	      if (strict) {
	        throw StrictError('Argument lists must begin with ,');
	      }
	      return {
	        address: address,
	        args: []
	      };
	    }
	    types = types.slice(1, +types.length + 1 || 9e9);
	    args = [];
	    arrayStack = [args];
	    for (_i = 0, _len = types.length; _i < _len; _i++) {
	      type = types[_i];
	      if (type === '[') {
	        arrayStack.push([]);
	        continue;
	      }
	      if (type === ']') {
	        if (arrayStack.length <= 1) {
	          if (strict) {
	            throw new StrictError("Mismatched ']' character.");
	          }
	        } else {
	          built = arrayStack.pop();
	          arrayStack[arrayStack.length - 1].push({
	            type: 'array',
	            value: built
	          });
	        }
	        continue;
	      }
	      typeString = exports.oscTypeCodeToTypeString(type);
	      if (typeString == null) {
	        throw new Error("I don't understand the argument code " + type);
	      }
	      arg = exports.splitOscArgument(buffer, typeString, strict);
	      if (arg != null) {
	        buffer = arg.rest;
	      }
	      arrayStack[arrayStack.length - 1].push({
	        type: typeString,
	        value: arg != null ? arg.value : void 0
	      });
	    }
	    if (arrayStack.length !== 1 && strict) {
	      throw new StrictError("Mismatched '[' character");
	    }
	    return {
	      address: address,
	      args: args,
	      oscType: "message"
	    };
	  };
	
	  exports.fromOscBundle = function(buffer, strict) {
	    var bundleTag, convertedElems, timetag, _ref, _ref1;
	    _ref = exports.splitOscString(buffer, strict), bundleTag = _ref.string, buffer = _ref.rest;
	    if (bundleTag !== "\#bundle") {
	      throw new Error("osc-bundles must begin with \#bundle");
	    }
	    _ref1 = exports.splitInteger(buffer, "UInt64"), timetag = _ref1.integer, buffer = _ref1.rest;
	    convertedElems = mapBundleList(buffer, function(buffer) {
	      return exports.fromOscPacket(buffer, strict);
	    });
	    return {
	      timetag: timetag,
	      elements: convertedElems,
	      oscType: "bundle"
	    };
	  };
	
	  exports.fromOscPacket = function(buffer, strict) {
	    if (isOscBundleBuffer(buffer, strict)) {
	      return exports.fromOscBundle(buffer, strict);
	    } else {
	      return exports.fromOscMessage(buffer, strict);
	    }
	  };
	
	  getArrayArg = function(arg) {
	    if (IsArray(arg)) {
	      return arg;
	    } else if (((arg != null ? arg.type : void 0) === "array") && (IsArray(arg != null ? arg.value : void 0))) {
	      return arg.value;
	    } else if ((arg != null) && (arg.type == null) && (IsArray(arg.value))) {
	      return arg.value;
	    } else {
	      return null;
	    }
	  };
	
	  toOscTypeAndArgs = function(argList, strict) {
	    var arg, buff, oscargs, osctype, thisArgs, thisType, typeCode, value, _i, _len, _ref;
	    osctype = "";
	    oscargs = [];
	    for (_i = 0, _len = argList.length; _i < _len; _i++) {
	      arg = argList[_i];
	      if ((getArrayArg(arg)) != null) {
	        _ref = toOscTypeAndArgs(getArrayArg(arg), strict), thisType = _ref[0], thisArgs = _ref[1];
	        osctype += "[" + thisType + "]";
	        oscargs = oscargs.concat(thisArgs);
	        continue;
	      }
	      typeCode = exports.argToTypeCode(arg, strict);
	      if (typeCode != null) {
	        value = arg != null ? arg.value : void 0;
	        if (value === void 0) {
	          value = arg;
	        }
	        buff = exports.toOscArgument(value, exports.oscTypeCodeToTypeString(typeCode), strict);
	        if (buff != null) {
	          oscargs.push(buff);
	          osctype += typeCode;
	        }
	      }
	    }
	    return [osctype, oscargs];
	  };
	
	  exports.toOscMessage = function(message, strict) {
	    var address, allArgs, args, old_arg, oscaddr, oscargs, osctype, _ref;
	    address = (message != null ? message.address : void 0) != null ? message.address : message;
	    if (typeof address !== "string") {
	      throw new Error("message must contain an address");
	    }
	    args = message != null ? message.args : void 0;
	    if (args === void 0) {
	      args = [];
	    }
	    if (!IsArray(args)) {
	      old_arg = args;
	      args = [];
	      args[0] = old_arg;
	    }
	    oscaddr = exports.toOscString(address, strict);
	    _ref = toOscTypeAndArgs(args, strict), osctype = _ref[0], oscargs = _ref[1];
	    osctype = "," + osctype;
	    allArgs = exports.concat(oscargs);
	    osctype = exports.toOscString(osctype);
	    return exports.concat([oscaddr, osctype, allArgs]);
	  };
	
	  exports.toOscBundle = function(bundle, strict) {
	    var allElems, buff, e, elem, elements, elemstr, oscBundleTag, oscElems, oscTimeTag, size, timetag, _i, _len, _ref, _ref1;
	    if (strict && ((bundle != null ? bundle.timetag : void 0) == null)) {
	      throw StrictError("bundles must have timetags.");
	    }
	    timetag = (_ref = bundle != null ? bundle.timetag : void 0) != null ? _ref : 0;
	    elements = (_ref1 = bundle != null ? bundle.elements : void 0) != null ? _ref1 : [];
	    if (!IsArray(elements)) {
	      elemstr = elements;
	      elements = [];
	      elements.push(elemstr);
	    }
	    oscBundleTag = exports.toOscString("\#bundle");
	    oscTimeTag = exports.toIntegerBuffer(timetag, "UInt64");
	    oscElems = [];
	    for (_i = 0, _len = elements.length; _i < _len; _i++) {
	      elem = elements[_i];
	      try {
	        buff = exports.toOscPacket(elem, strict);
	        size = exports.toIntegerBuffer(buff.length);
	        oscElems.push(exports.concat([size, buff]));
	      } catch (_error) {
	        e = _error;
	        null;
	      }
	    }
	    allElems = exports.concat(oscElems);
	    return exports.concat([oscBundleTag, oscTimeTag, allElems]);
	  };
	
	  exports.toOscPacket = function(bundleOrMessage, strict) {
	    if ((bundleOrMessage != null ? bundleOrMessage.oscType : void 0) != null) {
	      if (bundleOrMessage.oscType === "bundle") {
	        return exports.toOscBundle(bundleOrMessage, strict);
	      }
	      return exports.toOscMessage(bundleOrMessage, strict);
	    }
	    if (((bundleOrMessage != null ? bundleOrMessage.timetag : void 0) != null) || ((bundleOrMessage != null ? bundleOrMessage.elements : void 0) != null)) {
	      return exports.toOscBundle(bundleOrMessage, strict);
	    }
	    return exports.toOscMessage(bundleOrMessage, strict);
	  };
	
	  exports.applyMessageTranformerToBundle = function(transform) {
	    return function(buffer) {
	      var bundleTagBuffer, copyIndex, elem, elems, lengthBuff, outBuffer, string, timetagBuffer, totalLength, _i, _j, _len, _len1, _ref;
	      _ref = exports.splitOscString(buffer), string = _ref.string, buffer = _ref.rest;
	      if (string !== "\#bundle") {
	        throw new Error("osc-bundles must begin with \#bundle");
	      }
	      bundleTagBuffer = exports.toOscString(string);
	      timetagBuffer = buffer.slice(0, 8);
	      buffer = buffer.slice(8, buffer.length);
	      elems = mapBundleList(buffer, function(buffer) {
	        return exports.applyTransform(buffer, transform, exports.applyMessageTranformerToBundle(transform));
	      });
	      totalLength = bundleTagBuffer.length + timetagBuffer.length;
	      for (_i = 0, _len = elems.length; _i < _len; _i++) {
	        elem = elems[_i];
	        totalLength += 4 + elem.length;
	      }
	      outBuffer = new Buffer(totalLength);
	      bundleTagBuffer.copy(outBuffer, 0);
	      timetagBuffer.copy(outBuffer, bundleTagBuffer.length);
	      copyIndex = bundleTagBuffer.length + timetagBuffer.length;
	      for (_j = 0, _len1 = elems.length; _j < _len1; _j++) {
	        elem = elems[_j];
	        lengthBuff = exports.toIntegerBuffer(elem.length);
	        lengthBuff.copy(outBuffer, copyIndex);
	        copyIndex += 4;
	        elem.copy(outBuffer, copyIndex);
	        copyIndex += elem.length;
	      }
	      return outBuffer;
	    };
	  };
	
	  exports.applyTransform = function(buffer, mTransform, bundleTransform) {
	    if (bundleTransform == null) {
	      bundleTransform = exports.applyMessageTranformerToBundle(mTransform);
	    }
	    if (isOscBundleBuffer(buffer)) {
	      return bundleTransform(buffer);
	    } else {
	      return mTransform(buffer);
	    }
	  };
	
	  exports.addressTransform = function(transform) {
	    return function(buffer) {
	      var rest, string, _ref;
	      _ref = exports.splitOscString(buffer), string = _ref.string, rest = _ref.rest;
	      string = transform(string);
	      return exports.concat([exports.toOscString(string), rest]);
	    };
	  };
	
	  exports.messageTransform = function(transform) {
	    return function(buffer) {
	      var message;
	      message = exports.fromOscMessage(buffer);
	      return exports.toOscMessage(transform(message));
	    };
	  };
	
	  IsArray = Array.isArray;
	
	  StrictError = function(str) {
	    return new Error("Strict Error: " + str);
	  };
	
	  padding = function(str) {
	    var bufflength;
	    bufflength = Buffer.byteLength(str);
	    return 4 - (bufflength % 4);
	  };
	
	  isOscBundleBuffer = function(buffer, strict) {
	    var string;
	    string = exports.splitOscString(buffer, strict).string;
	    return string === "\#bundle";
	  };
	
	  mapBundleList = function(buffer, func) {
	    var e, elem, elems, nonNullElems, size, thisElemBuffer, _i, _len;
	    elems = (function() {
	      var _ref, _results;
	      _results = [];
	      while (buffer.length) {
	        _ref = exports.splitInteger(buffer), size = _ref.integer, buffer = _ref.rest;
	        if (size > buffer.length) {
	          throw new Error("Invalid bundle list: size of element is bigger than buffer");
	        }
	        thisElemBuffer = buffer.slice(0, size);
	        buffer = buffer.slice(size, buffer.length);
	        try {
	          _results.push(func(thisElemBuffer));
	        } catch (_error) {
	          e = _error;
	          _results.push(null);
	        }
	      }
	      return _results;
	    })();
	    nonNullElems = [];
	    for (_i = 0, _len = elems.length; _i < _len; _i++) {
	      elem = elems[_i];
	      if (elem != null) {
	        nonNullElems.push(elem);
	      }
	    }
	    return nonNullElems;
	  };
	
	}).call(this);


/***/ },
/* 21 */
/***/ function(module, exports) {

	// t is a binpack typename
	var sizeOfType = function(t) {
	    // unsigned are the same length as signed
	    if(t[0] === 'U') {
	        t = t.slice(1);
	    }
	
	    return {
	        'Float32' : 4,
	        'Float64' : 8,
	        'Int8' : 1,
	        'Int16' : 2,
	        'Int32' : 4,
	        'Int64' : 8
	    }[t];
	};
	
	var endianConv = function(e, t) {
	    // node doesn't define 8 bit endianness
	    if(t[t.length - 1] === '8')
	        return '';
	
	    if(e === 'big') {
	        return 'BE';
	    }
	    return 'LE';
	};
	
	var addBindings = function(binpackTypename, nodeTypename){
	    if(!(typeof nodeTypename !== "undefined" && nodeTypename !== null)) {
	        nodeTypename = binpackTypename;
	    }
	    module.exports['pack' + binpackTypename] = function(num, endian){
	        b = new Buffer(sizeOfType(binpackTypename));
	        b['write' + nodeTypename + endianConv(endian, binpackTypename)](num, 0, true);
	        return b;
	    }
	
	    module.exports['unpack' + binpackTypename] = function(buff, endian){
	        return buff['read' + nodeTypename + endianConv(endian, binpackTypename)](0);
	    }
	}
	
	var addIntBindings = function(n) {
	    addBindings("Int" + n);
	    addBindings("UInt" + n);
	}
	
	addIntBindings(8);
	addIntBindings(16);
	addIntBindings(32);
	
	twoToThe32 = Math.pow(2, 32);
	
	// 64 bit bindings require special care
	var read64 = function(unsigned){return function(buff, endian){
	    var e = endianConv(endian, '');
	    var u = unsigned ? 'U' : '';
	    var low, high;
	    if(e === 'LE') {
	        low = buff.readUInt32LE(0);
	        high = buff['read' + u + 'Int32LE'](4);
	    } else {
	        low = buff.readUInt32BE(4);
	        high = buff['read' + u + 'Int32BE'](0);
	    }
	    return high * twoToThe32 + low;
	};};
	
	var write64 = function(unsigned){return function(num, endian){
	    var e = endianConv(endian, '');
	    var u = unsigned ? 'U' : '';
	    var b = new Buffer(8);
	    var high = Math.floor(num / twoToThe32);
	    var low = Math.floor(num - high * twoToThe32);
	    if(e == 'LE') {
	        b.writeUInt32LE(low, 0, true);
	        b['write' + u + 'Int32LE'](high, 4, true);
	    } else {
	        b.writeUInt32BE(low, 4, true);
	        b['write' + u + 'Int32BE'](high, 0, true);
	    }
	    return b;
	};};
	
	module.exports.unpackInt64 = read64(false);
	module.exports.unpackUInt64 = read64(true);
	module.exports.packInt64 = write64(false);
	module.exports.packUInt64 = write64(true);
	
	addBindings("Float32", "Float");
	addBindings("Float64", "Double");


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var dgram = __webpack_require__(18);
	var util = __webpack_require__(23);
	var events = __webpack_require__(24);
	
	var decode = __webpack_require__(25);
	
	var Server = function(port, host) {
	    var server;
	    events.EventEmitter.call(this);
	    this.port = port;
	    this.host = host;
	    this._sock = dgram.createSocket({
	      type: 'udp4',
	      reuseAddr: true
	    });
	    this._sock.bind(port);
	    server = this;
	    this._sock.on('message', function (msg, rinfo) {
	        try {
	            var decoded = decode(msg);
	            // [<address>, <typetags>, <values>*]
	        }
	        catch (e) {
	            console.log('can\'t decode incoming message: ' + e.message);
	        }
	
	        if (decoded) {
	            server.emit('message', decoded, rinfo);
	            server.emit(decoded[0], decoded, rinfo);
	        }
	    });
	    this.kill = function() {
	        this._sock.close();
	    };
	};
	
	util.inherits(Server, events.EventEmitter);
	
	module.exports = Server;


/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = require("events");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var types = __webpack_require__(26);
	
	var TInt = types.TInt;
	var TFloat = types.TFloat;
	var TString = types.TString;
	var TBlob = types.TBlob;
	var TDouble = types.TDouble;
	var TTime = types.TTime;
	
	// for each OSC type tag we use a specific constructor function to decode its respective data
	var tagToConstructor = { 'i': function () { return new TInt(); },
	                         'f': function () { return new TFloat(); },
	                         's': function () { return new TString(); },
	                         'b': function () { return new TBlob(); },
	                         'd': function () { return new TDouble(); } };
	
	function decode (data) {
	    // this stores the decoded data as an array
	    var message = [];
	
	    // we start getting the <address> and <rest> of OSC msg /<address>\0<rest>\0<typetags>\0<data>
	    var address = new TString();
	    data = address.decode(data);
	
	    // Checking if we received a bundle (typical for TUIO/OSC)
	    if (address.value === '#bundle') {
	        var time = new TTime();
	        data = time.decode(data);
	
	        message.push('#bundle');
	        message.push(time.value);
	
	        var length, part;
	        while(data.length > 0) {
	            length = new TInt();
	            data = length.decode(data);
	
	            part = data.slice(0, length.value);
	            //message = message.concat(decode(part));
	            message.push(decode(part));
	
	            data = data.slice(length.value, data.length);
	        }
	
	    } else if (data.length > 0) {
	        message.push(address.value);
	
	        // if we have rest, maybe we have some typetags... let see...
	
	        // now we advance on the old rest, getting <typetags>
	        var typetags = new TString();
	        data = typetags.decode(data);
	        typetags = typetags.value;
	        // so we start building our message list
	        if (typetags[0] !== ',') {
	            throw 'invalid type tag in incoming OSC message, must start with comma';
	        }
	        for (var i = 1; i < typetags.length; i++) {
	            var constructor = tagToConstructor[typetags[i]];
	            if (!constructor) {
	                throw 'Unsupported OSC type tag ' + typetags[i] + ' in incoming message';
	            }
	            var argument = constructor();
	            data = argument.decode(data);
	            message.push(argument.value);
	        }
	    }
	
	    return message;
	}
	
	module.exports = decode;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var jspack = __webpack_require__(27).jspack;
	
	var pack = jspack.packTo;
	
	function ShortBuffer(type, buf, requiredLength)
	{
	    this.type = 'ShortBuffer';
	    var message = 'buffer [';
	    for (var i = 0; i < buf.length; i++) {
	        if (i) {
	            message += ', ';
	        }
	        message += buf.charCodeAt(i);
	    }
	    message += '] too short for ' + type + ', ' + requiredLength + ' bytes required';
	    this.message = message;
	}
	
	function TString (value) { this.value = value; }
	
	TString.prototype = {
	    typetag: 's',
	    decode: function (data) {
	        var end = 0;
	        while (data[end] && end < data.length) {
	            end++;
	        }
	        if (end === data.length) {
	            throw Error('OSC string not null terminated');
	        }
	        this.value = data.toString('ascii', 0, end);
	        var nextData = parseInt(Math.ceil((end + 1) / 4.0) * 4);
	        return data.slice(nextData);
	    },
	    encode: function (buf, pos) {
	        var len = Math.ceil((this.value.length + 1) / 4.0) * 4;
	        return pack('>' + len + 's', buf, pos, [ this.value ]);
	    }
	};
	
	exports.TString = TString;
	
	function TInt (value) { this.value = value; }
	
	TInt.prototype = {
	    typetag: 'i',
	    decode: function (data) {
	        if (data.length < 4) {
	            throw new ShortBuffer('int', data, 4);
	        }
	
	        this.value = jspack.Unpack('>i', data.slice(0, 4))[0];
	        return data.slice(4);
	    },
	    encode: function (buf, pos) {
	        return pack('>i', buf, pos, [ this.value ]);
	    }
	};
	
	exports.TInt = TInt;
	
	function TTime (value) { this.value = value; }
	
	TTime.prototype = {
	    typetag: 't',
	    decode: function (data) {
	        if (data.length < 8) {
	            throw new ShortBuffer('time', data, 8);
	        }
	        var raw = jspack.Unpack('>LL', data.slice(0, 8));
	        var secs = raw[0];
	        var fracs = raw[1];
	        this.value = secs + fracs / 4294967296;
	        return data.slice(8);
	    },
	    encode: function (buf, pos) {
	        return pack('>LL', buf, pos, this.value);
	    }
	};
	
	exports.TTime = TTime;
	
	function TFloat (value) { this.value = value; }
	TFloat.prototype = {
	    typetag: 'f',
	    decode: function (data) {
	        if (data.length < 4) {
	            throw new ShortBuffer('float', data, 4);
	        }
	
	        this.value = jspack.Unpack('>f', data.slice(0, 4))[0];
	        return data.slice(4);
	    },
	    encode: function (buf, pos) {
	        return pack('>f', buf, pos, [ this.value ]);
	    }
	};
	
	exports.TFloat = TFloat;
	
	function TBlob (value) { this.value = value; }
	TBlob.prototype = {
	    typetag: 'b',
	    decode: function (data) {
	        var length = jspack.Unpack('>i', data.slice(0, 4))[0];
	        var nextData = parseInt(Math.ceil((length) / 4.0) * 4) + 4;
	        this.value = data.slice(4, length + 4);
	        return data.slice(nextData);
	    },
	    encode: function (buf, pos) {
	        var len = Math.ceil((this.value.length) / 4.0) * 4;
	        return pack('>i' + len + 's', buf, pos, [len, this.value]);
	    }
	};
	
	exports.TBlob = TBlob;
	
	function TDouble (value) { this.value = value; }
	TDouble.prototype = {
	    typetag: 'd',
	    decode: function (data) {
	        if (data.length < 8) {
	            throw new ShortBuffer('double', data, 8);
	        }
	        this.value = jspack.Unpack('>d', data.slice(0, 8))[0];
	        return data.slice(8);
	    },
	    encode: function (buf, pos) {
	        return pack('>d', buf, pos, [ this.value ]);
	    }
	};
	
	exports.TDouble = TDouble;


/***/ },
/* 27 */
/***/ function(module, exports) {

	/*!
	 *  Copyright © 2008 Fair Oaks Labs, Inc.
	 *  All rights reserved.
	 */
	
	// Utility object:  Encode/Decode C-style binary primitives to/from octet arrays
	function JSPack()
	{
		// Module-level (private) variables
		var el,  bBE = false, m = this;
	
	
		// Raw byte arrays
		m._DeArray = function (a, p, l)
		{
			return [a.slice(p,p+l)];
		};
		m._EnArray = function (a, p, l, v)
		{
			for (var i = 0; i < l; a[p+i] = v[i]?v[i]:0, i++);
		};
	
		// ASCII characters
		m._DeChar = function (a, p)
		{
			return String.fromCharCode(a[p]);
		};
		m._EnChar = function (a, p, v)
		{
			a[p] = v.charCodeAt(0);
		};
	
		// Little-endian (un)signed N-byte integers
		m._DeInt = function (a, p)
		{
			var lsb = bBE?(el.len-1):0, nsb = bBE?-1:1, stop = lsb+nsb*el.len, rv, i, f;
			for (rv = 0, i = lsb, f = 1; i != stop; rv+=(a[p+i]*f), i+=nsb, f*=256);
			if (el.bSigned && (rv & Math.pow(2, el.len*8-1))) { rv -= Math.pow(2, el.len*8); }
			return rv;
		};
		m._EnInt = function (a, p, v)
		{
			var lsb = bBE?(el.len-1):0, nsb = bBE?-1:1, stop = lsb+nsb*el.len, i;
			v = (v<el.min)?el.min:(v>el.max)?el.max:v;
			for (i = lsb; i != stop; a[p+i]=v&0xff, i+=nsb, v>>=8);
		};
	
		// ASCII character strings
		m._DeString = function (a, p, l)
		{
			for (var rv = new Array(l), i = 0; i < l; rv[i] = String.fromCharCode(a[p+i]), i++);
			return rv.join('');
		};
		m._EnString = function (a, p, l, v)
		{
			for (var t, i = 0; i < l; a[p+i] = (t=v.charCodeAt(i))?t:0, i++);
		};
	
		// Little-endian N-bit IEEE 754 floating point
		m._De754 = function (a, p)
		{
			var s, e, m, i, d, nBits, mLen, eLen, eBias, eMax;
			mLen = el.mLen, eLen = el.len*8-el.mLen-1, eMax = (1<<eLen)-1, eBias = eMax>>1;
	
			i = bBE?0:(el.len-1); d = bBE?1:-1; s = a[p+i]; i+=d; nBits = -7;
			for (e = s&((1<<(-nBits))-1), s>>=(-nBits), nBits += eLen; nBits > 0; e=e*256+a[p+i], i+=d, nBits-=8);
			for (m = e&((1<<(-nBits))-1), e>>=(-nBits), nBits += mLen; nBits > 0; m=m*256+a[p+i], i+=d, nBits-=8);
	
			switch (e)
			{
				case 0:
					// Zero, or denormalized number
					e = 1-eBias;
					break;
				case eMax:
					// NaN, or +/-Infinity
					return m?NaN:((s?-1:1)*Infinity);
				default:
					// Normalized number
					m = m + Math.pow(2, mLen);
					e = e - eBias;
					break;
			}
			return (s?-1:1) * m * Math.pow(2, e-mLen);
		};
		m._En754 = function (a, p, v)
		{
			var s, e, m, i, d, c, mLen, eLen, eBias, eMax;
			mLen = el.mLen, eLen = el.len*8-el.mLen-1, eMax = (1<<eLen)-1, eBias = eMax>>1;
	
			s = v<0?1:0;
			v = Math.abs(v);
			if (isNaN(v) || (v == Infinity))
			{
				m = isNaN(v)?1:0;
				e = eMax;
			}
			else
			{
				e = Math.floor(Math.log(v)/Math.LN2);			// Calculate log2 of the value
				if (v*(c = Math.pow(2, -e)) < 1) { e--; c*=2; }		// Math.log() isn't 100% reliable
	
				// Round by adding 1/2 the significand's LSD
				if (e+eBias >= 1) { v += el.rt/c; }			// Normalized:  mLen significand digits
				else { v += el.rt*Math.pow(2, 1-eBias); } 		// Denormalized:  <= mLen significand digits
				if (v*c >= 2) { e++; c/=2; }				// Rounding can increment the exponent
	
				if (e+eBias >= eMax)
				{
					// Overflow
					m = 0;
					e = eMax;
				}
				else if (e+eBias >= 1)
				{
					// Normalized - term order matters, as Math.pow(2, 52-e) and v*Math.pow(2, 52) can overflow
					m = (v*c-1)*Math.pow(2, mLen);
					e = e + eBias;
				}
				else
				{
					// Denormalized - also catches the '0' case, somewhat by chance
					m = v*Math.pow(2, eBias-1)*Math.pow(2, mLen);
					e = 0;
				}
			}
	
			for (i = bBE?(el.len-1):0, d=bBE?-1:1; mLen >= 8; a[p+i]=m&0xff, i+=d, m/=256, mLen-=8);
			for (e=(e<<mLen)|m, eLen+=mLen; eLen > 0; a[p+i]=e&0xff, i+=d, e/=256, eLen-=8);
			a[p+i-d] |= s*128;
		};
	
		// Convert int64 to array with 3 elements: [lowBits, highBits, unsignedFlag]
		// '>>>' trick to convert signed 32bit int to unsigned int (because << always results in a signed 32bit int)
		m._DeInt64 = function (a, p) {
			var start = bBE ? 0 : 7, nsb = bBE ? 1 : -1, stop = start + nsb * 8, rv = [0,0, !el.bSigned], i, f, rvi;
			for (i = start, rvi = 1, f = 0;
				i != stop;
				rv[rvi] = (((rv[rvi]<<8)>>>0) + a[p + i]), i += nsb, f++, rvi = (f < 4 ? 1 : 0));
			return rv;
		};
		m._EnInt64 = function (a, p, v) {
			var start = bBE ? 0 : 7, nsb = bBE ? 1 : -1, stop = start + nsb * 8, i, f, rvi, s;
			for (i = start, rvi = 1, f = 0, s = 24;
				i != stop;
				a[p + i] = v[rvi]>>s & 0xff, i += nsb, f++, rvi = (f < 4 ? 1 : 0), s = 24 - (8 * (f % 4)));
		};
		
	
		// Class data
		m._sPattern	= '(\\d+)?([AxcbBhHsfdiIlLqQ])';
		m._lenLut	= {'A':1, 'x':1, 'c':1, 'b':1, 'B':1, 'h':2, 'H':2, 's':1, 'f':4, 'd':8, 'i':4, 'I':4, 'l':4, 'L':4, 'q':8, 'Q':8};
		m._elLut	= {	'A': {en:m._EnArray, de:m._DeArray},
					's': {en:m._EnString, de:m._DeString},
					'c': {en:m._EnChar, de:m._DeChar},
					'b': {en:m._EnInt, de:m._DeInt, len:1, bSigned:true, min:-Math.pow(2, 7), max:Math.pow(2, 7)-1},
					'B': {en:m._EnInt, de:m._DeInt, len:1, bSigned:false, min:0, max:Math.pow(2, 8)-1},
					'h': {en:m._EnInt, de:m._DeInt, len:2, bSigned:true, min:-Math.pow(2, 15), max:Math.pow(2, 15)-1},
					'H': {en:m._EnInt, de:m._DeInt, len:2, bSigned:false, min:0, max:Math.pow(2, 16)-1},
					'i': {en:m._EnInt, de:m._DeInt, len:4, bSigned:true, min:-Math.pow(2, 31), max:Math.pow(2, 31)-1},
					'I': {en:m._EnInt, de:m._DeInt, len:4, bSigned:false, min:0, max:Math.pow(2, 32)-1},
					'l': {en:m._EnInt, de:m._DeInt, len:4, bSigned:true, min:-Math.pow(2, 31), max:Math.pow(2, 31)-1},
					'L': {en:m._EnInt, de:m._DeInt, len:4, bSigned:false, min:0, max:Math.pow(2, 32)-1},
					'f': {en:m._En754, de:m._De754, len:4, mLen:23, rt:Math.pow(2, -24)-Math.pow(2, -77)},
					'd': {en:m._En754, de:m._De754, len:8, mLen:52, rt:0},
					'q': {en:m._EnInt64, de:m._DeInt64, bSigned:true},
					'Q': {en:m._EnInt64, de:m._DeInt64, bSigned:false}};
	
		// Unpack a series of n elements of size s from array a at offset p with fxn
		m._UnpackSeries = function (n, s, a, p)
		{
			for (var fxn = el.de, rv = [], i = 0; i < n; rv.push(fxn(a, p+i*s)), i++);
			return rv;
		};
	
		// Pack a series of n elements of size s from array v at offset i to array a at offset p with fxn
		m._PackSeries = function (n, s, a, p, v, i)
		{
			for (var fxn = el.en, o = 0; o < n; fxn(a, p+o*s, v[i+o]), o++);
		};
	
		// Unpack the octet array a, beginning at offset p, according to the fmt string
		m.Unpack = function (fmt, a, p)
		{
			// Set the private bBE flag based on the format string - assume big-endianness
			bBE = (fmt.charAt(0) != '<');
	
			p = p?p:0;
			var re = new RegExp(this._sPattern, 'g'), m, n, s, rv = [];
			while (m = re.exec(fmt))
			{
				n = ((m[1]==undefined)||(m[1]==''))?1:parseInt(m[1]);
				s = this._lenLut[m[2]];
				if ((p + n*s) > a.length)
				{
					return undefined;
				}
				switch (m[2])
				{
					case 'A': case 's':
						rv.push(this._elLut[m[2]].de(a, p, n));
						break;
					case 'c': case 'b': case 'B': case 'h': case 'H':
					case 'i': case 'I': case 'l': case 'L': case 'f': case 'd': case 'q': case 'Q':
						el = this._elLut[m[2]];
						rv.push(this._UnpackSeries(n, s, a, p));
						break;
				}
				p += n*s;
			}
			return Array.prototype.concat.apply([], rv);
		};
	
		// Pack the supplied values into the octet array a, beginning at offset p, according to the fmt string
		m.PackTo = function (fmt, a, p, values)
		{
			// Set the private bBE flag based on the format string - assume big-endianness
			bBE = (fmt.charAt(0) != '<');
	
			var re = new RegExp(this._sPattern, 'g'), m, n, s, i = 0, j;
			while (m = re.exec(fmt))
			{
				n = ((m[1]==undefined)||(m[1]==''))?1:parseInt(m[1]);
				s = this._lenLut[m[2]];
				if ((p + n*s) > a.length)
				{
					return false;
				}
				switch (m[2])
				{
					case 'A': case 's':
						if ((i + 1) > values.length) { return false; }
						this._elLut[m[2]].en(a, p, n, values[i]);
						i += 1;
						break;
					case 'c': case 'b': case 'B': case 'h': case 'H':
					case 'i': case 'I': case 'l': case 'L': case 'f': case 'd': case 'q': case 'Q':
						el = this._elLut[m[2]];
						if ((i + n) > values.length) { return false; }
						this._PackSeries(n, s, a, p, values, i);
						i += n;
						break;
					case 'x':
						for (j = 0; j < n; j++) { a[p+j] = 0; }
						break;
				}
				p += n*s;
			}
			return a;
		};
	
		// Pack the supplied values into a new octet array, according to the fmt string
		m.Pack = function (fmt, values)
		{
			return this.PackTo(fmt, new Array(this.CalcLength(fmt)), 0, values);
		};
	
		// Determine the number of bytes represented by the format string
		m.CalcLength = function (fmt)
		{
			var re = new RegExp(this._sPattern, 'g'), m, sum = 0;
			while (m = re.exec(fmt))
			{
				sum += (((m[1]==undefined)||(m[1]==''))?1:parseInt(m[1])) * this._lenLut[m[2]];
			}
			return sum;
		};
	};
	
	exports.jspack = new JSPack();


/***/ },
/* 28 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	window.AudioContext = window.AudioContext || window.webkitAudioContext;
	window.navigator.getUserMedia = window.navigator.getUserMedia || window.navigator.webkitGetUserMedia;
	
	var SOURCE_NAME = 'Soundflower (2ch)';
	// const SOURCE_NAME = 'Default'
	
	var AudioAnalyser = function () {
		function AudioAnalyser() {
			_classCallCheck(this, AudioAnalyser);
	
			this.volume = 0;
			this.initUserMedia = this.initUserMedia.bind(this);
	
			window.MediaStreamTrack.getSources(this.gotSources.bind(this));
		}
	
		_createClass(AudioAnalyser, [{
			key: 'gotSources',
			value: function gotSources(sourceInfos) {
	
				// console.log(sourceInfos)
	
				var sourceId = null;
	
				for (var i = 0; i < sourceInfos.length; i++) {
					var info = sourceInfos[i];
					if (info.label == SOURCE_NAME) {
						sourceId = info.id;
						break;
					}
				}
	
				var option = {
					audio: {
						optional: [{
							sourceId: sourceId
						}]
					}
				};
	
				// let option = {audio: true}
	
				window.navigator.getUserMedia(option, this.initUserMedia, function () {});
			}
		}, {
			key: 'initUserMedia',
			value: function initUserMedia(stream) {
	
				var context = new AudioContext();
				var source = context.createMediaStreamSource(stream);
	
				this.analyser = context.createAnalyser();
	
				source.connect(this.analyser);
				// this.analyser.connect(context.destination)
	
				// create data
				this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount);
	
				this.update = this._update;
			}
		}, {
			key: 'update',
			value: function update() {}
		}, {
			key: '_update',
			value: function _update() {
	
				this.analyser.getByteFrequencyData(this.frequencyData);
	
				// calc average
				this.volume = this.frequencyData[512];
				// for (let i = 0; i < 1024; i++) {
				// 	// average += this.frequencyData[i]
				// 	this.volume = Math.max(this.volume, this.frequencyData[i])
				// }
	
				console.log(this.volume);
				this.volume /= 256.0;
			}
		}]);
	
		return AudioAnalyser;
	}();

	exports.default = AudioAnalyser;

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYWUxOGFkZGI2ODJiYmUxZTIyNzYiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3RocmVlL3RocmVlLmpzIiwid2VicGFjazovLy8uL3dlYl9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL1NoYWRlclBhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vd2ViX21vZHVsZXMvcG9zdHByb2Nlc3NpbmcvTWFza1Bhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vd2ViX21vZHVsZXMvcG9zdHByb2Nlc3NpbmcvUmVuZGVyUGFzcy5qcyIsIndlYnBhY2s6Ly8vLi93ZWJfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9FZmZlY3RDb21wb3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYnJ1c2gtcGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFzZS1wYXNzLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL2Jhc2UtcGFzcy52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL2JydXNoLXBhc3MuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9yZW5kZXItcGFzcy5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ai1pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy90aWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ub2RlLW9zYy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9ub2RlLW9zYy9saWIvTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L25vZGUtb3NjL2xpYi9DbGllbnQuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZGdyYW1cIiIsIndlYnBhY2s6Ly8vLi9+L29zYy1taW4vbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vb3NjLW1pbi9saWIvb3NjLXV0aWxpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JpbnBhY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9ub2RlLW9zYy9saWIvU2VydmVyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInV0aWxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJldmVudHNcIiIsIndlYnBhY2s6Ly8vLi9+L25vZGUtb3NjL2xpYi9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ub2RlLW9zYy9saWIvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9qc3BhY2svanNwYWNrLmpzIiwid2VicGFjazovLy8uL3NyYy9hdWRpby1hbmFseXNlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FDdENBLHFCQUFRLENBQVIsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNXQSxRQUFPLFNBQVA7QUFDQSxRQUFPLFFBQVAsR0FBa0IsSUFBbEI7O0tBRU07QUFFTCxXQUZLLEdBRUwsR0FBYzt5QkFGVCxLQUVTO0dBQWQ7O2VBRks7OzBCQUlFOztBQUVOLFNBQUssU0FBTCxHQUZNO0FBR04sU0FBSyxVQUFMLEdBSE07Ozs7K0JBTUs7O0FBRVgsUUFBTSxJQUFJLE9BQU8sVUFBUCxDQUZDO0FBR1gsUUFBTSxJQUFJLE9BQU8sV0FBUCxDQUhDOztBQUtYLFNBQUssU0FBTCxHQUFpQix3QkFBYyxDQUFkLEVBQWlCLENBQWpCLENBQWpCOzs7QUFMVyxRQVFYLENBQUssUUFBTCxHQUFnQixJQUFJLE1BQU0sYUFBTixDQUFvQjtBQUN2QyxhQUFRLFNBQVMsY0FBVCxDQUF3QixRQUF4QixDQUFSO0tBRGUsQ0FBaEIsQ0FSVztBQVdYLFNBQUssUUFBTCxDQUFjLGFBQWQsQ0FBNEIsUUFBNUIsRUFYVzs7QUFhWCxTQUFLLGdCQUFMLEdBQXdCLElBQUksTUFBTSxpQkFBTixDQUF3QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxFQUFsQyxDQUF4QixDQWJXOztBQWdCWCxTQUFLLFNBQUwsR0FBaUIsd0JBQWMsS0FBSyxRQUFMLENBQS9CLENBaEJXOztBQWtCWCxTQUFLLFVBQUwsR0FBa0IsdUJBQWEsS0FBSyxRQUFMLEVBQWU7QUFDN0MsZUFBVSxLQUFLLFFBQUw7QUFDVixxQkFBZ0Isb0JBQVEsRUFBUixDQUFoQjtBQUNBLGVBQVU7QUFDVCxlQUFTLEVBQUMsTUFBTSxHQUFOLEVBQVcsT0FBTyxLQUFLLFNBQUwsQ0FBZSxPQUFmLEVBQTVCO01BREQ7S0FIaUIsQ0FBbEIsQ0FsQlc7O0FBMEJYLFdBQU8sZ0JBQVAsQ0FBd0IsUUFBeEIsRUFBa0MsS0FBSyxRQUFMLENBQWMsSUFBZCxDQUFtQixJQUFuQixDQUFsQyxFQTFCVztBQTJCWCxXQUFPLGdCQUFQLENBQXdCLE9BQXhCLEVBQWlDLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBbEIsQ0FBakMsRUEzQlc7O0FBNkJYLFNBQUssT0FBTCxHQUFlLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBbEIsQ0FBZixDQTdCVzs7QUErQlgsU0FBSyxRQUFMLEdBL0JXOztBQWlDWCxxQkFBTyxFQUFQLENBQVUsUUFBVixFQUFvQixLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLElBQWxCLENBQXBCLEVBakNXO0FBa0NYLHFCQUFPLEtBQVAsR0FsQ1c7Ozs7Z0NBcUNDOzs7MkJBR0wsU0FBUzs7QUFFaEIsMEJBQVUsTUFBVixHQUZnQjs7QUFJaEIsU0FBSyxTQUFMLENBQWUsTUFBZixHQUpnQjtBQUtoQixTQUFLLFVBQUwsQ0FBZ0IsTUFBaEIsR0FMZ0I7Ozs7OEJBUU47QUFDVixRQUFNLElBQUksT0FBTyxVQUFQLENBREE7QUFFVixRQUFNLElBQUksT0FBTyxXQUFQLENBRkE7O0FBSVYsU0FBSyxTQUFMLENBQWUsT0FBZixDQUF1QixDQUF2QixFQUEwQixDQUExQixFQUpVO0FBS1YsU0FBSyxVQUFMLENBQWdCLE9BQWhCLENBQXdCLENBQXhCLEVBQTJCLENBQTNCLEVBTFU7Ozs7MkJBUUgsR0FBRzs7Ozs7U0FsRU47OztBQXVFTixRQUFPLE1BQVAsR0FBZ0IsSUFBSSxNQUFNLGFBQU4sRUFBSixDQUEwQixJQUExQixDQUErQixvQkFBL0IsRUFBcUQsWUFBTTtBQUMxRSxNQUFJLEdBQUosR0FBVSxJQUFWLEdBRDBFO0VBQU4sQ0FBckUsQzs7Ozs7OztBQ3JGQSx5RkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQSxjQUFhOztBQUViOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQXlDLFNBQVM7O0FBRWxEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFEQUFvRCxtQkFBbUI7O0FBRXZFO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxnQkFBZTs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQzs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsZ0NBQStCOztBQUUvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLHlEQUF3RDtBQUN4RCx5Q0FBd0M7QUFDeEMseUNBQXdDOztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLGNBQWEsWUFBWTs7QUFFekI7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsMkJBQTBCO0FBQzFCLDJCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSwyQkFBMEI7QUFDMUIsMkJBQTBCO0FBQzFCLDJCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUVBQWtFOztBQUVsRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSwyQkFBMEI7QUFDMUIsMkJBQTBCO0FBQzFCLDJCQUEwQjtBQUMxQiwyQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlCQUFnQjs7QUFFaEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZTs7QUFFZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTBDOztBQUUxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLHVDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBcUMsUUFBUTs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLHVDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlGQUFnRjtBQUNoRixpRkFBZ0Y7QUFDaEYsaUZBQWdGO0FBQ2hGLGlGQUFnRjtBQUNoRixpRkFBZ0Y7QUFDaEYsaUZBQWdGO0FBQ2hGLGlGQUFnRjtBQUNoRixpRkFBZ0Y7O0FBRWhGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWdCLGVBQWU7QUFDL0IsaUJBQWdCLGVBQWU7QUFDL0IsaUJBQWdCLGVBQWU7O0FBRS9COztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQStCLFlBQVk7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBK0IsWUFBWTs7QUFFM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsZ0JBQWUsY0FBYztBQUM3QixnQkFBZSxjQUFjO0FBQzdCLGdCQUFlLGNBQWM7O0FBRTdCOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsZ0JBQWUsaUJBQWlCO0FBQ2hDLGdCQUFlLGlCQUFpQjtBQUNoQyxnQkFBZSxpQkFBaUI7O0FBRWhDOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWdCLGVBQWUsZUFBZTtBQUM5QyxpQkFBZ0IsZUFBZSxlQUFlO0FBQzlDLGlCQUFnQixlQUFlLGdCQUFnQjtBQUMvQyxpQkFBZ0IsZUFBZSxnQkFBZ0I7O0FBRS9DOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLGtCQUFpQixlQUFlO0FBQ2hDLGtCQUFpQixlQUFlO0FBQ2hDLGtCQUFpQixlQUFlOztBQUVoQzs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBbUIsa0JBQWtCLGtCQUFrQjtBQUN2RCxvQkFBbUIsa0JBQWtCLGtCQUFrQjtBQUN2RCxxQkFBb0IsbUJBQW1CLG9CQUFvQjtBQUMzRCxzQkFBcUIsb0JBQW9CLG9CQUFvQjs7QUFFN0Q7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxnQkFBZSxjQUFjLGNBQWM7QUFDM0MsZ0JBQWUsY0FBYyxjQUFjO0FBQzNDLGdCQUFlLGNBQWMsZUFBZTtBQUM1QyxnQkFBZSxjQUFjLGVBQWU7O0FBRTVDOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUErQixZQUFZOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQStCLFlBQVk7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxpQkFBZ0IsbUJBQW1CO0FBQ25DLGlCQUFnQixtQkFBbUI7QUFDbkMsaUJBQWdCLG1CQUFtQjs7QUFFbkMsaUJBQWdCLG9CQUFvQjtBQUNwQyxpQkFBZ0Isb0JBQW9CO0FBQ3BDLGtCQUFpQixxQkFBcUI7O0FBRXRDOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWUsY0FBYztBQUM3QixnQkFBZSxjQUFjO0FBQzdCLGdCQUFlLGNBQWM7QUFDN0IsZ0JBQWUsY0FBYzs7QUFFN0I7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXdDOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWMsYUFBYSxhQUFhO0FBQ3hDLGVBQWMsYUFBYSxhQUFhO0FBQ3hDLGVBQWMsYUFBYSxjQUFjO0FBQ3pDLGVBQWMsYUFBYSxnQkFBZ0I7O0FBRTNDOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCLGFBQWEsYUFBYTtBQUM1QyxlQUFjLGlCQUFpQixhQUFhO0FBQzVDLGVBQWMsYUFBYSxvQkFBb0I7QUFDL0MsZUFBYyxhQUFhLGNBQWM7O0FBRXpDOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxtQkFBa0IsUUFBUTs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7Ozs7QUFJRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLG1CQUFrQixPQUFPOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFrQixPQUFPOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLFFBQVE7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7OztBQUdGOztBQUVBOztBQUVBLG1CQUFrQixPQUFPOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0EsOENBQTZDOztBQUU3Qzs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW1CLFFBQVE7O0FBRTNCOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUEsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLGNBQWM7O0FBRWhDLHdCQUF1Qjs7QUFFdkI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZUFBYyxPQUFPOztBQUVyQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFjLGNBQWM7O0FBRTVCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFdBQVU7O0FBRVY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBYyx3QkFBd0I7O0FBRXRDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZSxrQkFBa0I7O0FBRWpDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBa0MsRUFBRTs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFDQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBYztBQUNkOztBQUVBOztBQUVBOztBQUVBLG1DQUFrQyxFQUFFOztBQUVwQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFDQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXFCOztBQUVyQjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQixjQUFjOztBQUVoQzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBa0IsY0FBYzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQWtCLGNBQWM7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1DQUFrQyxnQkFBZ0I7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW1CLFlBQVk7O0FBRS9COztBQUVBOztBQUVBLG9CQUFtQixZQUFZOztBQUUvQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVc7QUFDWCxZQUFXO0FBQ1gsV0FBVTtBQUNWLGFBQVksZUFBZTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFxQyxrQ0FBa0M7O0FBRXZFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxvQkFBbUIsc0JBQXNCOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTBCLGdCQUFnQjs7QUFFMUM7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLG9CQUFtQixzQkFBc0I7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJCQUEwQixrQkFBa0I7O0FBRTVDOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLDZDQUE0QyxPQUFPOztBQUVuRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRix5QkFBd0I7O0FBRXhCOztBQUVBOztBQUVBOztBQUVBLHdDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEIsa0JBQWlCO0FBQ2pCLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLDBCQUEwQjs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLDRCQUE0Qjs7QUFFL0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscURBQW9ELFFBQVE7O0FBRTVEOztBQUVBOztBQUVBLG9EQUFtRCxRQUFROztBQUUzRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXFDLE9BQU87O0FBRTVDOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxzQ0FBcUMsT0FBTzs7QUFFNUM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSx1Q0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsdUNBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLHVDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLHVDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUI7O0FBRXJCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBbUMsT0FBTzs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBcUMsa0NBQWtDOztBQUV2RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE2QyxRQUFROztBQUVyRDtBQUNBOztBQUVBOztBQUVBLDJDQUEwQyxRQUFROztBQUVsRDtBQUNBOztBQUVBLG9EQUFtRCxRQUFROztBQUUzRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBeUIsc0JBQXNCOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFCQUFvQixtQkFBbUI7O0FBRXZDOztBQUVBO0FBQ0E7O0FBRUEsOENBQTZDLFFBQVE7O0FBRXJEOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUoscUJBQW9CLG9CQUFvQjs7QUFFeEM7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSCxvQkFBbUIsMEJBQTBCOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLDJDQUEwQyxRQUFROztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSCx3Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDBDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQSx1Q0FBc0MsUUFBUTs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLGdEQUErQyxRQUFROztBQUV2RDs7QUFFQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsOENBQTZDLFFBQVE7O0FBRXJEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHlDQUF3QyxRQUFROztBQUVoRDtBQUNBLHVCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdDQUF1QyxRQUFROztBQUUvQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBc0MsUUFBUTs7QUFFOUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBa0MsUUFBUTs7QUFFMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbURBQWtELFFBQVE7O0FBRTFEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtEQUFpRCxRQUFROztBQUV6RDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlDQUFnQyxRQUFROztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBbUMsUUFBUTs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBdUI7QUFDdkI7O0FBRUE7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBLDBDQUF5QyxRQUFROztBQUVqRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBc0MsUUFBUTs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRDQUEyQyxRQUFROztBQUVuRDs7QUFFQTs7QUFFQSxnREFBK0MsUUFBUTs7QUFFdkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxtQkFBa0IsWUFBWTs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFrQixZQUFZOztBQUU5Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLDBCQUEwQjs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0IsdUJBQXVCOztBQUV6Qzs7QUFFQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWdEO0FBQ2hEOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXFDLFFBQVE7O0FBRTdDOztBQUVBOztBQUVBLHFEQUFvRCxRQUFROztBQUU1RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrQ0FBOEMsUUFBUTs7QUFFdEQ7O0FBRUEsc0NBQXFDLFFBQVE7O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUEsd0JBQXVCLGtCQUFrQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFxQyxrQ0FBa0M7O0FBRXZFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBa0Isa0JBQWtCOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQix3QkFBd0I7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLHdCQUF3Qjs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFrQixrQkFBa0I7O0FBRXBDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLHdCQUF3Qjs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLHdCQUF3Qjs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBLHdCQUF1QixrQkFBa0I7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFxQyxrQ0FBa0M7O0FBRXZFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFtQjs7QUFFbkI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUgsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTRDLE9BQU87O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0Q0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUEsd0NBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF3QyxRQUFROztBQUVoRDs7QUFFQTtBQUNBOztBQUVBLDhDQUE2QyxRQUFROztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBLDRDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZ0RBQStDLDRCQUE0Qjs7QUFFM0U7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBdUMsUUFBUTs7QUFFL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQSxxQkFBb0IsY0FBYzs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWUsZUFBZTs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNDQUFxQyxPQUFPOztBQUU1QztBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUEsd0JBQXVCLGtCQUFrQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFDQUFvQyxPQUFPOztBQUUzQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBcUMsU0FBUzs7QUFFOUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBLG1CQUFrQix3QkFBd0I7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUEsbUJBQWtCLHdCQUF3Qjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUF5QyxTQUFTOztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOzs7QUFHRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBeUMsU0FBUzs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7O0FBR0Y7O0FBRUE7QUFDQTs7QUFFQSxtQkFBa0IscUJBQXFCOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQSxtQkFBa0Isc0JBQXNCOztBQUV4Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTs7QUFFcEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBa0IsNEJBQTRCOztBQUU5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CLDBCQUEwQjs7QUFFOUM7O0FBRUEsdUJBQXNCLDBDQUEwQzs7QUFFaEU7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQWtEOztBQUVsRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQWtCLGdCQUFnQjs7QUFFbEM7O0FBRUE7O0FBRUEsbUJBQWtCLGlCQUFpQjs7QUFFbkM7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBa0IsZ0JBQWdCOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFrQixpQkFBaUI7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdEQUErQyxTQUFTOztBQUV4RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCLGVBQWU7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCLGdDQUErQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE2Qjs7QUFFN0Isc0JBQXFCO0FBQ3JCLHNCQUFxQjs7QUFFckIsa0NBQWlDOztBQUVqQyxnQ0FBK0I7QUFDL0IsOEJBQTZCOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxpQkFBZ0I7QUFDaEIsd0JBQXVCO0FBQ3ZCLDBCQUF5Qjs7QUFFekI7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxZQUFXOztBQUVYOztBQUVBOztBQUVBLDJCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNEMsU0FBUzs7QUFFckQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvREFBbUQ7QUFDbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQOztBQUVBLE9BQU07O0FBRU47O0FBRUE7QUFDQTs7QUFFQSxPQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBbUI7QUFDbkIsK0JBQThCOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQWtCLGVBQWU7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBd0MsU0FBUzs7QUFFakQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0EseUNBQXdDLFNBQVM7O0FBRWpEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxzQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSx1QkFBc0I7QUFDdEI7O0FBRUEsb0NBQW1DOzs7QUFHbkMsa0NBQWlDO0FBQ2pDOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWlCLDhCQUE4QixFQUFFO0FBQ2pELGtCQUFpQiw4QkFBOEI7QUFDL0MsS0FBSTtBQUNKO0FBQ0Esa0JBQWlCLCtCQUErQixFQUFFO0FBQ2xELGtCQUFpQiwrQkFBK0I7QUFDaEQsS0FBSTtBQUNKO0FBQ0Esa0JBQWlCLDBDQUEwQyxFQUFFO0FBQzdELGtCQUFpQiwwQ0FBMEM7QUFDM0Q7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0Esd0NBQXVDLFNBQVM7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7O0FBR0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQSxFQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMEI7QUFDMUI7O0FBRUE7QUFDQSxnQ0FBK0I7O0FBRS9CLHdDQUF1QyxTQUFTOztBQUVoRDs7QUFFQTs7QUFFQSxtQkFBa0I7QUFDbEIseUJBQXdCLGdCQUFnQjtBQUN4QyxzQkFBcUI7QUFDckIsbUNBQWtDOztBQUVsQzs7QUFFQTs7QUFFQTtBQUNBLGlCQUFnQiw4QkFBOEIsRUFBRTtBQUNoRCxpQkFBZ0IsMkNBQTJDO0FBQzNELElBQUc7O0FBRUgsNEJBQTJCLCtCQUErQjs7QUFFMUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBd0MsU0FBUzs7QUFFakQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBbUMsU0FBUzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW1DLFNBQVM7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQSxLQUFJOztBQUVKLElBQUc7O0FBRUg7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXdDLFNBQVM7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBbUMsU0FBUzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF3QyxTQUFTOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFDQUFvQyxTQUFTOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUNBQW9DLFNBQVM7O0FBRTdDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBSzs7QUFFTCxLQUFJOztBQUVKLElBQUc7O0FBRUg7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsU0FBUzs7QUFFaEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDZCQUE0Qjs7QUFFNUI7O0FBRUEsOENBQTZDOztBQUU3QyxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0IsU0FBUzs7QUFFM0I7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWlDLHVCQUF1Qjs7QUFFeEQ7O0FBRUEsb0JBQW1CLGNBQWM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBa0M7O0FBRWxDO0FBQ0EscUNBQW9DOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF3Qzs7QUFFeEM7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSixJQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKLElBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMLGlDQUFnQzs7QUFFaEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFDQUFvQyxTQUFTOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscUNBQW9DLFNBQVM7O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUTs7QUFFUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGtCQUFpQixhQUFhOztBQUU5Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF1QyxTQUFTOztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDQUF1QyxRQUFROztBQUUvQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFvQixjQUFjOztBQUVsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQkFBcUIsY0FBYzs7QUFFbkM7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQWtDOztBQUVsQzs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXFCLHlCQUF5Qjs7QUFFOUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0RBQWlEOztBQUVqRDtBQUNBOztBQUVBLElBQUcsZ0VBQWdFOztBQUVuRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFCQUFvQiw0Q0FBNEM7O0FBRWhFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGtEQUFpRDs7QUFFakQ7QUFDQSxzQ0FBcUM7QUFDckMsc0NBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUEsdUNBQXNDLFNBQVM7O0FBRS9DOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXFDLFNBQVM7O0FBRTlDOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUEsc0NBQXFDLFNBQVM7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUEsc0NBQXFDLFNBQVM7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWM7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQSx5QkFBd0IsU0FBUzs7QUFFakM7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBLHlCQUF3QixTQUFTOztBQUVqQzs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0EseUJBQXdCLFNBQVM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQWtCLDJCQUEyQjs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQWtCLHFCQUFxQjs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrREFBaUQ7O0FBRWpEO0FBQ0E7O0FBRUEsb0RBQW1EOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBbUIsY0FBYzs7QUFFakM7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDZDQUE0QyxTQUFTOztBQUVyRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaURBQWdELFNBQVM7O0FBRXpEOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7OztBQUdGOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQixjQUFjOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxtQkFBa0IsY0FBYzs7QUFFaEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBbUIsaUNBQWlDOztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQjs7QUFFaEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbURBQWtEOztBQUVsRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQWtEOztBQUVsRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxXQUFVOztBQUVWOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxtQkFBa0Isc0JBQXNCOztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSx3Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUgsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlCQUFnQixxQkFBcUI7O0FBRXJDOztBQUVBOztBQUVBLGlCQUFnQixlQUFlOztBQUUvQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLGVBQWU7O0FBRWpDOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW1CLE9BQU87O0FBRTFCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQixPQUFPOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLG1CQUFrQixPQUFPOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLGVBQWU7O0FBRWpDOztBQUVBOztBQUVBLG9CQUFtQixPQUFPOztBQUUxQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLE9BQU87O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLG1CQUFrQixPQUFPOztBQUV6QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtEQUFpRCxPQUFPOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrREFBaUQsT0FBTzs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtREFBa0QsT0FBTzs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQThDLFFBQVE7O0FBRXREO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBbUIsdUJBQXVCOztBQUUxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFlBQVc7O0FBRVgsSUFBRzs7QUFFSDs7QUFFQSxZQUFXOztBQUVYOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVILEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLFNBQVM7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSCxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLCtDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUgsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBb0MsT0FBTzs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUNBQW9DLE9BQU87O0FBRTNDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxtQkFBa0IsaUJBQWlCOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFvQyxPQUFPOztBQUUzQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQW9DLE9BQU87O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBb0IsbUJBQW1COztBQUV2QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBLG1CQUFrQixpQkFBaUI7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOzs7QUFHSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBb0MsUUFBUTs7QUFFNUM7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBcUIsV0FBVzs7QUFFaEMsc0JBQXFCOztBQUVyQix1QkFBc0IsMEJBQTBCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBcUMsa0NBQWtDOztBQUV2RTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBbUI7O0FBRW5COztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQ0FBeUM7O0FBRXpDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUEsd0JBQXVCLGlCQUFpQjs7QUFFeEMsR0FBRTs7QUFFRjs7QUFFQSx3QkFBdUIsa0JBQWtCOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMEM7O0FBRTFDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTBDOztBQUUxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEwQztBQUMxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEwQztBQUMxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF3QyxPQUFPOztBQUUvQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsbUJBQWtCLDJCQUEyQjs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxvQkFBb0I7QUFDbEMsZ0JBQWUsZ0JBQWdCLHdCQUF3QixpQkFBaUIsc0JBQXNCLEVBQUU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFtQyw2RUFBNkUsR0FBRztBQUNuSCxzQ0FBcUMsOENBQThDLEdBQUc7O0FBRXRGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQWtCOztBQUVsQixzQkFBcUI7O0FBRXJCLHFDQUFvQzs7QUFFcEMsd0JBQXVCOztBQUV2Qiw0QkFBMkI7QUFDM0IsNEJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXFDLGlDQUFpQzs7QUFFdEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTJDOztBQUUzQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBLHdCQUF1QixrQkFBa0I7O0FBRXpDLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTTs7QUFFTjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFNOztBQUVOOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWU7O0FBRWY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxpRkFBZ0Ysa0NBQWtDOztBQUVsSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDBDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKLCtDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBLHlDQUF3QyxPQUFPOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0ZBQW1GLGtDQUFrQzs7QUFFckg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNEMsT0FBTzs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdEQUErQzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFNOztBQUVOOztBQUVBLEtBQUk7O0FBRUosbURBQWtELE9BQU87O0FBRXpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0RBQStDOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU07O0FBRU47O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBLG9CQUFtQixvQkFBb0I7O0FBRXZDOztBQUVBOztBQUVBLCtDQUE4Qzs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvRkFBbUYsa0NBQWtDOztBQUVySDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMEQsUUFBUTs7QUFFbEU7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXdDLE9BQU87O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvREFBbUQ7QUFDbkQ7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7O0FBR0osMkNBQTBDLE9BQU87O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw4QkFBNkI7QUFDN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXNDLFFBQVE7O0FBRTlDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdEQUErQyxRQUFROztBQUV2RDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsaURBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4RkFBNkY7QUFDN0Y7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUEsNENBQTJDLFFBQVE7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMEMsUUFBUTs7QUFFbEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0RBQW1ELFFBQVE7O0FBRTNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0RBQW1ELFFBQVE7O0FBRTNEOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQixzQ0FBc0M7O0FBRXhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUosMEJBQXlCOztBQUV6Qjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLG1CQUFrQixzQkFBc0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUosMkJBQTBCOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWlCLG1CQUFtQjs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXVCLHFDQUFxQzs7QUFFNUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQW9DLE9BQU87O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTtBQUNBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVSxPQUFPOztBQUVqQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBLHFDQUFvQyxPQUFPOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBb0MsT0FBTzs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYSxRQUFROztBQUVyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnREFBK0MsT0FBTzs7QUFFdEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXdCOztBQUV4Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0hBQWlIOztBQUVqSDs7QUFFQSxtR0FBa0c7O0FBRWxHOztBQUVBLDJHQUEwRzs7QUFFMUc7O0FBRUEsdUVBQXNFLHFFQUFxRSxpQ0FBaUMsR0FBRzs7QUFFL0s7O0FBRUEsMkpBQTBKOztBQUUxSjs7QUFFQSwwRkFBeUYsZ0NBQWdDOztBQUV6SDs7QUFFQSw4RUFBNkU7O0FBRTdFOztBQUVBLG1GQUFrRjs7QUFFbEY7O0FBRUEsMEpBQXlKLCtCQUErQixvRkFBb0YsSUFBSSxjQUFjLEdBQUcsMkRBQTJELHVDQUF1QyxHQUFHLHVFQUF1RSxrRUFBa0UsNERBQTRELEdBQUcseUZBQXlGLDRCQUE0QixvRUFBb0Usb0VBQW9FLDRCQUE0QixHQUFHLDZEQUE2RCw0QkFBNEIsb0RBQW9ELGlEQUFpRCxHQUFHLDZKQUE2Six1Q0FBdUMsMEVBQTBFLDZFQUE2RSxzRUFBc0UsNkRBQTZELHFFQUFxRSw4Q0FBOEMsZ0RBQWdELG1DQUFtQyx3QkFBd0IsR0FBRyxtSUFBbUksc0VBQXNFLHlEQUF5RCxtREFBbUQsZ0NBQWdDLHFFQUFxRSwrQ0FBK0Msc0NBQXNDLEdBQUcsa0NBQWtDLGVBQWUsR0FBRyx3RUFBd0UsOEVBQThFLEdBQUcsb0tBQW9LLDBFQUEwRSw2REFBNkQscUVBQXFFLDhDQUE4QyxzQ0FBc0MsOENBQThDLHdCQUF3QixHQUFHLG9FQUFvRSwwREFBMEQsR0FBRzs7QUFFdmpHOztBQUVBLGdHQUErRiwyQkFBMkIscUJBQXFCLDZCQUE2Qiw2QkFBNkIsd0RBQXdELHNFQUFzRSxzRUFBc0UsNEJBQTRCLElBQUksdUVBQXVFLG9DQUFvQyxvQ0FBb0Msd0JBQXdCLG1DQUFtQyxtQ0FBbUMsb0NBQW9DLGdFQUFnRSx3REFBd0QsSUFBSTs7QUFFMXpCOztBQUVBLHdGQUF1Rjs7QUFFdkY7O0FBRUEsc0ZBQXFGOztBQUVyRjs7QUFFQSxvRkFBbUY7O0FBRW5GOztBQUVBLGtGQUFpRjs7QUFFakY7O0FBRUEsZ1VBQStULFlBQVksRUFBRSx3Q0FBd0MscUNBQXFDLEVBQUUsd0JBQXdCLGNBQWMsa0JBQWtCLElBQUkseUJBQXlCLHNCQUFzQix1QkFBdUIsd0JBQXdCLHlCQUF5QixJQUFJLDJCQUEyQixpQkFBaUIsZUFBZSxnQkFBZ0IsSUFBSSwwREFBMEQseURBQXlELEdBQUcsaUVBQWlFLHlEQUF5RCxHQUFHLGtGQUFrRiw2REFBNkQsMkNBQTJDLEdBQUcsaUZBQWlGLDJEQUEyRCxHQUFHLG9IQUFvSCwrSEFBK0gsR0FBRyxtQ0FBbUMsd0VBQXdFLHFCQUFxQixZQUFZLG9DQUFvQywrRUFBK0UscUJBQXFCLFlBQVk7O0FBRXZ2RDs7QUFFQSxpR0FBZ0csK0RBQStEOztBQUUvSjs7QUFFQSxxTEFBb0w7O0FBRXBMOztBQUVBLHNIQUFxSCxtQ0FBbUMsa0NBQWtDOztBQUUxTDs7QUFFQSw0SEFBMkgsMERBQTBELDJDQUEyQzs7QUFFaE87O0FBRUEsNEdBQTJHOztBQUUzRzs7QUFFQSxnTkFBK00sdUVBQXVFLCtGQUErRix3RkFBd0YsaURBQWlELDhGQUE4RixtQ0FBbUMsNElBQTRJLHlEQUF5RCxtRUFBbUUscUdBQXFHLGtEQUFrRCxvSkFBb0osb0VBQW9FLHlEQUF5RCwwSUFBMEksK0hBQStILDJHQUEyRzs7QUFFbnFEOztBQUVBLDhIQUE2SCxpQ0FBaUMsb0ZBQW9GLHFDQUFxQyxxQ0FBcUMsc0lBQXNJLGtDQUFrQzs7QUFFcGU7O0FBRUEseU1BQXdNLGlDQUFpQzs7QUFFek87O0FBRUEsb1BBQW1QLGlGQUFpRixzRkFBc0YsK0VBQStFOztBQUV6ZTs7QUFFQSxzSUFBcUksMERBQTBELDZIQUE2SCxtRUFBbUUseUVBQXlFOztBQUV4Yzs7QUFFQSxvRkFBbUYsK0NBQStDLGtDQUFrQyx5QkFBeUI7O0FBRTdMOztBQUVBLDhKQUE2Sjs7QUFFN0o7O0FBRUEsbUdBQWtHLG1DQUFtQzs7QUFFckk7O0FBRUEsNEVBQTJFLDRCQUE0QixxQ0FBcUMsbURBQW1ELGtEQUFrRCxnQ0FBZ0MsNENBQTRDLHlDQUF5QywwQ0FBMEMsNEJBQTRCLGlEQUFpRCxvQ0FBb0MsY0FBYyxnQ0FBZ0MsNkNBQTZDLHNCQUFzQixTQUFTLG9FQUFvRSwwREFBMEQsc0RBQXNELGdFQUFnRSx3RkFBd0YsY0FBYyxvREFBb0QscUJBQXFCLFNBQVMsa0VBQWtFLDBEQUEwRCxzREFBc0QsZ0VBQWdFLHdGQUF3RixjQUFjLG1EQUFtRCxvQkFBb0IsU0FBUyxnRkFBZ0YsMERBQTBELHNEQUFzRCxnRUFBZ0Usd0ZBQXdGLGNBQWMsb0RBQW9ELHFCQUFxQixTQUFTLG1GQUFtRiw4R0FBOEcsY0FBYzs7QUFFdGxFOztBQUVBLHlGQUF3RixtQkFBbUIsZUFBZSxlQUFlLHFCQUFxQix1QkFBdUIsdUJBQXVCLEtBQUssZ0VBQWdFLDhIQUE4SCw4QkFBOEIsK0NBQStDLHVEQUF1RCx1QkFBdUIsSUFBSSx3REFBd0Qsa0JBQWtCLGVBQWUsbUJBQW1CLGdCQUFnQixlQUFlLHFCQUFxQix1QkFBdUIsdUJBQXVCLEtBQUssc0RBQXNELDRHQUE0Ryw4QkFBOEIsMkRBQTJELGlEQUFpRCx5Q0FBeUMsMEdBQTBHLHVCQUF1QixJQUFJLHNEQUFzRCxrQkFBa0IsbUJBQW1CLGVBQWUsbUJBQW1CLGdCQUFnQixtQkFBbUIsbUJBQW1CLGVBQWUscUJBQXFCLHVCQUF1Qix1QkFBdUIsS0FBSyxtREFBbUQseUdBQXlHLDhCQUE4QiwwREFBMEQsaURBQWlELHlFQUF5RSw0Q0FBNEMsMEVBQTBFLGdGQUFnRix5Q0FBeUMsMEhBQTBILEtBQUssT0FBTyxxQ0FBcUMsS0FBSyx1QkFBdUIsSUFBSSw0REFBNEQsbUJBQW1CLGtCQUFrQixxQkFBcUIsS0FBSywrREFBK0QsZ0hBQWdILDhEQUE4RCxnREFBZ0Qsb0ZBQW9GLElBQUksbUtBQW1LLHVGQUF1RixxQ0FBcUMsMEZBQTBGLGdIQUFnSCxnSEFBZ0gseUZBQXlGLHdEQUF3RCxpRUFBaUUsa0RBQWtELElBQUksaUdBQWlHLG1EQUFtRCwrR0FBK0csNERBQTRELElBQUksOElBQThJLHNHQUFzRywrRkFBK0YsaUdBQWlHLHFDQUFxQywrRUFBK0Usd0ZBQXdGLHFIQUFxSCxtSEFBbUgsNEZBQTRGLHNFQUFzRSxvRUFBb0Usc0dBQXNHLDBHQUEwRyxtRkFBbUYsaUtBQWlLLDRIQUE0SCxxR0FBcUcsNEVBQTRFLDZDQUE2QyxJQUFJOztBQUVqeEw7O0FBRUEsNkVBQTRFLDJDQUEyQyxvQ0FBb0MseUNBQXlDLCtDQUErQzs7QUFFblA7O0FBRUEsc0dBQXFHLHFDQUFxQyw2Q0FBNkMscUNBQXFDLHFCQUFxQixzQkFBc0IsMkJBQTJCLDBCQUEwQixJQUFJLGtMQUFrTCwyRUFBMkUsb0RBQW9ELDhGQUE4RixtTEFBbUwsR0FBRyxpTEFBaUwsZ0dBQWdHLEdBQUc7O0FBRXpwQzs7QUFFQSxvR0FBbUc7O0FBRW5HOztBQUVBLHNHQUFxRzs7QUFFckc7O0FBRUEsOEVBQTZFLHVFQUF1RSxtRUFBbUUsa0ZBQWtGOztBQUV6Uzs7QUFFQSxrRkFBaUYscUJBQXFCLDJCQUEyQixzQkFBc0IsSUFBSSw4S0FBOEssMkVBQTJFLG9EQUFvRCw4RkFBOEYsZ0pBQWdKLEdBQUcsNktBQTZLLGdHQUFnRyxHQUFHLDRLQUE0SywrSUFBK0ksR0FBRzs7QUFFdndDOztBQUVBLHVFQUFzRSxzQ0FBc0MsMkJBQTJCLGdEQUFnRCw0QkFBNEIsK0VBQStFLG1CQUFtQixzQkFBc0IsU0FBUyxrQ0FBa0MsOERBQThELDJOQUEyTiwyRUFBMkUsSUFBSSxvRkFBb0YsbUJBQW1CLHFCQUFxQixTQUFTLGdDQUFnQyw0REFBNEQsZ05BQWdOLDJFQUEyRSxJQUFJLGlHQUFpRyxtQkFBbUIsb0JBQW9CLFNBQVMsOENBQThDLDBFQUEwRSwwUEFBMFAsMkVBQTJFLElBQUksK0dBQStHLGlHQUFpRywyREFBMkQscUJBQXFCLFNBQVMsbUZBQW1GLEtBQUssaUZBQWlGLGtMQUFrTCx1RUFBdUU7O0FBRTMvRTs7QUFFQSx1R0FBc0c7O0FBRXRHOztBQUVBLHdLQUF1Szs7QUFFdks7O0FBRUEsMEdBQXlHLDBEQUEwRDs7QUFFbks7O0FBRUEsbUlBQWtJLHdDQUF3Qzs7QUFFMUs7O0FBRUEsaUpBQWdKLGtFQUFrRSxrRUFBa0U7O0FBRXBSOztBQUVBLGlHQUFnRyxvREFBb0QsOEJBQThCOztBQUVsTDs7QUFFQSxvRkFBbUY7O0FBRW5GOztBQUVBLHVMQUFzTDs7QUFFdEw7O0FBRUEsaUdBQWdHLHlCQUF5Qjs7QUFFekg7O0FBRUEsbUZBQWtGLGlGQUFpRix1Q0FBdUM7O0FBRTFNOztBQUVBLCtHQUE4Rzs7QUFFOUc7O0FBRUEsK0lBQThJLDBFQUEwRSwwRUFBMEUsMEVBQTBFOztBQUU1Vzs7QUFFQSxpSkFBZ0osb0RBQW9EOztBQUVwTTs7QUFFQSxnSkFBK0ksMkVBQTJFLDJFQUEyRSwyRUFBMkUsc0dBQXNHLDJFQUEyRSwyRUFBMkUsMkVBQTJFOztBQUV2ckI7O0FBRUEsaUdBQWdHLG9DQUFvQyxnREFBZ0QsNkNBQTZDLHFGQUFxRiwrRkFBK0Ysa0dBQWtHOztBQUV2Zjs7QUFFQSxzR0FBcUcsNEJBQTRCLDJEQUEyRCxrQ0FBa0Msa0NBQWtDLDhCQUE4Qiw4QkFBOEIsa0RBQWtELG1EQUFtRCxvQ0FBb0MsNERBQTRELG9DQUFvQywrQkFBK0IsbUNBQW1DLElBQUk7O0FBRTNtQjs7QUFFQSw0R0FBMkcsdUVBQXVFLHNEQUFzRDs7QUFFeE87O0FBRUEsbUZBQWtGLGlGQUFpRix1Q0FBdUM7O0FBRTFNOztBQUVBLCtHQUE4Rzs7QUFFOUc7O0FBRUEsNkpBQTRKLDJEQUEyRCwwRkFBMEYscURBQXFELDZGQUE2Rix1REFBdUQsMkRBQTJELDhHQUE4Ryx3Q0FBd0MsSUFBSSx1RUFBdUUsbUVBQW1FLElBQUkscUZBQXFGLHlDQUF5Qyx3Q0FBd0Msc0RBQXNELHVGQUF1Rix1RkFBdUYsdUZBQXVGLHVGQUF1RixzQ0FBc0MsaUNBQWlDLGlDQUFpQywrQkFBK0IsYUFBYSxJQUFJLHVIQUF1SCxxQ0FBcUMsZ0NBQWdDLDBIQUEwSCx5Q0FBeUMsb0VBQW9FLDZDQUE2Qyx3QkFBd0IsdUZBQXVGLDhDQUE4Qyw4Q0FBOEMsOENBQThDLDhDQUE4Qyw4eEJBQTh4Qiw4RkFBOEYsOENBQThDLDhDQUE4Qyw4Q0FBOEMsOENBQThDLGc4QkFBZzhCLGtGQUFrRixlQUFlLGVBQWUsSUFBSSw4Q0FBOEMseUJBQXlCLG1FQUFtRSx3QkFBd0Isa0RBQWtELHVCQUF1QiwwQ0FBMEMseUNBQXlDLGdDQUFnQyxnREFBZ0QsS0FBSyxrQ0FBa0MsK0JBQStCLDBDQUEwQyxLQUFLLGtDQUFrQywrQkFBK0Isd0NBQXdDLGtDQUFrQyxLQUFLLDhEQUE4RCxJQUFJLDRIQUE0SCxpREFBaUQsMkNBQTJDLDZDQUE2QyxtRUFBbUUsbUpBQW1KLCt3REFBK3dELHNGQUFzRixjQUFjOztBQUUvNk87O0FBRUEseUpBQXdKLDJEQUEyRCx3RkFBd0YscURBQXFELDJGQUEyRix1REFBdUQ7O0FBRWxmOztBQUVBLDRHQUEyRyxvQkFBb0IsU0FBUyxnRkFBZ0YsSUFBSSxzREFBc0QscUJBQXFCLFNBQVMsa0VBQWtFLElBQUksdURBQXVELHNCQUFzQixTQUFTLG9FQUFvRSxJQUFJOztBQUVwaEI7O0FBRUEsMkVBQTBFLHNCQUFzQixxRkFBcUYsbUJBQW1CLG9CQUFvQixTQUFTLDhDQUE4Qyx1TkFBdU4sSUFBSSwwREFBMEQsbUJBQW1CLHFCQUFxQixTQUFTLGdDQUFnQyw2S0FBNkssSUFBSSw2REFBNkQsbUJBQW1CLHNCQUFzQixTQUFTLGtDQUFrQyx3TEFBd0wsSUFBSSxtQ0FBbUMsR0FBRzs7QUFFN3BDOztBQUVBLDhHQUE2RyxnREFBZ0QsZ0RBQWdELGdEQUFnRDs7QUFFN1A7O0FBRUEsOEZBQTZGLGtDQUFrQyx3REFBd0QsaUNBQWlDLGtDQUFrQyw0Q0FBNEMsdUJBQXVCLG1EQUFtRCxzREFBc0QsZ0RBQWdELGlEQUFpRCwwQkFBMEIscUVBQXFFLHFFQUFxRSxxRUFBcUUscUVBQXFFLHdDQUF3QyxpQkFBaUIsS0FBSyx5REFBeUQsNENBQTRDLDhDQUE4QyxpQkFBaUIsS0FBSzs7QUFFNWhDOztBQUVBLHlIQUF3SCw4QkFBOEIsbURBQW1ELG1EQUFtRCxtREFBbUQsbURBQW1ELDBDQUEwQzs7QUFFNVk7O0FBRUEsaUdBQWdHLHlDQUF5Qyx5Q0FBeUMseUNBQXlDLHlDQUF5Qyw2REFBNkQscUVBQXFFOztBQUV0WTs7QUFFQSx1RUFBc0UsOEVBQThFLHNDQUFzQyxpQ0FBaUM7O0FBRTNOOztBQUVBLDRHQUEyRzs7QUFFM0c7O0FBRUEscUhBQW9IOztBQUVwSDs7QUFFQSxvSEFBbUgscUJBQXFCOztBQUV4STs7QUFFQSx1R0FBc0c7O0FBRXRHOztBQUVBLGlTQUFnUzs7QUFFaFM7O0FBRUEsK1JBQThSLDZCQUE2Qjs7QUFFM1Q7O0FBRUEsc1RBQXFUOztBQUVyVDs7QUFFQSx1T0FBc08sd0VBQXdFOztBQUU5Uzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLHFCQUFxQjs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWMsZ0RBQWdEO0FBQzlELGVBQWMsd0JBQXdCOztBQUV0QyxXQUFVLHlCQUF5QjtBQUNuQyxvQkFBbUIscURBQXFEOztBQUV4RSxtQkFBa0IseUJBQXlCO0FBQzNDLGdCQUFlLHlCQUF5Qjs7QUFFeEMsY0FBYSx5QkFBeUI7QUFDdEMsa0JBQWlCLHdCQUF3QjtBQUN6QyxvQkFBbUIsd0JBQXdCO0FBQzNDLHVCQUFzQjs7QUFFdEIsR0FBRTs7QUFFRjs7QUFFQSxhQUFZLHlCQUF5QjtBQUNyQyxzQkFBcUI7O0FBRXJCLEdBQUU7O0FBRUY7O0FBRUEsZ0JBQWUseUJBQXlCO0FBQ3hDLHlCQUF3Qjs7QUFFeEIsR0FBRTs7QUFFRjs7QUFFQSxtQkFBa0I7O0FBRWxCLEdBQUU7O0FBRUY7O0FBRUEsZUFBYyx5QkFBeUI7QUFDdkMsaUJBQWdCOztBQUVoQixHQUFFOztBQUVGOztBQUVBLGlCQUFnQix5QkFBeUI7QUFDekMsbUJBQWtCOztBQUVsQixHQUFFOztBQUVGOztBQUVBLHVCQUFzQix5QkFBeUI7QUFDL0MseUJBQXdCLHNCQUFzQjtBQUM5Qyx3QkFBdUI7O0FBRXZCLEdBQUU7O0FBRUY7O0FBRUEsb0JBQW1COztBQUVuQixHQUFFOztBQUVGOztBQUVBLG9CQUFtQjs7QUFFbkIsR0FBRTs7QUFFRjs7QUFFQSxrQkFBaUIsNEJBQTRCO0FBQzdDLGVBQWMsc0JBQXNCO0FBQ3BDLGNBQWEseUJBQXlCO0FBQ3RDLGdCQUFlOztBQUVmLEdBQUU7O0FBRUY7O0FBRUEseUJBQXdCOztBQUV4QixHQUFFOztBQUVGOztBQUVBLHlCQUF3QjtBQUN4QixrQkFBaUIsYUFBYTtBQUM5QixjQUFhLFlBQVk7O0FBRXpCLGVBQWMsWUFBWTtBQUMxQixtQkFBa0IsWUFBWTtBQUM5QixxQkFBb0IsWUFBWTtBQUNoQyxzQkFBcUI7QUFDckIsSUFBRyxFQUFFOztBQUVMLDRCQUEyQix3QkFBd0I7QUFDbkQsK0JBQThCLHlCQUF5Qjs7QUFFdkQsa0JBQWlCO0FBQ2pCLGNBQWEsWUFBWTtBQUN6QixpQkFBZ0IsYUFBYTtBQUM3QixrQkFBaUIsYUFBYTtBQUM5QixpQkFBZ0IsWUFBWTtBQUM1QixpQkFBZ0IsWUFBWTtBQUM1QixpQkFBZ0IsWUFBWTtBQUM1QixjQUFhLFlBQVk7O0FBRXpCLGVBQWMsWUFBWTtBQUMxQixtQkFBa0IsWUFBWTtBQUM5QixxQkFBb0IsWUFBWTtBQUNoQyxzQkFBcUI7QUFDckIsSUFBRyxFQUFFOztBQUVMLHFCQUFvQix3QkFBd0I7QUFDNUMsd0JBQXVCLHlCQUF5Qjs7QUFFaEQsbUJBQWtCO0FBQ2xCLGNBQWEsWUFBWTtBQUN6QixpQkFBZ0IsYUFBYTtBQUM3QixjQUFhLFlBQVk7QUFDekIsaUJBQWdCLFlBQVk7O0FBRTVCLGVBQWMsWUFBWTtBQUMxQixtQkFBa0IsWUFBWTtBQUM5QixxQkFBb0IsWUFBWTtBQUNoQyxzQkFBcUI7QUFDckIsSUFBRyxFQUFFOztBQUVMLHNCQUFxQix3QkFBd0I7QUFDN0MseUJBQXdCLHlCQUF5Qjs7QUFFakQsd0JBQXVCO0FBQ3ZCLGtCQUFpQixhQUFhO0FBQzlCLGlCQUFnQixZQUFZO0FBQzVCLG9CQUFtQjtBQUNuQixJQUFHOztBQUVILEdBQUU7O0FBRUY7O0FBRUEsZUFBYyxnREFBZ0Q7QUFDOUQsZUFBYyx3QkFBd0I7QUFDdEMsWUFBVyx3QkFBd0I7QUFDbkMsYUFBWSx3QkFBd0I7QUFDcEMsV0FBVSx5QkFBeUI7QUFDbkMsb0JBQW1COztBQUVuQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUEsMEJBQXlCO0FBQ3pCLDJCQUEwQjs7QUFFMUI7O0FBRUEsMkJBQTBCOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCOztBQUVqQixtREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBbUM7QUFDbkMsaURBQWdEO0FBQ2hELGtEQUFpRDtBQUNqRCx3REFBdUQ7QUFDdkQsb0RBQW1EOztBQUVuRDs7QUFFQSwwREFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQSwyREFBMEQ7O0FBRTFELE1BQUs7O0FBRUw7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4QkFBNkI7O0FBRTdCOztBQUVBLDhCQUE2Qjs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQSwwQkFBeUI7QUFDekIsMkJBQTBCO0FBQzFCLDJCQUEwQjs7QUFFMUIsOEJBQTZCOztBQUU3Qjs7QUFFQSw4QkFBNkI7O0FBRTdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUI7O0FBRWpCLG1EQUFrRDtBQUNsRCwyR0FBMEc7QUFDMUcseUNBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNGQUFxRjs7QUFFckY7O0FBRUEsaUZBQWdGOztBQUVoRjs7QUFFQSxvRkFBbUY7O0FBRW5GOztBQUVBLGtEQUFpRDs7QUFFakQ7O0FBRUEsaUdBQWdHOztBQUVoRztBQUNBOztBQUVBLDhHQUE2Rzs7QUFFN0c7O0FBRUE7O0FBRUE7O0FBRUEsMkRBQTBEOztBQUUxRCxNQUFLOztBQUVMOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0IsZ0RBQWdEO0FBQ2xFLG1CQUFrQixnREFBZ0Q7QUFDbEUsbUJBQWtCO0FBQ2xCOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdDQUErQjs7QUFFL0I7O0FBRUEsMkJBQTBCOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQThDOztBQUU5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLDBCQUF5QjtBQUN6QiwyQkFBMEI7QUFDMUIsMkJBQTBCO0FBQzFCLDZCQUE0QjtBQUM1QiwyQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCOztBQUVqQixtREFBa0Q7QUFDbEQsMkdBQTBHO0FBQzFHLHlDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnTEFBK0s7O0FBRS9LO0FBQ0E7O0FBRUE7O0FBRUEsMkRBQTBEOztBQUUxRCxNQUFLOztBQUVMOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCLGdEQUFnRDtBQUNsRSxtQkFBa0Isd0JBQXdCO0FBQzFDLG1CQUFrQixzQkFBc0I7QUFDeEMsMEJBQXlCLHNCQUFzQjtBQUMvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBK0I7O0FBRS9COztBQUVBLDJCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtDQUE4Qzs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUFzQzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQXlCO0FBQ3pCLDJCQUEwQjtBQUMxQiw2QkFBNEI7QUFDNUIsNkJBQTRCO0FBQzVCLDJCQUEwQjs7QUFFMUIsbUNBQWtDOztBQUVsQyxnQ0FBK0I7O0FBRS9COztBQUVBLDJCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQjs7QUFFakIsbURBQWtEO0FBQ2xELDJHQUEwRztBQUMxRyx5Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdMQUErSzs7QUFFL0s7O0FBRUE7O0FBRUEsMkRBQTBEOztBQUUxRCxNQUFLOztBQUVMOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBdUI7QUFDdkIseUJBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF1RDtBQUN2RDtBQUNBLDJCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQSwwQkFBeUI7QUFDekIsMkJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCOztBQUVqQix1Q0FBc0M7QUFDdEMsbURBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBc0M7O0FBRXRDOztBQUVBLDJEQUEwRDs7QUFFMUQsTUFBSzs7QUFFTDs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0Isc0JBQXNCO0FBQ3hDLG1CQUFrQixzQkFBc0I7QUFDeEMsbUJBQWtCO0FBQ2xCOztBQUVBOztBQUVBOztBQUVBLHlCQUF3QjtBQUN4QixrQ0FBaUM7O0FBRWpDLGlDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBLGtCQUFpQjs7QUFFakI7O0FBRUEsMkNBQTBDOztBQUUxQyxnRUFBK0Q7QUFDL0Qsa0RBQWlEOztBQUVqRDs7QUFFQSxNQUFLOztBQUVMOztBQUVBOztBQUVBLDBCQUF5QjtBQUN6QiwyQkFBMEI7O0FBRTFCLDRCQUEyQjtBQUMzQiw2QkFBNEI7O0FBRTVCLGlDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCOztBQUVqQix5REFBd0Q7O0FBRXhELGVBQWM7O0FBRWQsT0FBTTs7QUFFTix1Q0FBc0M7QUFDdEMsbURBQWtEOztBQUVsRDtBQUNBOztBQUVBLHVDQUFzQzs7QUFFdEM7O0FBRUEsMkRBQTBEOztBQUUxRCxNQUFLOztBQUVMOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsY0FBYSx3QkFBd0I7QUFDckMsY0FBYSwyQkFBMkI7QUFDeEMsaUJBQWdCOztBQUVoQixJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUEseUJBQXdCO0FBQ3hCLHdCQUF1QjtBQUN2QiwyQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUEsa0JBQWlCOztBQUVqQjs7QUFFQTs7QUFFQSxzREFBcUQ7O0FBRXJEOztBQUVBLHFEQUFvRDs7QUFFcEQ7O0FBRUEsMkRBQTBEO0FBQzFELG9EQUFtRDs7QUFFbkQsTUFBSzs7QUFFTDs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLGlCQUFnQjs7QUFFaEIsSUFBRzs7QUFFSDs7QUFFQSwwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUI7O0FBRWpCLG1EQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQSwyQkFBMEI7QUFDMUIsMEJBQXlCOztBQUV6QjtBQUNBOztBQUVBLGtCQUFpQjs7QUFFakIsdUVBQXNFOztBQUV0RTs7QUFFQSxNQUFLOztBQUVMOztBQUVBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYSx5QkFBeUI7QUFDdEMsY0FBYTtBQUNiLElBQUc7O0FBRUg7O0FBRUEsaUNBQWdDOztBQUVoQztBQUNBOztBQUVBLGtCQUFpQjs7QUFFakIsbUVBQWtFOztBQUVsRSwrRUFBOEU7O0FBRTlFOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUEsK0JBQThCO0FBQzlCLHlCQUF3Qjs7QUFFeEIsaUNBQWdDOztBQUVoQztBQUNBOztBQUVBLGtCQUFpQjs7QUFFakIsK0ZBQThGOztBQUU5Rjs7QUFFQSxNQUFLOztBQUVMOztBQUVBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWlCLHlCQUF5QjtBQUMxQyxjQUFhO0FBQ2IsSUFBRzs7QUFFSDs7QUFFQSxpQ0FBZ0M7O0FBRWhDO0FBQ0E7O0FBRUEsa0JBQWlCOztBQUVqQixtRUFBa0U7O0FBRWxFLCtFQUE4RTs7QUFFOUU7O0FBRUEsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQSxpQ0FBZ0M7QUFDaEMseUJBQXdCOztBQUV4QixpQ0FBZ0M7O0FBRWhDO0FBQ0E7O0FBRUEsa0JBQWlCOztBQUVqQixtR0FBa0c7QUFDbEcsbURBQWtEO0FBQ2xELG9CQUFtQjtBQUNuQixnRUFBK0Q7QUFDL0QsMkVBQTBFO0FBQzFFLHNEQUFxRDs7QUFFckQ7O0FBRUEsTUFBSzs7QUFFTDs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBYzs7QUFFZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE2Qzs7QUFFN0Msc0ZBQXFGO0FBQ3JGLCtFQUE4RTtBQUM5RSxtRkFBa0Y7QUFDbEYsaUNBQWdDO0FBQ2hDLGlCQUFnQjs7QUFFaEIsTUFBSzs7QUFFTCxrQkFBaUI7O0FBRWpCOztBQUVBOztBQUVBLHdEQUF1RDs7QUFFdkQ7O0FBRUEsdURBQXNEOztBQUV0RDs7QUFFQSx5RUFBd0U7QUFDeEUsbUZBQWtGO0FBQ2xGLDJDQUEwQztBQUMxQyxnREFBK0M7O0FBRS9DLE1BQUs7O0FBRUw7O0FBRUEsR0FBRTs7O0FBR0Y7O0FBRUE7O0FBRUEsaUJBQWdCOztBQUVoQixJQUFHOztBQUVIOztBQUVBLGlDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFvQzs7QUFFcEMsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQSwyQkFBMEI7QUFDMUIsaUNBQWdDOztBQUVoQzs7QUFFQSxrQ0FBaUM7O0FBRWpDLHNCQUFxQjtBQUNyQixrRkFBaUY7QUFDakYsNkVBQTRFO0FBQzVFLCtFQUE4RTtBQUM5RSwrQkFBOEI7QUFDOUIsaUJBQWdCOztBQUVoQixNQUFLOztBQUVMLG9DQUFtQzs7QUFFbkMsNEdBQTJHO0FBQzNHLDBDQUF5Qzs7QUFFekMsTUFBSzs7QUFFTCxtQkFBa0I7O0FBRWxCLDJFQUEwRTs7QUFFMUUsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlCQUF3QjtBQUN4QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxXQUFVLFFBQVE7O0FBRWxCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQixPQUFPOztBQUUxQjtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTBDLE9BQU87O0FBRWpEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNEQUFxRCxPQUFPOztBQUU1RDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFnRCxPQUFPOztBQUV2RDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLElBQUc7O0FBRUg7O0FBRUEsaURBQWdEOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQSxxR0FBb0c7O0FBRXBHOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBLElBQUc7O0FBRUg7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMEMsT0FBTzs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBeUMsT0FBTzs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLDJCQUEyQjs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLDJCQUEyQjs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnRUFBK0QsUUFBUTs7QUFFdkU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUEyQjtBQUMzQiwwQkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQSxLQUFJOztBQUVKOztBQUVBLEtBQUk7O0FBRUo7O0FBRUEsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBd0MsUUFBUTs7QUFFaEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxJQUFHOztBQUVIOztBQUVBLElBQUc7O0FBRUg7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxJQUFHOztBQUVIOztBQUVBLElBQUc7O0FBRUg7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBb0Q7O0FBRXBEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxtRUFBa0U7O0FBRWxFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBNkM7QUFDN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXdDLFFBQVE7O0FBRWhEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBcUIsa0JBQWtCOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFnRCxRQUFROztBQUV4RDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFnRCxRQUFROztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWdELFFBQVE7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU07O0FBRU47O0FBRUEsT0FBTTs7QUFFTjs7QUFFQSxPQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFnRCxRQUFROztBQUV4RDs7QUFFQTs7QUFFQTs7QUFFQSxpREFBZ0QsUUFBUTs7QUFFeEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQU87O0FBRVA7O0FBRUEsUUFBTzs7QUFFUDs7QUFFQSxRQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQWtDLFFBQVE7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQXlDLFFBQVE7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQSxJQUFHOztBQUVILHlDQUF3QyxRQUFROztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFNOztBQUVOOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQXlDLFFBQVE7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFCQUFvQixPQUFPOztBQUUzQjs7QUFFQTs7QUFFQSxPQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFvQixPQUFPOztBQUUzQjs7QUFFQTs7QUFFQTs7QUFFQSxRQUFPOztBQUVQOztBQUVBOztBQUVBLE9BQU07O0FBRU47O0FBRUEsNENBQTJDLFFBQVE7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVM7O0FBRVQ7O0FBRUE7O0FBRUEsU0FBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQixPQUFPOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBLHdCQUF1QixrQkFBa0I7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwwQkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFxQyxPQUFPOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUEsK0JBQThCOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBLGtEQUFpRCxPQUFPOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLE9BQU87O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQixPQUFPOztBQUV6QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXdDLFlBQVksYUFBYSxlQUFlLEdBQUc7O0FBRW5GOztBQUVBOztBQUVBLG9DQUFtQyxxQkFBcUI7O0FBRXhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBLG1EQUFrRDtBQUNsRCxpREFBZ0Q7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBLCtCQUE4QjtBQUM5QixtQ0FBa0M7QUFDbEMsb0NBQW1DO0FBQ25DLDhCQUE2QjtBQUM3QixnQ0FBK0I7QUFDL0Isa0NBQWlDOztBQUVqQyw4QkFBNkI7QUFDN0IsNEJBQTJCO0FBQzNCLHdCQUF1Qjs7QUFFdkI7O0FBRUEsNEJBQTJCOztBQUUzQjs7QUFFQTs7QUFFQSxtQ0FBa0M7QUFDbEMsbUNBQWtDO0FBQ2xDLG1DQUFrQztBQUNsQyxtQ0FBa0M7O0FBRWxDOztBQUVBLG9DQUFtQztBQUNuQyxvQ0FBbUM7QUFDbkMsb0NBQW1DO0FBQ25DLG9DQUFtQzs7QUFFbkM7O0FBRUEsb0NBQW1DO0FBQ25DLG9DQUFtQztBQUNuQyxvQ0FBbUM7QUFDbkMsb0NBQW1DOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBK0I7QUFDL0IsaUNBQWdDOztBQUVoQzs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUEsbURBQWtEO0FBQ2xELGlEQUFnRDs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQTZCO0FBQzdCLGtDQUFpQzs7QUFFakM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBa0IsMkJBQTJCOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQixrQkFBa0I7O0FBRXBDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBaUIsaUNBQWlDOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdDQUF1QyxRQUFROztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlCQUFnQjs7QUFFaEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBc0Isa0JBQWtCOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBNkMsUUFBUTs7QUFFckQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTBDLFFBQVE7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBdUMsT0FBTzs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFnRCxPQUFPOztBQUV2RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQW9CLG9CQUFvQjs7QUFFeEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQjtBQUNuQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLDhCQUE4Qjs7QUFFaEQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBa0M7O0FBRWxDLG1DQUFrQztBQUNsQywwQkFBeUI7QUFDekIsOEJBQTZCOztBQUU3QixzQ0FBcUM7O0FBRXJDLCtCQUE4QjtBQUM5Qix5QkFBd0I7O0FBRXhCLHdCQUF1QjtBQUN2QixpQ0FBZ0M7O0FBRWhDLG9CQUFtQjs7QUFFbkIsaUJBQWdCOztBQUVoQiw0QkFBMkI7O0FBRTNCLGdDQUErQjs7QUFFL0IsdUVBQXNFO0FBQ3RFLG1FQUFrRTtBQUNsRSxtRUFBa0U7QUFDbEUsbUVBQWtFO0FBQ2xFLG1FQUFrRTtBQUNsRSxtRUFBa0U7QUFDbEUsbUVBQWtFO0FBQ2xFLG1FQUFrRTtBQUNsRSxtRUFBa0U7O0FBRWxFLGlEQUFnRDtBQUNoRCxpREFBZ0Q7QUFDaEQsaURBQWdEO0FBQ2hELGlEQUFnRDs7QUFFaEQsNkVBQTRFO0FBQzVFLDZFQUE0RTs7QUFFNUUsU0FBUTs7QUFFUiw0RkFBMkY7O0FBRTNGLFFBQU87O0FBRVA7O0FBRUE7O0FBRUEsbUNBQWtDOztBQUVsQyw2QkFBNEI7QUFDNUIsNkJBQTRCO0FBQzVCLDBCQUF5Qjs7QUFFekIsd0JBQXVCO0FBQ3ZCLGlDQUFnQzs7QUFFaEMsb0JBQW1COztBQUVuQjs7QUFFQSxnQ0FBK0I7O0FBRS9CLG1EQUFrRDs7QUFFbEQ7O0FBRUEsU0FBUSw4QkFBOEI7O0FBRXRDLDhDQUE2Qzs7QUFFN0M7O0FBRUEsU0FBUSxPQUFPOztBQUVmLDhDQUE2QztBQUM3Qyw0Q0FBMkM7QUFDM0MsZ0NBQStCO0FBQy9CLG1DQUFrQzs7QUFFbEMsU0FBUTs7QUFFUixRQUFPOztBQUVQOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUEsbUNBQWtDOztBQUVsQyxtQ0FBa0M7QUFDbEMsMEJBQXlCO0FBQ3pCLDhCQUE2Qjs7QUFFN0IsK0JBQThCO0FBQzlCLHlCQUF3Qjs7QUFFeEIsd0JBQXVCOztBQUV2QixvQkFBbUI7O0FBRW5CLGlCQUFnQjs7QUFFaEIsNEJBQTJCOztBQUUzQixnQ0FBK0I7O0FBRS9CLDZFQUE0RTtBQUM1RSw2RUFBNEU7O0FBRTVFLFNBQVE7O0FBRVIsNEZBQTJGOztBQUUzRixRQUFPOztBQUVQOztBQUVBOztBQUVBLCtCQUE4Qjs7QUFFOUIsbUNBQWtDOztBQUVsQyw2QkFBNEI7QUFDNUIsc0NBQXFDO0FBQ3JDLDZCQUE0QjtBQUM1QiwwQkFBeUI7O0FBRXpCLHdCQUF1Qjs7QUFFdkIsb0JBQW1COztBQUVuQjs7QUFFQSxnQ0FBK0I7O0FBRS9CLCtEQUE4RDs7QUFFOUQ7O0FBRUEsU0FBUSw4QkFBOEI7O0FBRXRDLDhDQUE2Qzs7QUFFN0M7O0FBRUEsU0FBUSxPQUFPOztBQUVmLDBFQUF5RTtBQUN6RSxxRUFBb0U7QUFDcEUscUVBQW9FO0FBQ3BFLHFFQUFvRTtBQUNwRSxpREFBZ0Q7O0FBRWhELDhDQUE2QztBQUM3QywyQ0FBMEM7QUFDMUMsZ0NBQStCO0FBQy9CLG1DQUFrQzs7QUFFbEMsU0FBUTs7QUFFUixRQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXFDLE9BQU87O0FBRTVDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtREFBa0QsUUFBUTs7QUFFMUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZ0U7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLHVDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFEQUFvRDs7QUFFcEQsa0NBQWlDO0FBQ2pDLG1DQUFrQztBQUNsQyw0QkFBMkI7QUFDM0Isd0JBQXVCO0FBQ3ZCLDJCQUEwQjtBQUMxQiwwQkFBeUI7O0FBRXpCLDZCQUE0QjtBQUM1Qix1QkFBc0I7O0FBRXRCLHNCQUFxQjs7QUFFckIsa0JBQWlCOztBQUVqQixvQ0FBbUM7O0FBRW5DLDhDQUE2Qzs7QUFFN0MsMkJBQTBCO0FBQzFCLG9HQUFtRztBQUNuRyxvR0FBbUc7O0FBRW5HLHlCQUF3Qjs7QUFFeEIsbUVBQWtFO0FBQ2xFLDBDQUF5QztBQUN6Qyx1REFBc0Q7O0FBRXRELGtDQUFpQzs7QUFFakMsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQSxxREFBb0Q7O0FBRXBELHdCQUF1QjtBQUN2QiwyQkFBMEI7QUFDMUIsMkJBQTBCOztBQUUxQix5QkFBd0I7QUFDeEIsMkJBQTBCO0FBQzFCLDhCQUE2QjtBQUM3QiwyQkFBMEI7QUFDMUIsMEJBQXlCO0FBQ3pCLDZCQUE0Qjs7QUFFNUIsc0JBQXFCOztBQUVyQixrQkFBaUI7O0FBRWpCLDJDQUEwQzs7QUFFMUMsMkNBQTBDOztBQUUxQyxzRUFBcUU7O0FBRXJFLDBCQUF5Qjs7QUFFekIscURBQW9EO0FBQ3BELDZCQUE0Qjs7QUFFNUIsNEJBQTJCOztBQUUzQix5REFBd0Q7O0FBRXhELFFBQU8sT0FBTzs7QUFFZCxvQ0FBbUM7QUFDbkMsNkVBQTRFO0FBQzVFLHVEQUFzRDs7QUFFdEQsUUFBTzs7QUFFUCx1RkFBc0Y7O0FBRXRGLE9BQU07O0FBRU4sTUFBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSwrQkFBOEI7QUFDOUIsbUNBQWtDO0FBQ2xDLGlDQUFnQztBQUNoQywrQkFBOEI7O0FBRTlCOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXdDLE9BQU87O0FBRS9DOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQTZCLE9BQU87O0FBRXBDOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBZ0I7QUFDaEIsaUJBQWdCO0FBQ2hCLGlCQUFnQjs7QUFFaEIsZ0JBQWUsT0FBTzs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCO0FBQ2xCLG1CQUFrQjtBQUNsQixtQkFBa0I7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWdCLE9BQU87O0FBRXZCLEtBQUk7O0FBRUosaUJBQWdCLE9BQU87O0FBRXZCOztBQUVBOztBQUVBOztBQUVBLHVCQUFzQjs7QUFFdEIscUJBQW9CLFFBQVE7O0FBRTVCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVSx5QkFBeUI7QUFDbkMsZUFBYyx1QkFBdUI7QUFDckMsZUFBYyx1QkFBdUI7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBLDZCQUE0QixRQUFROztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUEsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2QsOENBQTZDOztBQUU3QyxLQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEwRDtBQUMxRCwyREFBMEQ7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBLHFEQUFvRDtBQUNwRCwyQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQSx1RkFBc0Y7QUFDdEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVGQUFzRjtBQUN0Rjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEwQjtBQUMxQiwyQkFBMEI7O0FBRTFCLE9BQU07O0FBRU4sMkJBQTBCO0FBQzFCLDJCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQSwyQkFBMEI7QUFDMUIsMkJBQTBCOztBQUUxQixPQUFNOztBQUVOLDJCQUEwQjtBQUMxQiwyQkFBMEI7O0FBRTFCOztBQUVBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQSwyQkFBMEI7QUFDMUIsMkJBQTBCOztBQUUxQixPQUFNOztBQUVOLDJCQUEwQjtBQUMxQiwyQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUEsMkJBQTBCO0FBQzFCLDJCQUEwQjs7QUFFMUIsT0FBTTs7QUFFTiwyQkFBMEI7QUFDMUIsMkJBQTBCOztBQUUxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUEsaUNBQWdDO0FBQ2hDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixxQkFBcUI7O0FBRXhDLHlCQUF3QjtBQUN4QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQiwyQkFBMkI7O0FBRS9DO0FBQ0EscUJBQW9CLHVCQUF1Qjs7QUFFM0MsMEJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBcUMsMkJBQTJCOztBQUVoRTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLHVCQUF1Qjs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLGtCQUFrQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUNBQWtDOztBQUVsQyxtQ0FBa0M7O0FBRWxDO0FBQ0Esa0NBQWlDOztBQUVqQzs7QUFFQTs7QUFFQSxpQkFBZ0I7O0FBRWhCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXFDLFFBQVE7O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFxQyxRQUFROztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRFQUEyRTtBQUMzRTs7QUFFQTs7QUFFQSxzQ0FBcUMsUUFBUTs7QUFFN0M7O0FBRUEsZ0JBQWUsT0FBTzs7QUFFdEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWMsZ0JBQWdCOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWMsZ0JBQWdCOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBYyxnQkFBZ0I7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdCQUFlLEtBQUssd0JBQXdCOztBQUU1QyxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBc0I7O0FBRXRCOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsK0NBQThDOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEseUJBQXdCOztBQUV4Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBeUMsT0FBTzs7QUFFaEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQW9DLE9BQU87O0FBRTNDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFtQixrQkFBa0I7O0FBRXJDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQXlCLGlCQUFpQjs7QUFFMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBCQUF5QixpQkFBaUI7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxZQUFXOztBQUVYOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBcUMsUUFBUTs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXFDLE9BQU87O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNCQUFxQixtQ0FBbUM7O0FBRXhEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBcUIsbUNBQW1DOztBQUV4RDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXFCLDJEQUEyRDs7QUFFaEY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXFCLHdFQUF3RTs7QUFFN0Y7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXFCLG1DQUFtQzs7QUFFeEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsZ0NBQWdDOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBaUIsZUFBZTs7QUFFaEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEwQyxPQUFPOztBQUVqRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBbUIsZ0JBQWdCOztBQUVuQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxvQkFBbUIsZ0JBQWdCOztBQUVuQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLFFBQVE7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsaUJBQWlCOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBbUIsaUJBQWlCOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF3QyxPQUFPOztBQUUvQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQXlDLE9BQU87O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLGFBQWE7O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFpQztBQUNqQyxrQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7O0FBRUEsaURBQWdEO0FBQ2hELGtCQUFpQjs7QUFFakIsTUFBSzs7QUFFTDtBQUNBLDJDQUEwQztBQUMxQztBQUNBLHdCQUF1Qjs7QUFFdkI7O0FBRUEsS0FBSTs7QUFFSjtBQUNBLDhDQUE2QztBQUM3QztBQUNBO0FBQ0Esa0ZBQWlGO0FBQ2pGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBc0MsT0FBTzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNEJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVILG9DQUFtQyxnQ0FBZ0M7O0FBRW5FOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQThDLGFBQWE7O0FBRTNEOztBQUVBOztBQUVBLCtDQUE4QyxhQUFhOztBQUUzRDs7QUFFQSx1QkFBc0IsbUJBQW1COztBQUV6QztBQUNBOztBQUVBLHlCQUF3QiwwQkFBMEI7O0FBRWxEOztBQUVBLDZDQUE0QyxzQ0FBc0M7QUFDbEY7O0FBRUE7QUFDQTs7QUFFQSxRQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXdDLFFBQVE7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF3QyxPQUFPOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLHlDQUF3QztBQUN4QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQSxnQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSx1QkFBc0I7O0FBRXRCOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFnRTtBQUNoRSxtRUFBa0U7QUFDbEUsaUVBQWdFO0FBQ2hFLG1FQUFrRTtBQUNsRSxpRUFBZ0U7QUFDaEUsbUVBQWtFOztBQUVsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFlLGFBQWE7O0FBRTVCLGlCQUFnQixhQUFhOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZSxZQUFZOztBQUUzQixpQkFBZ0IsWUFBWTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBaUMsZUFBZTs7QUFFaEQ7O0FBRUE7QUFDQTs7QUFFQSx3QkFBdUI7O0FBRXZCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWlCLGVBQWU7O0FBRWhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFhLHFCQUFxQjs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWMscUJBQXFCOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxjQUFhLG9CQUFvQjs7QUFFakM7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxlQUFjLG9CQUFvQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWMsb0JBQW9COztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWMsb0JBQW9COztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW1DLE9BQU87O0FBRTFDOztBQUVBLG1CQUFrQixPQUFPOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1COztBQUVuQixLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGtCQUFpQixRQUFROztBQUV6QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlGQUF3RjtBQUN4RiwyRkFBMEY7QUFDMUY7O0FBRUEsc0ZBQXFGOztBQUVyRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQjtBQUNsQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtDQUFpQyxRQUFROztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBa0I7O0FBRWxCOzs7QUFHQTs7QUFFQTs7QUFFQSx5QkFBd0I7O0FBRXhCLGlDQUFnQyxRQUFROztBQUV4Qzs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBLDZCQUE0QjtBQUM1Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUEsOERBQTZELFFBQVE7O0FBRXJFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBZ0MsUUFBUTs7QUFFeEM7O0FBRUE7O0FBRUEseURBQXdELFFBQVE7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQSxjQUFhLG1CQUFtQjs7QUFFaEMsNkJBQTRCLE9BQU87O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQSxxREFBb0Q7QUFDcEQsd0JBQXVCOztBQUV2Qjs7QUFFQSxvQ0FBbUMsUUFBUTs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWlDLFFBQVE7O0FBRXpDO0FBQ0E7O0FBRUEsbUNBQWtDLFFBQVE7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGNBQWEsVUFBVTs7QUFFdkI7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYSxZQUFZOztBQUV6QixlQUFjLFVBQVU7O0FBRXhCOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUEsZ0JBQWUsb0JBQW9CO0FBQ25DLDhCQUE2QixRQUFROztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBbUMsUUFBUTs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBaUMsUUFBUTs7QUFFekM7QUFDQTs7QUFFQSxtQ0FBa0MsUUFBUTs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUEsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWlCO0FBQ2pCOztBQUVBOztBQUVBLGdCQUFlLFVBQVU7O0FBRXpCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZSxVQUFVOztBQUV6QjtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUEsZ0JBQWUsVUFBVTs7QUFFekI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZSxVQUFVOztBQUV6QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBaUMsUUFBUTs7QUFFekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdCQUFlLFFBQVE7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBb0MsT0FBTzs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBZ0MsT0FBTzs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0NBQStCLE9BQU87O0FBRXRDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxjQUFhLFVBQVU7O0FBRXZCOztBQUVBOztBQUVBOztBQUVBLGNBQWEsVUFBVTs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFnQyxTQUFTOztBQUV6Qzs7QUFFQTtBQUNBOztBQUVBLHVDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUNBQWdDLFFBQVE7O0FBRXhDLDJDQUEwQyxRQUFROztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFrQixhQUFhOztBQUUvQjs7QUFFQSxvQkFBbUIsYUFBYTs7QUFFaEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLFlBQVk7O0FBRTlCLG9CQUFtQixZQUFZOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYSxxQkFBcUI7O0FBRWxDOztBQUVBLGVBQWMsdUJBQXVCOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGNBQWEsaUJBQWlCOztBQUU5Qjs7QUFFQTs7QUFFQSxlQUFjLG9CQUFvQjs7QUFFbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBaUIscUJBQXFCOztBQUV0Qzs7QUFFQTs7QUFFQSxtQkFBa0Isb0JBQW9COztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFpQixvQkFBb0I7O0FBRXJDLG1CQUFrQixtQkFBbUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWlCLHFCQUFxQjs7QUFFdEMsbUJBQWtCLHNCQUFzQjs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWlCLHFCQUFxQjs7QUFFdEMsbUJBQWtCLHNCQUFzQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsb0JBQW9COztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCLHFCQUFxQjs7QUFFdkM7QUFDQSxvQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWlCLG9CQUFvQjs7QUFFckMsbUJBQWtCLHFCQUFxQjs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFhLGVBQWU7O0FBRTVCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFjLG9CQUFvQjs7QUFFbEM7O0FBRUEsNkJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQSxjQUFhLGNBQWM7O0FBRTNCLGVBQWMsb0JBQW9COztBQUVsQztBQUNBOztBQUVBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFhLGVBQWU7O0FBRTVCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwRUFBeUU7QUFDekU7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUEsY0FBYSxlQUFlOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw0RkFBMkY7O0FBRTNGOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWMsZUFBZTs7QUFFN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsdUNBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZDQUE0QyxPQUFPOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0NBQW1DLE9BQU87O0FBRTFDOztBQUVBOzs7QUFHQTs7QUFFQSxzREFBcUQsT0FBTzs7QUFFNUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQSw0Q0FBMkMsT0FBTzs7QUFFbEQ7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQixXQUFXOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLFdBQVc7O0FBRTlCOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLFdBQVc7O0FBRTdCLG9CQUFtQiwwQkFBMEI7O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGNBQWEsYUFBYTs7QUFFMUI7O0FBRUEsZUFBYyxhQUFhOztBQUUzQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYSxZQUFZOztBQUV6QixlQUFjLFlBQVk7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBb0MsT0FBTzs7QUFFM0M7O0FBRUEsb0JBQW1CLE9BQU87O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBZ0MsT0FBTzs7QUFFdkMsb0JBQW1CLE9BQU87O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNEMsUUFBUTs7QUFFcEQsc0JBQXFCLE9BQU87O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBaUMsT0FBTzs7QUFFeEMscUJBQW9CLE9BQU87O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFnQyxPQUFPOztBQUV2QyxxQkFBb0IsT0FBTzs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUE4QyxtQ0FBbUM7O0FBRWpGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyRUFBMEUsZUFBZTtBQUN6RjtBQUNBOztBQUVBLDJFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlFQUF3RSxrQkFBa0I7O0FBRTFGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUFzQixxQkFBcUI7QUFDM0MsdUJBQXNCLHFCQUFxQjtBQUMzQyx1QkFBc0IscUJBQXFCO0FBQzNDLHVCQUFzQixxQkFBcUI7QUFDM0MsdUJBQXNCLHFCQUFxQjtBQUMzQyx1QkFBc0IscUJBQXFCO0FBQzNDLHVCQUFzQixxQkFBcUI7QUFDM0MsdUJBQXNCLHFCQUFxQjs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUZBQXdGLGdDQUFnQzs7QUFFeEg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0NBQThDLGtEQUFrRDs7QUFFaEc7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQThDLGFBQWE7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEwQyxhQUFhO0FBQ3ZEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDJIQUEwSCxlQUFlOztBQUV6STtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5RUFBd0UsaUNBQWlDOztBQUV6Rzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFvQyxPQUFPOztBQUUzQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0NBQThDLG1DQUFtQzs7QUFFakY7QUFDQTs7QUFFQSx1QkFBc0IsV0FBVzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBCQUF5QixRQUFROztBQUVqQzs7QUFFQTs7QUFFQSwrQ0FBOEMsa0RBQWtEOztBQUVoRztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQThDLDhCQUE4QjtBQUM1RTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBc0QsZ0ZBQWdGOztBQUV0STtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWlCLHVCQUF1Qjs7QUFFeEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsK0NBQThDLDJGQUEyRjs7QUFFekk7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBaUIsNEJBQTRCOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBaUIsdUJBQXVCOztBQUV4Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBOEMsOEJBQThCOztBQUU1RTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUVBQXdFLGlDQUFpQzs7QUFFekc7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXFDLE9BQU87O0FBRTVDOztBQUVBLHFEQUFvRCxRQUFROztBQUU1RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwrR0FBOEcsZUFBZTs7QUFFN0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFEQUFvRCxRQUFROztBQUU1RDtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdEQUF1RDs7QUFFdkQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1EQUFrRCxRQUFROztBQUUxRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBOzs7Ozs7O0FDdm52Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsdURBQXNEO0FBQ3REOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7QUNyRkE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQjs7QUFFcEI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBYyxRQUFROztBQUV0Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcklBLEtBQU0sV0FBVyxJQUFYOztLQUVlOzs7QUFFcEIsV0FGb0IsU0FFcEIsQ0FBWSxRQUFaLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLEVBQTRCO3lCQUZSLFdBRVE7O0FBRTNCLE9BQUksV0FBVztBQUNkLFlBQVEsRUFBQyxNQUFNLEdBQU4sRUFBVyxPQUFPLElBQUksQ0FBSixFQUEzQjtBQUNBLFVBQU0sRUFBQyxNQUFNLEdBQU4sRUFBVyxPQUFPLElBQVAsRUFBbEI7QUFDQSxXQUFPLEVBQUMsTUFBTSxHQUFOLEVBQVcsT0FBTyxPQUFPLE1BQVAsRUFBMUI7QUFDQSxZQUFRLEVBQUMsTUFBTSxJQUFOLEVBQVksT0FBTyxJQUFJLE1BQU0sT0FBTixFQUFYLEVBQXJCO0FBQ0Esa0JBQWMsRUFBQyxNQUFNLEdBQU4sRUFBVyxPQUFPLENBQVAsRUFBMUI7QUFDQSxlQUFXLEVBQUMsTUFBTSxHQUFOLEVBQVcsT0FBTyxDQUFQLEVBQXZCO0FBQ0EsV0FBTyxFQUFDLE1BQU0sR0FBTixFQUFXLE9BQU8sUUFBUCxFQUFuQjtBQUNBLGNBQVUsRUFBQyxNQUFNLEdBQU4sRUFBVyxPQUFPLEtBQVAsRUFBdEI7QUFDQSxVQUFNLEVBQUMsTUFBTSxHQUFOLEVBQVcsT0FBTyxDQUFQLEVBQWxCO0lBVEcsQ0FGdUI7O3NFQUZSLHNCQWdCYixVQUFVO0FBQ2Ysb0JBQWdCLG9CQUFRLEVBQVIsQ0FBaEI7QUFDQSxjQUFVLFFBQVY7T0FoQjBCOztBQW1CM0IsT0FBSSxlQUFlOzs7SUFBZixDQW5CdUI7O0FBd0IzQixTQUFLLFFBQUwsR0FBZ0IsUUFBaEIsQ0F4QjJCOztBQTBCM0IsU0FBSyxXQUFMLEdBQW1CLElBQUksTUFBTSxpQkFBTixDQUF3QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxZQUFsQyxDQUFuQixDQTFCMkI7QUEyQjNCLFNBQUssT0FBTCxHQUFlLElBQUksTUFBTSxpQkFBTixDQUF3QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxZQUFsQyxDQUFmLENBM0IyQjs7QUE2QjNCLFNBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsS0FBbkIsR0FBMkIsTUFBSyxPQUFMOzs7Ozs7OztBQTdCQSxTQXFDM0IsQ0FBTyxTQUFQLENBQWlCLEVBQWpCLENBQW9CLGFBQXBCLEVBQW1DLE1BQUssWUFBTCxDQUFrQixJQUFsQixPQUFuQyxFQXJDMkI7QUFzQzNCLFVBQU8sU0FBUCxDQUFpQixFQUFqQixDQUFvQixVQUFwQixFQUFnQyxNQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsT0FBaEMsRUF0QzJCO0FBdUMzQixVQUFPLFNBQVAsQ0FBaUIsRUFBakIsQ0FBb0IsUUFBcEIsRUFBOEIsTUFBSyxjQUFMLENBQW9CLElBQXBCLE9BQTlCLEVBdkMyQjtBQXdDM0IsVUFBTyxTQUFQLENBQWlCLEVBQWpCLENBQW9CLFlBQXBCLEVBQWtDLE1BQUssaUJBQUwsQ0FBdUIsSUFBdkIsT0FBbEMsRUF4QzJCOztHQUE1Qjs7ZUFGb0I7O3FDQTZDRixPQUFPOztBQUV4QixTQUFLLFFBQUwsQ0FBYyxRQUFkLENBQXVCLEtBQXZCLEdBQStCLFFBQVEsSUFBUixDQUZQOzs7O2dDQUtaLE9BQU87O0FBRW5CLFNBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsS0FBbkIsR0FBMkIsS0FBSyxNQUFMLEVBQTNCLENBRm1COzs7OzhCQUtULE9BQU87OztBQUdqQixTQUFLLFFBQUwsQ0FBYyxZQUFkLENBQTJCLEtBQTNCLEdBQW1DLENBQW5DLENBSGlCOzs7O2tDQU1ILE9BQU87O0FBRXJCLFNBQUssUUFBTCxDQUFjLEtBQWQsQ0FBb0IsS0FBcEIsR0FBNkIsS0FBSyxHQUFMLENBQVMsS0FBVCxFQUFnQixDQUFoQixLQUFzQixJQUFJLFFBQUosQ0FBdEIsR0FBc0MsUUFBdEMsQ0FGUjs7Ozs0QkFLYjs7QUFFUixRQUFJLE9BQU8sS0FBSyxXQUFMLENBRkg7QUFHUixTQUFLLFdBQUwsR0FBbUIsS0FBSyxPQUFMLENBSFg7QUFJUixTQUFLLE9BQUwsR0FBZSxJQUFmLENBSlE7O0FBTVIsU0FBSyxRQUFMLENBQWMsSUFBZCxDQUFtQixLQUFuQixHQUEyQixLQUFLLFdBQUwsQ0FObkI7O0FBUVIsK0JBMUVtQixpREEwRU4sS0FBSyxPQUFMLENBQWIsQ0FSUTs7QUFVUixTQUFLLFFBQUwsQ0FBYyxZQUFkLENBQTJCLEtBQTNCLEdBQW1DLENBQW5DLENBVlE7Ozs7MkJBYUQsR0FBRyxHQUFHO0FBQ2IsK0JBaEZtQixrREFnRkwsR0FBRyxFQUFqQixDQURhO0FBRWIsU0FBSyxRQUFMLENBQWMsTUFBZCxDQUFxQixLQUFyQixHQUE2QixJQUFJLENBQUosQ0FGaEI7QUFHYixTQUFLLFdBQUwsQ0FBaUIsT0FBakIsQ0FBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsRUFIYTtBQUliLFNBQUssT0FBTCxDQUFhLE9BQWIsQ0FBcUIsQ0FBckIsRUFBd0IsQ0FBeEIsRUFKYTs7OztTQS9FTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NMQTtBQUVwQixXQUZvQixRQUVwQixDQUFZLFFBQVosRUFBc0IsTUFBdEIsRUFBOEI7eUJBRlYsVUFFVTs7QUFFN0IsUUFBSyxLQUFMLEdBQWEsSUFBSSxNQUFNLEtBQU4sRUFBakIsQ0FGNkI7O0FBSTdCLFFBQUssUUFBTCxHQUFnQixRQUFoQjs7O0FBSjZCLE9BTzdCLENBQUssTUFBTCxHQUFjLElBQUksTUFBTSxrQkFBTixDQUF5QixDQUFDLENBQUQsRUFBSSxDQUFqQyxFQUFvQyxDQUFwQyxFQUF1QyxDQUFDLENBQUQsRUFBSSxDQUEzQyxFQUE4QyxJQUE5QyxDQUFkLENBUDZCO0FBUTdCLFFBQUssTUFBTCxDQUFZLFFBQVosQ0FBcUIsR0FBckIsQ0FBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsRUFBK0IsRUFBL0IsRUFSNkI7QUFTN0IsUUFBSyxLQUFMLENBQVcsR0FBWCxDQUFlLEtBQUssTUFBTCxDQUFmLENBVDZCOztBQVc3QixRQUFLLFFBQUwsR0FBZ0IsT0FBTyxRQUFQLENBWGE7O0FBYTdCLE9BQUksTUFBTSxJQUFJLE1BQU0sY0FBTixDQUFxQjtBQUNsQyxjQUFVLEtBQUssUUFBTDtBQUNWLGtCQUFjLE9BQU8sWUFBUCxJQUF1QixvQkFBUSxDQUFSLENBQXZCO0FBQ2Qsb0JBQWdCLE9BQU8sY0FBUDtJQUhQLENBQU4sQ0FieUI7O0FBbUI3QixPQUFJLFFBQVEsSUFBSSxNQUFNLElBQU4sQ0FDZixJQUFJLE1BQU0sYUFBTixDQUFvQixDQUF4QixFQUEyQixDQUEzQixDQURXLEVBRVgsR0FGVyxDQUFSLENBbkJ5Qjs7QUF3QjdCLFFBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZSxLQUFmLEVBeEI2QjtHQUE5Qjs7ZUFGb0I7OzJCQTZCWixPQUFPLFFBQVE7QUFDdEIsU0FBSyxRQUFMLENBQWMsT0FBZCxDQUFzQixLQUF0QixFQUE2QixNQUE3QixFQURzQjs7OzswQkFJaEIsZ0JBQWdCO0FBQ3RCLFNBQUssUUFBTCxDQUFjLE1BQWQsQ0FBcUIsS0FBSyxLQUFMLEVBQVksS0FBSyxNQUFMLEVBQWEsY0FBOUMsRUFEc0I7Ozs7U0FqQ0g7Ozs7Ozs7Ozs7QUNBckIsdURBQXNELHFCQUFxQiwyQkFBMkIsc0NBQXNDLEdBQUcsRzs7Ozs7O0FDQS9JLDJDQUEwQywwYUFBMGEsZ0RBQWdELEdBQUcsNkJBQTZCLGdEQUFnRCxHQUFHLDhCQUE4Qix3Q0FBd0MsR0FBRyxpQ0FBaUMsOE9BQThPLHNFQUFzRSxxQ0FBcUMsZ0NBQWdDLGdDQUFnQyxtREFBbUQseURBQXlELG1DQUFtQyxrQ0FBa0MsbUNBQW1DLGdDQUFnQyxpQkFBaUIseUNBQXlDLG1KQUFtSix3RkFBd0YsYUFBYSxhQUFhLDZMQUE2TCwwQkFBMEIsNkJBQTZCLHFCQUFxQix5R0FBeUcsK0RBQStELGdEQUFnRCx1Q0FBdUMsMENBQTBDLDZCQUE2QixHQUFHLDJDQUEyQyxpQ0FBaUMsMEJBQTBCLHVCQUF1QixzQkFBc0IsNkJBQTZCLDBCQUEwQixzQkFBc0IseUJBQXlCLHFCQUFxQix1QkFBdUIsaUJBQWlCLCtIQUErSCx1REFBdUQsK0dBQStHLHdFQUF3RSxtQ0FBbUMsaUNBQWlDLG1CQUFtQixrREFBa0Qsb0RBQW9ELDREQUE0RCxzQ0FBc0MsS0FBSyxHOzs7Ozs7QUNBdHFHLDJDQUEwQyxpREFBaUQsK0JBQStCLHFCQUFxQixpQkFBaUIsMkNBQTJDLHlCQUF5QixLQUFLLEc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNPek8sS0FBTSxPQUFPO0FBQ1osU0FBTyxDQUFQO0FBQ0EsTUFBSSxDQUFKO0VBRks7O0FBS04sS0FBTSxVQUFVO0FBQ2YsYUFBVyxLQUFLLEtBQUw7QUFDWCxpQkFBZSxLQUFLLEtBQUw7QUFDZixlQUFhLEtBQUssRUFBTDtBQUNiLGtCQUFnQixLQUFLLEVBQUw7RUFKWDs7S0FPQTs7O0FBRUwsV0FGSyxXQUVMLEdBQWM7eUJBRlQsYUFFUzs7c0VBRlQseUJBRVM7O0FBR2IsU0FBSyxTQUFMLEdBQWlCLElBQUksa0JBQUksTUFBSixDQUFXLElBQWYsRUFBcUIsU0FBckIsQ0FBakIsQ0FIYTs7QUFLYixTQUFLLFNBQUwsQ0FBZSxFQUFmLENBQWtCLFNBQWxCLEVBQTZCLE1BQUssWUFBTCxDQUFrQixJQUFsQixPQUE3Qjs7OztBQUxhO0dBQWQ7O2VBRks7OzRCQWFJOzs7Ozs7Z0NBS0ksS0FBSyxPQUFPOztBQUV4QixRQUFJLE9BQU8sSUFBSSxDQUFKLENBQVAsQ0FGb0I7QUFHeEIsUUFBSSxRQUFRLElBQUksQ0FBSixDQUFSLENBSG9COztBQUt4QixRQUFJLFFBQVEsSUFBUixLQUFpQixLQUFLLEtBQUwsRUFBWTtBQUNoQyxVQUFLLElBQUwsQ0FBVSxLQUFLLE1BQUwsQ0FBWSxDQUFaLENBQVYsRUFBMEIsS0FBMUIsRUFEZ0M7S0FBakMsTUFFTyxJQUFJLFFBQVEsSUFBUixLQUFpQixLQUFLLEVBQUwsSUFBVyxTQUFTLENBQVQsRUFBWTtBQUNsRCxVQUFLLElBQUwsQ0FBVSxLQUFLLE1BQUwsQ0FBWSxDQUFaLENBQVYsRUFBMEIsS0FBMUIsRUFEa0Q7S0FBNUM7Ozs7U0F6Qkg7OzttQkFrQ1MsSUFBSSxXQUFKLEc7Ozs7OztBQ3JEZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsTUFBTTtBQUNqQixZQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsUUFBUTtBQUNuQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTBELE9BQU87QUFDakU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQSxnQkFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0EsNERBQTJEO0FBQzNELGdFQUErRDtBQUMvRCxvRUFBbUU7QUFDbkU7QUFDQSwyREFBMEQsU0FBUztBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsUUFBUTtBQUNuQixZQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxpREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NsUU07OztBQUVMLFdBRkssTUFFTCxHQUFjO3lCQUZULFFBRVM7O3NFQUZULG9CQUVTOztBQUViLFNBQUssTUFBTCxHQUFjLE1BQUssTUFBTCxDQUFZLElBQVosT0FBZCxDQUZhO0FBR2IsU0FBSyxZQUFMLEdBQW9CLENBQXBCLENBSGE7O0dBQWQ7O2VBRks7OzJCQVFHO0FBQ1AsWUFBUSxHQUFSLENBQVksY0FBWixFQURPO0FBRVAsU0FBSyxNQUFMLEdBRk87Ozs7MEJBS0Q7QUFDTix5QkFBcUIsS0FBSyxVQUFMLENBQXJCLENBRE07Ozs7MEJBSUEsR0FBRztBQUNULFNBQUssU0FBTCxHQUFpQixzQkFBc0IsS0FBSyxNQUFMLENBQXZDLENBRFM7QUFFVCxRQUFJLFVBQVUsSUFBSSxLQUFLLFlBQUwsQ0FGVDtBQUdULFNBQUssWUFBTCxHQUFvQixDQUFwQixDQUhTO0FBSVQsUUFBSSxPQUFKLEVBQWE7QUFDWixVQUFLLElBQUwsQ0FBVSxRQUFWLEVBQW9CLE9BQXBCLEVBRFk7S0FBYjs7OztTQXJCSTs7O21CQTJCUyxJQUFJLE1BQUosRzs7Ozs7O0FDOUJmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuREE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkRBLG1DOzs7Ozs7QUNBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0Msb0NBQW9DO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7Ozs7OztBQ3hLRDtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QyxtQ0FBbUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0Qsd0RBQXdEO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSx3Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLHNDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7Ozs7Ozs7QUM1b0JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDM0ZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDeENBLGtDOzs7Ozs7QUNBQSxvQzs7Ozs7O0FDQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXdCLG1CQUFtQixtQkFBbUIsRUFBRTtBQUNoRSw0Q0FBMkMscUJBQXFCLEVBQUU7QUFDbEUsNENBQTJDLHNCQUFzQixFQUFFO0FBQ25FLDRDQUEyQyxvQkFBb0IsRUFBRTtBQUNqRSw0Q0FBMkMsc0JBQXNCLEVBQUU7O0FBRW5FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6RUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTBCLG9CQUFvQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBdUIsb0JBQW9COztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBd0Isb0JBQW9COztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QixXQUFXO0FBQ3pDLHNEQUFxRCw2QkFBNkI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsV0FBVztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLGNBQWMsWUFBWSxNQUFNO0FBQ3ZELDZEQUE0RCxXQUFXO0FBQ3ZFLDZEQUE0RCxXQUFXOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXdDO0FBQ3hDLHNDQUFxQyxLQUFLLE1BQU0sRUFBRTs7QUFFbEQ7QUFDQSx1QkFBc0IsY0FBYyxFQUFFO0FBQ3RDLFVBQVMsaUNBQWlDLEVBQUU7QUFDNUMsbUJBQWtCLEtBQUssTUFBTSxFQUFFOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBd0MsV0FBVztBQUNuRCxrQ0FBaUMsVUFBVTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGVBQWM7QUFDZCxjQUFhLE9BQU8sNkJBQTZCO0FBQ2pELFdBQVUsK0JBQStCO0FBQ3pDLFdBQVUsMkJBQTJCO0FBQ3JDLFdBQVUseUZBQXlGO0FBQ25HLFdBQVUsNEVBQTRFO0FBQ3RGLFdBQVUsMkZBQTJGO0FBQ3JHLFdBQVUsNkVBQTZFO0FBQ3ZGLFdBQVUsMkZBQTJGO0FBQ3JHLFdBQVUsNkVBQTZFO0FBQ3ZGLFdBQVUsMkZBQTJGO0FBQ3JHLFdBQVUsNkVBQTZFO0FBQ3ZGLFdBQVUsK0VBQStFO0FBQ3pGLFdBQVUsK0NBQStDO0FBQ3pELFdBQVUsMkNBQTJDO0FBQ3JELFdBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLE9BQU87QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEIsT0FBTztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTyxPQUFPLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3UUEsUUFBTyxZQUFQLEdBQXNCLE9BQU8sWUFBUCxJQUF1QixPQUFPLGtCQUFQO0FBQzdDLFFBQU8sU0FBUCxDQUFpQixZQUFqQixHQUFnQyxPQUFPLFNBQVAsQ0FBaUIsWUFBakIsSUFBaUMsT0FBTyxTQUFQLENBQWlCLGtCQUFqQjs7QUFHakUsS0FBTSxjQUFjLG1CQUFkOzs7S0FHZTtBQUVwQixXQUZvQixhQUVwQixHQUFjO3lCQUZNLGVBRU47O0FBQ2IsUUFBSyxNQUFMLEdBQWMsQ0FBZCxDQURhO0FBRWIsUUFBSyxhQUFMLEdBQXFCLEtBQUssYUFBTCxDQUFtQixJQUFuQixDQUF3QixJQUF4QixDQUFyQixDQUZhOztBQUliLFVBQU8sZ0JBQVAsQ0FBd0IsVUFBeEIsQ0FBbUMsS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLElBQXJCLENBQW5DLEVBSmE7R0FBZDs7ZUFGb0I7OzhCQVNULGFBQWE7Ozs7QUFJdkIsUUFBSSxXQUFXLElBQVgsQ0FKbUI7O0FBTXZCLFNBQUssSUFBSSxJQUFJLENBQUosRUFBTyxJQUFJLFlBQVksTUFBWixFQUFvQixHQUF4QyxFQUE2QztBQUM1QyxTQUFJLE9BQU8sWUFBWSxDQUFaLENBQVAsQ0FEd0M7QUFFNUMsU0FBSSxLQUFLLEtBQUwsSUFBYyxXQUFkLEVBQTJCO0FBQzlCLGlCQUFXLEtBQUssRUFBTCxDQURtQjtBQUU5QixZQUY4QjtNQUEvQjtLQUZEOztBQVFBLFFBQU0sU0FBUztBQUNkLFlBQU87QUFDTixnQkFBVSxDQUNUO0FBQ0MsaUJBQVUsUUFBVjtPQUZRLENBQVY7TUFERDtLQURLOzs7O0FBZGlCLFVBMEJ2QixDQUFPLFNBQVAsQ0FBaUIsWUFBakIsQ0FBOEIsTUFBOUIsRUFBc0MsS0FBSyxhQUFMLEVBQW9CLFlBQU0sRUFBTixDQUExRCxDQTFCdUI7Ozs7aUNBNkJWLFFBQVE7O0FBRXJCLFFBQUksVUFBVSxJQUFJLFlBQUosRUFBVixDQUZpQjtBQUdyQixRQUFJLFNBQVMsUUFBUSx1QkFBUixDQUFnQyxNQUFoQyxDQUFULENBSGlCOztBQUtyQixTQUFLLFFBQUwsR0FBZ0IsUUFBUSxjQUFSLEVBQWhCLENBTHFCOztBQU9yQixXQUFPLE9BQVAsQ0FBZSxLQUFLLFFBQUwsQ0FBZjs7OztBQVBxQixRQVdyQixDQUFLLGFBQUwsR0FBcUIsSUFBSSxVQUFKLENBQWUsS0FBSyxRQUFMLENBQWMsaUJBQWQsQ0FBcEMsQ0FYcUI7O0FBYXJCLFNBQUssTUFBTCxHQUFjLEtBQUssT0FBTCxDQWJPOzs7OzRCQWtCYjs7OzZCQUVDOztBQUVULFNBQUssUUFBTCxDQUFjLG9CQUFkLENBQW1DLEtBQUssYUFBTCxDQUFuQzs7O0FBRlMsUUFLVCxDQUFLLE1BQUwsR0FBYyxLQUFLLGFBQUwsQ0FBbUIsR0FBbkIsQ0FBZDs7Ozs7O0FBTFMsV0FXVCxDQUFRLEdBQVIsQ0FBWSxLQUFLLE1BQUwsQ0FBWixDQVhTO0FBWVQsU0FBSyxNQUFMLElBQWUsS0FBZixDQVpTOzs7O1NBMURVIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGFlMThhZGRiNjgyYmJlMWUyMjc2XG4gKiovIiwicmVxdWlyZSgnLi9hcHAuanMnKVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbWFpbi5qc1xuICoqLyIsImltcG9ydCAncG9zdHByb2Nlc3NpbmcvU2hhZGVyUGFzcydcbmltcG9ydCAncG9zdHByb2Nlc3NpbmcvTWFza1Bhc3MnXG5pbXBvcnQgJ3Bvc3Rwcm9jZXNzaW5nL1JlbmRlclBhc3MnXG5pbXBvcnQgJ3Bvc3Rwcm9jZXNzaW5nL0VmZmVjdENvbXBvc2VyJ1xuXG5pbXBvcnQgSW50ZXJmYWNlIGZyb20gJy4vdmotaW50ZXJmYWNlLmpzJ1xuaW1wb3J0IFRpY2tlciBmcm9tICcuL3RpY2tlci5qcydcblxuaW1wb3J0IEJydXNoUGFzcyBmcm9tICcuL2JydXNoLXBhc3MuanMnXG5pbXBvcnQgQmFzZVBhc3MgZnJvbSAnLi9iYXNlLXBhc3MuanMnXG5cbndpbmRvdy5JbnRlcmZhY2UgPSBJbnRlcmZhY2VcbndpbmRvdy5yZW5kZXJlciA9IG51bGxcblxuY2xhc3MgQXBwIHtcblxuXHRjb25zdHJ1Y3RvcigpIHt9XG5cblx0aW5pdCgpIHtcblxuXHRcdHRoaXMuaW5pdFNjZW5lKClcblx0XHR0aGlzLmluaXRTb3VyY2UoKVxuXHR9XG5cblx0aW5pdFNjZW5lKCkge1xuXG5cdFx0Y29uc3QgdyA9IHdpbmRvdy5pbm5lcldpZHRoXG5cdFx0Y29uc3QgaCA9IHdpbmRvdy5pbm5lckhlaWdodFxuXG5cdFx0dGhpcy5icnVzaFBhc3MgPSBuZXcgQnJ1c2hQYXNzKHcsIGgpXG5cblx0XHQvLyBtYWtlIHJlbmRlcmVyXG5cdFx0dGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcblx0XHRcdGNhbnZhczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpXG5cdFx0fSlcblx0XHR0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHgwMDAwMDApXG5cblx0XHR0aGlzLnByZXZSZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQodywgaCwge1xuXHRcdH0pXG5cblx0XHR0aGlzLmJydXNoUGFzcyA9IG5ldyBCcnVzaFBhc3ModGhpcy5yZW5kZXJlcilcblxuXHRcdHRoaXMucmVuZGVyUGFzcyA9IG5ldyBCYXNlUGFzcyh0aGlzLnJlbmRlcmVyLCB7XG5cdFx0XHRyZW5kZXJlcjogdGhpcy5yZW5kZXJlcixcblx0XHRcdGZyYWdtZW50U2hhZGVyOiByZXF1aXJlKCcuL3NoYWRlcnMvcmVuZGVyLXBhc3MuZnJhZycpLFxuXHRcdFx0dW5pZm9ybXM6IHtcblx0XHRcdFx0dGV4dHVyZToge3R5cGU6ICd0JywgdmFsdWU6IHRoaXMuYnJ1c2hQYXNzLnRleHR1cmV9XG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplLmJpbmQodGhpcykpXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLmJpbmQodGhpcykpXG5cblx0XHR0aGlzLmFuaW1hdGUgPSB0aGlzLmFuaW1hdGUuYmluZCh0aGlzKVxuXG5cdFx0dGhpcy5vblJlc2l6ZSgpXG5cblx0XHRUaWNrZXIub24oJ3VwZGF0ZScsIHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpKVxuXHRcdFRpY2tlci5zdGFydCgpXG5cdH1cblxuXHRpbml0U291cmNlKCkge1xuXHR9XG5cblx0YW5pbWF0ZShlbGFwc2VkKSB7XG5cblx0XHRJbnRlcmZhY2UudXBkYXRlKClcblxuXHRcdHRoaXMuYnJ1c2hQYXNzLnJlbmRlcigpXG5cdFx0dGhpcy5yZW5kZXJQYXNzLnJlbmRlcigpXG5cdH1cblxuXHRvblJlc2l6ZSgpIHtcblx0XHRjb25zdCB3ID0gd2luZG93LmlubmVyV2lkdGhcblx0XHRjb25zdCBoID0gd2luZG93LmlubmVySGVpZ2h0XG5cblx0XHR0aGlzLmJydXNoUGFzcy5zZXRTaXplKHcsIGgpXG5cdFx0dGhpcy5yZW5kZXJQYXNzLnNldFNpemUodywgaClcblx0fVxuXG5cdG9uQ2xpY2soZSkge1xuXHRcdC8vIHRoaXMudW5pZm9ybXMuY3Vyc29yLnZhbHVlLnNldChlLmNsaWVudFgsIGUuY2xpZW50WSlcblx0fVxufVxuXG53aW5kb3cua3VtaWtvID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCcvYXNzZXRzL2t1bWlrby5wbmcnLCAoKSA9PiB7XG5cdG5ldyBBcHAoKS5pbml0KClcbn0pXG5cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYXBwLmpzXG4gKiovIiwidmFyIHNlbGYgPSBzZWxmIHx8IHt9Oy8vIEZpbGU6c3JjL1RocmVlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG52YXIgVEhSRUUgPSB7IFJFVklTSU9OOiAnNzQnIH07XHJcblxyXG4vL1xyXG5cclxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XHJcblxyXG5cdGRlZmluZSggJ3RocmVlJywgVEhSRUUgKTtcclxuXHJcbn0gZWxzZSBpZiAoICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZXhwb3J0cyAmJiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSApIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBUSFJFRTtcclxuXHJcbn1cclxuXHJcbi8vXHJcblxyXG5pZiAoIE51bWJlci5FUFNJTE9OID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdE51bWJlci5FUFNJTE9OID0gTWF0aC5wb3coIDIsIC0gNTIgKTtcclxuXHJcbn1cclxuXHJcbi8vXHJcblxyXG5pZiAoIE1hdGguc2lnbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NpZ25cclxuXHJcblx0TWF0aC5zaWduID0gZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdHJldHVybiAoIHggPCAwICkgPyAtIDEgOiAoIHggPiAwICkgPyAxIDogKyB4O1xyXG5cclxuXHR9O1xyXG5cclxufVxyXG5cclxuaWYgKCBGdW5jdGlvbi5wcm90b3R5cGUubmFtZSA9PT0gdW5kZWZpbmVkICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHQvLyBNaXNzaW5nIGluIElFOS0xMS5cclxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lXHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggRnVuY3Rpb24ucHJvdG90eXBlLCAnbmFtZScsIHtcclxuXHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnRvU3RyaW5nKCkubWF0Y2goIC9eXFxzKmZ1bmN0aW9uXFxzKihcXFMqKVxccypcXCgvIClbIDEgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcbn1cclxuXHJcbmlmICggT2JqZWN0LmFzc2lnbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduXHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggT2JqZWN0LCAnYXNzaWduJywge1xyXG5cclxuXHRcdHdyaXRhYmxlOiB0cnVlLFxyXG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxyXG5cclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHRcdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0XHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIkNhbm5vdCBjb252ZXJ0IGZpcnN0IGFyZ3VtZW50IHRvIG9iamVjdFwiICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdG8gPSBPYmplY3QoIHRhcmdldCApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0dmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBuZXh0U291cmNlID09PSB1bmRlZmluZWQgfHwgbmV4dFNvdXJjZSA9PT0gbnVsbCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRuZXh0U291cmNlID0gT2JqZWN0KCBuZXh0U291cmNlICk7XHJcblxyXG5cdFx0XHRcdHZhciBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyggbmV4dFNvdXJjZSApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4ICE9PSBsZW47ICsrIG5leHRJbmRleCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgbmV4dEtleSA9IGtleXNBcnJheVsgbmV4dEluZGV4IF07XHJcblx0XHRcdFx0XHR2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIG5leHRTb3VyY2UsIG5leHRLZXkgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0b1sgbmV4dEtleSBdID0gbmV4dFNvdXJjZVsgbmV4dEtleSBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRvO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxufVxyXG5cclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQuYnV0dG9uXHJcblxyXG5USFJFRS5NT1VTRSA9IHsgTEVGVDogMCwgTUlERExFOiAxLCBSSUdIVDogMiB9O1xyXG5cclxuLy8gR0wgU1RBVEUgQ09OU1RBTlRTXHJcblxyXG5USFJFRS5DdWxsRmFjZU5vbmUgPSAwO1xyXG5USFJFRS5DdWxsRmFjZUJhY2sgPSAxO1xyXG5USFJFRS5DdWxsRmFjZUZyb250ID0gMjtcclxuVEhSRUUuQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xyXG5cclxuVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgPSAwO1xyXG5USFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DQ1cgPSAxO1xyXG5cclxuLy8gU0hBRE9XSU5HIFRZUEVTXHJcblxyXG5USFJFRS5CYXNpY1NoYWRvd01hcCA9IDA7XHJcblRIUkVFLlBDRlNoYWRvd01hcCA9IDE7XHJcblRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgPSAyO1xyXG5cclxuLy8gTUFURVJJQUwgQ09OU1RBTlRTXHJcblxyXG4vLyBzaWRlXHJcblxyXG5USFJFRS5Gcm9udFNpZGUgPSAwO1xyXG5USFJFRS5CYWNrU2lkZSA9IDE7XHJcblRIUkVFLkRvdWJsZVNpZGUgPSAyO1xyXG5cclxuLy8gc2hhZGluZ1xyXG5cclxuVEhSRUUuRmxhdFNoYWRpbmcgPSAxO1xyXG5USFJFRS5TbW9vdGhTaGFkaW5nID0gMjtcclxuXHJcbi8vIGNvbG9yc1xyXG5cclxuVEhSRUUuTm9Db2xvcnMgPSAwO1xyXG5USFJFRS5GYWNlQ29sb3JzID0gMTtcclxuVEhSRUUuVmVydGV4Q29sb3JzID0gMjtcclxuXHJcbi8vIGJsZW5kaW5nIG1vZGVzXHJcblxyXG5USFJFRS5Ob0JsZW5kaW5nID0gMDtcclxuVEhSRUUuTm9ybWFsQmxlbmRpbmcgPSAxO1xyXG5USFJFRS5BZGRpdGl2ZUJsZW5kaW5nID0gMjtcclxuVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyA9IDM7XHJcblRIUkVFLk11bHRpcGx5QmxlbmRpbmcgPSA0O1xyXG5USFJFRS5DdXN0b21CbGVuZGluZyA9IDU7XHJcblxyXG4vLyBjdXN0b20gYmxlbmRpbmcgZXF1YXRpb25zXHJcbi8vIChudW1iZXJzIHN0YXJ0IGZyb20gMTAwIG5vdCB0byBjbGFzaCB3aXRoIG90aGVyXHJcbi8vIG1hcHBpbmdzIHRvIE9wZW5HTCBjb25zdGFudHMgZGVmaW5lZCBpbiBUZXh0dXJlLmpzKVxyXG5cclxuVEhSRUUuQWRkRXF1YXRpb24gPSAxMDA7XHJcblRIUkVFLlN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XHJcblRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xyXG5USFJFRS5NaW5FcXVhdGlvbiA9IDEwMztcclxuVEhSRUUuTWF4RXF1YXRpb24gPSAxMDQ7XHJcblxyXG4vLyBjdXN0b20gYmxlbmRpbmcgZGVzdGluYXRpb24gZmFjdG9yc1xyXG5cclxuVEhSRUUuWmVyb0ZhY3RvciA9IDIwMDtcclxuVEhSRUUuT25lRmFjdG9yID0gMjAxO1xyXG5USFJFRS5TcmNDb2xvckZhY3RvciA9IDIwMjtcclxuVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciA9IDIwMztcclxuVEhSRUUuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XHJcblRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XHJcblRIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xyXG5USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xyXG5cclxuLy8gY3VzdG9tIGJsZW5kaW5nIHNvdXJjZSBmYWN0b3JzXHJcblxyXG4vL1RIUkVFLlplcm9GYWN0b3IgPSAyMDA7XHJcbi8vVEhSRUUuT25lRmFjdG9yID0gMjAxO1xyXG4vL1RIUkVFLlNyY0FscGhhRmFjdG9yID0gMjA0O1xyXG4vL1RIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XHJcbi8vVEhSRUUuRHN0QWxwaGFGYWN0b3IgPSAyMDY7XHJcbi8vVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcclxuVEhSRUUuRHN0Q29sb3JGYWN0b3IgPSAyMDg7XHJcblRIUkVFLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XHJcblRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XHJcblxyXG4vLyBkZXB0aCBtb2Rlc1xyXG5cclxuVEhSRUUuTmV2ZXJEZXB0aCA9IDA7XHJcblRIUkVFLkFsd2F5c0RlcHRoID0gMTtcclxuVEhSRUUuTGVzc0RlcHRoID0gMjtcclxuVEhSRUUuTGVzc0VxdWFsRGVwdGggPSAzO1xyXG5USFJFRS5FcXVhbERlcHRoID0gNDtcclxuVEhSRUUuR3JlYXRlckVxdWFsRGVwdGggPSA1O1xyXG5USFJFRS5HcmVhdGVyRGVwdGggPSA2O1xyXG5USFJFRS5Ob3RFcXVhbERlcHRoID0gNztcclxuXHJcblxyXG4vLyBURVhUVVJFIENPTlNUQU5UU1xyXG5cclxuVEhSRUUuTXVsdGlwbHlPcGVyYXRpb24gPSAwO1xyXG5USFJFRS5NaXhPcGVyYXRpb24gPSAxO1xyXG5USFJFRS5BZGRPcGVyYXRpb24gPSAyO1xyXG5cclxuLy8gTWFwcGluZyBtb2Rlc1xyXG5cclxuVEhSRUUuVVZNYXBwaW5nID0gMzAwO1xyXG5cclxuVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gMzAxO1xyXG5USFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDI7XHJcblxyXG5USFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcclxuVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDQ7XHJcblxyXG5USFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyA9IDMwNTtcclxuXHJcbi8vIFdyYXBwaW5nIG1vZGVzXHJcblxyXG5USFJFRS5SZXBlYXRXcmFwcGluZyA9IDEwMDA7XHJcblRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xyXG5USFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcclxuXHJcbi8vIEZpbHRlcnNcclxuXHJcblRIUkVFLk5lYXJlc3RGaWx0ZXIgPSAxMDAzO1xyXG5USFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XHJcblRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xyXG5USFJFRS5MaW5lYXJGaWx0ZXIgPSAxMDA2O1xyXG5USFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcclxuVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODtcclxuXHJcbi8vIERhdGEgdHlwZXNcclxuXHJcblRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xyXG5USFJFRS5CeXRlVHlwZSA9IDEwMTA7XHJcblRIUkVFLlNob3J0VHlwZSA9IDEwMTE7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcclxuVEhSRUUuSW50VHlwZSA9IDEwMTM7XHJcblRIUkVFLlVuc2lnbmVkSW50VHlwZSA9IDEwMTQ7XHJcblRIUkVFLkZsb2F0VHlwZSA9IDEwMTU7XHJcblRIUkVFLkhhbGZGbG9hdFR5cGUgPSAxMDI1O1xyXG5cclxuLy8gUGl4ZWwgdHlwZXNcclxuXHJcbi8vVEhSRUUuVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IDEwMTY7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IDEwMTc7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gMTAxODtcclxuXHJcbi8vIFBpeGVsIGZvcm1hdHNcclxuXHJcblRIUkVFLkFscGhhRm9ybWF0ID0gMTAxOTtcclxuVEhSRUUuUkdCRm9ybWF0ID0gMTAyMDtcclxuVEhSRUUuUkdCQUZvcm1hdCA9IDEwMjE7XHJcblRIUkVFLkx1bWluYW5jZUZvcm1hdCA9IDEwMjI7XHJcblRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyMztcclxuLy8gVEhSRUUuUkdCRUZvcm1hdCBoYW5kbGVkIGFzIFRIUkVFLlJHQkFGb3JtYXQgaW4gc2hhZGVyc1xyXG5USFJFRS5SR0JFRm9ybWF0ID0gVEhSRUUuUkdCQUZvcm1hdDsgLy8xMDI0O1xyXG5cclxuLy8gRERTIC8gU1QzQyBDb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0c1xyXG5cclxuVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAxO1xyXG5USFJFRS5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAyO1xyXG5USFJFRS5SR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAyMDAzO1xyXG5USFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAyMDA0O1xyXG5cclxuXHJcbi8vIFBWUlRDIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRzXHJcblxyXG5USFJFRS5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDA7XHJcblRIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMTtcclxuVEhSRUUuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMjtcclxuVEhSRUUuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMztcclxuXHJcbi8vIEVUQyBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0c1xyXG5cclxuVEhSRUUuUkdCX0VUQzFfRm9ybWF0ID0gMjE1MTtcclxuXHJcbi8vIExvb3Agc3R5bGVzIGZvciBBbmltYXRpb25BY3Rpb25cclxuXHJcblRIUkVFLkxvb3BPbmNlID0gMjIwMDtcclxuVEhSRUUuTG9vcFJlcGVhdCA9IDIyMDE7XHJcblRIUkVFLkxvb3BQaW5nUG9uZyA9IDIyMDI7XHJcblxyXG4vLyBJbnRlcnBvbGF0aW9uXHJcblxyXG5USFJFRS5JbnRlcnBvbGF0ZURpc2NyZXRlID0gMjMwMDtcclxuVEhSRUUuSW50ZXJwb2xhdGVMaW5lYXIgPSAyMzAxO1xyXG5USFJFRS5JbnRlcnBvbGF0ZVNtb290aCA9IDIzMDI7XHJcblxyXG4vLyBJbnRlcnBvbGFudCBlbmRpbmcgbW9kZXNcclxuXHJcblRIUkVFLlplcm9DdXJ2YXR1cmVFbmRpbmcgPSAyNDAwO1xyXG5USFJFRS5aZXJvU2xvcGVFbmRpbmcgPSAyNDAxO1xyXG5USFJFRS5XcmFwQXJvdW5kRW5kaW5nID0gMjQwMjtcclxuXHJcbi8vIFRyaWFuZ2xlIERyYXcgbW9kZXNcclxuXHJcblRIUkVFLlRyaWFuZ2xlc0RyYXdNb2RlID0gMDtcclxuVEhSRUUuVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gMTtcclxuVEhSRUUuVHJpYW5nbGVGYW5EcmF3TW9kZSA9IDI7XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0NvbG9yLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Db2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMyApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIGFyZ3VtZW50cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzLnNldCggY29sb3IgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db2xvci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Db2xvcixcclxuXHJcblx0cjogMSwgZzogMSwgYjogMSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcclxuXHJcblx0XHRcdHRoaXMuY29weSggdmFsdWUgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXRIZXgoIHZhbHVlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0U3R5bGUoIHZhbHVlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMuciA9IHNjYWxhcjtcclxuXHRcdHRoaXMuZyA9IHNjYWxhcjtcclxuXHRcdHRoaXMuYiA9IHNjYWxhcjtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcclxuXHJcblx0XHRoZXggPSBNYXRoLmZsb29yKCBoZXggKTtcclxuXHJcblx0XHR0aGlzLnIgPSAoIGhleCA+PiAxNiAmIDI1NSApIC8gMjU1O1xyXG5cdFx0dGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xyXG5cdFx0dGhpcy5iID0gKCBoZXggJiAyNTUgKSAvIDI1NTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0UkdCOiBmdW5jdGlvbiAoIHIsIGcsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy5yID0gcjtcclxuXHRcdHRoaXMuZyA9IGc7XHJcblx0XHR0aGlzLmIgPSBiO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRIU0w6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmdW5jdGlvbiBodWUycmdiKCBwLCBxLCB0ICkge1xyXG5cclxuXHRcdFx0aWYgKCB0IDwgMCApIHQgKz0gMTtcclxuXHRcdFx0aWYgKCB0ID4gMSApIHQgLT0gMTtcclxuXHRcdFx0aWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xyXG5cdFx0XHRpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xyXG5cdFx0XHRpZiAoIHQgPCAyIC8gMyApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqICggMiAvIDMgLSB0ICk7XHJcblx0XHRcdHJldHVybiBwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBoLCBzLCBsICkge1xyXG5cclxuXHRcdFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcclxuXHRcdFx0aCA9IFRIUkVFLk1hdGguZXVjbGlkZWFuTW9kdWxvKCBoLCAxICk7XHJcblx0XHRcdHMgPSBUSFJFRS5NYXRoLmNsYW1wKCBzLCAwLCAxICk7XHJcblx0XHRcdGwgPSBUSFJFRS5NYXRoLmNsYW1wKCBsLCAwLCAxICk7XHJcblxyXG5cdFx0XHRpZiAoIHMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IGw7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xyXG5cdFx0XHRcdHZhciBxID0gKCAyICogbCApIC0gcDtcclxuXHJcblx0XHRcdFx0dGhpcy5yID0gaHVlMnJnYiggcSwgcCwgaCArIDEgLyAzICk7XHJcblx0XHRcdFx0dGhpcy5nID0gaHVlMnJnYiggcSwgcCwgaCApO1xyXG5cdFx0XHRcdHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKCBzdHlsZSApIHtcclxuXHJcblx0XHRmdW5jdGlvbiBoYW5kbGVBbHBoYSggc3RyaW5nICkge1xyXG5cclxuXHRcdFx0aWYgKCBzdHJpbmcgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHRcdGlmICggcGFyc2VGbG9hdCggc3RyaW5nICkgPCAxICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogQWxwaGEgY29tcG9uZW50IG9mICcgKyBzdHlsZSArICcgd2lsbCBiZSBpZ25vcmVkLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHZhciBtO1xyXG5cclxuXHRcdGlmICggbSA9IC9eKCg/OnJnYnxoc2wpYT8pXFwoXFxzKihbXlxcKV0qKVxcKS8uZXhlYyggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdC8vIHJnYiAvIGhzbFxyXG5cclxuXHRcdFx0dmFyIGNvbG9yO1xyXG5cdFx0XHR2YXIgbmFtZSA9IG1bIDEgXTtcclxuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSBtWyAyIF07XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdyZ2InOlxyXG5cdFx0XHRcdGNhc2UgJ3JnYmEnOlxyXG5cclxuXHRcdFx0XHRcdGlmICggY29sb3IgPSAvXihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyooLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZ2IoMjU1LDAsMCkgcmdiYSgyNTUsMCwwLDAuNSlcclxuXHRcdFx0XHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcclxuXHRcdFx0XHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcclxuXHRcdFx0XHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcclxuXHJcblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJnYigxMDAlLDAlLDAlKSByZ2JhKDEwMCUsMCUsMCUsMC41KVxyXG5cdFx0XHRcdFx0XHR0aGlzLnIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMTAwO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMTAwO1xyXG5cclxuXHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaHNsJzpcclxuXHRcdFx0XHRjYXNlICdoc2xhJzpcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL14oWzAtOV0qXFwuP1swLTldKylcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gaHNsKDEyMCw1MCUsNTAlKSBoc2xhKDEyMCw1MCUsNTAlLDAuNSlcclxuXHRcdFx0XHRcdFx0dmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICkgLyAzNjA7XHJcblx0XHRcdFx0XHRcdHZhciBzID0gcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgLyAxMDA7XHJcblx0XHRcdFx0XHRcdHZhciBsID0gcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgLyAxMDA7XHJcblxyXG5cdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mMC05XSspJC8uZXhlYyggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdC8vIGhleCBjb2xvclxyXG5cclxuXHRcdFx0dmFyIGhleCA9IG1bIDEgXTtcclxuXHRcdFx0dmFyIHNpemUgPSBoZXgubGVuZ3RoO1xyXG5cclxuXHRcdFx0aWYgKCBzaXplID09PSAzICkge1xyXG5cclxuXHRcdFx0XHQvLyAjZmYwXHJcblx0XHRcdFx0dGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDAgKSwgMTYgKSAvIDI1NTtcclxuXHRcdFx0XHR0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMSApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xyXG5cdFx0XHRcdHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAyICksIDE2ICkgLyAyNTU7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggc2l6ZSA9PT0gNiApIHtcclxuXHJcblx0XHRcdFx0Ly8gI2ZmMDAwMFxyXG5cdFx0XHRcdHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XHJcblx0XHRcdFx0dGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDMgKSwgMTYgKSAvIDI1NTtcclxuXHRcdFx0XHR0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggNCApICsgaGV4LmNoYXJBdCggNSApLCAxNiApIC8gMjU1O1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0Ly8gY29sb3Iga2V5d29yZHNcclxuXHRcdFx0dmFyIGhleCA9IFRIUkVFLkNvbG9yS2V5d29yZHNbIHN0eWxlIF07XHJcblxyXG5cdFx0XHRpZiAoIGhleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyByZWRcclxuXHRcdFx0XHR0aGlzLnNldEhleCggaGV4ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyB1bmtub3duIGNvbG9yXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgJyArIHN0eWxlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRcdHRoaXMuciA9IGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgPSBjb2xvci5nO1xyXG5cdFx0dGhpcy5iID0gY29sb3IuYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xyXG5cclxuXHRcdGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xyXG5cclxuXHRcdHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBnYW1tYUZhY3RvciApO1xyXG5cdFx0dGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIGdhbW1hRmFjdG9yICk7XHJcblx0XHR0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgZ2FtbWFGYWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUxpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xyXG5cclxuXHRcdGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xyXG5cclxuXHRcdHZhciBzYWZlSW52ZXJzZSA9ICggZ2FtbWFGYWN0b3IgPiAwICkgPyAoIDEuMCAvIGdhbW1hRmFjdG9yICkgOiAxLjA7XHJcblxyXG5cdFx0dGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIHNhZmVJbnZlcnNlICk7XHJcblx0XHR0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgc2FmZUludmVyc2UgKTtcclxuXHRcdHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBzYWZlSW52ZXJzZSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xyXG5cclxuXHRcdHRoaXMuciA9IHIgKiByO1xyXG5cdFx0dGhpcy5nID0gZyAqIGc7XHJcblx0XHR0aGlzLmIgPSBiICogYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29udmVydExpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnIgPSBNYXRoLnNxcnQoIHRoaXMuciApO1xyXG5cdFx0dGhpcy5nID0gTWF0aC5zcXJ0KCB0aGlzLmcgKTtcclxuXHRcdHRoaXMuYiA9IE1hdGguc3FydCggdGhpcy5iICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEhleDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRIZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gKCAnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KCkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLSA2ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEhTTDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxyXG5cclxuXHRcdHZhciBoc2wgPSBvcHRpb25hbFRhcmdldCB8fCB7IGg6IDAsIHM6IDAsIGw6IDAgfTtcclxuXHJcblx0XHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcclxuXHJcblx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcclxuXHRcdHZhciBtaW4gPSBNYXRoLm1pbiggciwgZywgYiApO1xyXG5cclxuXHRcdHZhciBodWUsIHNhdHVyYXRpb247XHJcblx0XHR2YXIgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcclxuXHJcblx0XHRpZiAoIG1pbiA9PT0gbWF4ICkge1xyXG5cclxuXHRcdFx0aHVlID0gMDtcclxuXHRcdFx0c2F0dXJhdGlvbiA9IDA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcclxuXHJcblx0XHRcdHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIG1heCApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSByOiBodWUgPSAoIGcgLSBiICkgLyBkZWx0YSArICggZyA8IGIgPyA2IDogMCApOyBicmVhaztcclxuXHRcdFx0XHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aHVlIC89IDY7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGhzbC5oID0gaHVlO1xyXG5cdFx0aHNsLnMgPSBzYXR1cmF0aW9uO1xyXG5cdFx0aHNsLmwgPSBsaWdodG5lc3M7XHJcblxyXG5cdFx0cmV0dXJuIGhzbDtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ3JnYignICsgKCAoIHRoaXMuciAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuZyAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuYiAqIDI1NSApIHwgMCApICsgJyknO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvZmZzZXRIU0w6IGZ1bmN0aW9uICggaCwgcywgbCApIHtcclxuXHJcblx0XHR2YXIgaHNsID0gdGhpcy5nZXRIU0woKTtcclxuXHJcblx0XHRoc2wuaCArPSBoOyBoc2wucyArPSBzOyBoc2wubCArPSBsO1xyXG5cclxuXHRcdHRoaXMuc2V0SFNMKCBoc2wuaCwgaHNsLnMsIGhzbC5sICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgKz0gY29sb3IucjtcclxuXHRcdHRoaXMuZyArPSBjb2xvci5nO1xyXG5cdFx0dGhpcy5iICs9IGNvbG9yLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZENvbG9yczogZnVuY3Rpb24gKCBjb2xvcjEsIGNvbG9yMiApIHtcclxuXHJcblx0XHR0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xyXG5cdFx0dGhpcy5nID0gY29sb3IxLmcgKyBjb2xvcjIuZztcclxuXHRcdHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMuciArPSBzO1xyXG5cdFx0dGhpcy5nICs9IHM7XHJcblx0XHR0aGlzLmIgKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdFx0dGhpcy5yICo9IGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgKj0gY29sb3IuZztcclxuXHRcdHRoaXMuYiAqPSBjb2xvci5iO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMuciAqPSBzO1xyXG5cdFx0dGhpcy5nICo9IHM7XHJcblx0XHR0aGlzLmIgKj0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy5yICs9ICggY29sb3IuciAtIHRoaXMuciApICogYWxwaGE7XHJcblx0XHR0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcclxuXHRcdHRoaXMuYiArPSAoIGNvbG9yLmIgLSB0aGlzLmIgKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYyApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBjLnIgPT09IHRoaXMuciApICYmICggYy5nID09PSB0aGlzLmcgKSAmJiAoIGMuYiA9PT0gdGhpcy5iICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMuciA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdHRoaXMuZyA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcblx0XHR0aGlzLmIgPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMucjtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmc7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5iO1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbG9yS2V5d29yZHMgPSB7ICdhbGljZWJsdWUnOiAweEYwRjhGRiwgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LCAnYXF1YSc6IDB4MDBGRkZGLCAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LCAnYXp1cmUnOiAweEYwRkZGRixcclxuJ2JlaWdlJzogMHhGNUY1REMsICdiaXNxdWUnOiAweEZGRTRDNCwgJ2JsYWNrJzogMHgwMDAwMDAsICdibGFuY2hlZGFsbW9uZCc6IDB4RkZFQkNELCAnYmx1ZSc6IDB4MDAwMEZGLCAnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxyXG4nYnJvd24nOiAweEE1MkEyQSwgJ2J1cmx5d29vZCc6IDB4REVCODg3LCAnY2FkZXRibHVlJzogMHg1RjlFQTAsICdjaGFydHJldXNlJzogMHg3RkZGMDAsICdjaG9jb2xhdGUnOiAweEQyNjkxRSwgJ2NvcmFsJzogMHhGRjdGNTAsXHJcbidjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELCAnY29ybnNpbGsnOiAweEZGRjhEQywgJ2NyaW1zb24nOiAweERDMTQzQywgJ2N5YW4nOiAweDAwRkZGRiwgJ2RhcmtibHVlJzogMHgwMDAwOEIsICdkYXJrY3lhbic6IDB4MDA4QjhCLFxyXG4nZGFya2dvbGRlbnJvZCc6IDB4Qjg4NjBCLCAnZGFya2dyYXknOiAweEE5QTlBOSwgJ2RhcmtncmVlbic6IDB4MDA2NDAwLCAnZGFya2dyZXknOiAweEE5QTlBOSwgJ2RhcmtraGFraSc6IDB4QkRCNzZCLCAnZGFya21hZ2VudGEnOiAweDhCMDA4QixcclxuJ2RhcmtvbGl2ZWdyZWVuJzogMHg1NTZCMkYsICdkYXJrb3JhbmdlJzogMHhGRjhDMDAsICdkYXJrb3JjaGlkJzogMHg5OTMyQ0MsICdkYXJrcmVkJzogMHg4QjAwMDAsICdkYXJrc2FsbW9uJzogMHhFOTk2N0EsICdkYXJrc2VhZ3JlZW4nOiAweDhGQkM4RixcclxuJ2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QiwgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RiwgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RiwgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSwgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcclxuJ2RlZXBwaW5rJzogMHhGRjE0OTMsICdkZWVwc2t5Ymx1ZSc6IDB4MDBCRkZGLCAnZGltZ3JheSc6IDB4Njk2OTY5LCAnZGltZ3JleSc6IDB4Njk2OTY5LCAnZG9kZ2VyYmx1ZSc6IDB4MUU5MEZGLCAnZmlyZWJyaWNrJzogMHhCMjIyMjIsXHJcbidmbG9yYWx3aGl0ZSc6IDB4RkZGQUYwLCAnZm9yZXN0Z3JlZW4nOiAweDIyOEIyMiwgJ2Z1Y2hzaWEnOiAweEZGMDBGRiwgJ2dhaW5zYm9ybyc6IDB4RENEQ0RDLCAnZ2hvc3R3aGl0ZSc6IDB4RjhGOEZGLCAnZ29sZCc6IDB4RkZENzAwLFxyXG4nZ29sZGVucm9kJzogMHhEQUE1MjAsICdncmF5JzogMHg4MDgwODAsICdncmVlbic6IDB4MDA4MDAwLCAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRiwgJ2dyZXknOiAweDgwODA4MCwgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsICdob3RwaW5rJzogMHhGRjY5QjQsXHJcbidpbmRpYW5yZWQnOiAweENENUM1QywgJ2luZGlnbyc6IDB4NEIwMDgyLCAnaXZvcnknOiAweEZGRkZGMCwgJ2toYWtpJzogMHhGMEU2OEMsICdsYXZlbmRlcic6IDB4RTZFNkZBLCAnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LCAnbGF3bmdyZWVuJzogMHg3Q0ZDMDAsXHJcbidsZW1vbmNoaWZmb24nOiAweEZGRkFDRCwgJ2xpZ2h0Ymx1ZSc6IDB4QUREOEU2LCAnbGlnaHRjb3JhbCc6IDB4RjA4MDgwLCAnbGlnaHRjeWFuJzogMHhFMEZGRkYsICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IDB4RkFGQUQyLCAnbGlnaHRncmF5JzogMHhEM0QzRDMsXHJcbidsaWdodGdyZWVuJzogMHg5MEVFOTAsICdsaWdodGdyZXknOiAweEQzRDNEMywgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLCAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSwgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSwgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxyXG4nbGlnaHRzbGF0ZWdyYXknOiAweDc3ODg5OSwgJ2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksICdsaWdodHN0ZWVsYmx1ZSc6IDB4QjBDNERFLCAnbGlnaHR5ZWxsb3cnOiAweEZGRkZFMCwgJ2xpbWUnOiAweDAwRkYwMCwgJ2xpbWVncmVlbic6IDB4MzJDRDMyLFxyXG4nbGluZW4nOiAweEZBRjBFNiwgJ21hZ2VudGEnOiAweEZGMDBGRiwgJ21hcm9vbic6IDB4ODAwMDAwLCAnbWVkaXVtYXF1YW1hcmluZSc6IDB4NjZDREFBLCAnbWVkaXVtYmx1ZSc6IDB4MDAwMENELCAnbWVkaXVtb3JjaGlkJzogMHhCQTU1RDMsXHJcbidtZWRpdW1wdXJwbGUnOiAweDkzNzBEQiwgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSwgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcclxuJ21lZGl1bXZpb2xldHJlZCc6IDB4QzcxNTg1LCAnbWlkbmlnaHRibHVlJzogMHgxOTE5NzAsICdtaW50Y3JlYW0nOiAweEY1RkZGQSwgJ21pc3R5cm9zZSc6IDB4RkZFNEUxLCAnbW9jY2FzaW4nOiAweEZGRTRCNSwgJ25hdmFqb3doaXRlJzogMHhGRkRFQUQsXHJcbiduYXZ5JzogMHgwMDAwODAsICdvbGRsYWNlJzogMHhGREY1RTYsICdvbGl2ZSc6IDB4ODA4MDAwLCAnb2xpdmVkcmFiJzogMHg2QjhFMjMsICdvcmFuZ2UnOiAweEZGQTUwMCwgJ29yYW5nZXJlZCc6IDB4RkY0NTAwLCAnb3JjaGlkJzogMHhEQTcwRDYsXHJcbidwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsICdwYWxlZ3JlZW4nOiAweDk4RkI5OCwgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSwgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MywgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSwgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxyXG4ncGVydSc6IDB4Q0Q4NTNGLCAncGluayc6IDB4RkZDMENCLCAncGx1bSc6IDB4RERBMERELCAncG93ZGVyYmx1ZSc6IDB4QjBFMEU2LCAncHVycGxlJzogMHg4MDAwODAsICdyZWQnOiAweEZGMDAwMCwgJ3Jvc3licm93bic6IDB4QkM4RjhGLFxyXG4ncm95YWxibHVlJzogMHg0MTY5RTEsICdzYWRkbGVicm93bic6IDB4OEI0NTEzLCAnc2FsbW9uJzogMHhGQTgwNzIsICdzYW5keWJyb3duJzogMHhGNEE0NjAsICdzZWFncmVlbic6IDB4MkU4QjU3LCAnc2Vhc2hlbGwnOiAweEZGRjVFRSxcclxuJ3NpZW5uYSc6IDB4QTA1MjJELCAnc2lsdmVyJzogMHhDMEMwQzAsICdza3libHVlJzogMHg4N0NFRUIsICdzbGF0ZWJsdWUnOiAweDZBNUFDRCwgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLCAnc2xhdGVncmV5JzogMHg3MDgwOTAsICdzbm93JzogMHhGRkZBRkEsXHJcbidzcHJpbmdncmVlbic6IDB4MDBGRjdGLCAnc3RlZWxibHVlJzogMHg0NjgyQjQsICd0YW4nOiAweEQyQjQ4QywgJ3RlYWwnOiAweDAwODA4MCwgJ3RoaXN0bGUnOiAweEQ4QkZEOCwgJ3RvbWF0byc6IDB4RkY2MzQ3LCAndHVycXVvaXNlJzogMHg0MEUwRDAsXHJcbid2aW9sZXQnOiAweEVFODJFRSwgJ3doZWF0JzogMHhGNURFQjMsICd3aGl0ZSc6IDB4RkZGRkZGLCAnd2hpdGVzbW9rZSc6IDB4RjVGNUY1LCAneWVsbG93JzogMHhGRkZGMDAsICd5ZWxsb3dncmVlbic6IDB4OUFDRDMyIH07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1F1YXRlcm5pb24uanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLlF1YXRlcm5pb24gPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdHRoaXMuX3ggPSB4IHx8IDA7XHJcblx0dGhpcy5feSA9IHkgfHwgMDtcclxuXHR0aGlzLl96ID0geiB8fCAwO1xyXG5cdHRoaXMuX3cgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbi5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5RdWF0ZXJuaW9uLFxyXG5cclxuXHRnZXQgeCAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3g7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB4ICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCB5ICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHkgKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IHogKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl96O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgeiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgdyAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3c7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB3ICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5fdyA9IHZhbHVlO1xyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSB4O1xyXG5cdFx0dGhpcy5feSA9IHk7XHJcblx0XHR0aGlzLl96ID0gejtcclxuXHRcdHRoaXMuX3cgPSB3O1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcclxuXHRcdHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XHJcblx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xyXG5cdFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyLCB1cGRhdGUgKSB7XHJcblxyXG5cdFx0aWYgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXHJcblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xyXG5cdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxyXG5cclxuXHRcdHZhciBjMSA9IE1hdGguY29zKCBldWxlci5feCAvIDIgKTtcclxuXHRcdHZhciBjMiA9IE1hdGguY29zKCBldWxlci5feSAvIDIgKTtcclxuXHRcdHZhciBjMyA9IE1hdGguY29zKCBldWxlci5feiAvIDIgKTtcclxuXHRcdHZhciBzMSA9IE1hdGguc2luKCBldWxlci5feCAvIDIgKTtcclxuXHRcdHZhciBzMiA9IE1hdGguc2luKCBldWxlci5feSAvIDIgKTtcclxuXHRcdHZhciBzMyA9IE1hdGguc2luKCBldWxlci5feiAvIDIgKTtcclxuXHJcblx0XHR2YXIgb3JkZXIgPSBldWxlci5vcmRlcjtcclxuXHJcblx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLCBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xyXG5cclxuXHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xyXG5cdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XHJcblx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcclxuXHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcclxuXHJcblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcclxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcclxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXHJcblxyXG5cdFx0XHR0cmFjZSA9IG0xMSArIG0yMiArIG0zMyxcclxuXHRcdFx0cztcclxuXHJcblx0XHRpZiAoIHRyYWNlID4gMCApIHtcclxuXHJcblx0XHRcdHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XHJcblx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcclxuXHRcdFx0dGhpcy5feSA9ICggbTEzIC0gbTMxICkgKiBzO1xyXG5cdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xyXG5cdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XHJcblx0XHRcdHRoaXMuX3kgPSAoIG0xMiArIG0yMSApIC8gcztcclxuXHRcdFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xyXG5cdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3kgPSAwLjI1ICogcztcclxuXHRcdFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcclxuXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xyXG5cdFx0XHR0aGlzLl95ID0gKCBtMjMgKyBtMzIgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Vbml0VmVjdG9yczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcclxuXHJcblx0XHQvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR2YXIgdjEsIHI7XHJcblxyXG5cdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHZGcm9tLCB2VG8gKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyID0gdkZyb20uZG90KCB2VG8gKSArIDE7XHJcblxyXG5cdFx0XHRpZiAoIHIgPCBFUFMgKSB7XHJcblxyXG5cdFx0XHRcdHIgPSAwO1xyXG5cclxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xyXG5cclxuXHRcdFx0XHRcdHYxLnNldCggLSB2RnJvbS55LCB2RnJvbS54LCAwICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0djEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0djEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gdjEueDtcclxuXHRcdFx0dGhpcy5feSA9IHYxLnk7XHJcblx0XHRcdHRoaXMuX3ogPSB2MS56O1xyXG5cdFx0XHR0aGlzLl93ID0gcjtcclxuXHJcblx0XHRcdHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGludmVyc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl94ICo9IC0gMTtcclxuXHRcdHRoaXMuX3kgKj0gLSAxO1xyXG5cdFx0dGhpcy5feiAqPSAtIDE7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBsID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHRpZiAoIGwgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gMDtcclxuXHRcdFx0dGhpcy5feSA9IDA7XHJcblx0XHRcdHRoaXMuX3ogPSAwO1xyXG5cdFx0XHR0aGlzLl93ID0gMTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bCA9IDEgLyBsO1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHRoaXMuX3ggKiBsO1xyXG5cdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XHJcblx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcclxuXHRcdFx0dGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggcSwgcCApIHtcclxuXHJcblx0XHRpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5UXVhdGVybmlvbnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cclxuXHJcblx0XHR2YXIgcWF4ID0gYS5feCwgcWF5ID0gYS5feSwgcWF6ID0gYS5feiwgcWF3ID0gYS5fdztcclxuXHRcdHZhciBxYnggPSBiLl94LCBxYnkgPSBiLl95LCBxYnogPSBiLl96LCBxYncgPSBiLl93O1xyXG5cclxuXHRcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XHJcblx0XHR0aGlzLl95ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xyXG5cdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcclxuXHRcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNsZXJwOiBmdW5jdGlvbiAoIHFiLCB0ICkge1xyXG5cclxuXHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xyXG5cdFx0aWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCB6ID0gdGhpcy5feiwgdyA9IHRoaXMuX3c7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cclxuXHJcblx0XHR2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xyXG5cclxuXHRcdGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAtIHFiLl93O1xyXG5cdFx0XHR0aGlzLl94ID0gLSBxYi5feDtcclxuXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XHJcblx0XHRcdHRoaXMuX3ogPSAtIHFiLl96O1xyXG5cclxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuY29weSggcWIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9IHc7XHJcblx0XHRcdHRoaXMuX3ggPSB4O1xyXG5cdFx0XHR0aGlzLl95ID0geTtcclxuXHRcdFx0dGhpcy5feiA9IHo7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XHJcblxyXG5cdFx0aWYgKCBNYXRoLmFicyggc2luSGFsZlRoZXRhICkgPCAwLjAwMSApIHtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAwLjUgKiAoIHcgKyB0aGlzLl93ICk7XHJcblx0XHRcdHRoaXMuX3ggPSAwLjUgKiAoIHggKyB0aGlzLl94ICk7XHJcblx0XHRcdHRoaXMuX3kgPSAwLjUgKiAoIHkgKyB0aGlzLl95ICk7XHJcblx0XHRcdHRoaXMuX3ogPSAwLjUgKiAoIHogKyB0aGlzLl96ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGhhbGZUaGV0YSA9IE1hdGguYXRhbjIoIHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhICk7XHJcblx0XHR2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxyXG5cdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcclxuXHJcblx0XHR0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xyXG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcclxuXHRcdHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XHJcblx0XHR0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHRcdHRoaXMuX3ogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5hc3NpZ24oIFRIUkVFLlF1YXRlcm5pb24sIHtcclxuXHJcblx0c2xlcnA6IGZ1bmN0aW9uKCBxYSwgcWIsIHFtLCB0ICkge1xyXG5cclxuXHRcdHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzbGVycEZsYXQ6IGZ1bmN0aW9uKFxyXG5cdFx0XHRkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSwgdCApIHtcclxuXHJcblx0XHQvLyBmdXp6LWZyZWUsIGFycmF5LWJhc2VkIFF1YXRlcm5pb24gU0xFUlAgb3BlcmF0aW9uXHJcblxyXG5cdFx0dmFyIHgwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDAgXSxcclxuXHRcdFx0eTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdLFxyXG5cdFx0XHR6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF0sXHJcblx0XHRcdHcwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDMgXSxcclxuXHJcblx0XHRcdHgxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDAgXSxcclxuXHRcdFx0eTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdLFxyXG5cdFx0XHR6MSA9IHNyYzFbIHNyY09mZnNldDEgKyAyIF0sXHJcblx0XHRcdHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcclxuXHJcblx0XHRpZiAoIHcwICE9PSB3MSB8fCB4MCAhPT0geDEgfHwgeTAgIT09IHkxIHx8IHowICE9PSB6MSApIHtcclxuXHJcblx0XHRcdHZhciBzID0gMSAtIHQsXHJcblxyXG5cdFx0XHRcdGNvcyA9IHgwICogeDEgKyB5MCAqIHkxICsgejAgKiB6MSArIHcwICogdzEsXHJcblxyXG5cdFx0XHRcdGRpciA9ICggY29zID49IDAgPyAxIDogLSAxICksXHJcblx0XHRcdFx0c3FyU2luID0gMSAtIGNvcyAqIGNvcztcclxuXHJcblx0XHRcdC8vIFNraXAgdGhlIFNsZXJwIGZvciB0aW55IHN0ZXBzIHRvIGF2b2lkIG51bWVyaWMgcHJvYmxlbXM6XHJcblx0XHRcdGlmICggc3FyU2luID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdHZhciBzaW4gPSBNYXRoLnNxcnQoIHNxclNpbiApLFxyXG5cdFx0XHRcdFx0bGVuID0gTWF0aC5hdGFuMiggc2luLCBjb3MgKiBkaXIgKTtcclxuXHJcblx0XHRcdFx0cyA9IE1hdGguc2luKCBzICogbGVuICkgLyBzaW47XHJcblx0XHRcdFx0dCA9IE1hdGguc2luKCB0ICogbGVuICkgLyBzaW47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdERpciA9IHQgKiBkaXI7XHJcblxyXG5cdFx0XHR4MCA9IHgwICogcyArIHgxICogdERpcjtcclxuXHRcdFx0eTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XHJcblx0XHRcdHowID0gejAgKiBzICsgejEgKiB0RGlyO1xyXG5cdFx0XHR3MCA9IHcwICogcyArIHcxICogdERpcjtcclxuXHJcblx0XHRcdC8vIE5vcm1hbGl6ZSBpbiBjYXNlIHdlIGp1c3QgZGlkIGEgbGVycDpcclxuXHRcdFx0aWYgKCBzID09PSAxIC0gdCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGYgPSAxIC8gTWF0aC5zcXJ0KCB4MCAqIHgwICsgeTAgKiB5MCArIHowICogejAgKyB3MCAqIHcwICk7XHJcblxyXG5cdFx0XHRcdHgwICo9IGY7XHJcblx0XHRcdFx0eTAgKj0gZjtcclxuXHRcdFx0XHR6MCAqPSBmO1xyXG5cdFx0XHRcdHcwICo9IGY7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MDtcclxuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTA7XHJcblx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowO1xyXG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3IyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcjIgPSBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVmVjdG9yMi5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IyLFxyXG5cclxuXHRnZXQgd2lkdGgoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHdpZHRoKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnggPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IGhlaWdodCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy55O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgaGVpZ2h0KCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnkgPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly9cclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy55ID0gc2NhbGFyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gdi54O1xyXG5cdFx0dGhpcy55ID0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueDtcclxuXHRcdHRoaXMueSArPSB2Lnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKyBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xyXG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggLT0gdi54O1xyXG5cdFx0dGhpcy55IC09IHYueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54IC09IHM7XHJcblx0XHR0aGlzLnkgLT0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggKj0gdi54O1xyXG5cdFx0dGhpcy55ICo9IHYueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdGlmICggaXNGaW5pdGUoIHNjYWxhciApICkge1xyXG5cclxuXHRcdFx0dGhpcy54ICo9IHNjYWxhcjtcclxuXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gMDtcclxuXHRcdFx0dGhpcy55ID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAvPSB2Lng7XHJcblx0XHR0aGlzLnkgLz0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcclxuXHJcblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsICk7XHJcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdHRoaXMubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgLyBsZW5ndGggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSAtIHRoaXMueDtcclxuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhbmdsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGNvbXB1dGVzIHRoZSBhbmdsZSBpbiByYWRpYW5zIHdpdGggcmVzcGVjdCB0byB0aGUgcG9zaXRpdmUgeC1heGlzXHJcblxyXG5cdFx0dmFyIGFuZ2xlID0gTWF0aC5hdGFuMiggdGhpcy55LCB0aGlzLnggKTtcclxuXHJcblx0XHRpZiAoIGFuZ2xlIDwgMCApIGFuZ2xlICs9IDIgKiBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBhbmdsZTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XHJcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xyXG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcclxuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZUFyb3VuZDogZnVuY3Rpb24gKCBjZW50ZXIsIGFuZ2xlICkge1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICksIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCAtIGNlbnRlci54O1xyXG5cdFx0dmFyIHkgPSB0aGlzLnkgLSBjZW50ZXIueTtcclxuXHJcblx0XHR0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XHJcblx0XHR0aGlzLnkgPSB4ICogcyArIHkgKiBjICsgY2VudGVyLnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yICpraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xyXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5WZWN0b3IzID0gZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xyXG5cclxuXHR0aGlzLnggPSB4IHx8IDA7XHJcblx0dGhpcy55ID0geSB8fCAwO1xyXG5cdHRoaXMueiA9IHogfHwgMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZWN0b3IzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjMsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0dGhpcy56ID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHR0aGlzLnggPSBzY2FsYXI7XHJcblx0XHR0aGlzLnkgPSBzY2FsYXI7XHJcblx0XHR0aGlzLnogPSBzY2FsYXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFg6IGZ1bmN0aW9uICggeCApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XHJcblxyXG5cdFx0dGhpcy55ID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xyXG5cclxuXHRcdHRoaXMueiA9IHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSB2Lng7XHJcblx0XHR0aGlzLnkgPSB2Lnk7XHJcblx0XHR0aGlzLnogPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKz0gdi54O1xyXG5cdFx0dGhpcy55ICs9IHYueTtcclxuXHRcdHRoaXMueiArPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblx0XHR0aGlzLnogKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSArIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiArIGIuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XHJcblx0XHR0aGlzLnkgKz0gdi55ICogcztcclxuXHRcdHRoaXMueiArPSB2LnogKiBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54IC09IHYueDtcclxuXHRcdHRoaXMueSAtPSB2Lnk7XHJcblx0XHR0aGlzLnogLT0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR0aGlzLnggLT0gcztcclxuXHRcdHRoaXMueSAtPSBzO1xyXG5cdFx0dGhpcy56IC09IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggLSBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCAqPSB2Lng7XHJcblx0XHR0aGlzLnkgKj0gdi55O1xyXG5cdFx0dGhpcy56ICo9IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdGlmICggaXNGaW5pdGUoIHNjYWxhciApICkge1xyXG5cclxuXHRcdFx0dGhpcy54ICo9IHNjYWxhcjtcclxuXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcclxuXHRcdFx0dGhpcy56ICo9IHNjYWxhcjtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gMDtcclxuXHRcdFx0dGhpcy55ID0gMDtcclxuXHRcdFx0dGhpcy56ID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAqIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAqIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiAqIGIuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlFdWxlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBxdWF0ZXJuaW9uO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseUV1bGVyKCBldWxlciApIHtcclxuXHJcblx0XHRcdGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBxdWF0ZXJuaW9uO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHF1YXRlcm5pb24gPT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRhcHBseU1hdHJpeDM6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueDtcclxuXHRcdHZhciB5ID0gdGhpcy55O1xyXG5cdFx0dmFyIHogPSB0aGlzLno7XHJcblxyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcclxuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cclxuXHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6ICsgZVsgMTIgXTtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHogKyBlWyAxMyBdO1xyXG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5UHJvamVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IHByb2plY3Rpb24gbWF0cml4XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblxyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cdFx0dmFyIGQgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApOyAvLyBwZXJzcGVjdGl2ZSBkaXZpZGVcclxuXHJcblx0XHR0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICAqIHogKyBlWyAxMiBdICkgKiBkO1xyXG5cdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXSApICogZDtcclxuXHRcdHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIGQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5UXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54O1xyXG5cdFx0dmFyIHkgPSB0aGlzLnk7XHJcblx0XHR2YXIgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgcXggPSBxLng7XHJcblx0XHR2YXIgcXkgPSBxLnk7XHJcblx0XHR2YXIgcXogPSBxLno7XHJcblx0XHR2YXIgcXcgPSBxLnc7XHJcblxyXG5cdFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcclxuXHJcblx0XHR2YXIgaXggPSAgcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xyXG5cdFx0dmFyIGl5ID0gIHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcclxuXHRcdHZhciBpeiA9ICBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XHJcblx0XHR2YXIgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcclxuXHJcblx0XHQvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XHJcblxyXG5cdFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcclxuXHRcdHRoaXMueSA9IGl5ICogcXcgKyBpdyAqIC0gcXkgKyBpeiAqIC0gcXggLSBpeCAqIC0gcXo7XHJcblx0XHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdCggY2FtZXJhICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdW5wcm9qZWN0KCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGQsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XHJcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogejtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHo7XHJcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xyXG5cclxuXHRcdHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAvPSB2Lng7XHJcblx0XHR0aGlzLnkgLz0gdi55O1xyXG5cdFx0dGhpcy56IC89IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1pbiwgbWF4O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtaW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRcdG1heCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XHJcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdFx0dGhpcy5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSAvIGxlbmd0aCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSAtIHRoaXMueDtcclxuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xyXG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggLyB0aGlzLmxlbmd0aCgpICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR0aGlzLnggPSB5ICogdi56IC0geiAqIHYueTtcclxuXHRcdHRoaXMueSA9IHogKiB2LnggLSB4ICogdi56O1xyXG5cdFx0dGhpcy56ID0geCAqIHYueSAtIHkgKiB2Lng7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xyXG5cdFx0dmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XHJcblxyXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XHJcblx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcclxuXHRcdHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0T25WZWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEsIGRvdDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uVmVjdG9yKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2MS5jb3B5KCB2ZWN0b3IgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGRvdCA9IHRoaXMuZG90KCB2MSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY29weSggdjEgKS5tdWx0aXBseVNjYWxhciggZG90ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uUGxhbmUoIHBsYW5lTm9ybWFsICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0djEuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cmVmbGVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxyXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxyXG5cclxuXHRcdHZhciB2MTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcmVmbGVjdCggbm9ybWFsICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViKCB2MS5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9KCksXHJcblxyXG5cdGFuZ2xlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gKCBNYXRoLnNxcnQoIHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSApICk7XHJcblxyXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueDtcclxuXHRcdHZhciBkeSA9IHRoaXMueSAtIHYueTtcclxuXHRcdHZhciBkeiA9IHRoaXMueiAtIHYuejtcclxuXHJcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR0aGlzLnggPSBtLmVsZW1lbnRzWyAxMiBdO1xyXG5cdFx0dGhpcy55ID0gbS5lbGVtZW50c1sgMTMgXTtcclxuXHRcdHRoaXMueiA9IG0uZWxlbWVudHNbIDE0IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21NYXRyaXhTY2FsZTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciBzeCA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyAwIF0sIG0uZWxlbWVudHNbIDEgXSwgbS5lbGVtZW50c1sgMiBdICkubGVuZ3RoKCk7XHJcblx0XHR2YXIgc3kgPSB0aGlzLnNldCggbS5lbGVtZW50c1sgNCBdLCBtLmVsZW1lbnRzWyA1IF0sIG0uZWxlbWVudHNbIDYgXSApLmxlbmd0aCgpO1xyXG5cdFx0dmFyIHN6ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDggXSwgbS5lbGVtZW50c1sgOSBdLCBtLmVsZW1lbnRzWyAxMCBdICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0dGhpcy54ID0gc3g7XHJcblx0XHR0aGlzLnkgPSBzeTtcclxuXHRcdHRoaXMueiA9IHN6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4Q29sdW1uOiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dmFyIG9mZnNldCA9IGluZGV4ICogNDtcclxuXHJcblx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gbWVbIG9mZnNldCBdO1xyXG5cdFx0dGhpcy55ID0gbWVbIG9mZnNldCArIDEgXTtcclxuXHRcdHRoaXMueiA9IG1lWyBvZmZzZXQgKyAyIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0aW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcclxuXHJcblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XHJcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xyXG5cdFx0dGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvVmVjdG9yNC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcjQgPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblx0dGhpcy56ID0geiB8fCAwO1xyXG5cdHRoaXMudyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZWN0b3I0LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjQsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0dGhpcy56ID0gejtcclxuXHRcdHRoaXMudyA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy55ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy56ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy53ID0gc2NhbGFyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcclxuXHJcblx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRXOiBmdW5jdGlvbiAoIHcgKSB7XHJcblxyXG5cdFx0dGhpcy53ID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMzogdGhpcy53ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcclxuXHRcdFx0Y2FzZSAzOiByZXR1cm4gdGhpcy53O1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gdi54O1xyXG5cdFx0dGhpcy55ID0gdi55O1xyXG5cdFx0dGhpcy56ID0gdi56O1xyXG5cdFx0dGhpcy53ID0gKCB2LncgIT09IHVuZGVmaW5lZCApID8gdi53IDogMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCArPSB2Lng7XHJcblx0XHR0aGlzLnkgKz0gdi55O1xyXG5cdFx0dGhpcy56ICs9IHYuejtcclxuXHRcdHRoaXMudyArPSB2Lnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblx0XHR0aGlzLnogKz0gcztcclxuXHRcdHRoaXMudyArPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xyXG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xyXG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xyXG5cdFx0dGhpcy53ID0gYS53ICsgYi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gdi54ICogcztcclxuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xyXG5cdFx0dGhpcy56ICs9IHYueiAqIHM7XHJcblx0XHR0aGlzLncgKz0gdi53ICogcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCAtPSB2Lng7XHJcblx0XHR0aGlzLnkgLT0gdi55O1xyXG5cdFx0dGhpcy56IC09IHYuejtcclxuXHRcdHRoaXMudyAtPSB2Lnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCAtPSBzO1xyXG5cdFx0dGhpcy55IC09IHM7XHJcblx0XHR0aGlzLnogLT0gcztcclxuXHRcdHRoaXMudyAtPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xyXG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xyXG5cdFx0dGhpcy56ID0gYS56IC0gYi56O1xyXG5cdFx0dGhpcy53ID0gYS53IC0gYi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0aWYgKCBpc0Zpbml0ZSggc2NhbGFyICkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggKj0gc2NhbGFyO1xyXG5cdFx0XHR0aGlzLnkgKj0gc2NhbGFyO1xyXG5cdFx0XHR0aGlzLnogKj0gc2NhbGFyO1xyXG5cdFx0XHR0aGlzLncgKj0gc2NhbGFyO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSAwO1xyXG5cdFx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0XHR0aGlzLnogPSAwO1xyXG5cdFx0XHR0aGlzLncgPSAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLng7XHJcblx0XHR2YXIgeSA9IHRoaXMueTtcclxuXHRcdHZhciB6ID0gdGhpcy56O1xyXG5cdFx0dmFyIHcgPSB0aGlzLnc7XHJcblxyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKiB3O1xyXG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSAqIHc7XHJcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSAqIHc7XHJcblx0XHR0aGlzLncgPSBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSAqIHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR0aGlzLncgPSAyICogTWF0aC5hY29zKCBxLncgKTtcclxuXHJcblx0XHR2YXIgcyA9IE1hdGguc3FydCggMSAtIHEudyAqIHEudyApO1xyXG5cclxuXHRcdGlmICggcyA8IDAuMDAwMSApIHtcclxuXHJcblx0XHRcdCB0aGlzLnggPSAxO1xyXG5cdFx0XHQgdGhpcy55ID0gMDtcclxuXHRcdFx0IHRoaXMueiA9IDA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdCB0aGlzLnggPSBxLnggLyBzO1xyXG5cdFx0XHQgdGhpcy55ID0gcS55IC8gcztcclxuXHRcdFx0IHRoaXMueiA9IHEueiAvIHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9BbmdsZS9pbmRleC5odG1cclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHZhciBhbmdsZSwgeCwgeSwgeixcdFx0Ly8gdmFyaWFibGVzIGZvciByZXN1bHRcclxuXHRcdFx0ZXBzaWxvbiA9IDAuMDEsXHRcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXHJcblx0XHRcdGVwc2lsb24yID0gMC4xLFx0XHQvLyBtYXJnaW4gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiAwIGFuZCAxODAgZGVncmVlc1xyXG5cclxuXHRcdFx0dGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcclxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcclxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XHJcblxyXG5cdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgLSBtMjEgKSA8IGVwc2lsb24gKVxyXG5cdFx0ICAgJiYgKCBNYXRoLmFicyggbTEzIC0gbTMxICkgPCBlcHNpbG9uIClcclxuXHRcdCAgICYmICggTWF0aC5hYnMoIG0yMyAtIG0zMiApIDwgZXBzaWxvbiApICkge1xyXG5cclxuXHRcdFx0Ly8gc2luZ3VsYXJpdHkgZm91bmRcclxuXHRcdFx0Ly8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xyXG5cdFx0XHQvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXHJcblxyXG5cdFx0XHRpZiAoICggTWF0aC5hYnMoIG0xMiArIG0yMSApIDwgZXBzaWxvbjIgKVxyXG5cdFx0XHQgICAmJiAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yIClcclxuXHRcdFx0ICAgJiYgKCBNYXRoLmFicyggbTIzICsgbTMyICkgPCBlcHNpbG9uMiApXHJcblx0XHRcdCAgICYmICggTWF0aC5hYnMoIG0xMSArIG0yMiArIG0zMyAtIDMgKSA8IGVwc2lsb24yICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHRoaXMgc2luZ3VsYXJpdHkgaXMgaWRlbnRpdHkgbWF0cml4IHNvIGFuZ2xlID0gMFxyXG5cclxuXHRcdFx0XHR0aGlzLnNldCggMSwgMCwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpczsgLy8gemVybyBhbmdsZSwgYXJiaXRyYXJ5IGF4aXNcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXHJcblxyXG5cdFx0XHRhbmdsZSA9IE1hdGguUEk7XHJcblxyXG5cdFx0XHR2YXIgeHggPSAoIG0xMSArIDEgKSAvIDI7XHJcblx0XHRcdHZhciB5eSA9ICggbTIyICsgMSApIC8gMjtcclxuXHRcdFx0dmFyIHp6ID0gKCBtMzMgKyAxICkgLyAyO1xyXG5cdFx0XHR2YXIgeHkgPSAoIG0xMiArIG0yMSApIC8gNDtcclxuXHRcdFx0dmFyIHh6ID0gKCBtMTMgKyBtMzEgKSAvIDQ7XHJcblx0XHRcdHZhciB5eiA9ICggbTIzICsgbTMyICkgLyA0O1xyXG5cclxuXHRcdFx0aWYgKCAoIHh4ID4geXkgKSAmJiAoIHh4ID4genogKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gbTExIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cclxuXHJcblx0XHRcdFx0aWYgKCB4eCA8IGVwc2lsb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IDA7XHJcblx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IE1hdGguc3FydCggeHggKTtcclxuXHRcdFx0XHRcdHkgPSB4eSAvIHg7XHJcblx0XHRcdFx0XHR6ID0geHogLyB4O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB5eSA+IHp6ICkge1xyXG5cclxuXHRcdFx0XHQvLyBtMjIgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxyXG5cclxuXHRcdFx0XHRpZiAoIHl5IDwgZXBzaWxvbiApIHtcclxuXHJcblx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHR5ID0gMDtcclxuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR5ID0gTWF0aC5zcXJ0KCB5eSApO1xyXG5cdFx0XHRcdFx0eCA9IHh5IC8geTtcclxuXHRcdFx0XHRcdHogPSB5eiAvIHk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcclxuXHJcblx0XHRcdFx0aWYgKCB6eiA8IGVwc2lsb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eiA9IDA7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0eiA9IE1hdGguc3FydCggenogKTtcclxuXHRcdFx0XHRcdHggPSB4eiAvIHo7XHJcblx0XHRcdFx0XHR5ID0geXogLyB6O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnNldCggeCwgeSwgeiwgYW5nbGUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzOyAvLyByZXR1cm4gMTgwIGRlZyByb3RhdGlvblxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhcyB3ZSBoYXZlIHJlYWNoZWQgaGVyZSB0aGVyZSBhcmUgbm8gc2luZ3VsYXJpdGllcyBzbyB3ZSBjYW4gaGFuZGxlIG5vcm1hbGx5XHJcblxyXG5cdFx0dmFyIHMgPSBNYXRoLnNxcnQoICggbTMyIC0gbTIzICkgKiAoIG0zMiAtIG0yMyApXHJcblx0XHRcdFx0XHRcdCAgKyAoIG0xMyAtIG0zMSApICogKCBtMTMgLSBtMzEgKVxyXG5cdFx0XHRcdFx0XHQgICsgKCBtMjEgLSBtMTIgKSAqICggbTIxIC0gbTEyICkgKTsgLy8gdXNlZCB0byBub3JtYWxpemVcclxuXHJcblx0XHRpZiAoIE1hdGguYWJzKCBzICkgPCAwLjAwMSApIHMgPSAxO1xyXG5cclxuXHRcdC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcclxuXHRcdC8vIGNhdWdodCBieSBzaW5ndWxhcml0eSB0ZXN0IGFib3ZlLCBidXQgSSd2ZSBsZWZ0IGl0IGluIGp1c3QgaW4gY2FzZVxyXG5cclxuXHRcdHRoaXMueCA9ICggbTMyIC0gbTIzICkgLyBzO1xyXG5cdFx0dGhpcy55ID0gKCBtMTMgLSBtMzEgKSAvIHM7XHJcblx0XHR0aGlzLnogPSAoIG0yMSAtIG0xMiApIC8gcztcclxuXHRcdHRoaXMudyA9IE1hdGguYWNvcyggKCBtMTEgKyBtMjIgKyBtMzMgLSAxICkgLyAyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcclxuXHRcdHRoaXMudyA9IE1hdGgubWluKCB0aGlzLncsIHYudyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLm1heCggdGhpcy53LCB2LncgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLm1heCggbWluLncsIE1hdGgubWluKCBtYXgudywgdGhpcy53ICkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcclxuXHJcblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1pbiA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XHJcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xyXG5cdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLmZsb29yKCB0aGlzLncgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHRcdHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cdFx0dGhpcy53ID0gKCB0aGlzLncgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMudyApIDogTWF0aC5mbG9vciggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xyXG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XHJcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcclxuXHRcdHRoaXMudyA9IC0gdGhpcy53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggbGVuZ3RoIC8gdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XHJcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xyXG5cdFx0dGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMudyArPSAoIHYudyAtIHRoaXMudyApICogYWxwaGE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICYmICggdi53ID09PSB0aGlzLncgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcclxuXHRcdHRoaXMudyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy53O1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0aW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcclxuXHJcblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XHJcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xyXG5cdFx0dGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcclxuXHRcdHRoaXMudyA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAzIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0V1bGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5FdWxlciA9IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XHJcblxyXG5cdHRoaXMuX3ggPSB4IHx8IDA7XHJcblx0dGhpcy5feSA9IHkgfHwgMDtcclxuXHR0aGlzLl96ID0geiB8fCAwO1xyXG5cdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkV1bGVyLlJvdGF0aW9uT3JkZXJzID0gWyAnWFlaJywgJ1laWCcsICdaWFknLCAnWFpZJywgJ1lYWicsICdaWVgnIF07XHJcblxyXG5USFJFRS5FdWxlci5EZWZhdWx0T3JkZXIgPSAnWFlaJztcclxuXHJcblRIUkVFLkV1bGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkV1bGVyLFxyXG5cclxuXHRnZXQgeCAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3g7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB4ICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCB5ICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHkgKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IHogKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl96O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgeiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgb3JkZXIgKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9vcmRlcjtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IG9yZGVyICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5fb3JkZXIgPSB2YWx1ZTtcclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHg7XHJcblx0XHR0aGlzLl95ID0geTtcclxuXHRcdHRoaXMuX3ogPSB6O1xyXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggZXVsZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IGV1bGVyLl94O1xyXG5cdFx0dGhpcy5feSA9IGV1bGVyLl95O1xyXG5cdFx0dGhpcy5feiA9IGV1bGVyLl96O1xyXG5cdFx0dGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciwgdXBkYXRlICkge1xyXG5cclxuXHRcdHZhciBjbGFtcCA9IFRIUkVFLk1hdGguY2xhbXA7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcclxuXHJcblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XHJcblx0XHR2YXIgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcclxuXHRcdHZhciBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcclxuXHJcblx0XHRvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xyXG5cclxuXHRcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xyXG5cclxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0xMyApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XHJcblx0XHRcdFx0dGhpcy5feiA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggLSBjbGFtcCggbTIzLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XHJcblx0XHRcdFx0dGhpcy5feiA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0zMiApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feSA9IDA7XHJcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xyXG5cclxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTMxICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggY2xhbXAoIG0yMSwgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IDA7XHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xyXG5cclxuXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEyICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMTEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XHJcblx0XHRcdFx0dGhpcy5feSA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6ICcgKyBvcmRlciApXHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XHJcblxyXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBxLCBvcmRlciwgdXBkYXRlICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0XHRcdG1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xyXG5cdFx0XHR0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4LCBvcmRlciwgdXBkYXRlICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiAoIHYsIG9yZGVyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldCggdi54LCB2LnksIHYueiwgb3JkZXIgfHwgdGhpcy5fb3JkZXIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0cmVvcmRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIFdBUk5JTkc6IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbiAtYmhvdXN0b25cclxuXHJcblx0XHR2YXIgcSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbmV3T3JkZXIgKSB7XHJcblxyXG5cdFx0XHRxLnNldEZyb21FdWxlciggdGhpcyApO1xyXG5cdFx0XHR0aGlzLnNldEZyb21RdWF0ZXJuaW9uKCBxLCBuZXdPcmRlciApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuXHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSBhcnJheVsgMCBdO1xyXG5cdFx0dGhpcy5feSA9IGFycmF5WyAxIF07XHJcblx0XHR0aGlzLl96ID0gYXJyYXlbIDIgXTtcclxuXHRcdGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX29yZGVyO1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0dG9WZWN0b3IzOiBmdW5jdGlvbiAoIG9wdGlvbmFsUmVzdWx0ICkge1xyXG5cclxuXHRcdGlmICggb3B0aW9uYWxSZXN1bHQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gb3B0aW9uYWxSZXN1bHQuc2V0KCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0b25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9MaW5lMy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5MaW5lMyA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcclxuXHJcblx0dGhpcy5zdGFydCA9ICggc3RhcnQgIT09IHVuZGVmaW5lZCApID8gc3RhcnQgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMuZW5kID0gKCBlbmQgIT09IHVuZGVmaW5lZCApID8gZW5kIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaW5lMy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5MaW5lMyxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQgKSB7XHJcblxyXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBzdGFydCApO1xyXG5cdFx0dGhpcy5lbmQuY29weSggZW5kICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGxpbmUgKSB7XHJcblxyXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBsaW5lLnN0YXJ0ICk7XHJcblx0XHR0aGlzLmVuZC5jb3B5KCBsaW5lLmVuZCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuc3RhcnQsIHRoaXMuZW5kICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkZWx0YTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmVuZCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG8oIHRoaXMuZW5kICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHN0YXJ0UCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgc3RhcnRFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBjbGFtcFRvTGluZSApIHtcclxuXHJcblx0XHRcdHN0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xyXG5cdFx0XHRzdGFydEVuZC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xyXG5cclxuXHRcdFx0dmFyIHN0YXJ0RW5kMiA9IHN0YXJ0RW5kLmRvdCggc3RhcnRFbmQgKTtcclxuXHRcdFx0dmFyIHN0YXJ0RW5kX3N0YXJ0UCA9IHN0YXJ0RW5kLmRvdCggc3RhcnRQICk7XHJcblxyXG5cdFx0XHR2YXIgdCA9IHN0YXJ0RW5kX3N0YXJ0UCAvIHN0YXJ0RW5kMjtcclxuXHJcblx0XHRcdGlmICggY2xhbXBUb0xpbmUgKSB7XHJcblxyXG5cdFx0XHRcdHQgPSBUSFJFRS5NYXRoLmNsYW1wKCB0LCAwLCAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIGNsYW1wVG9MaW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgdCA9IHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICk7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGVsdGEoIHJlc3VsdCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dGhpcy5zdGFydC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cdFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGxpbmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGxpbmUuc3RhcnQuZXF1YWxzKCB0aGlzLnN0YXJ0ICkgJiYgbGluZS5lbmQuZXF1YWxzKCB0aGlzLmVuZCApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9Cb3gyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLkJveDIgPSBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHR0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBUSFJFRS5WZWN0b3IyKCArIEluZmluaXR5LCArIEluZmluaXR5ICk7XHJcblx0dGhpcy5tYXggPSAoIG1heCAhPT0gdW5kZWZpbmVkICkgPyBtYXggOiBuZXcgVEhSRUUuVmVjdG9yMiggLSBJbmZpbml0eSwgLSBJbmZpbml0eSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJveDIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQm94MixcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xyXG5cdFx0dGhpcy5tYXguY29weSggbWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XHJcblx0XHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZUVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSArIEluZmluaXR5O1xyXG5cdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSAtIEluZmluaXR5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcclxuXHJcblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcclxuXHRcdHRoaXMubWF4Lm1heCggcG9pbnQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XHJcblx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xyXG5cdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XHJcblx0XHQgICAgIHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxyXG5cdFx0ICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxyXG5cdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0LnNldChcclxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxyXG5cdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55IClcclxuXHRcdCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxyXG5cclxuXHRcdGlmICggYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XHJcblx0XHQgICAgIGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRcdHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XHJcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvQm94My5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuQm94MyA9IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjMoICsgSW5maW5pdHksICsgSW5maW5pdHksICsgSW5maW5pdHkgKTtcclxuXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm94My5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gzLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uY29weSggbWluICk7XHJcblx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0dmFyIG1pblggPSArIEluZmluaXR5O1xyXG5cdFx0dmFyIG1pblkgPSArIEluZmluaXR5O1xyXG5cdFx0dmFyIG1pblogPSArIEluZmluaXR5O1xyXG5cclxuXHRcdHZhciBtYXhYID0gLSBJbmZpbml0eTtcclxuXHRcdHZhciBtYXhZID0gLSBJbmZpbml0eTtcclxuXHRcdHZhciBtYXhaID0gLSBJbmZpbml0eTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdHZhciB4ID0gYXJyYXlbIGkgXTtcclxuXHRcdFx0dmFyIHkgPSBhcnJheVsgaSArIDEgXTtcclxuXHRcdFx0dmFyIHogPSBhcnJheVsgaSArIDIgXTtcclxuXHJcblx0XHRcdGlmICggeCA8IG1pblggKSBtaW5YID0geDtcclxuXHRcdFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xyXG5cdFx0XHRpZiAoIHogPCBtaW5aICkgbWluWiA9IHo7XHJcblxyXG5cdFx0XHRpZiAoIHggPiBtYXhYICkgbWF4WCA9IHg7XHJcblx0XHRcdGlmICggeSA+IG1heFkgKSBtYXhZID0geTtcclxuXHRcdFx0aWYgKCB6ID4gbWF4WiApIG1heFogPSB6O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm1pbi5zZXQoIG1pblgsIG1pblksIG1pblogKTtcclxuXHRcdHRoaXMubWF4LnNldCggbWF4WCwgbWF4WSwgbWF4WiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggY2VudGVyLCBzaXplICkge1xyXG5cclxuXHRcdFx0dmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcclxuXHRcdFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcclxuXHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGQgdHJhbnNmb3Jtc1xyXG5cclxuXHRcdHZhciBib3g7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBib3ggPT09IHVuZGVmaW5lZCApIGJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHRcdG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdFx0b2JqZWN0LnRyYXZlcnNlKCBmdW5jdGlvbiAoIG5vZGUgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJveC5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApO1xyXG5cdFx0XHRcdFx0Ym94LmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0c2NvcGUudW5pb24oIGJveCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9ICsgSW5maW5pdHk7XHJcblx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IHRoaXMubWF4LnogPSAtIEluZmluaXR5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcclxuXHJcblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xyXG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcclxuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0XHRcdCBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxyXG5cdFx0XHRcdCBwb2ludC56IDwgdGhpcy5taW4ueiB8fCBwb2ludC56ID4gdGhpcy5tYXgueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcclxuXHRcdFx0ICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgJiZcclxuXHRcdFx0ICggdGhpcy5taW4ueiA8PSBib3gubWluLnogKSAmJiAoIGJveC5tYXgueiA8PSB0aGlzLm1heC56ICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XHJcblx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQuc2V0KFxyXG5cdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXHJcblx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSxcclxuXHRcdFx0KCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXHJcblx0XHQpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cclxuXHJcblx0XHRpZiAoIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0XHRcdCBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHxcclxuXHRcdFx0XHQgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c1NwaGVyZTogKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGNsb3Nlc3RQb2ludDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xyXG5cclxuXHRcdFx0aWYgKCBjbG9zZXN0UG9pbnQgPT09IHVuZGVmaW5lZCApIGNsb3Nlc3RQb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHQvLyBGaW5kIHRoZSBwb2ludCBvbiB0aGUgQUFCQiBjbG9zZXN0IHRvIHRoZSBzcGhlcmUgY2VudGVyLlxyXG5cdFx0XHR0aGlzLmNsYW1wUG9pbnQoIHNwaGVyZS5jZW50ZXIsIGNsb3Nlc3RQb2ludCApO1xyXG5cclxuXHRcdFx0Ly8gSWYgdGhhdCBwb2ludCBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgdGhlIEFBQkIgYW5kIHNwaGVyZSBpbnRlcnNlY3QuXHJcblx0XHRcdHJldHVybiBjbG9zZXN0UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHNwaGVyZS5jZW50ZXIgKSA8PSAoIHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCksXHJcblxyXG5cdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHQvLyBXZSBjb21wdXRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRvdCBwcm9kdWN0IHZhbHVlcy4gSWYgdGhvc2UgdmFsdWVzXHJcblx0XHQvLyBhcmUgb24gdGhlIHNhbWUgc2lkZSAoYmFjayBvciBmcm9udCkgb2YgdGhlIHBsYW5lLCB0aGVuIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbi5cclxuXHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XHJcblxyXG5cdFx0XHRtaW4gPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XHJcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54O1xyXG5cdFx0XHRtYXggPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xyXG5cclxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcclxuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcclxuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XHJcblxyXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xyXG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xyXG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKCBtaW4gPD0gcGxhbmUuY29uc3RhbnQgJiYgbWF4ID49IHBsYW5lLmNvbnN0YW50ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRcdHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRnZXRCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuXHRcdFx0cmVzdWx0LmNlbnRlciA9IHRoaXMuY2VudGVyKCk7XHJcblx0XHRcdHJlc3VsdC5yYWRpdXMgPSB0aGlzLnNpemUoIHYxICkubGVuZ3RoKCkgKiAwLjU7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1bmlvbjogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IFtcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKVxyXG5cdFx0XTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0XHQvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xyXG5cdFx0XHRwb2ludHNbIDAgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDBcclxuXHRcdFx0cG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXHJcblx0XHRcdHBvaW50c1sgMiBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMFxyXG5cdFx0XHRwb2ludHNbIDMgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTFcclxuXHRcdFx0cG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXHJcblx0XHRcdHBvaW50c1sgNSBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMVxyXG5cdFx0XHRwb2ludHNbIDYgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTBcclxuXHRcdFx0cG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcdC8vIDExMVxyXG5cclxuXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcclxuXHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xyXG5cdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL01hdHJpeDMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLk1hdHJpeDMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXHJcblxyXG5cdFx0MSwgMCwgMCxcclxuXHRcdDAsIDEsIDAsXHJcblx0XHQwLCAwLCAxXHJcblxyXG5cdF0gKTtcclxuXHJcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4MzogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NYXRyaXgzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDMsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDMgXSA9IG4xMjsgdGVbIDYgXSA9IG4xMztcclxuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA0IF0gPSBuMjI7IHRlWyA3IF0gPSBuMjM7XHJcblx0XHR0ZVsgMiBdID0gbjMxOyB0ZVsgNSBdID0gbjMyOyB0ZVsgOCBdID0gbjMzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0MSwgMCwgMCxcclxuXHRcdFx0MCwgMSwgMCxcclxuXHRcdFx0MCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0bWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSxcclxuXHRcdFx0bWVbIDEgXSwgbWVbIDQgXSwgbWVbIDcgXSxcclxuXHRcdFx0bWVbIDIgXSwgbWVbIDUgXSwgbWVbIDggXVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHRcdFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHYxLmZyb21BcnJheSggYXJyYXksIGogKTtcclxuXHRcdFx0XHR2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcclxuXHRcdFx0XHR2MS50b0FycmF5KCBhcnJheSwgaiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlciggYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCApIHtcclxuXHJcblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICsrLCBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2MS54ID0gYnVmZmVyLmdldFgoIGogKTtcclxuXHRcdFx0XHR2MS55ID0gYnVmZmVyLmdldFkoIGogKTtcclxuXHRcdFx0XHR2MS56ID0gYnVmZmVyLmdldFooIGogKTtcclxuXHJcblx0XHRcdFx0djEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XHJcblxyXG5cdFx0XHRcdGJ1ZmZlci5zZXRYWVooIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBidWZmZXI7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgMyBdICo9IHM7IHRlWyA2IF0gKj0gcztcclxuXHRcdHRlWyAxIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgNyBdICo9IHM7XHJcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDggXSAqPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIGEgPSB0ZVsgMCBdLCBiID0gdGVbIDEgXSwgYyA9IHRlWyAyIF0sXHJcblx0XHRcdGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXHJcblx0XHRcdGcgPSB0ZVsgNiBdLCBoID0gdGVbIDcgXSwgaSA9IHRlWyA4IF07XHJcblxyXG5cdFx0cmV0dXJuIGEgKiBlICogaSAtIGEgKiBmICogaCAtIGIgKiBkICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtYXRyaXgsIHRocm93T25EZWdlbmVyYXRlICkge1xyXG5cclxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0XHJcblx0XHQvLyAoIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJnbC1tanMvIClcclxuXHJcblx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gPSAgIG1lWyAxMCBdICogbWVbIDUgXSAtIG1lWyA2IF0gKiBtZVsgOSBdO1xyXG5cdFx0dGVbIDEgXSA9IC0gbWVbIDEwIF0gKiBtZVsgMSBdICsgbWVbIDIgXSAqIG1lWyA5IF07XHJcblx0XHR0ZVsgMiBdID0gICBtZVsgNiBdICogbWVbIDEgXSAtIG1lWyAyIF0gKiBtZVsgNSBdO1xyXG5cdFx0dGVbIDMgXSA9IC0gbWVbIDEwIF0gKiBtZVsgNCBdICsgbWVbIDYgXSAqIG1lWyA4IF07XHJcblx0XHR0ZVsgNCBdID0gICBtZVsgMTAgXSAqIG1lWyAwIF0gLSBtZVsgMiBdICogbWVbIDggXTtcclxuXHRcdHRlWyA1IF0gPSAtIG1lWyA2IF0gKiBtZVsgMCBdICsgbWVbIDIgXSAqIG1lWyA0IF07XHJcblx0XHR0ZVsgNiBdID0gICBtZVsgOSBdICogbWVbIDQgXSAtIG1lWyA1IF0gKiBtZVsgOCBdO1xyXG5cdFx0dGVbIDcgXSA9IC0gbWVbIDkgXSAqIG1lWyAwIF0gKyBtZVsgMSBdICogbWVbIDggXTtcclxuXHRcdHRlWyA4IF0gPSAgIG1lWyA1IF0gKiBtZVsgMCBdIC0gbWVbIDEgXSAqIG1lWyA0IF07XHJcblxyXG5cdFx0dmFyIGRldCA9IG1lWyAwIF0gKiB0ZVsgMCBdICsgbWVbIDEgXSAqIHRlWyAzIF0gKyBtZVsgMiBdICogdGVbIDYgXTtcclxuXHJcblx0XHQvLyBubyBpbnZlcnNlXHJcblxyXG5cdFx0aWYgKCBkZXQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgbXNnID0gXCJUSFJFRS5NYXRyaXgzLmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xyXG5cclxuXHRcdFx0aWYgKCB0aHJvd09uRGVnZW5lcmF0ZSB8fCBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmlkZW50aXR5KCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tdWx0aXBseVNjYWxhciggMS4wIC8gZGV0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0bXAsIG0gPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XHJcblx0XHR0bXAgPSBtWyAyIF07IG1bIDIgXSA9IG1bIDYgXTsgbVsgNiBdID0gdG1wO1xyXG5cdFx0dG1wID0gbVsgNSBdOyBtWyA1IF0gPSBtWyA3IF07IG1bIDcgXSA9IHRtcDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDggXSAgPSB0ZVsgOCBdO1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Tm9ybWFsTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDRcclxuXHJcblx0XHR0aGlzLmdldEludmVyc2UoIG0gKS50cmFuc3Bvc2UoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XHJcblxyXG5cdFx0dmFyIG0gPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHJbIDAgXSA9IG1bIDAgXTtcclxuXHRcdHJbIDEgXSA9IG1bIDMgXTtcclxuXHRcdHJbIDIgXSA9IG1bIDYgXTtcclxuXHRcdHJbIDMgXSA9IG1bIDEgXTtcclxuXHRcdHJbIDQgXSA9IG1bIDQgXTtcclxuXHRcdHJbIDUgXSA9IG1bIDcgXTtcclxuXHRcdHJbIDYgXSA9IG1bIDIgXTtcclxuXHRcdHJbIDcgXSA9IG1bIDUgXTtcclxuXHRcdHJbIDggXSA9IG1bIDggXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdHRoaXMuZWxlbWVudHMuc2V0KCBhcnJheSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHR0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdLFxyXG5cdFx0XHR0ZVsgMyBdLCB0ZVsgNCBdLCB0ZVsgNSBdLFxyXG5cdFx0XHR0ZVsgNiBdLCB0ZVsgNyBdLCB0ZVsgOCBdXHJcblx0XHRdO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9NYXRyaXg0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBqb3JkaV9yb3MgLyBodHRwOi8vcGxhdHRzb2Z0LmNvbVxyXG4gKiBAYXV0aG9yIEQxcGxvMWQgLyBodHRwOi8vZ2l0aHViLmNvbS9EMXBsbzFkXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgdGlta25pcCAvIGh0dHA6Ly93d3cuZmxvb3JwbGFubmVyLmNvbS9cclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5NYXRyaXg0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheSggW1xyXG5cclxuXHRcdDEsIDAsIDAsIDAsXHJcblx0XHQwLCAxLCAwLCAwLFxyXG5cdFx0MCwgMCwgMSwgMCxcclxuXHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XSApO1xyXG5cclxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1hdHJpeDQucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4NCxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xyXG5cdFx0dGVbIDEgXSA9IG4yMTsgdGVbIDUgXSA9IG4yMjsgdGVbIDkgXSA9IG4yMzsgdGVbIDEzIF0gPSBuMjQ7XHJcblx0XHR0ZVsgMiBdID0gbjMxOyB0ZVsgNiBdID0gbjMyOyB0ZVsgMTAgXSA9IG4zMzsgdGVbIDE0IF0gPSBuMzQ7XHJcblx0XHR0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAxLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHRoaXMuZWxlbWVudHMuc2V0KCBtLmVsZW1lbnRzICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAxMiBdID0gbWVbIDEyIF07XHJcblx0XHR0ZVsgMTMgXSA9IG1lWyAxMyBdO1xyXG5cdFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXh0cmFjdEJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR4QXhpcy5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKTtcclxuXHRcdHlBeGlzLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApO1xyXG5cdFx0ekF4aXMuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlQmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcclxuXHRcdFx0eEF4aXMueSwgeUF4aXMueSwgekF4aXMueSwgMCxcclxuXHRcdFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcclxuXHRcdFx0MCwgICAgICAgMCwgICAgICAgMCwgICAgICAgMVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXh0cmFjdFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dmFyIHNjYWxlWCA9IDEgLyB2MS5zZXQoIG1lWyAwIF0sIG1lWyAxIF0sIG1lWyAyIF0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHNjYWxlWSA9IDEgLyB2MS5zZXQoIG1lWyA0IF0sIG1lWyA1IF0sIG1lWyA2IF0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHNjYWxlWiA9IDEgLyB2MS5zZXQoIG1lWyA4IF0sIG1lWyA5IF0sIG1lWyAxMCBdICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gbWVbIDAgXSAqIHNjYWxlWDtcclxuXHRcdFx0dGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XHJcblx0XHRcdHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xyXG5cclxuXHRcdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XHJcblx0XHRcdHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xyXG5cdFx0XHR0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcclxuXHJcblx0XHRcdHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xyXG5cdFx0XHR0ZVsgOSBdID0gbWVbIDkgXSAqIHNjYWxlWjtcclxuXHRcdFx0dGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuXHRcdGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgeCA9IGV1bGVyLngsIHkgPSBldWxlci55LCB6ID0gZXVsZXIuejtcclxuXHRcdHZhciBhID0gTWF0aC5jb3MoIHggKSwgYiA9IE1hdGguc2luKCB4ICk7XHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCB5ICksIGQgPSBNYXRoLnNpbiggeSApO1xyXG5cdFx0dmFyIGUgPSBNYXRoLmNvcyggeiApLCBmID0gTWF0aC5zaW4oIHogKTtcclxuXHJcblx0XHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcblx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVsgNCBdID0gLSBjICogZjtcclxuXHRcdFx0dGVbIDggXSA9IGQ7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYWYgKyBiZSAqIGQ7XHJcblx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcclxuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGM7XHJcblxyXG5cdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XHJcblx0XHRcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcclxuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBjZSArIGRmICogYjtcclxuXHRcdFx0dGVbIDQgXSA9IGRlICogYiAtIGNmO1xyXG5cdFx0XHR0ZVsgOCBdID0gYSAqIGQ7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYSAqIGY7XHJcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcclxuXHRcdFx0dGVbIDkgXSA9IC0gYjtcclxuXHJcblx0XHRcdHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcclxuXHRcdFx0dGVbIDYgXSA9IGRmICsgY2UgKiBiO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcclxuXHJcblx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xyXG5cdFx0XHR0ZVsgNCBdID0gLSBhICogZjtcclxuXHRcdFx0dGVbIDggXSA9IGRlICsgY2YgKiBiO1xyXG5cclxuXHRcdFx0dGVbIDEgXSA9IGNmICsgZGUgKiBiO1xyXG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XHJcblx0XHRcdHRlWyA5IF0gPSBkZiAtIGNlICogYjtcclxuXHJcblx0XHRcdHRlWyAyIF0gPSAtIGEgKiBkO1xyXG5cdFx0XHR0ZVsgNiBdID0gYjtcclxuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBjICogZTtcclxuXHRcdFx0dGVbIDQgXSA9IGJlICogZCAtIGFmO1xyXG5cdFx0XHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYyAqIGY7XHJcblx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcclxuXHRcdFx0dGVbIDkgXSA9IGFmICogZCAtIGJlO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IC0gZDtcclxuXHRcdFx0dGVbIDYgXSA9IGIgKiBjO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcclxuXHJcblx0XHRcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVsgNCBdID0gYmQgLSBhYyAqIGY7XHJcblx0XHRcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcclxuXHJcblx0XHRcdHRlWyAxIF0gPSBmO1xyXG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XHJcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBlO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IC0gZCAqIGU7XHJcblx0XHRcdHRlWyA2IF0gPSBhZCAqIGYgKyBiYztcclxuXHRcdFx0dGVbIDEwIF0gPSBhYyAtIGJkICogZjtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBjICogZTtcclxuXHRcdFx0dGVbIDQgXSA9IC0gZjtcclxuXHRcdFx0dGVbIDggXSA9IGQgKiBlO1xyXG5cclxuXHRcdFx0dGVbIDEgXSA9IGFjICogZiArIGJkO1xyXG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XHJcblx0XHRcdHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcclxuXHJcblx0XHRcdHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcclxuXHRcdFx0dGVbIDYgXSA9IGIgKiBlO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGJkICogZiArIGFjO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBsYXN0IGNvbHVtblxyXG5cdFx0dGVbIDMgXSA9IDA7XHJcblx0XHR0ZVsgNyBdID0gMDtcclxuXHRcdHRlWyAxMSBdID0gMDtcclxuXHJcblx0XHQvLyBib3R0b20gcm93XHJcblx0XHR0ZVsgMTIgXSA9IDA7XHJcblx0XHR0ZVsgMTMgXSA9IDA7XHJcblx0XHR0ZVsgMTQgXSA9IDA7XHJcblx0XHR0ZVsgMTUgXSA9IDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudztcclxuXHRcdHZhciB4MiA9IHggKyB4LCB5MiA9IHkgKyB5LCB6MiA9IHogKyB6O1xyXG5cdFx0dmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XHJcblx0XHR2YXIgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6MjtcclxuXHRcdHZhciB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyO1xyXG5cclxuXHRcdHRlWyAwIF0gPSAxIC0gKCB5eSArIHp6ICk7XHJcblx0XHR0ZVsgNCBdID0geHkgLSB3ejtcclxuXHRcdHRlWyA4IF0gPSB4eiArIHd5O1xyXG5cclxuXHRcdHRlWyAxIF0gPSB4eSArIHd6O1xyXG5cdFx0dGVbIDUgXSA9IDEgLSAoIHh4ICsgenogKTtcclxuXHRcdHRlWyA5IF0gPSB5eiAtIHd4O1xyXG5cclxuXHRcdHRlWyAyIF0gPSB4eiAtIHd5O1xyXG5cdFx0dGVbIDYgXSA9IHl6ICsgd3g7XHJcblx0XHR0ZVsgMTAgXSA9IDEgLSAoIHh4ICsgeXkgKTtcclxuXHJcblx0XHQvLyBsYXN0IGNvbHVtblxyXG5cdFx0dGVbIDMgXSA9IDA7XHJcblx0XHR0ZVsgNyBdID0gMDtcclxuXHRcdHRlWyAxMSBdID0gMDtcclxuXHJcblx0XHQvLyBib3R0b20gcm93XHJcblx0XHR0ZVsgMTIgXSA9IDA7XHJcblx0XHR0ZVsgMTMgXSA9IDA7XHJcblx0XHR0ZVsgMTQgXSA9IDA7XHJcblx0XHR0ZVsgMTUgXSA9IDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB4LCB5LCB6O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcclxuXHJcblx0XHRcdGlmICggeCA9PT0gdW5kZWZpbmVkICkgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdGlmICggeSA9PT0gdW5kZWZpbmVkICkgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdGlmICggeiA9PT0gdW5kZWZpbmVkICkgeiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0ei5zdWJWZWN0b3JzKCBleWUsIHRhcmdldCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0aWYgKCB6Lmxlbmd0aFNxKCkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHoueiA9IDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGlmICggeC5sZW5ndGhTcSgpID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR6LnggKz0gMC4wMDAxO1xyXG5cdFx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0eS5jcm9zc1ZlY3RvcnMoIHosIHggKTtcclxuXHJcblxyXG5cdFx0XHR0ZVsgMCBdID0geC54OyB0ZVsgNCBdID0geS54OyB0ZVsgOCBdID0gei54O1xyXG5cdFx0XHR0ZVsgMSBdID0geC55OyB0ZVsgNSBdID0geS55OyB0ZVsgOSBdID0gei55O1xyXG5cdFx0XHR0ZVsgMiBdID0geC56OyB0ZVsgNiBdID0geS56OyB0ZVsgMTAgXSA9IHouejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcclxuXHJcblx0XHRpZiAoIG4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR2YXIgYWUgPSBhLmVsZW1lbnRzO1xyXG5cdFx0dmFyIGJlID0gYi5lbGVtZW50cztcclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xyXG5cdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xyXG5cdFx0dmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcclxuXHRcdHZhciBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XHJcblxyXG5cdFx0dmFyIGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xyXG5cdFx0dmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xyXG5cdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcclxuXHRcdHZhciBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XHJcblxyXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcclxuXHRcdHRlWyA0IF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XHJcblx0XHR0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xyXG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcclxuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XHJcblx0XHR0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xyXG5cdFx0dGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcclxuXHRcdHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XHJcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0MztcclxuXHRcdHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xyXG5cclxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XHJcblx0XHR0ZVsgNyBdID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xyXG5cdFx0dGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XHJcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlUb0FycmF5OiBmdW5jdGlvbiAoIGEsIGIsIHIgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKTtcclxuXHJcblx0XHRyWyAwIF0gPSB0ZVsgMCBdOyByWyAxIF0gPSB0ZVsgMSBdOyByWyAyIF0gPSB0ZVsgMiBdOyByWyAzIF0gPSB0ZVsgMyBdO1xyXG5cdFx0clsgNCBdID0gdGVbIDQgXTsgclsgNSBdID0gdGVbIDUgXTsgclsgNiBdID0gdGVbIDYgXTsgclsgNyBdID0gdGVbIDcgXTtcclxuXHRcdHJbIDggXSAgPSB0ZVsgOCBdOyByWyA5IF0gID0gdGVbIDkgXTsgclsgMTAgXSA9IHRlWyAxMCBdOyByWyAxMSBdID0gdGVbIDExIF07XHJcblx0XHRyWyAxMiBdID0gdGVbIDEyIF07IHJbIDEzIF0gPSB0ZVsgMTMgXTsgclsgMTQgXSA9IHRlWyAxNCBdOyByWyAxNSBdID0gdGVbIDE1IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDggXSAqPSBzOyB0ZVsgMTIgXSAqPSBzO1xyXG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA5IF0gKj0gczsgdGVbIDEzIF0gKj0gcztcclxuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xyXG5cdFx0dGVbIDMgXSAqPSBzOyB0ZVsgNyBdICo9IHM7IHRlWyAxMSBdICo9IHM7IHRlWyAxNSBdICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHRcdFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHYxLmZyb21BcnJheSggYXJyYXksIGogKTtcclxuXHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcclxuXHRcdFx0XHR2MS50b0FycmF5KCBhcnJheSwgaiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlciggYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCApIHtcclxuXHJcblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICsrLCBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2MS54ID0gYnVmZmVyLmdldFgoIGogKTtcclxuXHRcdFx0XHR2MS55ID0gYnVmZmVyLmdldFkoIGogKTtcclxuXHRcdFx0XHR2MS56ID0gYnVmZmVyLmdldFooIGogKTtcclxuXHJcblx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XHJcblxyXG5cdFx0XHRcdGJ1ZmZlci5zZXRYWVooIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBidWZmZXI7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIG4xMSA9IHRlWyAwIF0sIG4xMiA9IHRlWyA0IF0sIG4xMyA9IHRlWyA4IF0sIG4xNCA9IHRlWyAxMiBdO1xyXG5cdFx0dmFyIG4yMSA9IHRlWyAxIF0sIG4yMiA9IHRlWyA1IF0sIG4yMyA9IHRlWyA5IF0sIG4yNCA9IHRlWyAxMyBdO1xyXG5cdFx0dmFyIG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcclxuXHRcdHZhciBuNDEgPSB0ZVsgMyBdLCBuNDIgPSB0ZVsgNyBdLCBuNDMgPSB0ZVsgMTEgXSwgbjQ0ID0gdGVbIDE1IF07XHJcblxyXG5cdFx0Ly9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcclxuXHRcdC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxyXG5cclxuXHRcdHJldHVybiAoXHJcblx0XHRcdG40MSAqIChcclxuXHRcdFx0XHQrIG4xNCAqIG4yMyAqIG4zMlxyXG5cdFx0XHRcdCAtIG4xMyAqIG4yNCAqIG4zMlxyXG5cdFx0XHRcdCAtIG4xNCAqIG4yMiAqIG4zM1xyXG5cdFx0XHRcdCArIG4xMiAqIG4yNCAqIG4zM1xyXG5cdFx0XHRcdCArIG4xMyAqIG4yMiAqIG4zNFxyXG5cdFx0XHRcdCAtIG4xMiAqIG4yMyAqIG4zNFxyXG5cdFx0XHQpICtcclxuXHRcdFx0bjQyICogKFxyXG5cdFx0XHRcdCsgbjExICogbjIzICogbjM0XHJcblx0XHRcdFx0IC0gbjExICogbjI0ICogbjMzXHJcblx0XHRcdFx0ICsgbjE0ICogbjIxICogbjMzXHJcblx0XHRcdFx0IC0gbjEzICogbjIxICogbjM0XHJcblx0XHRcdFx0ICsgbjEzICogbjI0ICogbjMxXHJcblx0XHRcdFx0IC0gbjE0ICogbjIzICogbjMxXHJcblx0XHRcdCkgK1xyXG5cdFx0XHRuNDMgKiAoXHJcblx0XHRcdFx0KyBuMTEgKiBuMjQgKiBuMzJcclxuXHRcdFx0XHQgLSBuMTEgKiBuMjIgKiBuMzRcclxuXHRcdFx0XHQgLSBuMTQgKiBuMjEgKiBuMzJcclxuXHRcdFx0XHQgKyBuMTIgKiBuMjEgKiBuMzRcclxuXHRcdFx0XHQgKyBuMTQgKiBuMjIgKiBuMzFcclxuXHRcdFx0XHQgLSBuMTIgKiBuMjQgKiBuMzFcclxuXHRcdFx0KSArXHJcblx0XHRcdG40NCAqIChcclxuXHRcdFx0XHQtIG4xMyAqIG4yMiAqIG4zMVxyXG5cdFx0XHRcdCAtIG4xMSAqIG4yMyAqIG4zMlxyXG5cdFx0XHRcdCArIG4xMSAqIG4yMiAqIG4zM1xyXG5cdFx0XHRcdCArIG4xMyAqIG4yMSAqIG4zMlxyXG5cdFx0XHRcdCAtIG4xMiAqIG4yMSAqIG4zM1xyXG5cdFx0XHRcdCArIG4xMiAqIG4yMyAqIG4zMVxyXG5cdFx0XHQpXHJcblxyXG5cdFx0KTtcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB0bXA7XHJcblxyXG5cdFx0dG1wID0gdGVbIDEgXTsgdGVbIDEgXSA9IHRlWyA0IF07IHRlWyA0IF0gPSB0bXA7XHJcblx0XHR0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcclxuXHRcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xyXG5cclxuXHRcdHRtcCA9IHRlWyAzIF07IHRlWyAzIF0gPSB0ZVsgMTIgXTsgdGVbIDEyIF0gPSB0bXA7XHJcblx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbIDExIF07IHRlWyAxMSBdID0gdGVbIDE0IF07IHRlWyAxNCBdID0gdG1wO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdICA9IHRlWyA4IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgOSBdICA9IHRlWyA5IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDExIF0gPSB0ZVsgMTEgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEzIF0gPSB0ZVsgMTMgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxNCBdID0gdGVbIDE0IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmdldFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHRcdHJldHVybiB2MS5zZXQoIHRlWyAxMiBdLCB0ZVsgMTMgXSwgdGVbIDE0IF0gKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMTIgXSA9IHYueDtcclxuXHRcdHRlWyAxMyBdID0gdi55O1xyXG5cdFx0dGVbIDE0IF0gPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEludmVyc2U6IGZ1bmN0aW9uICggbSwgdGhyb3dPbkludmVydGlibGUgKSB7XHJcblxyXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgbjExID0gbWVbIDAgXSwgbjEyID0gbWVbIDQgXSwgbjEzID0gbWVbIDggXSwgbjE0ID0gbWVbIDEyIF07XHJcblx0XHR2YXIgbjIxID0gbWVbIDEgXSwgbjIyID0gbWVbIDUgXSwgbjIzID0gbWVbIDkgXSwgbjI0ID0gbWVbIDEzIF07XHJcblx0XHR2YXIgbjMxID0gbWVbIDIgXSwgbjMyID0gbWVbIDYgXSwgbjMzID0gbWVbIDEwIF0sIG4zNCA9IG1lWyAxNCBdO1xyXG5cdFx0dmFyIG40MSA9IG1lWyAzIF0sIG40MiA9IG1lWyA3IF0sIG40MyA9IG1lWyAxMSBdLCBuNDQgPSBtZVsgMTUgXTtcclxuXHJcblx0XHR0ZVsgMCBdID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0O1xyXG5cdFx0dGVbIDQgXSA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NDtcclxuXHRcdHRlWyA4IF0gPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQ7XHJcblx0XHR0ZVsgMTIgXSA9IG4xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNDtcclxuXHRcdHRlWyAxIF0gPSBuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQ7XHJcblx0XHR0ZVsgNSBdID0gbjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0O1xyXG5cdFx0dGVbIDkgXSA9IG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NDtcclxuXHRcdHRlWyAxMyBdID0gbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0O1xyXG5cdFx0dGVbIDIgXSA9IG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NDtcclxuXHRcdHRlWyA2IF0gPSBuMTQgKiBuMzIgKiBuNDEgLSBuMTIgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzEgKiBuNDIgKyBuMTEgKiBuMzQgKiBuNDIgKyBuMTIgKiBuMzEgKiBuNDQgLSBuMTEgKiBuMzIgKiBuNDQ7XHJcblx0XHR0ZVsgMTAgXSA9IG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NDtcclxuXHRcdHRlWyAxNCBdID0gbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0O1xyXG5cdFx0dGVbIDMgXSA9IG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MztcclxuXHRcdHRlWyA3IF0gPSBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDM7XHJcblx0XHR0ZVsgMTEgXSA9IG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MztcclxuXHRcdHRlWyAxNSBdID0gbjEyICogbjIzICogbjMxIC0gbjEzICogbjIyICogbjMxICsgbjEzICogbjIxICogbjMyIC0gbjExICogbjIzICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjExICogbjIyICogbjMzO1xyXG5cclxuXHRcdHZhciBkZXQgPSBuMTEgKiB0ZVsgMCBdICsgbjIxICogdGVbIDQgXSArIG4zMSAqIHRlWyA4IF0gKyBuNDEgKiB0ZVsgMTIgXTtcclxuXHJcblx0XHRpZiAoIGRldCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHZhciBtc2cgPSBcIlRIUkVFLk1hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XHJcblxyXG5cdFx0XHRpZiAoIHRocm93T25JbnZlcnRpYmxlIHx8IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCBtc2cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuaWRlbnRpdHkoKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gZGV0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xyXG5cclxuXHRcdHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XHJcblx0XHR0ZVsgMSBdICo9IHg7IHRlWyA1IF0gKj0geTsgdGVbIDkgXSAqPSB6O1xyXG5cdFx0dGVbIDIgXSAqPSB4OyB0ZVsgNiBdICo9IHk7IHRlWyAxMCBdICo9IHo7XHJcblx0XHR0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcclxuXHRcdHZhciBzY2FsZVlTcSA9IHRlWyA0IF0gKiB0ZVsgNCBdICsgdGVbIDUgXSAqIHRlWyA1IF0gKyB0ZVsgNiBdICogdGVbIDYgXTtcclxuXHRcdHZhciBzY2FsZVpTcSA9IHRlWyA4IF0gKiB0ZVsgOCBdICsgdGVbIDkgXSAqIHRlWyA5IF0gKyB0ZVsgMTAgXSAqIHRlWyAxMCBdO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLCB4LFxyXG5cdFx0XHQwLCAxLCAwLCB5LFxyXG5cdFx0XHQwLCAwLCAxLCB6LFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uWDogZnVuY3Rpb24gKCB0aGV0YSApIHtcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAgMCwgMCxcclxuXHRcdFx0MCwgYywgLSBzLCAwLFxyXG5cdFx0XHQwLCBzLCAgYywgMCxcclxuXHRcdFx0MCwgMCwgIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlUm90YXRpb25ZOiBmdW5jdGlvbiAoIHRoZXRhICkge1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdCBjLCAwLCBzLCAwLFxyXG5cdFx0XHQgMCwgMSwgMCwgMCxcclxuXHRcdFx0LSBzLCAwLCBjLCAwLFxyXG5cdFx0XHQgMCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VSb3RhdGlvblo6IGZ1bmN0aW9uICggdGhldGEgKSB7XHJcblxyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0YywgLSBzLCAwLCAwLFxyXG5cdFx0XHRzLCAgYywgMCwgMCxcclxuXHRcdFx0MCwgIDAsIDEsIDAsXHJcblx0XHRcdDAsICAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uQXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHQvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0dmFyIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHRcdHZhciB0ID0gMSAtIGM7XHJcblx0XHR2YXIgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcclxuXHRcdHZhciB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxyXG5cdFx0XHR0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXHJcblx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0IHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlU2NhbGU6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdHgsIDAsIDAsIDAsXHJcblx0XHRcdDAsIHksIDAsIDAsXHJcblx0XHRcdDAsIDAsIHosIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wb3NlOiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcclxuXHJcblx0XHR0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XHJcblx0XHR0aGlzLnNjYWxlKCBzY2FsZSApO1xyXG5cdFx0dGhpcy5zZXRQb3NpdGlvbiggcG9zaXRpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGVjb21wb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHZlY3RvciwgbWF0cml4O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcclxuXHJcblx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHR2YXIgc3ggPSB2ZWN0b3Iuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XHJcblx0XHRcdHZhciBzeSA9IHZlY3Rvci5zZXQoIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHN6ID0gdmVjdG9yLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKS5sZW5ndGgoKTtcclxuXHJcblx0XHRcdC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXHJcblx0XHRcdHZhciBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XHJcblx0XHRcdGlmICggZGV0IDwgMCApIHtcclxuXHJcblx0XHRcdFx0c3ggPSAtIHN4O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cG9zaXRpb24ueCA9IHRlWyAxMiBdO1xyXG5cdFx0XHRwb3NpdGlvbi55ID0gdGVbIDEzIF07XHJcblx0XHRcdHBvc2l0aW9uLnogPSB0ZVsgMTQgXTtcclxuXHJcblx0XHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XHJcblxyXG5cdFx0XHRtYXRyaXguZWxlbWVudHMuc2V0KCB0aGlzLmVsZW1lbnRzICk7IC8vIGF0IHRoaXMgcG9pbnQgbWF0cml4IGlzIGluY29tcGxldGUgc28gd2UgY2FuJ3QgdXNlIC5jb3B5KClcclxuXHJcblx0XHRcdHZhciBpbnZTWCA9IDEgLyBzeDtcclxuXHRcdFx0dmFyIGludlNZID0gMSAvIHN5O1xyXG5cdFx0XHR2YXIgaW52U1ogPSAxIC8gc3o7XHJcblxyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMiBdICo9IGludlNYO1xyXG5cclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNSBdICo9IGludlNZO1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcclxuXHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOCBdICo9IGludlNaO1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xyXG5cclxuXHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0c2NhbGUueCA9IHN4O1xyXG5cdFx0XHRzY2FsZS55ID0gc3k7XHJcblx0XHRcdHNjYWxlLnogPSBzejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bWFrZUZydXN0dW06IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB4ID0gMiAqIG5lYXIgLyAoIHJpZ2h0IC0gbGVmdCApO1xyXG5cdFx0dmFyIHkgPSAyICogbmVhciAvICggdG9wIC0gYm90dG9tICk7XHJcblxyXG5cdFx0dmFyIGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcclxuXHRcdHZhciBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XHJcblx0XHR2YXIgYyA9IC0gKCBmYXIgKyBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcclxuXHRcdHZhciBkID0gLSAyICogZmFyICogbmVhciAvICggZmFyIC0gbmVhciApO1xyXG5cclxuXHRcdHRlWyAwIF0gPSB4O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gYTtcdHRlWyAxMiBdID0gMDtcclxuXHRcdHRlWyAxIF0gPSAwO1x0dGVbIDUgXSA9IHk7XHR0ZVsgOSBdID0gYjtcdHRlWyAxMyBdID0gMDtcclxuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IGM7XHR0ZVsgMTQgXSA9IGQ7XHJcblx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAtIDE7XHR0ZVsgMTUgXSA9IDA7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VQZXJzcGVjdGl2ZTogZnVuY3Rpb24gKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdHZhciB5bWF4ID0gbmVhciAqIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApO1xyXG5cdFx0dmFyIHltaW4gPSAtIHltYXg7XHJcblx0XHR2YXIgeG1pbiA9IHltaW4gKiBhc3BlY3Q7XHJcblx0XHR2YXIgeG1heCA9IHltYXggKiBhc3BlY3Q7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubWFrZUZydXN0dW0oIHhtaW4sIHhtYXgsIHltaW4sIHltYXgsIG5lYXIsIGZhciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgdyA9IHJpZ2h0IC0gbGVmdDtcclxuXHRcdHZhciBoID0gdG9wIC0gYm90dG9tO1xyXG5cdFx0dmFyIHAgPSBmYXIgLSBuZWFyO1xyXG5cclxuXHRcdHZhciB4ID0gKCByaWdodCArIGxlZnQgKSAvIHc7XHJcblx0XHR2YXIgeSA9ICggdG9wICsgYm90dG9tICkgLyBoO1xyXG5cdFx0dmFyIHogPSAoIGZhciArIG5lYXIgKSAvIHA7XHJcblxyXG5cdFx0dGVbIDAgXSA9IDIgLyB3O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gMDtcdHRlWyAxMiBdID0gLSB4O1xyXG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0gMiAvIGg7XHR0ZVsgOSBdID0gMDtcdHRlWyAxMyBdID0gLSB5O1xyXG5cdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gLSAyIC8gcDtcdHRlWyAxNCBdID0gLSB6O1xyXG5cdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gMDtcdHRlWyAxNSBdID0gMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdHRoaXMuZWxlbWVudHMuc2V0KCBhcnJheSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHR0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdLCB0ZVsgMyBdLFxyXG5cdFx0XHR0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdLCB0ZVsgNyBdLFxyXG5cdFx0XHR0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSwgdGVbIDExIF0sXHJcblx0XHRcdHRlWyAxMiBdLCB0ZVsgMTMgXSwgdGVbIDE0IF0sIHRlWyAxNSBdXHJcblx0XHRdO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9SYXkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuVEhSRUUuUmF5ID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcclxuXHJcblx0dGhpcy5vcmlnaW4gPSAoIG9yaWdpbiAhPT0gdW5kZWZpbmVkICkgPyBvcmlnaW4gOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMuZGlyZWN0aW9uID0gKCBkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCApID8gZGlyZWN0aW9uIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5SYXkucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuUmF5LFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5vcmlnaW4uY29weSggb3JpZ2luICk7XHJcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggcmF5ICkge1xyXG5cclxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcclxuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIHJheS5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXQ6IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsb29rQXQ6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCB2ICkuc3ViKCB0aGlzLm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyZWNhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmVzdWx0LnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApO1xyXG5cdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gcmVzdWx0LmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHRpZiAoIGRpcmVjdGlvbkRpc3RhbmNlIDwgMCApIHtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VTcVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gdjEuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICkuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdFx0Ly8gcG9pbnQgYmVoaW5kIHRoZSByYXlcclxuXHJcblx0XHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2MS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHRcdHJldHVybiB2MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGRpc3RhbmNlU3FUb1NlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgc2VnQ2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBzZWdEaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIGRpZmYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHYwLCB2MSwgb3B0aW9uYWxQb2ludE9uUmF5LCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xyXG5cclxuXHRcdFx0Ly8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9MaWJNYXRoZW1hdGljcy9EaXN0YW5jZS9XbTVEaXN0UmF5M1NlZ21lbnQzLmNwcFxyXG5cdFx0XHQvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxyXG5cdFx0XHQvLyBkZWZpbmVkIGJ5IHYwIGFuZCB2MVxyXG5cdFx0XHQvLyBJdCBjYW4gYWxzbyBzZXQgdHdvIG9wdGlvbmFsIHRhcmdldHMgOlxyXG5cdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcclxuXHRcdFx0Ly8gLSBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgc2VnbWVudFxyXG5cclxuXHRcdFx0c2VnQ2VudGVyLmNvcHkoIHYwICkuYWRkKCB2MSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHRcdFx0c2VnRGlyLmNvcHkoIHYxICkuc3ViKCB2MCApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHRkaWZmLmNvcHkoIHRoaXMub3JpZ2luICkuc3ViKCBzZWdDZW50ZXIgKTtcclxuXHJcblx0XHRcdHZhciBzZWdFeHRlbnQgPSB2MC5kaXN0YW5jZVRvKCB2MSApICogMC41O1xyXG5cdFx0XHR2YXIgYTAxID0gLSB0aGlzLmRpcmVjdGlvbi5kb3QoIHNlZ0RpciApO1xyXG5cdFx0XHR2YXIgYjAgPSBkaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHRcdFx0dmFyIGIxID0gLSBkaWZmLmRvdCggc2VnRGlyICk7XHJcblx0XHRcdHZhciBjID0gZGlmZi5sZW5ndGhTcSgpO1xyXG5cdFx0XHR2YXIgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcclxuXHRcdFx0dmFyIHMwLCBzMSwgc3FyRGlzdCwgZXh0RGV0O1xyXG5cclxuXHRcdFx0aWYgKCBkZXQgPiAwICkge1xyXG5cclxuXHRcdFx0XHQvLyBUaGUgcmF5IGFuZCBzZWdtZW50IGFyZSBub3QgcGFyYWxsZWwuXHJcblxyXG5cdFx0XHRcdHMwID0gYTAxICogYjEgLSBiMDtcclxuXHRcdFx0XHRzMSA9IGEwMSAqIGIwIC0gYjE7XHJcblx0XHRcdFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xyXG5cclxuXHRcdFx0XHRpZiAoIHMwID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzMSA+PSAtIGV4dERldCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggczEgPD0gZXh0RGV0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyByZWdpb24gMFxyXG5cdFx0XHRcdFx0XHRcdC8vIE1pbmltdW0gYXQgaW50ZXJpb3IgcG9pbnRzIG9mIHJheSBhbmQgc2VnbWVudC5cclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGludkRldCA9IDEgLyBkZXQ7XHJcblx0XHRcdFx0XHRcdFx0czAgKj0gaW52RGV0O1xyXG5cdFx0XHRcdFx0XHRcdHMxICo9IGludkRldDtcclxuXHRcdFx0XHRcdFx0XHRzcXJEaXN0ID0gczAgKiAoIHMwICsgYTAxICogczEgKyAyICogYjAgKSArIHMxICogKCBhMDEgKiBzMCArIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDFcclxuXHJcblx0XHRcdFx0XHRcdFx0czEgPSBzZWdFeHRlbnQ7XHJcblx0XHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xyXG5cdFx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA1XHJcblxyXG5cdFx0XHRcdFx0XHRzMSA9IC0gc2VnRXh0ZW50O1xyXG5cdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XHJcblx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggczEgPD0gLSBleHREZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gNFxyXG5cclxuXHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIC0gYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xyXG5cdFx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyAtIHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XHJcblx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggczEgPD0gZXh0RGV0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDNcclxuXHJcblx0XHRcdFx0XHRcdHMwID0gMDtcclxuXHRcdFx0XHRcdFx0czEgPSBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xyXG5cdFx0XHRcdFx0XHRzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMlxyXG5cclxuXHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcclxuXHRcdFx0XHRcdFx0czEgPSAoIHMwID4gMCApID8gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcclxuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIFJheSBhbmQgc2VnbWVudCBhcmUgcGFyYWxsZWwuXHJcblxyXG5cdFx0XHRcdHMxID0gKCBhMDEgPiAwICkgPyAtIHNlZ0V4dGVudCA6IHNlZ0V4dGVudDtcclxuXHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XHJcblx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb3B0aW9uYWxQb2ludE9uUmF5ICkge1xyXG5cclxuXHRcdFx0XHRvcHRpb25hbFBvaW50T25SYXkuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggczAgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XHJcblxyXG5cdFx0XHRcdG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weSggc2VnRGlyICkubXVsdGlwbHlTY2FsYXIoIHMxICkuYWRkKCBzZWdDZW50ZXIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBzcXJEaXN0O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aW50ZXJzZWN0U3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBzcGhlcmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0djEuc3ViVmVjdG9ycyggc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4gKTtcclxuXHRcdFx0dmFyIHRjYSA9IHYxLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHRcdFx0dmFyIGQyID0gdjEuZG90KCB2MSApIC0gdGNhICogdGNhO1xyXG5cdFx0XHR2YXIgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdFx0aWYgKCBkMiA+IHJhZGl1czIgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xyXG5cclxuXHRcdFx0Ly8gdDAgPSBmaXJzdCBpbnRlcnNlY3QgcG9pbnQgLSBlbnRyYW5jZSBvbiBmcm9udCBvZiBzcGhlcmVcclxuXHRcdFx0dmFyIHQwID0gdGNhIC0gdGhjO1xyXG5cclxuXHRcdFx0Ly8gdDEgPSBzZWNvbmQgaW50ZXJzZWN0IHBvaW50IC0gZXhpdCBwb2ludCBvbiBiYWNrIG9mIHNwaGVyZVxyXG5cdFx0XHR2YXIgdDEgPSB0Y2EgKyB0aGM7XHJcblxyXG5cdFx0XHQvLyB0ZXN0IHRvIHNlZSBpZiBib3RoIHQwIGFuZCB0MSBhcmUgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcclxuXHRcdFx0aWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHQvLyB0ZXN0IHRvIHNlZSBpZiB0MCBpcyBiZWhpbmQgdGhlIHJheTpcclxuXHRcdFx0Ly8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxyXG5cdFx0XHQvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXHJcblx0XHRcdGlmICggdDAgPCAwICkgcmV0dXJuIHRoaXMuYXQoIHQxLCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHRcdFx0Ly8gZWxzZSB0MCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LCBzbyByZXR1cm4gdGhlIGZpcnN0IGNvbGxpc2lvbiBwb2ludCBzY2FsZWQgYnkgdDBcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIHQwLCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSgpLFxyXG5cclxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSA8PSBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0dmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxyXG5cdFx0XHRpZiAoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBOdWxsIGlzIHByZWZlcmFibGUgdG8gdW5kZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBtZWFucy4uLi4gaXQgaXMgdW5kZWZpbmVkXHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHQgPSAtICggdGhpcy5vcmlnaW4uZG90KCBwbGFuZS5ub3JtYWwgKSArIHBsYW5lLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcclxuXHJcblx0XHQvLyBSZXR1cm4gaWYgdGhlIHJheSBuZXZlciBpbnRlcnNlY3RzIHRoZSBwbGFuZVxyXG5cclxuXHRcdHJldHVybiB0ID49IDAgPyB0IDogIG51bGw7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKCBwbGFuZSApO1xyXG5cclxuXHRcdGlmICggdCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hdCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0fSxcclxuXHJcblxyXG5cclxuXHRpbnRlcnNlY3RzUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxyXG5cclxuXHRcdHZhciBkaXN0VG9Qb2ludCA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHRpZiAoIGRpc3RUb1BvaW50ID09PSAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0aWYgKCBkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByYXkgb3JpZ2luIGlzIGJlaGluZCB0aGUgcGxhbmUgKGFuZCBpcyBwb2ludGluZyBiZWhpbmQgaXQpXHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uICggYm94LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgdG1pbiwgdG1heCwgdHltaW4sIHR5bWF4LCB0em1pbiwgdHptYXg7XHJcblxyXG5cdFx0dmFyIGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcclxuXHRcdFx0aW52ZGlyeSA9IDEgLyB0aGlzLmRpcmVjdGlvbi55LFxyXG5cdFx0XHRpbnZkaXJ6ID0gMSAvIHRoaXMuZGlyZWN0aW9uLno7XHJcblxyXG5cdFx0dmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xyXG5cclxuXHRcdGlmICggaW52ZGlyeCA+PSAwICkge1xyXG5cclxuXHRcdFx0dG1pbiA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XHJcblx0XHRcdHRtYXggPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0bWluID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcclxuXHRcdFx0dG1heCA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggaW52ZGlyeSA+PSAwICkge1xyXG5cclxuXHRcdFx0dHltaW4gPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xyXG5cdFx0XHR0eW1heCA9ICggYm94Lm1heC55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHR5bWluID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcclxuXHRcdFx0dHltYXggPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoICggdG1pbiA+IHR5bWF4ICkgfHwgKCB0eW1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdC8vIFRoZXNlIGxpbmVzIGFsc28gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRtaW4gb3IgdG1heCBpcyBOYU5cclxuXHRcdC8vIChyZXN1bHQgb2YgMCAqIEluZmluaXR5KS4geCAhPT0geCByZXR1cm5zIHRydWUgaWYgeCBpcyBOYU5cclxuXHJcblx0XHRpZiAoIHR5bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR5bWluO1xyXG5cclxuXHRcdGlmICggdHltYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHltYXg7XHJcblxyXG5cdFx0aWYgKCBpbnZkaXJ6ID49IDAgKSB7XHJcblxyXG5cdFx0XHR0em1pbiA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XHJcblx0XHRcdHR6bWF4ID0gKCBib3gubWF4LnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dHptaW4gPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xyXG5cdFx0XHR0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggKCB0bWluID4gdHptYXggKSB8fCAoIHR6bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0aWYgKCB0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcclxuXHJcblx0XHRpZiAoIHR6bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4ICkgdG1heCA9IHR6bWF4O1xyXG5cclxuXHRcdC8vcmV0dXJuIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHJheSAocG9zaXRpdmUgc2lkZSlcclxuXHJcblx0XHRpZiAoIHRtYXggPCAwICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXQoIHRtaW4gPj0gMCA/IHRtaW4gOiB0bWF4LCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KCBib3gsIHYgKSAhPT0gbnVsbDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9ICkoKSxcclxuXHJcblx0aW50ZXJzZWN0VHJpYW5nbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cclxuXHRcdHZhciBkaWZmID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBlZGdlMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgZWRnZTIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYywgYmFja2ZhY2VDdWxsaW5nLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vTGliTWF0aGVtYXRpY3MvSW50ZXJzZWN0aW9uL1dtNUludHJSYXkzVHJpYW5nbGUzLmNwcFxyXG5cclxuXHRcdFx0ZWRnZTEuc3ViVmVjdG9ycyggYiwgYSApO1xyXG5cdFx0XHRlZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XHJcblx0XHRcdG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xyXG5cclxuXHRcdFx0Ly8gU29sdmUgUSArIHQqRCA9IGIxKkUxICsgYjIqRTIgKFEgPSBrRGlmZiwgRCA9IHJheSBkaXJlY3Rpb24sXHJcblx0XHRcdC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcclxuXHRcdFx0Ly8gICB8RG90KEQsTil8KmIxID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoUSxFMikpXHJcblx0XHRcdC8vICAgfERvdChELE4pfCpiMiA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKEUxLFEpKVxyXG5cdFx0XHQvLyAgIHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxyXG5cdFx0XHR2YXIgRGROID0gdGhpcy5kaXJlY3Rpb24uZG90KCBub3JtYWwgKTtcclxuXHRcdFx0dmFyIHNpZ247XHJcblxyXG5cdFx0XHRpZiAoIERkTiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0c2lnbiA9IDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBEZE4gPCAwICkge1xyXG5cclxuXHRcdFx0XHRzaWduID0gLSAxO1xyXG5cdFx0XHRcdERkTiA9IC0gRGROO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XHJcblx0XHRcdHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcclxuXHJcblx0XHRcdC8vIGIxIDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRcdGlmICggRGRReEUyIDwgMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgRGRFMXhRID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTEuY3Jvc3MoIGRpZmYgKSApO1xyXG5cclxuXHRcdFx0Ly8gYjIgPCAwLCBubyBpbnRlcnNlY3Rpb25cclxuXHRcdFx0aWYgKCBEZEUxeFEgPCAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRcdGlmICggRGRReEUyICsgRGRFMXhRID4gRGROICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIExpbmUgaW50ZXJzZWN0cyB0cmlhbmdsZSwgY2hlY2sgaWYgcmF5IGRvZXMuXHJcblx0XHRcdHZhciBRZE4gPSAtIHNpZ24gKiBkaWZmLmRvdCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHQvLyB0IDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRcdGlmICggUWROIDwgMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cclxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xyXG5cclxuXHRcdHRoaXMuZGlyZWN0aW9uLmFkZCggdGhpcy5vcmlnaW4gKS5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcclxuXHRcdHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24uc3ViKCB0aGlzLm9yaWdpbiApO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCByYXkgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHJheS5vcmlnaW4uZXF1YWxzKCB0aGlzLm9yaWdpbiApICYmIHJheS5kaXJlY3Rpb24uZXF1YWxzKCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9TcGhlcmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BoZXJlID0gZnVuY3Rpb24gKCBjZW50ZXIsIHJhZGl1cyApIHtcclxuXHJcblx0dGhpcy5jZW50ZXIgPSAoIGNlbnRlciAhPT0gdW5kZWZpbmVkICkgPyBjZW50ZXIgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcGhlcmUucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuU3BoZXJlLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2VudGVyID0gdGhpcy5jZW50ZXI7XHJcblxyXG5cdFx0XHRpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNlbnRlci5jb3B5KCBvcHRpb25hbENlbnRlciApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ym94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmNlbnRlciggY2VudGVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnRzWyBpIF0gKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5jb3B5KCBzcGhlcmUuY2VudGVyICk7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5yYWRpdXMgPD0gMCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0dmFyIHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNTcGhlcmUoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuXHRcdC8vIFdlIHVzZSB0aGUgZm9sbG93aW5nIGVxdWF0aW9uIHRvIGNvbXB1dGUgdGhlIHNpZ25lZCBkaXN0YW5jZSBmcm9tXHJcblx0XHQvLyB0aGUgY2VudGVyIG9mIHRoZSBzcGhlcmUgdG8gdGhlIHBsYW5lLlxyXG5cdFx0Ly9cclxuXHRcdC8vIGRpc3RhbmNlID0gcSAqIG4gLSBkXHJcblx0XHQvL1xyXG5cdFx0Ly8gSWYgdGhpcyBkaXN0YW5jZSBpcyBncmVhdGVyIHRoYW4gdGhlIHJhZGl1cyBvZiB0aGUgc3BoZXJlLFxyXG5cdFx0Ly8gdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLmNlbnRlci5kb3QoIHBsYW5lLm5vcm1hbCApIC0gcGxhbmUuY29uc3RhbnQgKSA8PSB0aGlzLnJhZGl1cztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXN1bHQuY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcclxuXHJcblx0XHRcdHJlc3VsdC5zdWIoIHRoaXMuY2VudGVyICkubm9ybWFsaXplKCk7XHJcblx0XHRcdHJlc3VsdC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciBib3ggPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuXHRcdGJveC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xyXG5cdFx0Ym94LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xyXG5cclxuXHRcdHJldHVybiBib3g7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHRcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmVxdWFscyggdGhpcy5jZW50ZXIgKSAmJiAoIHNwaGVyZS5yYWRpdXMgPT09IHRoaXMucmFkaXVzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0ZydXN0dW0uanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuVEhSRUUuRnJ1c3R1bSA9IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcclxuXHJcblx0dGhpcy5wbGFuZXMgPSBbXHJcblxyXG5cdFx0KCBwMCAhPT0gdW5kZWZpbmVkICkgPyBwMCA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwMSAhPT0gdW5kZWZpbmVkICkgPyBwMSA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwMiAhPT0gdW5kZWZpbmVkICkgPyBwMiA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwMyAhPT0gdW5kZWZpbmVkICkgPyBwMyA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwNCAhPT0gdW5kZWZpbmVkICkgPyBwNCA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwNSAhPT0gdW5kZWZpbmVkICkgPyBwNSA6IG5ldyBUSFJFRS5QbGFuZSgpXHJcblxyXG5cdF07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRnJ1c3R1bS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5GcnVzdHVtLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcclxuXHJcblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblxyXG5cdFx0cGxhbmVzWyAwIF0uY29weSggcDAgKTtcclxuXHRcdHBsYW5lc1sgMSBdLmNvcHkoIHAxICk7XHJcblx0XHRwbGFuZXNbIDIgXS5jb3B5KCBwMiApO1xyXG5cdFx0cGxhbmVzWyAzIF0uY29weSggcDMgKTtcclxuXHRcdHBsYW5lc1sgNCBdLmNvcHkoIHA0ICk7XHJcblx0XHRwbGFuZXNbIDUgXS5jb3B5KCBwNSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBmcnVzdHVtICkge1xyXG5cclxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0cGxhbmVzWyBpIF0uY29weSggZnJ1c3R1bS5wbGFuZXNbIGkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblx0XHR2YXIgbWUwID0gbWVbIDAgXSwgbWUxID0gbWVbIDEgXSwgbWUyID0gbWVbIDIgXSwgbWUzID0gbWVbIDMgXTtcclxuXHRcdHZhciBtZTQgPSBtZVsgNCBdLCBtZTUgPSBtZVsgNSBdLCBtZTYgPSBtZVsgNiBdLCBtZTcgPSBtZVsgNyBdO1xyXG5cdFx0dmFyIG1lOCA9IG1lWyA4IF0sIG1lOSA9IG1lWyA5IF0sIG1lMTAgPSBtZVsgMTAgXSwgbWUxMSA9IG1lWyAxMSBdO1xyXG5cdFx0dmFyIG1lMTIgPSBtZVsgMTIgXSwgbWUxMyA9IG1lWyAxMyBdLCBtZTE0ID0gbWVbIDE0IF0sIG1lMTUgPSBtZVsgMTUgXTtcclxuXHJcblx0XHRwbGFuZXNbIDAgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTAsIG1lNyAtIG1lNCwgbWUxMSAtIG1lOCwgbWUxNSAtIG1lMTIgKS5ub3JtYWxpemUoKTtcclxuXHRcdHBsYW5lc1sgMSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMCwgbWU3ICsgbWU0LCBtZTExICsgbWU4LCBtZTE1ICsgbWUxMiApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0cGxhbmVzWyAyIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUxLCBtZTcgKyBtZTUsIG1lMTEgKyBtZTksIG1lMTUgKyBtZTEzICkubm9ybWFsaXplKCk7XHJcblx0XHRwbGFuZXNbIDMgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTEsIG1lNyAtIG1lNSwgbWUxMSAtIG1lOSwgbWUxNSAtIG1lMTMgKS5ub3JtYWxpemUoKTtcclxuXHRcdHBsYW5lc1sgNCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMiwgbWU3IC0gbWU2LCBtZTExIC0gbWUxMCwgbWUxNSAtIG1lMTQgKS5ub3JtYWxpemUoKTtcclxuXHRcdHBsYW5lc1sgNSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMiwgbWU3ICsgbWU2LCBtZTExICsgbWUxMCwgbWUxNSArIG1lMTQgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c09iamVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XHJcblx0XHRcdHNwaGVyZS5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblx0XHR2YXIgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcclxuXHRcdHZhciBuZWdSYWRpdXMgPSAtIHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBkaXN0YW5jZSA9IHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggY2VudGVyICk7XHJcblxyXG5cdFx0XHRpZiAoIGRpc3RhbmNlIDwgbmVnUmFkaXVzICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHAxID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0cDIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDYgOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcGxhbmUgPSBwbGFuZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0cDEueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5taW4ueCA6IGJveC5tYXgueDtcclxuXHRcdFx0XHRwMi54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1heC54IDogYm94Lm1pbi54O1xyXG5cdFx0XHRcdHAxLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWluLnkgOiBib3gubWF4Lnk7XHJcblx0XHRcdFx0cDIueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcclxuXHRcdFx0XHRwMS56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1pbi56IDogYm94Lm1heC56O1xyXG5cdFx0XHRcdHAyLnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWF4LnogOiBib3gubWluLno7XHJcblxyXG5cdFx0XHRcdHZhciBkMSA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDEgKTtcclxuXHRcdFx0XHR2YXIgZDIgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAyICk7XHJcblxyXG5cdFx0XHRcdC8vIGlmIGJvdGggb3V0c2lkZSBwbGFuZSwgbm8gaW50ZXJzZWN0aW9uXHJcblxyXG5cdFx0XHRcdGlmICggZDEgPCAwICYmIGQyIDwgMCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1BsYW5lLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLlBsYW5lID0gZnVuY3Rpb24gKCBub3JtYWwsIGNvbnN0YW50ICkge1xyXG5cclxuXHR0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XHJcblx0dGhpcy5jb25zdGFudCA9ICggY29uc3RhbnQgIT09IHVuZGVmaW5lZCApID8gY29uc3RhbnQgOiAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBsYW5lLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlBsYW5lLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcclxuXHJcblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcclxuXHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q29tcG9uZW50czogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMubm9ybWFsLnNldCggeCwgeSwgeiApO1xyXG5cdFx0dGhpcy5jb25zdGFudCA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG5vcm1hbCwgcG9pbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcblx0XHR0aGlzLmNvbnN0YW50ID0gLSBwb2ludC5kb3QoIHRoaXMubm9ybWFsICk7XHQvLyBtdXN0IGJlIHRoaXMubm9ybWFsLCBub3Qgbm9ybWFsLCBhcyB0aGlzLm5vcm1hbCBpcyBub3JtYWxpemVkXHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Db3BsYW5hclBvaW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFsID0gdjEuc3ViVmVjdG9ycyggYywgYiApLmNyb3NzKCB2Mi5zdWJWZWN0b3JzKCBhLCBiICkgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdC8vIFE6IHNob3VsZCBhbiBlcnJvciBiZSB0aHJvd24gaWYgbm9ybWFsIGlzIHplcm8gKGUuZy4gZGVnZW5lcmF0ZSBwbGFuZSk/XHJcblxyXG5cdFx0XHR0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBub3JtYWwsIGEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWwuY29weSggcGxhbmUubm9ybWFsICk7XHJcblx0XHR0aGlzLmNvbnN0YW50ID0gcGxhbmUuY29uc3RhbnQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIE5vdGU6IHdpbGwgbGVhZCB0byBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBwbGFuZSBpcyBpbnZhbGlkLlxyXG5cclxuXHRcdHZhciBpbnZlcnNlTm9ybWFsTGVuZ3RoID0gMS4wIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7XHJcblx0XHR0aGlzLm5vcm1hbC5tdWx0aXBseVNjYWxhciggaW52ZXJzZU5vcm1hbExlbmd0aCApO1xyXG5cdFx0dGhpcy5jb25zdGFudCAqPSBpbnZlcnNlTm9ybWFsTGVuZ3RoO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNvbnN0YW50ICo9IC0gMTtcclxuXHRcdHRoaXMubm9ybWFsLm5lZ2F0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsLmRvdCggcG9pbnQgKSArIHRoaXMuY29uc3RhbnQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIC0gc3BoZXJlLnJhZGl1cztcclxuXHJcblx0fSxcclxuXHJcblx0cHJvamVjdFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vcnRob1BvaW50KCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKS5zdWIoIHBvaW50ICkubmVnYXRlKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9ydGhvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciBwZXJwZW5kaWN1bGFyTWFnbml0dWRlID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICk7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIHBlcnBlbmRpY3VsYXJNYWduaXR1ZGUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0TGluZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xyXG5cclxuXHRcdFx0dmFyIGRlbm9taW5hdG9yID0gdGhpcy5ub3JtYWwuZG90KCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cclxuXHRcdFx0XHRpZiAoIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBsaW5lLnN0YXJ0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gVW5zdXJlIGlmIHRoaXMgaXMgdGhlIGNvcnJlY3QgbWV0aG9kIHRvIGhhbmRsZSB0aGlzIGNhc2UuXHJcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB0ID0gLSAoIGxpbmUuc3RhcnQuZG90KCB0aGlzLm5vcm1hbCApICsgdGhpcy5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XHJcblxyXG5cdFx0XHRpZiAoIHQgPCAwIHx8IHQgPiAxICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBkaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggbGluZS5zdGFydCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aW50ZXJzZWN0c0xpbmU6IGZ1bmN0aW9uICggbGluZSApIHtcclxuXHJcblx0XHQvLyBOb3RlOiB0aGlzIHRlc3RzIGlmIGEgbGluZSBpbnRlcnNlY3RzIHRoZSBwbGFuZSwgbm90IHdoZXRoZXIgaXQgKG9yIGl0cyBlbmQtcG9pbnRzKSBhcmUgY29wbGFuYXIgd2l0aCBpdC5cclxuXHJcblx0XHR2YXIgc3RhcnRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKTtcclxuXHRcdHZhciBlbmRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuZW5kICk7XHJcblxyXG5cdFx0cmV0dXJuICggc3RhcnRTaWduIDwgMCAmJiBlbmRTaWduID4gMCApIHx8ICggZW5kU2lnbiA8IDAgJiYgc3RhcnRTaWduID4gMCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHRyZXR1cm4gc3BoZXJlLmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAtIHRoaXMuY29uc3RhbnQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIG5ldyBub3JtYWwgYmFzZWQgb24gdGhlb3J5IGhlcmU6XHJcblx0XHRcdC8vIGh0dHA6Ly93d3cuc29uZ2hvLmNhL29wZW5nbC9nbF9ub3JtYWx0cmFuc2Zvcm0uaHRtbFxyXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gb3B0aW9uYWxOb3JtYWxNYXRyaXggfHwgbTEuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcclxuXHRcdFx0dmFyIG5ld05vcm1hbCA9IHYxLmNvcHkoIHRoaXMubm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKTtcclxuXHJcblx0XHRcdHZhciBuZXdDb3BsYW5hclBvaW50ID0gdGhpcy5jb3BsYW5hclBvaW50KCB2MiApO1xyXG5cdFx0XHRuZXdDb3BsYW5hclBvaW50LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHR0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBuZXdOb3JtYWwsIG5ld0NvcGxhbmFyUG9pbnQgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLmNvbnN0YW50ID0gdGhpcy5jb25zdGFudCAtIG9mZnNldC5kb3QoIHRoaXMubm9ybWFsICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHRyZXR1cm4gcGxhbmUubm9ybWFsLmVxdWFscyggdGhpcy5ub3JtYWwgKSAmJiAoIHBsYW5lLmNvbnN0YW50ID09PSB0aGlzLmNvbnN0YW50ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL01hdGguanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk1hdGggPSB7XHJcblxyXG5cdGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuYnJvb2ZhLmNvbS9Ub29scy9NYXRoLnV1aWQuaHRtXHJcblxyXG5cdFx0dmFyIGNoYXJzID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jy5zcGxpdCggJycgKTtcclxuXHRcdHZhciB1dWlkID0gbmV3IEFycmF5KCAzNiApO1xyXG5cdFx0dmFyIHJuZCA9IDAsIHI7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDM2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGkgPT09IDggfHwgaSA9PT0gMTMgfHwgaSA9PT0gMTggfHwgaSA9PT0gMjMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dXVpZFsgaSBdID0gJy0nO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpID09PSAxNCApIHtcclxuXHJcblx0XHRcdFx0XHR1dWlkWyBpIF0gPSAnNCc7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBybmQgPD0gMHgwMiApIHJuZCA9IDB4MjAwMDAwMCArICggTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMCApIHwgMDtcclxuXHRcdFx0XHRcdHIgPSBybmQgJiAweGY7XHJcblx0XHRcdFx0XHRybmQgPSBybmQgPj4gNDtcclxuXHRcdFx0XHRcdHV1aWRbIGkgXSA9IGNoYXJzWyAoIGkgPT09IDE5ICkgPyAoIHIgJiAweDMgKSB8IDB4OCA6IHIgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHV1aWQuam9pbiggJycgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsYW1wOiBmdW5jdGlvbiAoIHZhbHVlLCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgdmFsdWUgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBjb21wdXRlIGV1Y2xpZGlhbiBtb2R1bG8gb2YgbSAlIG5cclxuXHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2R1bG9fb3BlcmF0aW9uXHJcblxyXG5cdGV1Y2xpZGVhbk1vZHVsbzogZnVuY3Rpb24gKCBuLCBtICkge1xyXG5cclxuXHRcdHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cclxuXHJcblx0bWFwTGluZWFyOiBmdW5jdGlvbiAoIHgsIGExLCBhMiwgYjEsIGIyICkge1xyXG5cclxuXHRcdHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcclxuXHJcblx0c21vb3Roc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XHJcblx0XHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XHJcblxyXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRyZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XHJcblxyXG5cdFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xyXG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xyXG5cclxuXHRcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XHJcblxyXG5cdFx0cmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcclxuXHJcblx0fSxcclxuXHJcblx0cmFuZG9tMTY6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRoLnJhbmRvbTE2KCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIE1hdGgucmFuZG9tKCkgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gTWF0aC5yYW5kb20oKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxyXG5cclxuXHRyYW5kSW50OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcclxuXHJcblx0XHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxyXG5cclxuXHRyYW5kRmxvYXQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xyXG5cclxuXHRcdHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcclxuXHJcblx0cmFuZEZsb2F0U3ByZWFkOiBmdW5jdGlvbiAoIHJhbmdlICkge1xyXG5cclxuXHRcdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkZWdUb1JhZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkZWdyZWVUb1JhZGlhbnNGYWN0b3IgPSBNYXRoLlBJIC8gMTgwO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZGVncmVlcyAqIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvcjtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJhZFRvRGVnOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlhblRvRGVncmVlc0ZhY3RvciA9IDE4MCAvIE1hdGguUEk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcmFkaWFucyApIHtcclxuXHJcblx0XHRcdHJldHVybiByYWRpYW5zICogcmFkaWFuVG9EZWdyZWVzRmFjdG9yO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWFyZXN0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGgucm91bmQoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZXh0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR2YWx1ZSAtLTtcclxuXHRcdHZhbHVlIHw9IHZhbHVlID4+IDE7XHJcblx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiAyO1xyXG5cdFx0dmFsdWUgfD0gdmFsdWUgPj4gNDtcclxuXHRcdHZhbHVlIHw9IHZhbHVlID4+IDg7XHJcblx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiAxNjtcclxuXHRcdHZhbHVlICsrO1xyXG5cclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvU3BsaW5lLmpzXHJcblxyXG4vKipcclxuICogU3BsaW5lIGZyb20gVHdlZW4uanMsIHNsaWdodGx5IG9wdGltaXplZCAoYW5kIHRyYXNoZWQpXHJcbiAqIGh0dHA6Ly9zb2xlLmdpdGh1Yi5jb20vdHdlZW4uanMvZXhhbXBsZXMvMDVfc3BsaW5lLmh0bWxcclxuICpcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcGxpbmUgPSBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0dGhpcy5wb2ludHMgPSBwb2ludHM7XHJcblxyXG5cdHZhciBjID0gW10sIHYzID0geyB4OiAwLCB5OiAwLCB6OiAwIH0sXHJcblx0cG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3MyxcclxuXHRwYSwgcGIsIHBjLCBwZDtcclxuXHJcblx0dGhpcy5pbml0RnJvbUFycmF5ID0gZnVuY3Rpb24gKCBhICkge1xyXG5cclxuXHRcdHRoaXMucG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnBvaW50c1sgaSBdID0geyB4OiBhWyBpIF1bIDAgXSwgeTogYVsgaSBdWyAxIF0sIHo6IGFbIGkgXVsgMiBdIH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmdldFBvaW50ID0gZnVuY3Rpb24gKCBrICkge1xyXG5cclxuXHRcdHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBrO1xyXG5cdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG5cdFx0d2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcblx0XHRjWyAwIF0gPSBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xyXG5cdFx0Y1sgMSBdID0gaW50UG9pbnQ7XHJcblx0XHRjWyAyIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAyID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMTtcclxuXHRcdGNbIDMgXSA9IGludFBvaW50ICA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDMgPyB0aGlzLnBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyO1xyXG5cclxuXHRcdHBhID0gdGhpcy5wb2ludHNbIGNbIDAgXSBdO1xyXG5cdFx0cGIgPSB0aGlzLnBvaW50c1sgY1sgMSBdIF07XHJcblx0XHRwYyA9IHRoaXMucG9pbnRzWyBjWyAyIF0gXTtcclxuXHRcdHBkID0gdGhpcy5wb2ludHNbIGNbIDMgXSBdO1xyXG5cclxuXHRcdHcyID0gd2VpZ2h0ICogd2VpZ2h0O1xyXG5cdFx0dzMgPSB3ZWlnaHQgKiB3MjtcclxuXHJcblx0XHR2My54ID0gaW50ZXJwb2xhdGUoIHBhLngsIHBiLngsIHBjLngsIHBkLngsIHdlaWdodCwgdzIsIHczICk7XHJcblx0XHR2My55ID0gaW50ZXJwb2xhdGUoIHBhLnksIHBiLnksIHBjLnksIHBkLnksIHdlaWdodCwgdzIsIHczICk7XHJcblx0XHR2My56ID0gaW50ZXJwb2xhdGUoIHBhLnosIHBiLnosIHBjLnosIHBkLnosIHdlaWdodCwgdzIsIHczICk7XHJcblxyXG5cdFx0cmV0dXJuIHYzO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmdldENvbnRyb2xQb2ludHNBcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgaSwgcCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aCxcclxuXHRcdFx0Y29vcmRzID0gW107XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0cCA9IHRoaXMucG9pbnRzWyBpIF07XHJcblx0XHRcdGNvb3Jkc1sgaSBdID0gWyBwLngsIHAueSwgcC56IF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb29yZHM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIGFwcHJveGltYXRlIGxlbmd0aCBieSBzdW1taW5nIGxpbmVhciBzZWdtZW50c1xyXG5cclxuXHR0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uICggblN1YkRpdmlzaW9ucyApIHtcclxuXHJcblx0XHR2YXIgaSwgaW5kZXgsIG5TYW1wbGVzLCBwb3NpdGlvbixcclxuXHRcdFx0cG9pbnQgPSAwLCBpbnRQb2ludCA9IDAsIG9sZEludFBvaW50ID0gMCxcclxuXHRcdFx0b2xkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHR0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRjaHVua0xlbmd0aHMgPSBbXSxcclxuXHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cclxuXHRcdC8vIGZpcnN0IHBvaW50IGhhcyAwIGxlbmd0aFxyXG5cclxuXHRcdGNodW5rTGVuZ3Roc1sgMCBdID0gMDtcclxuXHJcblx0XHRpZiAoICEgblN1YkRpdmlzaW9ucyApIG5TdWJEaXZpc2lvbnMgPSAxMDA7XHJcblxyXG5cdFx0blNhbXBsZXMgPSB0aGlzLnBvaW50cy5sZW5ndGggKiBuU3ViRGl2aXNpb25zO1xyXG5cclxuXHRcdG9sZFBvc2l0aW9uLmNvcHkoIHRoaXMucG9pbnRzWyAwIF0gKTtcclxuXHJcblx0XHRmb3IgKCBpID0gMTsgaSA8IG5TYW1wbGVzOyBpICsrICkge1xyXG5cclxuXHRcdFx0aW5kZXggPSBpIC8gblNhbXBsZXM7XHJcblxyXG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnQoIGluZGV4ICk7XHJcblx0XHRcdHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0dG90YWxMZW5ndGggKz0gdG1wVmVjLmRpc3RhbmNlVG8oIG9sZFBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRvbGRQb3NpdGlvbi5jb3B5KCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0cG9pbnQgPSAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKSAqIGluZGV4O1xyXG5cdFx0XHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XHJcblxyXG5cdFx0XHRpZiAoIGludFBvaW50ICE9PSBvbGRJbnRQb2ludCApIHtcclxuXHJcblx0XHRcdFx0Y2h1bmtMZW5ndGhzWyBpbnRQb2ludCBdID0gdG90YWxMZW5ndGg7XHJcblx0XHRcdFx0b2xkSW50UG9pbnQgPSBpbnRQb2ludDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbGFzdCBwb2ludCBlbmRzIHdpdGggdG90YWwgbGVuZ3RoXHJcblxyXG5cdFx0Y2h1bmtMZW5ndGhzWyBjaHVua0xlbmd0aHMubGVuZ3RoIF0gPSB0b3RhbExlbmd0aDtcclxuXHJcblx0XHRyZXR1cm4geyBjaHVua3M6IGNodW5rTGVuZ3RocywgdG90YWw6IHRvdGFsTGVuZ3RoIH07XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVwYXJhbWV0cml6ZUJ5QXJjTGVuZ3RoID0gZnVuY3Rpb24gKCBzYW1wbGluZ0NvZWYgKSB7XHJcblxyXG5cdFx0dmFyIGksIGosXHJcblx0XHRcdGluZGV4LCBpbmRleEN1cnJlbnQsIGluZGV4TmV4dCxcclxuXHRcdFx0cmVhbERpc3RhbmNlLFxyXG5cdFx0XHRzYW1wbGluZywgcG9zaXRpb24sXHJcblx0XHRcdG5ld3BvaW50cyA9IFtdLFxyXG5cdFx0XHR0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRzbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG5cdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICkuY2xvbmUoKSApO1xyXG5cclxuXHRcdGZvciAoIGkgPSAxOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0Ly90bXBWZWMuY29weSggdGhpcy5wb2ludHNbIGkgLSAxIF0gKTtcclxuXHRcdFx0Ly9saW5lYXJEaXN0YW5jZSA9IHRtcFZlYy5kaXN0YW5jZVRvKCB0aGlzLnBvaW50c1sgaSBdICk7XHJcblxyXG5cdFx0XHRyZWFsRGlzdGFuY2UgPSBzbC5jaHVua3NbIGkgXSAtIHNsLmNodW5rc1sgaSAtIDEgXTtcclxuXHJcblx0XHRcdHNhbXBsaW5nID0gTWF0aC5jZWlsKCBzYW1wbGluZ0NvZWYgKiByZWFsRGlzdGFuY2UgLyBzbC50b3RhbCApO1xyXG5cclxuXHRcdFx0aW5kZXhDdXJyZW50ID0gKCBpIC0gMSApIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XHJcblx0XHRcdGluZGV4TmV4dCA9IGkgLyAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKTtcclxuXHJcblx0XHRcdGZvciAoIGogPSAxOyBqIDwgc2FtcGxpbmcgLSAxOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRpbmRleCA9IGluZGV4Q3VycmVudCArIGogKiAoIDEgLyBzYW1wbGluZyApICogKCBpbmRleE5leHQgLSBpbmRleEN1cnJlbnQgKTtcclxuXHJcblx0XHRcdFx0cG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xyXG5cdFx0XHRcdG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggcG9zaXRpb24gKS5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIF0gKS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMucG9pbnRzID0gbmV3cG9pbnRzO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBDYXRtdWxsLVJvbVxyXG5cclxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSggcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0MyApIHtcclxuXHJcblx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcclxuXHRcdFx0djEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcclxuXHJcblx0XHRyZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvVHJpYW5nbGUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuVHJpYW5nbGUgPSBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XHJcblxyXG5cdHRoaXMuYSA9ICggYSAhPT0gdW5kZWZpbmVkICkgPyBhIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLmIgPSAoIGIgIT09IHVuZGVmaW5lZCApID8gYiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5jID0gKCBjICE9PSB1bmRlZmluZWQgKSA/IGMgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRyaWFuZ2xlLm5vcm1hbCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmVzdWx0LnN1YlZlY3RvcnMoIGMsIGIgKTtcclxuXHRcdHYwLnN1YlZlY3RvcnMoIGEsIGIgKTtcclxuXHRcdHJlc3VsdC5jcm9zcyggdjAgKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0TGVuZ3RoU3EgPSByZXN1bHQubGVuZ3RoU3EoKTtcclxuXHRcdGlmICggcmVzdWx0TGVuZ3RoU3EgPiAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5tdWx0aXBseVNjYWxhciggMSAvIE1hdGguc3FydCggcmVzdWx0TGVuZ3RoU3EgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgMCApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuLy8gc3RhdGljL2luc3RhbmNlIG1ldGhvZCB0byBjYWxjdWxhdGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcclxuLy8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcclxuVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQsIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHYwLnN1YlZlY3RvcnMoIGMsIGEgKTtcclxuXHRcdHYxLnN1YlZlY3RvcnMoIGIsIGEgKTtcclxuXHRcdHYyLnN1YlZlY3RvcnMoIHBvaW50LCBhICk7XHJcblxyXG5cdFx0dmFyIGRvdDAwID0gdjAuZG90KCB2MCApO1xyXG5cdFx0dmFyIGRvdDAxID0gdjAuZG90KCB2MSApO1xyXG5cdFx0dmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xyXG5cdFx0dmFyIGRvdDExID0gdjEuZG90KCB2MSApO1xyXG5cdFx0dmFyIGRvdDEyID0gdjEuZG90KCB2MiApO1xyXG5cclxuXHRcdHZhciBkZW5vbSA9ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHQvLyBjb2xsaW5lYXIgb3Igc2luZ3VsYXIgdHJpYW5nbGVcclxuXHRcdGlmICggZGVub20gPT09IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cclxuXHRcdFx0Ly8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBpZGVhLCBtYXliZSBzaG91bGQgYmUgcmV0dXJuaW5nIHVuZGVmaW5lZFxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggLSAyLCAtIDEsIC0gMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW52RGVub20gPSAxIC8gZGVub207XHJcblx0XHR2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xyXG5cdFx0dmFyIHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcclxuXHJcblx0XHQvLyBiYXJ5Y2VudHJpYyBjb29yZGluYXRlcyBtdXN0IGFsd2F5cyBzdW0gdG8gMVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuVHJpYW5nbGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQsIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIHYxICk7XHJcblxyXG5cdFx0cmV0dXJuICggcmVzdWx0LnggPj0gMCApICYmICggcmVzdWx0LnkgPj0gMCApICYmICggKCByZXN1bHQueCArIHJlc3VsdC55ICkgPD0gMSApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuVHJpYW5nbGUucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVHJpYW5nbGUsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdHRoaXMuYS5jb3B5KCBhICk7XHJcblx0XHR0aGlzLmIuY29weSggYiApO1xyXG5cdFx0dGhpcy5jLmNvcHkoIGMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVBvaW50c0FuZEluZGljZXM6IGZ1bmN0aW9uICggcG9pbnRzLCBpMCwgaTEsIGkyICkge1xyXG5cclxuXHRcdHRoaXMuYS5jb3B5KCBwb2ludHNbIGkwIF0gKTtcclxuXHRcdHRoaXMuYi5jb3B5KCBwb2ludHNbIGkxIF0gKTtcclxuXHRcdHRoaXMuYy5jb3B5KCBwb2ludHNbIGkyIF0gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XHJcblxyXG5cdFx0dGhpcy5hLmNvcHkoIHRyaWFuZ2xlLmEgKTtcclxuXHRcdHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XHJcblx0XHR0aGlzLmMuY29weSggdHJpYW5nbGUuYyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcmVhOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHYwLnN1YlZlY3RvcnMoIHRoaXMuYywgdGhpcy5iICk7XHJcblx0XHRcdHYxLnN1YlZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdjAuY3Jvc3MoIHYxICkubGVuZ3RoKCkgKiAwLjU7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRtaWRwb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKS5hZGQoIHRoaXMuYyApLm11bHRpcGx5U2NhbGFyKCAxIC8gMyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWw6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFRIUkVFLlRyaWFuZ2xlLm5vcm1hbCggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0cGxhbmU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5QbGFuZSgpO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGJhcnljb29yZEZyb21Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHMoIHRoaXMuYSApICYmIHRyaWFuZ2xlLmIuZXF1YWxzKCB0aGlzLmIgKSAmJiB0cmlhbmdsZS5jLmVxdWFscyggdGhpcy5jICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0ludGVycG9sYW50LmpzXHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBvZiBpbnRlcnBvbGFudHMgb3ZlciBwYXJhbWV0cmljIHNhbXBsZXMuXHJcbiAqXHJcbiAqIFRoZSBwYXJhbWV0ZXIgZG9tYWluIGlzIG9uZSBkaW1lbnNpb25hbCwgdHlwaWNhbGx5IHRoZSB0aW1lIG9yIGEgcGF0aFxyXG4gKiBhbG9uZyBhIGN1cnZlIGRlZmluZWQgYnkgdGhlIGRhdGEuXHJcbiAqXHJcbiAqIFRoZSBzYW1wbGUgdmFsdWVzIGNhbiBoYXZlIGFueSBkaW1lbnNpb25hbGl0eSBhbmQgZGVyaXZlZCBjbGFzc2VzIG1heVxyXG4gKiBhcHBseSBzcGVjaWFsIGludGVycHJldGF0aW9ucyB0byB0aGUgZGF0YS5cclxuICpcclxuICogVGhpcyBjbGFzcyBwcm92aWRlcyB0aGUgaW50ZXJ2YWwgc2VlayBpbiBhIFRlbXBsYXRlIE1ldGhvZCwgZGVmZXJyaW5nXHJcbiAqIHRoZSBhY3R1YWwgaW50ZXJwb2xhdGlvbiB0byBkZXJpdmVkIGNsYXNzZXMuXHJcbiAqXHJcbiAqIFRpbWUgY29tcGxleGl0eSBpcyBPKDEpIGZvciBsaW5lYXIgYWNjZXNzIGNyb3NzaW5nIGF0IG1vc3QgdHdvIHBvaW50c1xyXG4gKiBhbmQgTyhsb2cgTikgZm9yIHJhbmRvbSBhY2Nlc3MsIHdoZXJlIE4gaXMgdGhlIG51bWJlciBvZiBwb3NpdGlvbnMuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZXM6XHJcbiAqXHJcbiAqIFx0XHRodHRwOi8vd3d3Lm9vZGVzaWduLmNvbS90ZW1wbGF0ZS1tZXRob2QtcGF0dGVybi5odG1sXHJcbiAqXHJcbiAqIEBhdXRob3IgdHNjaHdcclxuICovXHJcblxyXG5USFJFRS5JbnRlcnBvbGFudCA9IGZ1bmN0aW9uKFxyXG5cdFx0cGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMgPSBwYXJhbWV0ZXJQb3NpdGlvbnM7XHJcblx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xyXG5cclxuXHR0aGlzLnJlc3VsdEJ1ZmZlciA9IHJlc3VsdEJ1ZmZlciAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0cmVzdWx0QnVmZmVyIDogbmV3IHNhbXBsZVZhbHVlcy5jb25zdHJ1Y3Rvciggc2FtcGxlU2l6ZSApO1xyXG5cdHRoaXMuc2FtcGxlVmFsdWVzID0gc2FtcGxlVmFsdWVzO1xyXG5cdHRoaXMudmFsdWVTaXplID0gc2FtcGxlU2l6ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbnRlcnBvbGFudC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5JbnRlcnBvbGFudCxcclxuXHJcblx0ZXZhbHVhdGU6IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHRcdHZhciBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zLFxyXG5cdFx0XHRpMSA9IHRoaXMuX2NhY2hlZEluZGV4LFxyXG5cclxuXHRcdFx0dDEgPSBwcFsgICBpMSAgIF0sXHJcblx0XHRcdHQwID0gcHBbIGkxIC0gMSBdO1xyXG5cclxuXHRcdHZhbGlkYXRlX2ludGVydmFsOiB7XHJcblxyXG5cdFx0XHRzZWVrOiB7XHJcblxyXG5cdFx0XHRcdHZhciByaWdodDtcclxuXHJcblx0XHRcdFx0bGluZWFyX3NjYW46IHtcclxuLy8tIFNlZSBodHRwOi8vanNwZXJmLmNvbS9jb21wYXJpc29uLXRvLXVuZGVmaW5lZC8zXHJcbi8vLSBzbG93ZXIgY29kZTpcclxuLy8tXHJcbi8vLSBcdFx0XHRcdGlmICggdCA+PSB0MSB8fCB0MSA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdFx0Zm9yd2FyZF9zY2FuOiBpZiAoICEgKCB0IDwgdDEgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBnaXZlVXBBdCA9IGkxICsgMjsgOykge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0IDwgdDAgKSBicmVhayBmb3J3YXJkX3NjYW47XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYWZ0ZXIgZW5kXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aTEgPSBwcC5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWZ0ZXJFbmRfKCBpMSAtIDEsIHQsIHQwICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBpMSA9PT0gZ2l2ZVVwQXQgKSBicmVhazsgLy8gdGhpcyBsb29wXHJcblxyXG5cdFx0XHRcdFx0XHRcdHQwID0gdDE7XHJcblx0XHRcdFx0XHRcdFx0dDEgPSBwcFsgKysgaTEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCB0IDwgdDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhcnJpdmVkIGF0IHRoZSBzb3VnaHQgaW50ZXJ2YWxcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrIHNlZWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgaW5kZXhcclxuXHRcdFx0XHRcdFx0cmlnaHQgPSBwcC5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdGJyZWFrIGxpbmVhcl9zY2FuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcbi8vLSBzbG93ZXIgY29kZTpcclxuLy8tXHRcdFx0XHRcdGlmICggdCA8IHQwIHx8IHQwID09PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdFx0XHRpZiAoICEgKCB0ID49IHQwICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBsb29waW5nP1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHQxZ2xvYmFsID0gcHBbIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdCA8IHQxZ2xvYmFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpMSA9IDI7IC8vICsgMSwgdXNpbmcgdGhlIHNjYW4gZm9yIHRoZSBkZXRhaWxzXHJcblx0XHRcdFx0XHRcdFx0dDAgPSB0MWdsb2JhbDtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIGxpbmVhciByZXZlcnNlIHNjYW5cclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBnaXZlVXBBdCA9IGkxIC0gMjsgOykge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYmVmb3JlIHN0YXJ0XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmVmb3JlU3RhcnRfKCAwLCB0LCB0MSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggaTEgPT09IGdpdmVVcEF0ICkgYnJlYWs7IC8vIHRoaXMgbG9vcFxyXG5cclxuXHRcdFx0XHRcdFx0XHR0MSA9IHQwO1xyXG5cdFx0XHRcdFx0XHRcdHQwID0gcHBbIC0tIGkxIC0gMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHQgPj0gdDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhcnJpdmVkIGF0IHRoZSBzb3VnaHQgaW50ZXJ2YWxcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrIHNlZWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBpbmRleFxyXG5cdFx0XHRcdFx0XHRyaWdodCA9IGkxO1xyXG5cdFx0XHRcdFx0XHRpMSA9IDA7XHJcblx0XHRcdFx0XHRcdGJyZWFrIGxpbmVhcl9zY2FuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyB0aGUgaW50ZXJ2YWwgaXMgdmFsaWRcclxuXHJcblx0XHRcdFx0XHRicmVhayB2YWxpZGF0ZV9pbnRlcnZhbDtcclxuXHJcblx0XHRcdFx0fSAvLyBsaW5lYXIgc2NhblxyXG5cclxuXHRcdFx0XHQvLyBiaW5hcnkgc2VhcmNoXHJcblxyXG5cdFx0XHRcdHdoaWxlICggaTEgPCByaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgbWlkID0gKCBpMSArIHJpZ2h0ICkgPj4+IDE7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0IDwgcHBbIG1pZCBdICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cmlnaHQgPSBtaWQ7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGkxID0gbWlkICsgMTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dDEgPSBwcFsgICBpMSAgIF07XHJcblx0XHRcdFx0dDAgPSBwcFsgaTEgLSAxIF07XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrIGJvdW5kYXJ5IGNhc2VzLCBhZ2FpblxyXG5cclxuXHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmVmb3JlU3RhcnRfKCAwLCB0LCB0MSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdDEgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRpMSA9IHBwLmxlbmd0aDtcclxuXHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hZnRlckVuZF8oIGkxIC0gMSwgdDAsIHQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSAvLyBzZWVrXHJcblxyXG5cdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xyXG5cclxuXHRcdFx0dGhpcy5pbnRlcnZhbENoYW5nZWRfKCBpMSwgdDAsIHQxICk7XHJcblxyXG5cdFx0fSAvLyB2YWxpZGF0ZV9pbnRlcnZhbFxyXG5cclxuXHRcdHJldHVybiB0aGlzLmludGVycG9sYXRlXyggaTEsIHQwLCB0LCB0MSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXR0aW5nczogbnVsbCwgLy8gb3B0aW9uYWwsIHN1YmNsYXNzLXNwZWNpZmljIHNldHRpbmdzIHN0cnVjdHVyZVxyXG5cdC8vIE5vdGU6IFRoZSBpbmRpcmVjdGlvbiBhbGxvd3MgY2VudHJhbCBjb250cm9sIG9mIG1hbnkgaW50ZXJwb2xhbnRzLlxyXG5cclxuXHQvLyAtLS0gUHJvdGVjdGVkIGludGVyZmFjZVxyXG5cclxuXHREZWZhdWx0U2V0dGluZ3NfOiB7fSxcclxuXHJcblx0Z2V0U2V0dGluZ3NfOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncyB8fCB0aGlzLkRlZmF1bHRTZXR0aW5nc187XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlTYW1wbGVWYWx1ZV86IGZ1bmN0aW9uKCBpbmRleCApIHtcclxuXHJcblx0XHQvLyBjb3BpZXMgYSBzYW1wbGUgdmFsdWUgdG8gdGhlIHJlc3VsdCBidWZmZXJcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXHJcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcclxuXHRcdFx0b2Zmc2V0ID0gaW5kZXggKiBzdHJpZGU7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHRbIGkgXSA9IHZhbHVlc1sgb2Zmc2V0ICsgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBUZW1wbGF0ZSBtZXRob2RzIGZvciBkZXJpdmVkIGNsYXNzZXM6XHJcblxyXG5cdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XHJcblxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcImNhbGwgdG8gYWJzdHJhY3QgbWV0aG9kXCIgKTtcclxuXHRcdC8vIGltcGxlbWVudGF0aW9ucyBzaGFsbCByZXR1cm4gdGhpcy5yZXN1bHRCdWZmZXJcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJ2YWxDaGFuZ2VkXzogZnVuY3Rpb24oIGkxLCB0MCwgdDEgKSB7XHJcblxyXG5cdFx0Ly8gZW1wdHlcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5hc3NpZ24oIFRIUkVFLkludGVycG9sYW50LnByb3RvdHlwZSwge1xyXG5cclxuXHRiZWZvcmVTdGFydF86IC8vKCAwLCB0LCB0MCApLCByZXR1cm5zIHRoaXMucmVzdWx0QnVmZmVyXHJcblx0XHRUSFJFRS5JbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXyxcclxuXHJcblx0YWZ0ZXJFbmRfOiAvLyggTi0xLCB0Ti0xLCB0ICksIHJldHVybnMgdGhpcy5yZXN1bHRCdWZmZXJcclxuXHRcdFRIUkVFLkludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfXHJcblxyXG59ICk7XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL2ludGVycG9sYW50cy9DdWJpY0ludGVycG9sYW50LmpzXHJcblxyXG4vKipcclxuICogRmFzdCBhbmQgc2ltcGxlIGN1YmljIHNwbGluZSBpbnRlcnBvbGFudC5cclxuICpcclxuICogSXQgd2FzIGRlcml2ZWQgZnJvbSBhIEhlcm1pdGlhbiBjb25zdHJ1Y3Rpb24gc2V0dGluZyB0aGUgZmlyc3QgZGVyaXZhdGl2ZVxyXG4gKiBhdCBlYWNoIHNhbXBsZSBwb3NpdGlvbiB0byB0aGUgbGluZWFyIHNsb3BlIGJldHdlZW4gbmVpZ2hib3JpbmcgcG9zaXRpb25zXHJcbiAqIG92ZXIgdGhlaXIgcGFyYW1ldGVyIGludGVydmFsLlxyXG4gKlxyXG4gKiBAYXV0aG9yIHRzY2h3XHJcbiAqL1xyXG5cclxuVEhSRUUuQ3ViaWNJbnRlcnBvbGFudCA9IGZ1bmN0aW9uKFxyXG5cdFx0cGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcclxuXHJcblx0VEhSRUUuSW50ZXJwb2xhbnQuY2FsbChcclxuXHRcdFx0dGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xyXG5cclxuXHR0aGlzLl93ZWlnaHRQcmV2ID0gLTA7XHJcblx0dGhpcy5fb2Zmc2V0UHJldiA9IC0wO1xyXG5cdHRoaXMuX3dlaWdodE5leHQgPSAtMDtcclxuXHR0aGlzLl9vZmZzZXROZXh0ID0gLTA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViaWNJbnRlcnBvbGFudC5wcm90b3R5cGUgPVxyXG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVEhSRUUuSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkN1YmljSW50ZXJwb2xhbnQsXHJcblxyXG5cdERlZmF1bHRTZXR0aW5nc186IHtcclxuXHJcblx0XHRlbmRpbmdTdGFydDogXHRUSFJFRS5aZXJvQ3VydmF0dXJlRW5kaW5nLFxyXG5cdFx0ZW5kaW5nRW5kOlx0XHRUSFJFRS5aZXJvQ3VydmF0dXJlRW5kaW5nXHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVydmFsQ2hhbmdlZF86IGZ1bmN0aW9uKCBpMSwgdDAsIHQxICkge1xyXG5cclxuXHRcdHZhciBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zLFxyXG5cdFx0XHRpUHJldiA9IGkxIC0gMixcclxuXHRcdFx0aU5leHQgPSBpMSArIDEsXHJcblxyXG5cdFx0XHR0UHJldiA9IHBwWyBpUHJldiBdLFxyXG5cdFx0XHR0TmV4dCA9IHBwWyBpTmV4dCBdO1xyXG5cclxuXHRcdGlmICggdFByZXYgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHN3aXRjaCAoIHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nU3RhcnQgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuWmVyb1Nsb3BlRW5kaW5nOlxyXG5cclxuXHRcdFx0XHRcdC8vIGYnKHQwKSA9IDBcclxuXHRcdFx0XHRcdGlQcmV2ID0gaTE7XHJcblx0XHRcdFx0XHR0UHJldiA9IDIgKiB0MCAtIHQxO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLldyYXBBcm91bmRFbmRpbmc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXHJcblx0XHRcdFx0XHRpUHJldiA9IHBwLmxlbmd0aCAtIDI7XHJcblx0XHRcdFx0XHR0UHJldiA9IHQwICsgcHBbIGlQcmV2IF0gLSBwcFsgaVByZXYgKyAxIF07XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6IC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcclxuXHJcblx0XHRcdFx0XHQvLyBmJycodDApID0gMCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcclxuXHRcdFx0XHRcdGlQcmV2ID0gaTE7XHJcblx0XHRcdFx0XHR0UHJldiA9IHQxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHROZXh0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ0VuZCApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5aZXJvU2xvcGVFbmRpbmc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gZicodE4pID0gMFxyXG5cdFx0XHRcdFx0aU5leHQgPSBpMTtcclxuXHRcdFx0XHRcdHROZXh0ID0gMiAqIHQxIC0gdDA7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuV3JhcEFyb3VuZEVuZGluZzpcclxuXHJcblx0XHRcdFx0XHQvLyB1c2UgdGhlIG90aGVyIGVuZCBvZiB0aGUgY3VydmVcclxuXHRcdFx0XHRcdGlOZXh0ID0gMTtcclxuXHRcdFx0XHRcdHROZXh0ID0gdDEgKyBwcFsgMSBdIC0gcHBbIDAgXTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDogLy8gWmVyb0N1cnZhdHVyZUVuZGluZ1xyXG5cclxuXHRcdFx0XHRcdC8vIGYnJyh0TikgPSAwLCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcclxuXHRcdFx0XHRcdGlOZXh0ID0gaTEgLSAxO1xyXG5cdFx0XHRcdFx0dE5leHQgPSB0MDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGhhbGZEdCA9ICggdDEgLSB0MCApICogMC41LFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcclxuXHJcblx0XHR0aGlzLl93ZWlnaHRQcmV2ID0gaGFsZkR0IC8gKCB0MCAtIHRQcmV2ICk7XHJcblx0XHR0aGlzLl93ZWlnaHROZXh0ID0gaGFsZkR0IC8gKCB0TmV4dCAtIHQxICk7XHJcblx0XHR0aGlzLl9vZmZzZXRQcmV2ID0gaVByZXYgKiBzdHJpZGU7XHJcblx0XHR0aGlzLl9vZmZzZXROZXh0ID0gaU5leHQgKiBzdHJpZGU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxyXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcclxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXHJcblxyXG5cdFx0XHRvMSA9IGkxICogc3RyaWRlLFx0XHRvMCA9IG8xIC0gc3RyaWRlLFxyXG5cdFx0XHRvUCA9IHRoaXMuX29mZnNldFByZXYsIFx0b04gPSB0aGlzLl9vZmZzZXROZXh0LFxyXG5cdFx0XHR3UCA9IHRoaXMuX3dlaWdodFByZXYsXHR3TiA9IHRoaXMuX3dlaWdodE5leHQsXHJcblxyXG5cdFx0XHRwID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxyXG5cdFx0XHRwcCA9IHAgKiBwLFxyXG5cdFx0XHRwcHAgPSBwcCAqIHA7XHJcblxyXG5cdFx0Ly8gZXZhbHVhdGUgcG9seW5vbWlhbHNcclxuXHJcblx0XHR2YXIgc1AgPSAgICAgLSB3UCAgICogcHBwICAgKyAgICAgICAgIDIgKiB3UCAgICAqIHBwICAgIC0gICAgICAgICAgd1AgICAqIHA7XHJcblx0XHR2YXIgczAgPSAoIDEgKyB3UCApICogcHBwICAgKyAoLTEuNSAtIDIgKiB3UCApICAqIHBwICAgICsgKCAtMC41ICsgd1AgKSAqIHAgICAgICsgMTtcclxuXHRcdHZhciBzMSA9ICgtMSAtIHdOICkgKiBwcHAgICArICggMS41ICsgICB3TiAgICkgICogcHAgICAgKyAgICAwLjUgICAgICAgICogcDtcclxuXHRcdHZhciBzTiA9ICAgICAgIHdOICAgKiBwcHAgICAtICAgICAgICAgICB3TiAgICAgICogcHA7XHJcblxyXG5cdFx0Ly8gY29tYmluZSBkYXRhIGxpbmVhcmx5XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHRbIGkgXSA9XHJcblx0XHRcdFx0XHRzUCAqIHZhbHVlc1sgb1AgKyBpIF0gK1xyXG5cdFx0XHRcdFx0czAgKiB2YWx1ZXNbIG8wICsgaSBdICtcclxuXHRcdFx0XHRcdHMxICogdmFsdWVzWyBvMSArIGkgXSArXHJcblx0XHRcdFx0XHRzTiAqIHZhbHVlc1sgb04gKyBpIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvaW50ZXJwb2xhbnRzL0Rpc2NyZXRlSW50ZXJwb2xhbnQuanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBJbnRlcnBvbGFudCB0aGF0IGV2YWx1YXRlcyB0byB0aGUgc2FtcGxlIHZhbHVlIGF0IHRoZSBwb3NpdGlvbiBwcmVjZWVkaW5nXHJcbiAqIHRoZSBwYXJhbWV0ZXIuXHJcbiAqXHJcbiAqIEBhdXRob3IgdHNjaHdcclxuICovXHJcblxyXG5USFJFRS5EaXNjcmV0ZUludGVycG9sYW50ID0gZnVuY3Rpb24oXHJcblx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xyXG5cclxuXHRUSFJFRS5JbnRlcnBvbGFudC5jYWxsKFxyXG5cdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGlzY3JldGVJbnRlcnBvbGFudC5wcm90b3R5cGUgPVxyXG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVEhSRUUuSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkRpc2NyZXRlSW50ZXJwb2xhbnQsXHJcblxyXG5cdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggaTEgLSAxICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvaW50ZXJwb2xhbnRzL0xpbmVhckludGVycG9sYW50LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0c2Nod1xyXG4gKi9cclxuXHJcblRIUkVFLkxpbmVhckludGVycG9sYW50ID0gZnVuY3Rpb24oXHJcblx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xyXG5cclxuXHRUSFJFRS5JbnRlcnBvbGFudC5jYWxsKFxyXG5cdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZWFySW50ZXJwb2xhbnQucHJvdG90eXBlID1cclxuXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFRIUkVFLkludGVycG9sYW50LnByb3RvdHlwZSApLCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5MaW5lYXJJbnRlcnBvbGFudCxcclxuXHJcblx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiggaTEsIHQwLCB0LCB0MSApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXHJcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcclxuXHJcblx0XHRcdG9mZnNldDEgPSBpMSAqIHN0cmlkZSxcclxuXHRcdFx0b2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUsXHJcblxyXG5cdFx0XHR3ZWlnaHQxID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxyXG5cdFx0XHR3ZWlnaHQwID0gMSAtIHdlaWdodDE7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHRbIGkgXSA9XHJcblx0XHRcdFx0XHR2YWx1ZXNbIG9mZnNldDAgKyBpIF0gKiB3ZWlnaHQwICtcclxuXHRcdFx0XHRcdHZhbHVlc1sgb2Zmc2V0MSArIGkgXSAqIHdlaWdodDE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvaW50ZXJwb2xhbnRzL1F1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudC5qc1xyXG5cclxuLyoqXHJcbiAqIFNwaGVyaWNhbCBsaW5lYXIgdW5pdCBxdWF0ZXJuaW9uIGludGVycG9sYW50LlxyXG4gKlxyXG4gKiBAYXV0aG9yIHRzY2h3XHJcbiAqL1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50ID0gZnVuY3Rpb24oXHJcblx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xyXG5cclxuXHRUSFJFRS5JbnRlcnBvbGFudC5jYWxsKFxyXG5cdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LnByb3RvdHlwZSA9XHJcblx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBUSFJFRS5JbnRlcnBvbGFudC5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LFxyXG5cclxuXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uKCBpMSwgdDAsIHQsIHQxICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcclxuXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXHJcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxyXG5cclxuXHRcdFx0b2Zmc2V0ID0gaTEgKiBzdHJpZGUsXHJcblxyXG5cdFx0XHRhbHBoYSA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgZW5kID0gb2Zmc2V0ICsgc3RyaWRlOyBvZmZzZXQgIT09IGVuZDsgb2Zmc2V0ICs9IDQgKSB7XHJcblxyXG5cdFx0XHRUSFJFRS5RdWF0ZXJuaW9uLnNsZXJwRmxhdCggcmVzdWx0LCAwLFxyXG5cdFx0XHRcdFx0dmFsdWVzLCBvZmZzZXQgLSBzdHJpZGUsIHZhbHVlcywgb2Zmc2V0LCBhbHBoYSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0Nsb2NrLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DbG9jayA9IGZ1bmN0aW9uICggYXV0b1N0YXJ0ICkge1xyXG5cclxuXHR0aGlzLmF1dG9TdGFydCA9ICggYXV0b1N0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IGF1dG9TdGFydCA6IHRydWU7XHJcblxyXG5cdHRoaXMuc3RhcnRUaW1lID0gMDtcclxuXHR0aGlzLm9sZFRpbWUgPSAwO1xyXG5cdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xyXG5cclxuXHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DbG9jay5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5DbG9jayxcclxuXHJcblx0c3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuXHRcdHRoaXMub2xkVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xyXG5cdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZ2V0RWxhcHNlZFRpbWUoKTtcclxuXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRFbGFwc2VkVGltZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZ2V0RGVsdGEoKTtcclxuXHRcdHJldHVybiB0aGlzLmVsYXBzZWRUaW1lO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXREZWx0YTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkaWZmID0gMDtcclxuXHJcblx0XHRpZiAoIHRoaXMuYXV0b1N0YXJ0ICYmICEgdGhpcy5ydW5uaW5nICkge1xyXG5cclxuXHRcdFx0dGhpcy5zdGFydCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMucnVubmluZyApIHtcclxuXHJcblx0XHRcdHZhciBuZXdUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcblxyXG5cdFx0XHRkaWZmID0gMC4wMDEgKiAoIG5ld1RpbWUgLSB0aGlzLm9sZFRpbWUgKTtcclxuXHRcdFx0dGhpcy5vbGRUaW1lID0gbmV3VGltZTtcclxuXHJcblx0XHRcdHRoaXMuZWxhcHNlZFRpbWUgKz0gZGlmZjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRpZmY7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0V2ZW50RGlzcGF0Y2hlci5qc1xyXG5cclxuLyoqXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xyXG4gKi9cclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkV2ZW50RGlzcGF0Y2hlcixcclxuXHJcblx0YXBwbHk6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdG9iamVjdC5hZGRFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xyXG5cdFx0b2JqZWN0Lmhhc0V2ZW50TGlzdGVuZXIgPSBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmhhc0V2ZW50TGlzdGVuZXI7XHJcblx0XHRvYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50ID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50O1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuXHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cclxuXHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLSAxICkge1xyXG5cclxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGhhc0V2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cclxuXHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyB0eXBlIF07XHJcblxyXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5kZXggPSBsaXN0ZW5lckFycmF5LmluZGV4T2YoIGxpc3RlbmVyICk7XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdGxpc3RlbmVyQXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0ZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xyXG5cclxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcztcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IFtdO1xyXG5cdFx0XHR2YXIgbGVuZ3RoID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGFycmF5WyBpIF0gPSBsaXN0ZW5lckFycmF5WyBpIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0xheWVycy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGF5ZXJzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLm1hc2sgPSAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxheWVycy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5MYXllcnMsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBjaGFubmVsICkge1xyXG5cclxuXHRcdHRoaXMubWFzayA9IDEgPDwgY2hhbm5lbDtcclxuXHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG5cdFx0dGhpcy5tYXNrIHw9IDEgPDwgY2hhbm5lbDtcclxuXHJcblx0fSxcclxuXHJcblx0dG9nZ2xlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG5cdFx0dGhpcy5tYXNrIF49IDEgPDwgY2hhbm5lbDtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xyXG5cclxuXHRcdHRoaXMubWFzayAmPSB+ICggMSA8PCBjaGFubmVsICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRlc3Q6IGZ1bmN0aW9uICggbGF5ZXJzICkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMubWFzayAmIGxheWVycy5tYXNrICkgIT09IDA7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL1JheWNhc3Rlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3Igc3RlcGhvbWkgLyBodHRwOi8vc3RlcGhhbmVnaW5pZXIuY29tL1xyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24gKCBUSFJFRSApIHtcclxuXHJcblx0VEhSRUUuUmF5Y2FzdGVyID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdHRoaXMucmF5ID0gbmV3IFRIUkVFLlJheSggb3JpZ2luLCBkaXJlY3Rpb24gKTtcclxuXHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXHJcblxyXG5cdFx0dGhpcy5uZWFyID0gbmVhciB8fCAwO1xyXG5cdFx0dGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XHJcblxyXG5cdFx0dGhpcy5wYXJhbXMgPSB7XHJcblx0XHRcdE1lc2g6IHt9LFxyXG5cdFx0XHRMaW5lOiB7fSxcclxuXHRcdFx0TE9EOiB7fSxcclxuXHRcdFx0UG9pbnRzOiB7IHRocmVzaG9sZDogMSB9LFxyXG5cdFx0XHRTcHJpdGU6IHt9XHJcblx0XHR9O1xyXG5cclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLnBhcmFtcywge1xyXG5cdFx0XHRQb2ludENsb3VkOiB7XHJcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXI6IHBhcmFtcy5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gcGFyYW1zLlBvaW50cy4nICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5Qb2ludHM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGFzY1NvcnQoIGEsIGIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGludGVyc2VjdE9iamVjdCggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRvYmplY3QucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XHJcblxyXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdHJ1ZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHRUSFJFRS5SYXljYXN0ZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5SYXljYXN0ZXIsXHJcblxyXG5cdFx0bGluZVByZWNpc2lvbjogMSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0XHQvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxyXG5cclxuXHRcdFx0dGhpcy5yYXkuc2V0KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RnJvbUNhbWVyYTogZnVuY3Rpb24gKCBjb29yZHMsIGNhbWVyYSApIHtcclxuXHJcblx0XHRcdGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgMC41ICkudW5wcm9qZWN0KCBjYW1lcmEgKS5zdWIoIHRoaXMucmF5Lm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnJheS5vcmlnaW4uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIC0gMSApLnVucHJvamVjdCggY2FtZXJhICk7XHJcblx0XHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5SYXljYXN0ZXI6IFVuc3VwcG9ydGVkIGNhbWVyYSB0eXBlLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGludGVyc2VjdE9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRcdHZhciBpbnRlcnNlY3RzID0gW107XHJcblxyXG5cdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0XHRpbnRlcnNlY3RzLnNvcnQoIGFzY1NvcnQgKTtcclxuXHJcblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0aW50ZXJzZWN0T2JqZWN0czogZnVuY3Rpb24gKCBvYmplY3RzLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xyXG5cclxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmplY3RzICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0czogb2JqZWN0cyBpcyBub3QgYW4gQXJyYXkuJyApO1xyXG5cdFx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpbnRlcnNlY3RzLnNvcnQoIGFzY1NvcnQgKTtcclxuXHJcblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn0oIFRIUkVFICkgKTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvT2JqZWN0M0QuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBlbGVwaGFudGF0d29yayAvIHd3dy5lbGVwaGFudGF0d29yay5jaFxyXG4gKi9cclxuXHJcblRIUkVFLk9iamVjdDNEID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLk9iamVjdDNESWRDb3VudCArKyB9ICk7XHJcblxyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cdHRoaXMudHlwZSA9ICdPYmplY3QzRCc7XHJcblxyXG5cdHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHR0aGlzLmNoaWxkcmVuID0gW107XHJcblxyXG5cdHRoaXMudXAgPSBUSFJFRS5PYmplY3QzRC5EZWZhdWx0VXAuY2xvbmUoKTtcclxuXHJcblx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgcm90YXRpb24gPSBuZXcgVEhSRUUuRXVsZXIoKTtcclxuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblx0dmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKTtcclxuXHJcblx0ZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcclxuXHJcblx0XHRxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggcm90YXRpb24sIGZhbHNlICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25RdWF0ZXJuaW9uQ2hhbmdlKCkge1xyXG5cclxuXHRcdHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlICk7XHJcblxyXG5cdH1cclxuXHJcblx0cm90YXRpb24ub25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcclxuXHRxdWF0ZXJuaW9uLm9uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcclxuXHRcdHBvc2l0aW9uOiB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdHZhbHVlOiBwb3NpdGlvblxyXG5cdFx0fSxcclxuXHRcdHJvdGF0aW9uOiB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdHZhbHVlOiByb3RhdGlvblxyXG5cdFx0fSxcclxuXHRcdHF1YXRlcm5pb246IHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0dmFsdWU6IHF1YXRlcm5pb25cclxuXHRcdH0sXHJcblx0XHRzY2FsZToge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHR2YWx1ZTogc2NhbGVcclxuXHRcdH0sXHJcblx0XHRtb2RlbFZpZXdNYXRyaXg6IHtcclxuXHRcdFx0dmFsdWU6IG5ldyBUSFJFRS5NYXRyaXg0KClcclxuXHRcdH0sXHJcblx0XHRub3JtYWxNYXRyaXg6IHtcclxuXHRcdFx0dmFsdWU6IG5ldyBUSFJFRS5NYXRyaXgzKClcclxuXHRcdH1cclxuXHR9ICk7XHJcblxyXG5cdHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdHRoaXMubWF0cml4V29ybGQgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBUSFJFRS5PYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZTtcclxuXHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5sYXllcnMgPSBuZXcgVEhSRUUuTGF5ZXJzKCk7XHJcblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XHJcblx0dGhpcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XHJcblx0dGhpcy5yZW5kZXJPcmRlciA9IDA7XHJcblxyXG5cdHRoaXMudXNlckRhdGEgPSB7fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5PYmplY3QzRC5EZWZhdWx0VXAgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5USFJFRS5PYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XHJcblxyXG5USFJFRS5PYmplY3QzRC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3QzRCxcclxuXHJcblx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuXHRcdHRoaXMubWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIsIHRydWUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Um90YXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIHEgaXMgbm9ybWFsaXplZFxyXG5cclxuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiBvYmplY3Qgc3BhY2VcclxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0dmFyIHExID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHRcdHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XHJcblxyXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoIHExICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2VcclxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBheGlzLCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdHYxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xyXG5cclxuXHRcdFx0dGhpcy5wb3NpdGlvbi5hZGQoIHYxLm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGxvY2FsVG9Xb3JsZDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0d29ybGRUb0xvY2FsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggbTEuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBUaGlzIHJvdXRpbmUgZG9lcyBub3Qgc3VwcG9ydCBvYmplY3RzIHdpdGggcm90YXRlZCBhbmQvb3IgdHJhbnNsYXRlZCBwYXJlbnQocylcclxuXHJcblx0XHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRcdG0xLmxvb2tBdCggdmVjdG9yLCB0aGlzLnBvc2l0aW9uLCB0aGlzLnVwICk7XHJcblxyXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hZGQoIGFyZ3VtZW50c1sgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLlwiLCBvYmplY3QgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuT2JqZWN0M0QgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5wYXJlbnQucmVtb3ZlKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xyXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnYWRkZWQnIH0gKTtcclxuXHJcblx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELlwiLCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcclxuXHJcblx0XHRcdG9iamVjdC5wYXJlbnQgPSBudWxsO1xyXG5cclxuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3JlbW92ZWQnIH0gKTtcclxuXHJcblx0XHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0T2JqZWN0QnlJZDogZnVuY3Rpb24gKCBpZCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRPYmplY3RCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0T2JqZWN0QnlQcm9wZXJ0eTogZnVuY3Rpb24gKCBuYW1lLCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XHJcblx0XHRcdHZhciBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0V29ybGRQb3NpdGlvbjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0V29ybGRRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcmVzdWx0LCBzY2FsZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGdldFdvcmxkUm90YXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkV1bGVyKCk7XHJcblxyXG5cdFx0XHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdGhpcy5yb3RhdGlvbi5vcmRlciwgZmFsc2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHJlc3VsdCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJheWNhc3Q6IGZ1bmN0aW9uICgpIHt9LFxyXG5cclxuXHR0cmF2ZXJzZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHRjYWxsYmFjayggdGhpcyApO1xyXG5cclxuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR0cmF2ZXJzZVZpc2libGU6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XHJcblxyXG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcblxyXG5cdFx0aWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjYWxsYmFjayggcGFyZW50ICk7XHJcblxyXG5cdFx0XHRwYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVNYXRyaXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLm1hdHJpeC5jb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24gKCBmb3JjZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPT09IHRydWUgfHwgZm9yY2UgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3JjZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuY2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuXHRcdHZhciBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCApO1xyXG5cclxuXHRcdHZhciBvdXRwdXQgPSB7fTtcclxuXHJcblx0XHQvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxyXG5cdFx0Ly8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3RcclxuXHRcdC8vIGJlaW5nIHNlcmlhbGl6ZWQuXHJcblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcclxuXHJcblx0XHRcdC8vIGluaXRpYWxpemUgbWV0YSBvYmpcclxuXHRcdFx0bWV0YSA9IHtcclxuXHRcdFx0XHRnZW9tZXRyaWVzOiB7fSxcclxuXHRcdFx0XHRtYXRlcmlhbHM6IHt9LFxyXG5cdFx0XHRcdHRleHR1cmVzOiB7fSxcclxuXHRcdFx0XHRpbWFnZXM6IHt9XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRvdXRwdXQubWV0YWRhdGEgPSB7XHJcblx0XHRcdFx0dmVyc2lvbjogNC40LFxyXG5cdFx0XHRcdHR5cGU6ICdPYmplY3QnLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc3RhbmRhcmQgT2JqZWN0M0Qgc2VyaWFsaXphdGlvblxyXG5cclxuXHRcdHZhciBvYmplY3QgPSB7fTtcclxuXHJcblx0XHRvYmplY3QudXVpZCA9IHRoaXMudXVpZDtcclxuXHRcdG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xyXG5cclxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIG9iamVjdC5uYW1lID0gdGhpcy5uYW1lO1xyXG5cdFx0aWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy51c2VyRGF0YSApICE9PSAne30nICkgb2JqZWN0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcclxuXHRcdGlmICggdGhpcy5jYXN0U2hhZG93ID09PSB0cnVlICkgb2JqZWN0LmNhc3RTaGFkb3cgPSB0cnVlO1xyXG5cdFx0aWYgKCB0aGlzLnJlY2VpdmVTaGFkb3cgPT09IHRydWUgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IHRydWU7XHJcblx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHRcdG9iamVjdC5tYXRyaXggPSB0aGlzLm1hdHJpeC50b0FycmF5KCk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHRoaXMuZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGlmICggbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID0gdGhpcy5nZW9tZXRyeS50b0pTT04oIG1ldGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnkudXVpZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPSB0aGlzLm1hdGVyaWFsLnRvSlNPTiggbWV0YSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2JqZWN0Lm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbC51dWlkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0LmNoaWxkcmVuLnB1c2goIHRoaXMuY2hpbGRyZW5bIGkgXS50b0pTT04oIG1ldGEgKS5vYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XHJcblxyXG5cdFx0XHR2YXIgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xyXG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5tYXRlcmlhbHMgKTtcclxuXHRcdFx0dmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xyXG5cdFx0XHR2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xyXG5cdFx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkgb3V0cHV0Lm1hdGVyaWFscyA9IG1hdGVyaWFscztcclxuXHRcdFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgb3V0cHV0LnRleHR1cmVzID0gdGV4dHVyZXM7XHJcblx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuXHRcdHJldHVybiBvdXRwdXQ7XHJcblxyXG5cdFx0Ly8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIGNhY2hlIGhhc2hcclxuXHRcdC8vIHJlbW92ZSBtZXRhZGF0YSBvbiBlYWNoIGl0ZW1cclxuXHRcdC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcclxuXHRcdGZ1bmN0aW9uIGV4dHJhY3RGcm9tQ2FjaGUgKCBjYWNoZSApIHtcclxuXHJcblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcclxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XHJcblx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHZhbHVlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzLCByZWN1cnNpdmUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkICkgcmVjdXJzaXZlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcclxuXHJcblx0XHR0aGlzLnVwLmNvcHkoIHNvdXJjZS51cCApO1xyXG5cclxuXHRcdHRoaXMucG9zaXRpb24uY29weSggc291cmNlLnBvc2l0aW9uICk7XHJcblx0XHR0aGlzLnF1YXRlcm5pb24uY29weSggc291cmNlLnF1YXRlcm5pb24gKTtcclxuXHRcdHRoaXMuc2NhbGUuY29weSggc291cmNlLnNjYWxlICk7XHJcblxyXG5cdFx0dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSBzb3VyY2Uucm90YXRpb25BdXRvVXBkYXRlO1xyXG5cclxuXHRcdHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcclxuXHRcdHRoaXMubWF0cml4V29ybGQuY29weSggc291cmNlLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBzb3VyY2UubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcclxuXHJcblx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcclxuXHJcblx0XHR0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcclxuXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xyXG5cclxuXHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5mcnVzdHVtQ3VsbGVkO1xyXG5cdFx0dGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcclxuXHJcblx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XHJcblxyXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY2hpbGQgPSBzb3VyY2UuY2hpbGRyZW5bIGkgXTtcclxuXHRcdFx0XHR0aGlzLmFkZCggY2hpbGQuY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuT2JqZWN0M0RJZENvdW50ID0gMDtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvRmFjZTMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZhY2UzID0gZnVuY3Rpb24gKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHR0aGlzLmEgPSBhO1xyXG5cdHRoaXMuYiA9IGI7XHJcblx0dGhpcy5jID0gYztcclxuXHJcblx0dGhpcy5ub3JtYWwgPSBub3JtYWwgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzID8gbm9ybWFsIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLnZlcnRleE5vcm1hbHMgPSBBcnJheS5pc0FycmF5KCBub3JtYWwgKSA/IG5vcm1hbCA6IFtdO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gY29sb3IgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciA/IGNvbG9yIDogbmV3IFRIUkVFLkNvbG9yKCk7XHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBBcnJheS5pc0FycmF5KCBjb2xvciApID8gY29sb3IgOiBbXTtcclxuXHJcblx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRmFjZTMucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRmFjZTMsXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLmEgPSBzb3VyY2UuYTtcclxuXHRcdHRoaXMuYiA9IHNvdXJjZS5iO1xyXG5cdFx0dGhpcy5jID0gc291cmNlLmM7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWwuY29weSggc291cmNlLm5vcm1hbCApO1xyXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsSW5kZXggPSBzb3VyY2UubWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRleE5vcm1hbHNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRleENvbG9yc1sgaSBdID0gc291cmNlLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9CdWZmZXJBdHRyaWJ1dGUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLmFycmF5ID0gYXJyYXk7XHJcblx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xyXG5cclxuXHR0aGlzLmR5bmFtaWMgPSBmYWxzZTtcclxuXHR0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcclxuXHJcblx0dGhpcy52ZXJzaW9uID0gMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyQXR0cmlidXRlLFxyXG5cclxuXHRnZXQgY291bnQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoIC8gdGhpcy5pdGVtU2l6ZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXREeW5hbWljOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuZHluYW1pYyA9IHZhbHVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvciggc291cmNlLmFycmF5ICk7XHJcblx0XHR0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xyXG5cclxuXHRcdHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcclxuXHJcblx0XHRpbmRleDEgKj0gdGhpcy5pdGVtU2l6ZTtcclxuXHRcdGluZGV4MiAqPSBhdHRyaWJ1dGUuaXRlbVNpemU7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlBcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5LnNldCggYXJyYXkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUNvbG9yc0FycmF5OiBmdW5jdGlvbiAoIGNvbG9ycyApIHtcclxuXHJcblx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNvbG9yID0gY29sb3JzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoKTogY29sb3IgaXMgdW5kZWZpbmVkJywgaSApO1xyXG5cdFx0XHRcdGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5yO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5nO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5iO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUluZGljZXNBcnJheTogZnVuY3Rpb24gKCBpbmRpY2VzICkge1xyXG5cclxuXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gaW5kaWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYjtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlWZWN0b3Iyc0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XHJcblxyXG5cdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcblx0XHRcdFx0dmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlWZWN0b3Izc0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XHJcblxyXG5cdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcblx0XHRcdFx0dmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5VmVjdG9yNHNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xyXG5cclxuXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yNHNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xyXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci56O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IudztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB2YWx1ZSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFg6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIGluZGV4LCB4ICkge1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0WTogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFo6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRXOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFc6IGZ1bmN0aW9uICggaW5kZXgsIHcgKSB7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WFk6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHkgKSB7XHJcblxyXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcclxuXHJcblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcclxuXHJcblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vL1xyXG5cclxuVEhSRUUuSW50OEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5VaW50OEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVWludDhDbGFtcGVkQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW50MTZBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlVpbnQxNkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkludDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5VaW50MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5GbG9hdDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZsb2F0NjRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDY0QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuXHJcbi8vIERlcHJlY2F0ZWRcclxuXHJcblRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0Y29uc29sZS53YXJuKCAnVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSgpLnNldER5bmFtaWMoIHRydWUgKSBpbnN0ZWFkLicgKTtcclxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkuc2V0RHluYW1pYyggdHJ1ZSApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUsIG1lc2hQZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBhcnJheSwgaXRlbVNpemUgKTtcclxuXHJcblx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZSB8fCAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU7XHJcblxyXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9JbnRlcmxlYXZlZEJ1ZmZlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xyXG4gKi9cclxuXHJcblRIUkVFLkludGVybGVhdmVkQnVmZmVyID0gZnVuY3Rpb24gKCBhcnJheSwgc3RyaWRlICkge1xyXG5cclxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLmFycmF5ID0gYXJyYXk7XHJcblx0dGhpcy5zdHJpZGUgPSBzdHJpZGU7XHJcblxyXG5cdHRoaXMuZHluYW1pYyA9IGZhbHNlO1xyXG5cdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xyXG5cclxuXHR0aGlzLnZlcnNpb24gPSAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkludGVybGVhdmVkQnVmZmVyLFxyXG5cclxuXHRnZXQgbGVuZ3RoICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCBjb3VudCAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoIC8gdGhpcy5zdHJpZGU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RHluYW1pYzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xyXG5cdFx0dGhpcy5zdHJpZGUgPSBzb3VyY2Uuc3RyaWRlO1xyXG5cdFx0dGhpcy5keW5hbWljID0gc291cmNlLmR5bmFtaWM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xyXG5cclxuXHRcdGluZGV4MSAqPSB0aGlzLnN0cmlkZTtcclxuXHRcdGluZGV4MiAqPSBhdHRyaWJ1dGUuc3RyaWRlO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPSBmdW5jdGlvbiAoIGFycmF5LCBzdHJpZGUsIG1lc2hQZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFRIUkVFLkludGVybGVhdmVkQnVmZmVyLmNhbGwoIHRoaXMsIGFycmF5LCBzdHJpZGUgKTtcclxuXHJcblx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZSB8fCAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSApO1xyXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcjtcclxuXHJcblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xyXG4gKi9cclxuXHJcblRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCApIHtcclxuXHJcblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy5kYXRhID0gaW50ZXJsZWF2ZWRCdWZmZXI7XHJcblx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xyXG5cdHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSxcclxuXHJcblx0Z2V0IGxlbmd0aCgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAuY291bnQuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgY291bnQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5jb3VudDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WDogZnVuY3Rpb24gKCBpbmRleCwgeCApIHtcclxuXHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF0gPSB4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xyXG5cclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF0gPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRaOiBmdW5jdGlvbiAoIGluZGV4LCB6ICkge1xyXG5cclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF0gPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRXOiBmdW5jdGlvbiAoIGluZGV4LCB3ICkge1xyXG5cclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF0gPSB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRYOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFk6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFo6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xyXG5cclxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WFlaOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYWVpXOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0dlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5HZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKysgfSApO1xyXG5cclxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHR0aGlzLnR5cGUgPSAnR2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnZlcnRpY2VzID0gW107XHJcblx0dGhpcy5jb2xvcnMgPSBbXTtcclxuXHR0aGlzLmZhY2VzID0gW107XHJcblx0dGhpcy5mYWNlVmVydGV4VXZzID0gWyBbXSBdO1xyXG5cclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IFtdO1xyXG5cdHRoaXMubW9ycGhOb3JtYWxzID0gW107XHJcblxyXG5cdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcclxuXHR0aGlzLnNraW5JbmRpY2VzID0gW107XHJcblxyXG5cdHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xyXG5cclxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0Ly8gdXBkYXRlIGZsYWdzXHJcblxyXG5cdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkdlb21ldHJ5LFxyXG5cclxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XHJcblx0XHRcdHZlcnRleC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xyXG5cdFx0XHRmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF0uYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xyXG5cclxuXHRcdHZhciBtMTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWCggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXHJcblxyXG5cdFx0dmFyIG0xO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG0xLm1ha2VSb3RhdGlvblkoIGFuZ2xlICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB6LWF4aXNcclxuXHJcblx0XHR2YXIgbTE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxyXG5cclxuXHRcdHZhciBtMTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0bTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzY2FsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHNjYWxlIGdlb21ldHJ5XHJcblxyXG5cdFx0dmFyIG0xO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBzY2FsZSggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG0xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG9iajtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iaiA9PT0gdW5kZWZpbmVkICkgb2JqID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblxyXG5cdFx0XHRvYmoubG9va0F0KCB2ZWN0b3IgKTtcclxuXHJcblx0XHRcdG9iai51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGZyb21CdWZmZXJHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IHVuZGVmaW5lZDtcclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHJcblx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuXHRcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5IDogdW5kZWZpbmVkO1xyXG5cdFx0dmFyIGNvbG9ycyA9IGF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuY29sb3IuYXJyYXkgOiB1bmRlZmluZWQ7XHJcblx0XHR2YXIgdXZzID0gYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51di5hcnJheSA6IHVuZGVmaW5lZDtcclxuXHRcdHZhciB1dnMyID0gYXR0cmlidXRlcy51djIgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYyLmFycmF5IDogdW5kZWZpbmVkO1xyXG5cclxuXHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBbXTtcclxuXHJcblx0XHR2YXIgdGVtcE5vcm1hbHMgPSBbXTtcclxuXHRcdHZhciB0ZW1wVVZzID0gW107XHJcblx0XHR2YXIgdGVtcFVWczIgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzLCBqICs9IDIgKSB7XHJcblxyXG5cdFx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggcG9zaXRpb25zWyBpIF0sIHBvc2l0aW9uc1sgaSArIDEgXSwgcG9zaXRpb25zWyBpICsgMiBdICkgKTtcclxuXHJcblx0XHRcdGlmICggbm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0ZW1wTm9ybWFscy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggbm9ybWFsc1sgaSBdLCBub3JtYWxzWyBpICsgMSBdLCBub3JtYWxzWyBpICsgMiBdICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggY29sb3JzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgaSBdLCBjb2xvcnNbIGkgKyAxIF0sIGNvbG9yc1sgaSArIDIgXSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0ZW1wVVZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dnNbIGogXSwgdXZzWyBqICsgMSBdICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0ZW1wVVZzMi5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdXZzMlsgaiBdLCB1dnMyWyBqICsgMSBdICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYWRkRmFjZSggYSwgYiwgYyApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gbm9ybWFscyAhPT0gdW5kZWZpbmVkID8gWyB0ZW1wTm9ybWFsc1sgYSBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBiIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcclxuXHRcdFx0dmFyIHZlcnRleENvbG9ycyA9IGNvbG9ycyAhPT0gdW5kZWZpbmVkID8gWyBzY29wZS5jb2xvcnNbIGEgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGIgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCB2ZXJ0ZXhOb3JtYWxzLCB2ZXJ0ZXhDb2xvcnMgKTtcclxuXHJcblx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHJcblx0XHRcdGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHRlbXBVVnNbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzWyBiIF0uY2xvbmUoKSwgdGVtcFVWc1sgYyBdLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDEgXS5wdXNoKCBbIHRlbXBVVnMyWyBhIF0uY2xvbmUoKSwgdGVtcFVWczJbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYyBdLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGluZGljZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblxyXG5cdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xyXG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSBzdGFydCwgamwgPSBzdGFydCArIGNvdW50OyBqIDwgamw7IGogKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGFkZEZhY2UoIGluZGljZXNbIGogXSwgaW5kaWNlc1sgaiArIDEgXSwgaW5kaWNlc1sgaiArIDIgXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRhZGRGYWNlKCBpbmRpY2VzWyBpIF0sIGluZGljZXNbIGkgKyAxIF0sIGluZGljZXNbIGkgKyAyIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRhZGRGYWNlKCBpLCBpICsgMSwgaSArIDIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guY2VudGVyKCkubmVnYXRlKCk7XHJcblxyXG5cdFx0dGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0O1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcclxuXHRcdHZhciByYWRpdXMgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHR2YXIgcyA9IHJhZGl1cyA9PT0gMCA/IDEgOiAxLjAgLyByYWRpdXM7XHJcblxyXG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0XHRtYXRyaXguc2V0KFxyXG5cdFx0XHRzLCAwLCAwLCAtIHMgKiBjZW50ZXIueCxcclxuXHRcdFx0MCwgcywgMCwgLSBzICogY2VudGVyLnksXHJcblx0XHRcdDAsIDAsIHMsIC0gcyAqIGNlbnRlci56LFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblx0XHQpO1xyXG5cclxuXHRcdHRoaXMuYXBwbHlNYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdHZhciB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHR2YXIgdkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0dmFyIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcclxuXHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XHJcblx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0Y2Iubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBjYiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICggYXJlYVdlaWdodGVkICkge1xyXG5cclxuXHRcdGlmICggYXJlYVdlaWdodGVkID09PSB1bmRlZmluZWQgKSBhcmVhV2VpZ2h0ZWQgPSB0cnVlO1xyXG5cclxuXHRcdHZhciB2LCB2bCwgZiwgZmwsIGZhY2UsIHZlcnRpY2VzO1xyXG5cclxuXHRcdHZlcnRpY2VzID0gbmV3IEFycmF5KCB0aGlzLnZlcnRpY2VzLmxlbmd0aCApO1xyXG5cclxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlc1sgdiBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBhcmVhV2VpZ2h0ZWQgKSB7XHJcblxyXG5cdFx0XHQvLyB2ZXJ0ZXggbm9ybWFscyB3ZWlnaHRlZCBieSB0cmlhbmdsZSBhcmVhc1xyXG5cdFx0XHQvLyBodHRwOi8vd3d3LmlxdWlsZXpsZXMub3JnL3d3dy9hcnRpY2xlcy9ub3JtYWxzL25vcm1hbHMuaHRtXHJcblxyXG5cdFx0XHR2YXIgdkEsIHZCLCB2QztcclxuXHRcdFx0dmFyIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgYWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0dkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHR2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xyXG5cdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xyXG5cdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBjYiApO1xyXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGNiICk7XHJcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggY2IgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYSBdLmFkZCggZmFjZS5ub3JtYWwgKTtcclxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlc1sgdiBdLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcclxuXHJcblx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAyIF0uY29weSggdmVydGljZXNbIGZhY2UuYyBdICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAwIF0gPSB2ZXJ0aWNlc1sgZmFjZS5hIF0uY2xvbmUoKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAyIF0gPSB2ZXJ0aWNlc1sgZmFjZS5jIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmZhY2VzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVNb3JwaE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgaSwgaWwsIGYsIGZsLCBmYWNlO1xyXG5cclxuXHRcdC8vIHNhdmUgb3JpZ2luYWwgbm9ybWFsc1xyXG5cdFx0Ly8gLSBjcmVhdGUgdGVtcCB2YXJpYWJsZXMgb24gZmlyc3QgYWNjZXNzXHJcblx0XHQvLyAgIG90aGVyd2lzZSBqdXN0IGNvcHkgKGZvciBmYXN0ZXIgcmVwZWF0ZWQgY2FsbHMpXHJcblxyXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyApIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gPSBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVzZSB0ZW1wIGdlb21ldHJ5IHRvIGNvbXB1dGUgZmFjZSBhbmQgdmVydGV4IG5vcm1hbHMgZm9yIGVhY2ggbW9ycGhcclxuXHJcblx0XHR2YXIgdG1wR2VvID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0XHR0bXBHZW8uZmFjZXMgPSB0aGlzLmZhY2VzO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Ly8gY3JlYXRlIG9uIGZpcnN0IGFjY2Vzc1xyXG5cclxuXHRcdFx0aWYgKCAhIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gPSB7fTtcclxuXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzID0gW107XHJcblx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzID0gW107XHJcblxyXG5cdFx0XHRcdHZhciBkc3ROb3JtYWxzRmFjZSA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHM7XHJcblx0XHRcdFx0dmFyIGRzdE5vcm1hbHNWZXJ0ZXggPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2VOb3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFscyA9IHsgYTogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYjogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYzogbmV3IFRIUkVFLlZlY3RvcjMoKSB9O1xyXG5cclxuXHRcdFx0XHRcdGRzdE5vcm1hbHNGYWNlLnB1c2goIGZhY2VOb3JtYWwgKTtcclxuXHRcdFx0XHRcdGRzdE5vcm1hbHNWZXJ0ZXgucHVzaCggdmVydGV4Tm9ybWFscyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXTtcclxuXHJcblx0XHRcdC8vIHNldCB2ZXJ0aWNlcyB0byBtb3JwaCB0YXJnZXRcclxuXHJcblx0XHRcdHRtcEdlby52ZXJ0aWNlcyA9IHRoaXMubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0XHRcdHRtcEdlby5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHRcdFx0dG1wR2VvLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG5cdFx0XHQvLyBzdG9yZSBtb3JwaCBub3JtYWxzXHJcblxyXG5cdFx0XHR2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRcdGZhY2VOb3JtYWwgPSBtb3JwaE5vcm1hbHMuZmFjZU5vcm1hbHNbIGYgXTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0gbW9ycGhOb3JtYWxzLnZlcnRleE5vcm1hbHNbIGYgXTtcclxuXHJcblx0XHRcdFx0ZmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmEuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0gKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmIuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAxIF0gKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmMuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVzdG9yZSBvcmlnaW5hbCBub3JtYWxzXHJcblxyXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRmYWNlLm5vcm1hbCA9IGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWw7XHJcblx0XHRcdGZhY2UudmVydGV4Tm9ybWFscyA9IGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkID0gMDtcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBpID4gMCApIHtcclxuXHJcblx0XHRcdFx0ZCArPSB2ZXJ0aWNlc1sgaSBdLmRpc3RhbmNlVG8oIHZlcnRpY2VzWyBpIC0gMSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmxpbmVEaXN0YW5jZXNbIGkgXSA9IGQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5vcm1hbE1hdHJpeCxcclxuXHRcdHZlcnRleE9mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxyXG5cdFx0dmVydGljZXMxID0gdGhpcy52ZXJ0aWNlcyxcclxuXHRcdHZlcnRpY2VzMiA9IGdlb21ldHJ5LnZlcnRpY2VzLFxyXG5cdFx0ZmFjZXMxID0gdGhpcy5mYWNlcyxcclxuXHRcdGZhY2VzMiA9IGdlb21ldHJ5LmZhY2VzLFxyXG5cdFx0dXZzMSA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLFxyXG5cdFx0dXZzMiA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsSW5kZXhPZmZzZXQgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsSW5kZXhPZmZzZXQgPSAwO1xyXG5cclxuXHRcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHZlcnRpY2VzXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlczJbIGkgXTtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhDb3B5ID0gdmVydGV4LmNsb25lKCk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkgdmVydGV4Q29weS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0dmVydGljZXMxLnB1c2goIHZlcnRleENvcHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmFjZXNcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzMlsgaSBdLCBmYWNlQ29weSwgbm9ybWFsLCBjb2xvcixcclxuXHRcdFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHMsXHJcblx0XHRcdGZhY2VWZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcclxuXHJcblx0XHRcdGZhY2VDb3B5ID0gbmV3IFRIUkVFLkZhY2UzKCBmYWNlLmEgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYiArIHZlcnRleE9mZnNldCwgZmFjZS5jICsgdmVydGV4T2Zmc2V0ICk7XHJcblx0XHRcdGZhY2VDb3B5Lm5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0aWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZUNvcHkubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdG5vcm1hbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzWyBqIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0aWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmYWNlQ29weS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZmFjZUNvcHkuY29sb3IuY29weSggZmFjZS5jb2xvciApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhDb2xvcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbG9yID0gZmFjZVZlcnRleENvbG9yc1sgaiBdO1xyXG5cdFx0XHRcdGZhY2VDb3B5LnZlcnRleENvbG9ycy5wdXNoKCBjb2xvci5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmYWNlQ29weS5tYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4ICsgbWF0ZXJpYWxJbmRleE9mZnNldDtcclxuXHJcblx0XHRcdGZhY2VzMS5wdXNoKCBmYWNlQ29weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1dnNcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB1dnMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHV2ID0gdXZzMlsgaSBdLCB1dkNvcHkgPSBbXTtcclxuXHJcblx0XHRcdGlmICggdXYgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHV2Q29weS5wdXNoKCB1dlsgaiBdLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHV2czEucHVzaCggdXZDb3B5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRtZXJnZU1lc2g6IGZ1bmN0aW9uICggbWVzaCApIHtcclxuXHJcblx0XHRpZiAoIG1lc2ggaW5zdGFuY2VvZiBUSFJFRS5NZXNoID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZU1lc2goKTogbWVzaCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuTWVzaC4nLCBtZXNoICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bWVzaC5tYXRyaXhBdXRvVXBkYXRlICYmIG1lc2gudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0dGhpcy5tZXJnZSggbWVzaC5nZW9tZXRyeSwgbWVzaC5tYXRyaXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0LypcclxuXHQgKiBDaGVja3MgZm9yIGR1cGxpY2F0ZSB2ZXJ0aWNlcyB3aXRoIGhhc2htYXAuXHJcblx0ICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxyXG5cdCAqIGFuZCBmYWNlcycgdmVydGljZXMgYXJlIHVwZGF0ZWQuXHJcblx0ICovXHJcblxyXG5cdG1lcmdlVmVydGljZXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdmVydGljZXNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlcyBieSBwb3NpdGlvbiBjb29yZGluYXRlcyAoYW5kIG1ha2luZyBzdXJlIHRoZXkgYXJlIHVuaXF1ZSlcclxuXHRcdHZhciB1bmlxdWUgPSBbXSwgY2hhbmdlcyA9IFtdO1xyXG5cclxuXHRcdHZhciB2LCBrZXk7XHJcblx0XHR2YXIgcHJlY2lzaW9uUG9pbnRzID0gNDsgLy8gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCBlLmcuIDQgZm9yIGVwc2lsb24gb2YgMC4wMDAxXHJcblx0XHR2YXIgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcclxuXHRcdHZhciBpLCBpbCwgZmFjZTtcclxuXHRcdHZhciBpbmRpY2VzLCBqLCBqbDtcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0diA9IHRoaXMudmVydGljZXNbIGkgXTtcclxuXHRcdFx0a2V5ID0gTWF0aC5yb3VuZCggdi54ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnkgKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueiAqIHByZWNpc2lvbiApO1xyXG5cclxuXHRcdFx0aWYgKCB2ZXJ0aWNlc01hcFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmVydGljZXNNYXBbIGtleSBdID0gaTtcclxuXHRcdFx0XHR1bmlxdWUucHVzaCggdGhpcy52ZXJ0aWNlc1sgaSBdICk7XHJcblx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gdW5pcXVlLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdEdXBsaWNhdGUgdmVydGV4IGZvdW5kLiAnLCBpLCAnIGNvdWxkIGJlIHVzaW5nICcsIHZlcnRpY2VzTWFwW2tleV0pO1xyXG5cdFx0XHRcdGNoYW5nZXNbIGkgXSA9IGNoYW5nZXNbIHZlcnRpY2VzTWFwWyBrZXkgXSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gaWYgZmFjZXMgYXJlIGNvbXBsZXRlbHkgZGVnZW5lcmF0ZSBhZnRlciBtZXJnaW5nIHZlcnRpY2VzLCB3ZVxyXG5cdFx0Ly8gaGF2ZSB0byByZW1vdmUgdGhlbSBmcm9tIHRoZSBnZW9tZXRyeS5cclxuXHRcdHZhciBmYWNlSW5kaWNlc1RvUmVtb3ZlID0gW107XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRmYWNlLmEgPSBjaGFuZ2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0ZmFjZS5iID0gY2hhbmdlc1sgZmFjZS5iIF07XHJcblx0XHRcdGZhY2UuYyA9IGNoYW5nZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0aW5kaWNlcyA9IFsgZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0dmFyIGR1cEluZGV4ID0gLSAxO1xyXG5cclxuXHRcdFx0Ly8gaWYgYW55IGR1cGxpY2F0ZSB2ZXJ0aWNlcyBhcmUgZm91bmQgaW4gYSBGYWNlM1xyXG5cdFx0XHQvLyB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgZmFjZSBhcyBub3RoaW5nIGNhbiBiZSBzYXZlZFxyXG5cdFx0XHRmb3IgKCB2YXIgbiA9IDA7IG4gPCAzOyBuICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZGljZXNbIG4gXSA9PT0gaW5kaWNlc1sgKCBuICsgMSApICUgMyBdICkge1xyXG5cclxuXHRcdFx0XHRcdGR1cEluZGV4ID0gbjtcclxuXHRcdFx0XHRcdGZhY2VJbmRpY2VzVG9SZW1vdmUucHVzaCggaSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaSA9IGZhY2VJbmRpY2VzVG9SZW1vdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC0tICkge1xyXG5cclxuXHRcdFx0dmFyIGlkeCA9IGZhY2VJbmRpY2VzVG9SZW1vdmVbIGkgXTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMuc3BsaWNlKCBpZHgsIDEgKTtcclxuXHJcblx0XHRcdGZvciAoIGogPSAwLCBqbCA9IHRoaXMuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBqIF0uc3BsaWNlKCBpZHgsIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXNlIHVuaXF1ZSBzZXQgb2YgdmVydGljZXNcclxuXHJcblx0XHR2YXIgZGlmZiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gdW5pcXVlLmxlbmd0aDtcclxuXHRcdHRoaXMudmVydGljZXMgPSB1bmlxdWU7XHJcblx0XHRyZXR1cm4gZGlmZjtcclxuXHJcblx0fSxcclxuXHJcblx0c29ydEZhY2VzQnlNYXRlcmlhbEluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gdGhpcy5mYWNlcztcclxuXHRcdHZhciBsZW5ndGggPSBmYWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0Ly8gdGFnIGZhY2VzXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZXNbIGkgXS5faWQgPSBpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzb3J0IGZhY2VzXHJcblxyXG5cdFx0ZnVuY3Rpb24gbWF0ZXJpYWxJbmRleFNvcnQoIGEsIGIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5tYXRlcmlhbEluZGV4IC0gYi5tYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmYWNlcy5zb3J0KCBtYXRlcmlhbEluZGV4U29ydCApO1xyXG5cclxuXHRcdC8vIHNvcnQgdXZzXHJcblxyXG5cdFx0dmFyIHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHRcdHZhciB1dnMyID0gdGhpcy5mYWNlVmVydGV4VXZzWyAxIF07XHJcblxyXG5cdFx0dmFyIG5ld1V2czEsIG5ld1V2czI7XHJcblxyXG5cdFx0aWYgKCB1dnMxICYmIHV2czEubGVuZ3RoID09PSBsZW5ndGggKSBuZXdVdnMxID0gW107XHJcblx0XHRpZiAoIHV2czIgJiYgdXZzMi5sZW5ndGggPT09IGxlbmd0aCApIG5ld1V2czIgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgaWQgPSBmYWNlc1sgaSBdLl9pZDtcclxuXHJcblx0XHRcdGlmICggbmV3VXZzMSApIG5ld1V2czEucHVzaCggdXZzMVsgaWQgXSApO1xyXG5cdFx0XHRpZiAoIG5ld1V2czIgKSBuZXdVdnMyLnB1c2goIHV2czJbIGlkIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBuZXdVdnMxICkgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0gPSBuZXdVdnMxO1xyXG5cdFx0aWYgKCBuZXdVdnMyICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBuZXdVdnMyO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bWV0YWRhdGE6IHtcclxuXHRcdFx0XHR2ZXJzaW9uOiA0LjQsXHJcblx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5JyxcclxuXHRcdFx0XHRnZW5lcmF0b3I6ICdHZW9tZXRyeS50b0pTT04nXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gc3RhbmRhcmQgR2VvbWV0cnkgc2VyaWFsaXphdGlvblxyXG5cclxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcclxuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcclxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcclxuXHJcblx0XHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xyXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmYWNlcyA9IFtdO1xyXG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcclxuXHRcdHZhciBub3JtYWxzSGFzaCA9IHt9O1xyXG5cdFx0dmFyIGNvbG9ycyA9IFtdO1xyXG5cdFx0dmFyIGNvbG9yc0hhc2ggPSB7fTtcclxuXHRcdHZhciB1dnMgPSBbXTtcclxuXHRcdHZhciB1dnNIYXNoID0ge307XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdHZhciBoYXNNYXRlcmlhbCA9IHRydWU7XHJcblx0XHRcdHZhciBoYXNGYWNlVXYgPSBmYWxzZTsgLy8gZGVwcmVjYXRlZFxyXG5cdFx0XHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXSAhPT0gdW5kZWZpbmVkO1xyXG5cdFx0XHR2YXIgaGFzRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmxlbmd0aCgpID4gMDtcclxuXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoID4gMDtcclxuXHRcdFx0dmFyIGhhc0ZhY2VDb2xvciA9IGZhY2UuY29sb3IuciAhPT0gMSB8fCBmYWNlLmNvbG9yLmcgIT09IDEgfHwgZmFjZS5jb2xvci5iICE9PSAxO1xyXG5cdFx0XHR2YXIgaGFzRmFjZVZlcnRleENvbG9yID0gZmFjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoID4gMDtcclxuXHJcblx0XHRcdHZhciBmYWNlVHlwZSA9IDA7XHJcblxyXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDAsIDAgKTsgLy8gaXNRdWFkXHJcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMSwgaGFzTWF0ZXJpYWwgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAyLCBoYXNGYWNlVXYgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAzLCBoYXNGYWNlVmVydGV4VXYgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA0LCBoYXNGYWNlTm9ybWFsICk7XHJcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNSwgaGFzRmFjZVZlcnRleE5vcm1hbCApO1xyXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDYsIGhhc0ZhY2VDb2xvciApO1xyXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDcsIGhhc0ZhY2VWZXJ0ZXhDb2xvciApO1xyXG5cclxuXHRcdFx0ZmFjZXMucHVzaCggZmFjZVR5cGUgKTtcclxuXHRcdFx0ZmFjZXMucHVzaCggZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyApO1xyXG5cdFx0XHRmYWNlcy5wdXNoKCBmYWNlLm1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XHJcblxyXG5cdFx0XHRcdGZhY2VzLnB1c2goXHJcblx0XHRcdFx0XHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAwIF0gKSxcclxuXHRcdFx0XHRcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDEgXSApLFxyXG5cdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMiBdIClcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKCBnZXROb3JtYWxJbmRleCggZmFjZS5ub3JtYWwgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdFx0ZmFjZXMucHVzaChcclxuXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAwIF0gKSxcclxuXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAxIF0gKSxcclxuXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcblx0XHRcdFx0ZmFjZXMucHVzaCggZ2V0Q29sb3JJbmRleCggZmFjZS5jb2xvciApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKFxyXG5cdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAwIF0gKSxcclxuXHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMSBdICksXHJcblx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDIgXSApXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2V0Qml0KCB2YWx1ZSwgcG9zaXRpb24sIGVuYWJsZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZW5hYmxlZCA/IHZhbHVlIHwgKCAxIDw8IHBvc2l0aW9uICkgOiB2YWx1ZSAmICggfiAoIDEgPDwgcG9zaXRpb24gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXROb3JtYWxJbmRleCggbm9ybWFsICkge1xyXG5cclxuXHRcdFx0dmFyIGhhc2ggPSBub3JtYWwueC50b1N0cmluZygpICsgbm9ybWFsLnkudG9TdHJpbmcoKSArIG5vcm1hbC56LnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRpZiAoIG5vcm1hbHNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRub3JtYWxzSGFzaFsgaGFzaCBdID0gbm9ybWFscy5sZW5ndGggLyAzO1xyXG5cdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcclxuXHJcblx0XHRcdHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRDb2xvckluZGV4KCBjb2xvciApIHtcclxuXHJcblx0XHRcdHZhciBoYXNoID0gY29sb3Iuci50b1N0cmluZygpICsgY29sb3IuZy50b1N0cmluZygpICsgY29sb3IuYi50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0aWYgKCBjb2xvcnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbG9yc0hhc2hbIGhhc2ggXSA9IGNvbG9ycy5sZW5ndGg7XHJcblx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5nZXRIZXgoKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0VXZJbmRleCggdXYgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFzaCA9IHV2LngudG9TdHJpbmcoKSArIHV2LnkudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdGlmICggdXZzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB1dnNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR1dnNIYXNoWyBoYXNoIF0gPSB1dnMubGVuZ3RoIC8gMjtcclxuXHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcclxuXHJcblx0XHRcdHJldHVybiB1dnNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGRhdGEuZGF0YSA9IHt9O1xyXG5cclxuXHRcdGRhdGEuZGF0YS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG5cdFx0ZGF0YS5kYXRhLm5vcm1hbHMgPSBub3JtYWxzO1xyXG5cdFx0aWYgKCBjb2xvcnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS5jb2xvcnMgPSBjb2xvcnM7XHJcblx0XHRpZiAoIHV2cy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLnV2cyA9IFsgdXZzIF07IC8vIHRlbXBvcmFsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuXHRcdGRhdGEuZGF0YS5mYWNlcyA9IGZhY2VzO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8qXHJcblx0XHQvLyBIYW5kbGUgcHJpbWl0aXZlc1xyXG5cclxuXHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdFx0XHR2YWx1ZXMucHVzaCggcGFyYW1ldGVyc1sga2V5IF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBnZW9tZXRyeSA9IE9iamVjdC5jcmVhdGUoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlICk7XHJcblx0XHRcdHRoaXMuY29uc3RydWN0b3IuYXBwbHkoIGdlb21ldHJ5LCB2YWx1ZXMgKTtcclxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblx0XHQqL1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuR2VvbWV0cnkoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMudmVydGljZXMgPSBbXTtcclxuXHRcdHRoaXMuZmFjZXMgPSBbXTtcclxuXHRcdHRoaXMuZmFjZVZlcnRleFV2cyA9IFsgW10gXTtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBzb3VyY2UudmVydGljZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gc291cmNlLmZhY2VzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggZmFjZXNbIGkgXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gc291cmNlLmZhY2VWZXJ0ZXhVdnNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5mYWNlVmVydGV4VXZzWyBpIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdXZzID0gZmFjZVZlcnRleFV2c1sgaiBdLCB1dnNDb3B5ID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBrID0gMCwga2wgPSB1dnMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHV2ID0gdXZzWyBrIF07XHJcblxyXG5cdFx0XHRcdFx0dXZzQ29weS5wdXNoKCB1di5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0ucHVzaCggdXZzQ29weSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5HZW9tZXRyeUlkQ291bnQgPSAwO1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9EaXJlY3RHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRGlyZWN0R2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuR2VvbWV0cnlJZENvdW50ICsrIH0gKTtcclxuXHJcblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblx0dGhpcy50eXBlID0gJ0RpcmVjdEdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5pbmRpY2VzID0gW107XHJcblx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xyXG5cdHRoaXMubm9ybWFscyA9IFtdO1xyXG5cdHRoaXMuY29sb3JzID0gW107XHJcblx0dGhpcy51dnMgPSBbXTtcclxuXHR0aGlzLnV2czIgPSBbXTtcclxuXHJcblx0dGhpcy5ncm91cHMgPSBbXTtcclxuXHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSB7fTtcclxuXHJcblx0dGhpcy5za2luV2VpZ2h0cyA9IFtdO1xyXG5cdHRoaXMuc2tpbkluZGljZXMgPSBbXTtcclxuXHJcblx0Ly8gdGhpcy5saW5lRGlzdGFuY2VzID0gW107XHJcblxyXG5cdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xyXG5cclxuXHQvLyB1cGRhdGUgZmxhZ3NcclxuXHJcblx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGlyZWN0R2VvbWV0cnkucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRGlyZWN0R2VvbWV0cnksXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ0JveDogVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVCb3VuZGluZ0JveCxcclxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdTcGhlcmUsXHJcblxyXG5cdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5OiBjb21wdXRlRmFjZU5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZVZlcnRleE5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUdyb3VwczogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgZ3JvdXA7XHJcblx0XHR2YXIgZ3JvdXBzID0gW107XHJcblx0XHR2YXIgbWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHQvLyBtYXRlcmlhbHNcclxuXHJcblx0XHRcdGlmICggZmFjZS5tYXRlcmlhbEluZGV4ICE9PSBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdFx0XHRpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z3JvdXAuY291bnQgPSAoIGkgKiAzICkgLSBncm91cC5zdGFydDtcclxuXHRcdFx0XHRcdGdyb3Vwcy5wdXNoKCBncm91cCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdyb3VwID0ge1xyXG5cdFx0XHRcdFx0c3RhcnQ6IGkgKiAzLFxyXG5cdFx0XHRcdFx0bWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleFxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XHJcblx0XHRcdGdyb3Vwcy5wdXNoKCBncm91cCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdyb3VwcyA9IGdyb3VwcztcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG5cdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnM7XHJcblxyXG5cdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IGZhY2VWZXJ0ZXhVdnNbIDAgXSAmJiBmYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoID4gMDtcclxuXHRcdHZhciBoYXNGYWNlVmVydGV4VXYyID0gZmFjZVZlcnRleFV2c1sgMSBdICYmIGZhY2VWZXJ0ZXhVdnNbIDEgXS5sZW5ndGggPiAwO1xyXG5cclxuXHRcdC8vIG1vcnBoc1xyXG5cclxuXHRcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XHJcblx0XHR2YXIgbW9ycGhUYXJnZXRzTGVuZ3RoID0gbW9ycGhUYXJnZXRzLmxlbmd0aDtcclxuXHJcblx0XHR2YXIgbW9ycGhUYXJnZXRzUG9zaXRpb247XHJcblxyXG5cdFx0aWYgKCBtb3JwaFRhcmdldHNMZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0bW9ycGhUYXJnZXRzUG9zaXRpb24gPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bW9ycGhUYXJnZXRzUG9zaXRpb25bIGkgXSA9IFtdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldHMucG9zaXRpb24gPSBtb3JwaFRhcmdldHNQb3NpdGlvbjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoTm9ybWFscztcclxuXHRcdHZhciBtb3JwaE5vcm1hbHNMZW5ndGggPSBtb3JwaE5vcm1hbHMubGVuZ3RoO1xyXG5cclxuXHRcdHZhciBtb3JwaFRhcmdldHNOb3JtYWw7XHJcblxyXG5cdFx0aWYgKCBtb3JwaE5vcm1hbHNMZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0bW9ycGhUYXJnZXRzTm9ybWFsID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdG1vcnBoVGFyZ2V0c05vcm1hbFsgaSBdID0gW107XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0cy5ub3JtYWwgPSBtb3JwaFRhcmdldHNOb3JtYWw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNraW5zXHJcblxyXG5cdFx0dmFyIHNraW5JbmRpY2VzID0gZ2VvbWV0cnkuc2tpbkluZGljZXM7XHJcblx0XHR2YXIgc2tpbldlaWdodHMgPSBnZW9tZXRyeS5za2luV2VpZ2h0cztcclxuXHJcblx0XHR2YXIgaGFzU2tpbkluZGljZXMgPSBza2luSW5kaWNlcy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcclxuXHRcdHZhciBoYXNTa2luV2VpZ2h0cyA9IHNraW5XZWlnaHRzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgZmFjZS5hIF0sIHZlcnRpY2VzWyBmYWNlLmIgXSwgdmVydGljZXNbIGZhY2UuYyBdICk7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubm9ybWFscy5wdXNoKCB2ZXJ0ZXhOb3JtYWxzWyAwIF0sIHZlcnRleE5vcm1hbHNbIDEgXSwgdmVydGV4Tm9ybWFsc1sgMiBdICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XHJcblxyXG5cdFx0XHRcdHRoaXMubm9ybWFscy5wdXNoKCBub3JtYWwsIG5vcm1hbCwgbm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHRpZiAoIHZlcnRleENvbG9ycy5sZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuY29sb3JzLnB1c2goIHZlcnRleENvbG9yc1sgMCBdLCB2ZXJ0ZXhDb2xvcnNbIDEgXSwgdmVydGV4Q29sb3JzWyAyIF0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZhciBjb2xvciA9IGZhY2UuY29sb3I7XHJcblxyXG5cdFx0XHRcdHRoaXMuY29sb3JzLnB1c2goIGNvbG9yLCBjb2xvciwgY29sb3IgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy51dnMucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYgJywgaSApO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYyID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMSBdWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy51dnMyLnB1c2goIHZlcnRleFV2c1sgMCBdLCB2ZXJ0ZXhVdnNbIDEgXSwgdmVydGV4VXZzWyAyIF0gKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2MiAnLCBpICk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy51dnMyLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbW9ycGhzXHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaFRhcmdldHNMZW5ndGg7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaiBdLnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRtb3JwaFRhcmdldHNQb3NpdGlvblsgaiBdLnB1c2goIG1vcnBoVGFyZ2V0WyBmYWNlLmEgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYiBdLCBtb3JwaFRhcmdldFsgZmFjZS5jIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIG1vcnBoTm9ybWFsID0gbW9ycGhOb3JtYWxzWyBqIF0udmVydGV4Tm9ybWFsc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRtb3JwaFRhcmdldHNOb3JtYWxbIGogXS5wdXNoKCBtb3JwaE5vcm1hbC5hLCBtb3JwaE5vcm1hbC5iLCBtb3JwaE5vcm1hbC5jICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBza2luc1xyXG5cclxuXHRcdFx0aWYgKCBoYXNTa2luSW5kaWNlcyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5za2luSW5kaWNlcy5wdXNoKCBza2luSW5kaWNlc1sgZmFjZS5hIF0sIHNraW5JbmRpY2VzWyBmYWNlLmIgXSwgc2tpbkluZGljZXNbIGZhY2UuYyBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc1NraW5XZWlnaHRzICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnNraW5XZWlnaHRzLnB1c2goIHNraW5XZWlnaHRzWyBmYWNlLmEgXSwgc2tpbldlaWdodHNbIGZhY2UuYiBdLCBza2luV2VpZ2h0c1sgZmFjZS5jIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlR3JvdXBzKCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcclxuXHRcdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XHJcblx0XHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5EaXJlY3RHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvQnVmZmVyR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKyB9ICk7XHJcblxyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMuaW5kZXggPSBudWxsO1xyXG5cdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xyXG5cclxuXHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xyXG5cclxuXHR0aGlzLmdyb3VwcyA9IFtdO1xyXG5cclxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0dGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogSW5maW5pdHkgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJHZW9tZXRyeSxcclxuXHJcblx0Z2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5pbmRleDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0SW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0dGhpcy5pbmRleCA9IGluZGV4O1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSwgYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyQXR0cmlidXRlID09PSBmYWxzZSAmJiBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEF0dHJpYnV0ZSgpIG5vdyBleHBlY3RzICggbmFtZSwgYXR0cmlidXRlICkuJyApO1xyXG5cclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFyZ3VtZW50c1sgMSBdLCBhcmd1bWVudHNbIDIgXSApICk7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbmFtZSA9PT0gJ2luZGV4JyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZTogVXNlIC5zZXRJbmRleCgpIGZvciBpbmRleCBhdHRyaWJ1dGUuJyApO1xyXG5cdFx0XHR0aGlzLnNldEluZGV4KCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSBhdHRyaWJ1dGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0fSxcclxuXHJcblx0cmVtb3ZlQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRHcm91cDogZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggKSB7XHJcblxyXG5cdFx0dGhpcy5ncm91cHMucHVzaCgge1xyXG5cclxuXHRcdFx0c3RhcnQ6IHN0YXJ0LFxyXG5cdFx0XHRjb3VudDogY291bnQsXHJcblx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwXHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbGVhckdyb3VwczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZ3JvdXBzID0gW107XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldERyYXdSYW5nZTogZnVuY3Rpb24gKCBzdGFydCwgY291bnQgKSB7XHJcblxyXG5cdFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzdGFydDtcclxuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG5cdFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIHBvc2l0aW9uLmFycmF5ICk7XHJcblx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XHJcblxyXG5cdFx0aWYgKCBub3JtYWwgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHRub3JtYWxNYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggbm9ybWFsLmFycmF5ICk7XHJcblx0XHRcdG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcclxuXHJcblx0XHR2YXIgbTE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xyXG5cclxuXHRcdHZhciBtMTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXHJcblxyXG5cdFx0dmFyIG0xO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcclxuXHJcblx0XHR2YXIgbTE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBzY2FsZSBnZW9tZXRyeVxyXG5cclxuXHRcdHZhciBtMTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBvYmo7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmogPT09IHVuZGVmaW5lZCApIG9iaiA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuXHRcdFx0b2JqLmxvb2tBdCggdmVjdG9yICk7XHJcblxyXG5cdFx0XHRvYmoudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmNlbnRlcigpLm5lZ2F0ZSgpO1xyXG5cclxuXHRcdHRoaXMudHJhbnNsYXRlKCBvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56ICk7XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbU9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5zZXRGcm9tT2JqZWN0KCkuIENvbnZlcnRpbmcnLCBvYmplY3QsIHRoaXMgKTtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMywgMyApO1xyXG5cdFx0XHR2YXIgY29sb3JzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzLCAzICk7XHJcblxyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBjb2xvcnMuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICYmIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoID09PSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsaW5lRGlzdGFuY2VzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoLCAxICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbGluZURpc3RhbmNlJywgbGluZURpc3RhbmNlcy5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHR2YXIgZGlyZWN0ID0gZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeTtcclxuXHJcblx0XHRcdGlmICggZGlyZWN0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRpcmVjdC52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XHJcblx0XHRcdGRpcmVjdC5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xyXG5cdFx0XHRkaXJlY3QuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XHJcblx0XHRcdGRpcmVjdC51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcclxuXHRcdFx0ZGlyZWN0Lmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRnZW9tZXRyeSA9IGRpcmVjdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApO1xyXG5cdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICk7XHJcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMuY29sb3I7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKTtcclxuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnV2O1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKTtcclxuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5saW5lRGlzdGFuY2U7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGUuY29weUFycmF5KCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICk7XHJcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5LmNvbXB1dGVHcm91cHMoIG9iamVjdC5nZW9tZXRyeSApO1xyXG5cdFx0XHR0aGlzLmdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcclxuXHJcblx0XHRcdGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ID0gbmV3IFRIUkVFLkRpcmVjdEdlb21ldHJ5KCkuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZyb21EaXJlY3RHZW9tZXRyeSggZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tRGlyZWN0R2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCAqIDMgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzICk7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkudXZzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzLmxlbmd0aCAqIDIgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LnV2czIubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciB1dnMyID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzMi5sZW5ndGggKiAyICk7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYyJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzMiwgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMyICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgVHlwZUFycmF5ID0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xyXG5cdFx0XHR2YXIgaW5kaWNlcyA9IG5ldyBUeXBlQXJyYXkoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoICogMyApO1xyXG5cdFx0XHR0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkuY29weUluZGljZXNBcnJheSggZ2VvbWV0cnkuaW5kaWNlcyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGdyb3Vwc1xyXG5cclxuXHRcdHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cclxuXHRcdC8vIG1vcnBoc1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IFtdO1xyXG5cdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XHJcblxyXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbW9ycGhUYXJnZXQubGVuZ3RoICogMywgMyApO1xyXG5cclxuXHRcdFx0XHRhcnJheS5wdXNoKCBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIG1vcnBoVGFyZ2V0ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2tpbm5pbmdcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2tpbkluZGljZXMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICogNCwgNCApO1xyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5JbmRleCcsIHNraW5JbmRpY2VzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luSW5kaWNlcyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciBza2luV2VpZ2h0cyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKiA0LCA0ICk7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbldlaWdodCcsIHNraW5XZWlnaHRzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luV2VpZ2h0cyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIHBvc2l0aW9ucyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tQXJyYXkoIHBvc2l0aW9ucyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBwb3NpdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbnMubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1pbi5zZXQoIDAsIDAsIDAgKTtcclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1heC5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnggKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueSApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi56ICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3g6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cdFx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIHBvc2l0aW9ucyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xyXG5cclxuXHRcdFx0XHRib3guc2V0RnJvbUFycmF5KCBwb3NpdGlvbnMgKTtcclxuXHRcdFx0XHRib3guY2VudGVyKCBjZW50ZXIgKTtcclxuXHJcblx0XHRcdFx0Ly8gaG9waW5nIHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcclxuXHRcdFx0XHQvLyBib3VuZGluZ1NwaGVyZSBvZiB0aGUgYm91bmRpbmdCb3g6IHNxcnQoMykgc21hbGxlciBpbiB0aGUgYmVzdCBjYXNlXHJcblxyXG5cdFx0XHRcdHZhciBtYXhSYWRpdXNTcSA9IDA7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHR2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcclxuXHRcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHZlY3RvciApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG5cdFx0XHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblx0XHR2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XHJcblxyXG5cdFx0aWYgKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25zLmxlbmd0aCApLCAzICkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIHJlc2V0IGV4aXN0aW5nIG5vcm1hbHMgdG8gemVyb1xyXG5cclxuXHRcdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGFycmF5WyBpIF0gPSAwO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG5cclxuXHRcdFx0dmFyIHZBLCB2QiwgdkMsXHJcblxyXG5cdFx0XHRwQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdHBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0cEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuXHRcdFx0Y2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xyXG5cclxuXHRcdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5hZGRHcm91cCggMCwgaW5kaWNlcy5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGpsOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xyXG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZBID0gaW5kaWNlc1sgaSArIDAgXSAqIDM7XHJcblx0XHRcdFx0XHRcdHZCID0gaW5kaWNlc1sgaSArIDEgXSAqIDM7XHJcblx0XHRcdFx0XHRcdHZDID0gaW5kaWNlc1sgaSArIDIgXSAqIDM7XHJcblxyXG5cdFx0XHRcdFx0XHRwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkEgKTtcclxuXHRcdFx0XHRcdFx0cEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZCICk7XHJcblx0XHRcdFx0XHRcdHBDLmZyb21BcnJheSggcG9zaXRpb25zLCB2QyApO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcblx0XHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xyXG5cdFx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBIF0gKz0gY2IueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCIF0gKz0gY2IueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDIF0gKz0gY2IueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDkgKSB7XHJcblxyXG5cdFx0XHRcdFx0cEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcclxuXHRcdFx0XHRcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgMyApO1xyXG5cdFx0XHRcdFx0cEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyA2ICk7XHJcblxyXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcclxuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgXSA9IGNiLng7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMSBdID0gY2IueTtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAyIF0gPSBjYi56O1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAzIF0gPSBjYi54O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDQgXSA9IGNiLnk7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNSBdID0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNiBdID0gY2IueDtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA3IF0gPSBjYi55O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDggXSA9IGNiLno7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlcy5ub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZTEgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcclxuXHRcdFx0dmFyIGF0dHJpYnV0ZUFycmF5MSA9IGF0dHJpYnV0ZTEuYXJyYXk7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cdFx0XHR2YXIgYXR0cmlidXRlQXJyYXkyID0gYXR0cmlidXRlMi5hcnJheTtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGVTaXplID0gYXR0cmlidXRlMi5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IGF0dHJpYnV0ZVNpemUgKiBvZmZzZXQ7IGkgPCBhdHRyaWJ1dGVBcnJheTIubGVuZ3RoOyBpICsrLCBqICsrICkge1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGVBcnJheTFbIGogXSA9IGF0dHJpYnV0ZUFycmF5MlsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcclxuXHJcblx0XHR2YXIgeCwgeSwgeiwgbjtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0eCA9IG5vcm1hbHNbIGkgXTtcclxuXHRcdFx0eSA9IG5vcm1hbHNbIGkgKyAxIF07XHJcblx0XHRcdHogPSBub3JtYWxzWyBpICsgMiBdO1xyXG5cclxuXHRcdFx0biA9IDEuMCAvIE1hdGguc3FydCggeCAqIHggKyB5ICogeSArIHogKiB6ICk7XHJcblxyXG5cdFx0XHRub3JtYWxzWyBpIF0gKj0gbjtcclxuXHRcdFx0bm9ybWFsc1sgaSArIDEgXSAqPSBuO1xyXG5cdFx0XHRub3JtYWxzWyBpICsgMiBdICo9IG47XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR0b05vbkluZGV4ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuaW5kZXggPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeS50b05vbkluZGV4ZWQoKTogR2VvbWV0cnkgaXMgYWxyZWFkeSBub24taW5kZXhlZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkyID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG5cdFx0dmFyIGluZGljZXMgPSB0aGlzLmluZGV4LmFycmF5O1xyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XHJcblx0XHRcdHZhciBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdHZhciBhcnJheTIgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IoIGluZGljZXMubGVuZ3RoICogaXRlbVNpemUgKTtcclxuXHJcblx0XHRcdHZhciBpbmRleCA9IDAsIGluZGV4MiA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGluZGV4ID0gaW5kaWNlc1sgaSBdICogaXRlbVNpemU7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGl0ZW1TaXplOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGFycmF5MlsgaW5kZXgyICsrIF0gPSBhcnJheVsgaW5kZXggKysgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkyLmFkZEF0dHJpYnV0ZSggbmFtZSwgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXkyLCBpdGVtU2l6ZSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZW9tZXRyeTI7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdHZlcnNpb246IDQuNCxcclxuXHRcdFx0XHR0eXBlOiAnQnVmZmVyR2VvbWV0cnknLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBzdGFuZGFyZCBCdWZmZXJHZW9tZXRyeSBzZXJpYWxpemF0aW9uXHJcblxyXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xyXG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xyXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xyXG5cclxuXHRcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkYXRhLmRhdGEgPSB7IGF0dHJpYnV0ZXM6IHt9IH07XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5ICk7XHJcblxyXG5cdFx0XHRkYXRhLmRhdGEuaW5kZXggPSB7XHJcblx0XHRcdFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcclxuXHRcdFx0XHRhcnJheTogYXJyYXlcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cclxuXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGF0dHJpYnV0ZS5hcnJheSApO1xyXG5cclxuXHRcdFx0ZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0ge1xyXG5cdFx0XHRcdGl0ZW1TaXplOiBhdHRyaWJ1dGUuaXRlbVNpemUsXHJcblx0XHRcdFx0dHlwZTogYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXHJcblx0XHRcdFx0YXJyYXk6IGFycmF5XHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcclxuXHJcblx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0ZGF0YS5kYXRhLmdyb3VwcyA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBncm91cHMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xyXG5cclxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XHJcblx0XHRcdFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxyXG5cdFx0XHRcdHJhZGl1czogYm91bmRpbmdTcGhlcmUucmFkaXVzXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8qXHJcblx0XHQvLyBIYW5kbGUgcHJpbWl0aXZlc1xyXG5cclxuXHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdFx0XHR2YWx1ZXMucHVzaCggcGFyYW1ldGVyc1sga2V5IF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBnZW9tZXRyeSA9IE9iamVjdC5jcmVhdGUoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlICk7XHJcblx0XHRcdHRoaXMuY29uc3RydWN0b3IuYXBwbHkoIGdlb21ldHJ5LCB2YWx1ZXMgKTtcclxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblx0XHQqL1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdHZhciBpbmRleCA9IHNvdXJjZS5pbmRleDtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuXHRcdFx0dGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5Lk1heEluZGV4ID0gNjU1MzU7XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5JztcclxuXHR0aGlzLm1heEluc3RhbmNlZENvdW50ID0gdW5kZWZpbmVkO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5hZGRHcm91cCA9IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbnN0YW5jZXMgKSB7XHJcblxyXG5cdHRoaXMuZ3JvdXBzLnB1c2goIHtcclxuXHJcblx0XHRzdGFydDogc3RhcnQsXHJcblx0XHRjb3VudDogY291bnQsXHJcblx0XHRpbnN0YW5jZXM6IGluc3RhbmNlc1xyXG5cclxuXHR9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0dmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xyXG5cclxuXHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGV4LmNsb25lKCkgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcblx0XHR0aGlzLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLmluc3RhbmNlcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9Vbmlmb3JtLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Vbmlmb3JtID0gZnVuY3Rpb24gKCB0eXBlLCB2YWx1ZSApIHtcclxuXHJcblx0dGhpcy50eXBlID0gdHlwZTtcclxuXHR0aGlzLnZhbHVlID0gdmFsdWU7XHJcblxyXG5cdHRoaXMuZHluYW1pYyA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlVuaWZvcm0ucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVW5pZm9ybSxcclxuXHJcblx0b25VcGRhdGU6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0dGhpcy5keW5hbWljID0gdHJ1ZTtcclxuXHRcdHRoaXMub25VcGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL0FuaW1hdGlvbkNsaXAuanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBSZXVzYWJsZSBzZXQgb2YgVHJhY2tzIHRoYXQgcmVwcmVzZW50IGFuIGFuaW1hdGlvbi5cclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uQ2xpcCA9IGZ1bmN0aW9uICggbmFtZSwgZHVyYXRpb24sIHRyYWNrcyApIHtcclxuXHJcblx0dGhpcy5uYW1lID0gbmFtZSB8fCBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cdHRoaXMudHJhY2tzID0gdHJhY2tzO1xyXG5cdHRoaXMuZHVyYXRpb24gPSAoIGR1cmF0aW9uICE9PSB1bmRlZmluZWQgKSA/IGR1cmF0aW9uIDogLTE7XHJcblxyXG5cdC8vIHRoaXMgbWVhbnMgaXQgc2hvdWxkIGZpZ3VyZSBvdXQgaXRzIGR1cmF0aW9uIGJ5IHNjYW5uaW5nIHRoZSB0cmFja3NcclxuXHRpZiAoIHRoaXMuZHVyYXRpb24gPCAwICkge1xyXG5cclxuXHRcdHRoaXMucmVzZXREdXJhdGlvbigpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIG1heWJlIG9ubHkgZG8gdGhlc2Ugb24gZGVtYW5kLCBhcyBkb2luZyB0aGVtIGhlcmUgY291bGQgcG90ZW50aWFsbHkgc2xvdyBkb3duIGxvYWRpbmdcclxuXHQvLyBidXQgbGVhdmluZyB0aGVzZSBoZXJlIGR1cmluZyBkZXZlbG9wbWVudCBhcyB0aGlzIGVuc3VyZXMgYSBsb3Qgb2YgdGVzdGluZyBvZiB0aGVzZSBmdW5jdGlvbnNcclxuXHR0aGlzLnRyaW0oKTtcclxuXHR0aGlzLm9wdGltaXplKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uQ2xpcC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5BbmltYXRpb25DbGlwLFxyXG5cclxuXHRyZXNldER1cmF0aW9uOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdHJhY2tzID0gdGhpcy50cmFja3MsXHJcblx0XHRcdGR1cmF0aW9uID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB0cmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIHRyYWNrID0gdGhpcy50cmFja3NbIGkgXTtcclxuXHJcblx0XHRcdGR1cmF0aW9uID0gTWF0aC5tYXgoXHJcblx0XHRcdFx0XHRkdXJhdGlvbiwgdHJhY2sudGltZXNbIHRyYWNrLnRpbWVzLmxlbmd0aCAtIDEgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyaW06IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMudHJhY2tzWyBpIF0udHJpbSggMCwgdGhpcy5kdXJhdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0b3B0aW1pemU6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMudHJhY2tzWyBpIF0ub3B0aW1pemUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBTdGF0aWMgbWV0aG9kczpcclxuXHJcbk9iamVjdC5hc3NpZ24oIFRIUkVFLkFuaW1hdGlvbkNsaXAsIHtcclxuXHJcblx0cGFyc2U6IGZ1bmN0aW9uKCBqc29uICkge1xyXG5cclxuXHRcdHZhciB0cmFja3MgPSBbXSxcclxuXHRcdFx0anNvblRyYWNrcyA9IGpzb24udHJhY2tzLFxyXG5cdFx0XHRmcmFtZVRpbWUgPSAxLjAgLyAoIGpzb24uZnBzIHx8IDEuMCApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGpzb25UcmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dHJhY2tzLnB1c2goIFRIUkVFLktleWZyYW1lVHJhY2sucGFyc2UoIGpzb25UcmFja3NbIGkgXSApLnNjYWxlKCBmcmFtZVRpbWUgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLkFuaW1hdGlvbkNsaXAoIGpzb24ubmFtZSwganNvbi5kdXJhdGlvbiwgdHJhY2tzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uKCBjbGlwICkge1xyXG5cclxuXHRcdHZhciB0cmFja3MgPSBbXSxcclxuXHRcdFx0Y2xpcFRyYWNrcyA9IGNsaXAudHJhY2tzO1xyXG5cclxuXHRcdHZhciBqc29uID0ge1xyXG5cclxuXHRcdFx0J25hbWUnOiBjbGlwLm5hbWUsXHJcblx0XHRcdCdkdXJhdGlvbic6IGNsaXAuZHVyYXRpb24sXHJcblx0XHRcdCd0cmFja3MnOiB0cmFja3NcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGNsaXBUcmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dHJhY2tzLnB1c2goIFRIUkVFLktleWZyYW1lVHJhY2sudG9KU09OKCBjbGlwVHJhY2tzWyBpIF0gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ganNvbjtcclxuXHJcblx0fSxcclxuXHJcblxyXG5cdENyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlOiBmdW5jdGlvbiggbmFtZSwgbW9ycGhUYXJnZXRTZXF1ZW5jZSwgZnBzICkge1xyXG5cclxuXHRcdHZhciBudW1Nb3JwaFRhcmdldHMgPSBtb3JwaFRhcmdldFNlcXVlbmNlLmxlbmd0aDtcclxuXHRcdHZhciB0cmFja3MgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1Nb3JwaFRhcmdldHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGltZXMgPSBbXTtcclxuXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0dGltZXMucHVzaChcclxuXHRcdFx0XHRcdCggaSArIG51bU1vcnBoVGFyZ2V0cyAtIDEgKSAlIG51bU1vcnBoVGFyZ2V0cyxcclxuXHRcdFx0XHRcdGksXHJcblx0XHRcdFx0XHQoIGkgKyAxICkgJSBudW1Nb3JwaFRhcmdldHMgKTtcclxuXHJcblx0XHRcdHZhbHVlcy5wdXNoKCAwLCAxLCAwICk7XHJcblxyXG5cdFx0XHR2YXIgb3JkZXIgPSBUSFJFRS5BbmltYXRpb25VdGlscy5nZXRLZXlmcmFtZU9yZGVyKCB0aW1lcyApO1xyXG5cdFx0XHR0aW1lcyA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KCB0aW1lcywgMSwgb3JkZXIgKTtcclxuXHRcdFx0dmFsdWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuc29ydGVkQXJyYXkoIHZhbHVlcywgMSwgb3JkZXIgKTtcclxuXHJcblx0XHRcdC8vIGlmIHRoZXJlIGlzIGEga2V5IGF0IHRoZSBmaXJzdCBmcmFtZSwgZHVwbGljYXRlIGl0IGFzIHRoZVxyXG5cdFx0XHQvLyBsYXN0IGZyYW1lIGFzIHdlbGwgZm9yIHBlcmZlY3QgbG9vcC5cclxuXHRcdFx0aWYgKCB0aW1lc1sgMCBdID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR0aW1lcy5wdXNoKCBudW1Nb3JwaFRhcmdldHMgKTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWVzWyAwIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRyYWNrcy5wdXNoKFxyXG5cdFx0XHRcdFx0bmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soXHJcblx0XHRcdFx0XHRcdCcubW9ycGhUYXJnZXRJbmZsdWVuY2VzWycgKyBtb3JwaFRhcmdldFNlcXVlbmNlWyBpIF0ubmFtZSArICddJyxcclxuXHRcdFx0XHRcdFx0dGltZXMsIHZhbHVlc1xyXG5cdFx0XHRcdFx0KS5zY2FsZSggMS4wIC8gZnBzICkgKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLkFuaW1hdGlvbkNsaXAoIG5hbWUsIC0xLCB0cmFja3MgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZmluZEJ5TmFtZTogZnVuY3Rpb24oIGNsaXBBcnJheSwgbmFtZSApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjbGlwQXJyYXkubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBjbGlwQXJyYXlbIGkgXS5uYW1lID09PSBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2xpcEFycmF5WyBpIF07XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH0sXHJcblxyXG5cdENyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzOiBmdW5jdGlvbiggbW9ycGhUYXJnZXRzLCBmcHMgKSB7XHJcblxyXG5cdFx0dmFyIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzID0ge307XHJcblxyXG5cdFx0Ly8gdGVzdGVkIHdpdGggaHR0cHM6Ly9yZWdleDEwMS5jb20vIG9uIHRyaWNrIHNlcXVlbmNlc1xyXG5cdFx0Ly8gc3VjaCBmbGFtaW5nb19mbHlBXzAwMywgZmxhbWluZ29fcnVuMV8wMDMsIGNyZGVhdGgwMDU5XHJcblx0XHR2YXIgcGF0dGVybiA9IC9eKFtcXHctXSo/KShbXFxkXSspJC87XHJcblxyXG5cdFx0Ly8gc29ydCBtb3JwaCB0YXJnZXQgbmFtZXMgaW50byBhbmltYXRpb24gZ3JvdXBzIGJhc2VkXHJcblx0XHQvLyBwYXR0ZXJucyBsaWtlIFdhbGtfMDAxLCBXYWxrXzAwMiwgUnVuXzAwMSwgUnVuXzAwMlxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xyXG5cdFx0XHR2YXIgcGFydHMgPSBtb3JwaFRhcmdldC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XHJcblxyXG5cdFx0XHRpZiAoIHBhcnRzICYmIHBhcnRzLmxlbmd0aCA+IDEgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBuYW1lID0gcGFydHNbIDEgXTtcclxuXHJcblx0XHRcdFx0dmFyIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF07XHJcblx0XHRcdFx0aWYgKCAhIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0XHRhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdID0gYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gW107XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YW5pbWF0aW9uTW9ycGhUYXJnZXRzLnB1c2goIG1vcnBoVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjbGlwcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0Y2xpcHMucHVzaCggVEhSRUUuQW5pbWF0aW9uQ2xpcC5DcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZSggbmFtZSwgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSwgZnBzICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNsaXBzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBwYXJzZSB0aGUgYW5pbWF0aW9uLmhpZXJhcmNoeSBmb3JtYXRcclxuXHRwYXJzZUFuaW1hdGlvbjogZnVuY3Rpb24oIGFuaW1hdGlvbiwgYm9uZXMsIG5vZGVOYW1lICkge1xyXG5cclxuXHRcdGlmICggISBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgbm8gYW5pbWF0aW9uIGluIEpTT05Mb2FkZXIgZGF0YVwiICk7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYWRkTm9uZW1wdHlUcmFjayA9IGZ1bmN0aW9uKFxyXG5cdFx0XHRcdHRyYWNrVHlwZSwgdHJhY2tOYW1lLCBhbmltYXRpb25LZXlzLCBwcm9wZXJ0eU5hbWUsIGRlc3RUcmFja3MgKSB7XHJcblxyXG5cdFx0XHQvLyBvbmx5IHJldHVybiB0cmFjayBpZiB0aGVyZSBhcmUgYWN0dWFsbHkga2V5cy5cclxuXHRcdFx0aWYgKCBhbmltYXRpb25LZXlzLmxlbmd0aCAhPT0gMCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHRpbWVzID0gW107XHJcblx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0XHRUSFJFRS5BbmltYXRpb25VdGlscy5mbGF0dGVuSlNPTihcclxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgdGltZXMsIHZhbHVlcywgcHJvcGVydHlOYW1lICk7XHJcblxyXG5cdFx0XHRcdC8vIGVtcHR5IGtleXMgYXJlIGZpbHRlcmVkIG91dCwgc28gY2hlY2sgYWdhaW5cclxuXHRcdFx0XHRpZiAoIHRpbWVzLmxlbmd0aCAhPT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRkZXN0VHJhY2tzLnB1c2goIG5ldyB0cmFja1R5cGUoIHRyYWNrTmFtZSwgdGltZXMsIHZhbHVlcyApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciB0cmFja3MgPSBbXTtcclxuXHJcblx0XHR2YXIgY2xpcE5hbWUgPSBhbmltYXRpb24ubmFtZSB8fCAnZGVmYXVsdCc7XHJcblx0XHQvLyBhdXRvbWF0aWMgbGVuZ3RoIGRldGVybWluYXRpb24gaW4gQW5pbWF0aW9uQ2xpcC5cclxuXHRcdHZhciBkdXJhdGlvbiA9IGFuaW1hdGlvbi5sZW5ndGggfHwgLTE7XHJcblx0XHR2YXIgZnBzID0gYW5pbWF0aW9uLmZwcyB8fCAzMDtcclxuXHJcblx0XHR2YXIgaGllcmFyY2h5VHJhY2tzID0gYW5pbWF0aW9uLmhpZXJhcmNoeSB8fCBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaCA9IDA7IGggPCBoaWVyYXJjaHlUcmFja3MubGVuZ3RoOyBoICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGFuaW1hdGlvbktleXMgPSBoaWVyYXJjaHlUcmFja3NbIGggXS5rZXlzO1xyXG5cclxuXHRcdFx0Ly8gc2tpcCBlbXB0eSB0cmFja3NcclxuXHRcdFx0aWYgKCAhIGFuaW1hdGlvbktleXMgfHwgYW5pbWF0aW9uS2V5cy5sZW5ndGggPT0gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0Ly8gcHJvY2VzcyBtb3JwaCB0YXJnZXRzIGluIGEgd2F5IGV4YWN0bHkgY29tcGF0aWJsZVxyXG5cdFx0XHQvLyB3aXRoIEFuaW1hdGlvbkhhbmRsZXIuaW5pdCggYW5pbWF0aW9uIClcclxuXHRcdFx0aWYgKCBhbmltYXRpb25LZXlzWzBdLm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0Ly8gZmlndXJlIG91dCBhbGwgbW9ycGggdGFyZ2V0cyB1c2VkIGluIHRoaXMgdHJhY2tcclxuXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXROYW1lcyA9IHt9O1xyXG5cdFx0XHRcdGZvciAoIHZhciBrID0gMDsgayA8IGFuaW1hdGlvbktleXMubGVuZ3RoOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDA7IG0gPCBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG1vcnBoVGFyZ2V0TmFtZXNbIGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzW21dIF0gPSAtMTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBjcmVhdGUgYSB0cmFjayBmb3IgZWFjaCBtb3JwaCB0YXJnZXQgd2l0aCBhbGwgemVyb1xyXG5cdFx0XHRcdC8vIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBleGNlcHQgZm9yIHRoZSBrZXlzIGluIHdoaWNoXHJcblx0XHRcdFx0Ly8gdGhlIG1vcnBoVGFyZ2V0IGlzIG5hbWVkLlxyXG5cdFx0XHRcdGZvciAoIHZhciBtb3JwaFRhcmdldE5hbWUgaW4gbW9ycGhUYXJnZXROYW1lcyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdGltZXMgPSBbXTtcclxuXHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDA7XHJcblx0XHRcdFx0XHRcdFx0bSAhPT0gYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHMubGVuZ3RoOyArKyBtICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGFuaW1hdGlvbktleSA9IGFuaW1hdGlvbktleXNba107XHJcblxyXG5cdFx0XHRcdFx0XHR0aW1lcy5wdXNoKCBhbmltYXRpb25LZXkudGltZSApO1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggKCBhbmltYXRpb25LZXkubW9ycGhUYXJnZXQgPT09IG1vcnBoVGFyZ2V0TmFtZSApID8gMSA6IDAgKVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0cmFja3MucHVzaCggbmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soXHJcblx0XHRcdFx0XHRcdFx0Jy5tb3JwaFRhcmdldEluZmx1ZW5jZVsnICsgbW9ycGhUYXJnZXROYW1lICsgJ10nLCB0aW1lcywgdmFsdWVzICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkdXJhdGlvbiA9IG1vcnBoVGFyZ2V0TmFtZXMubGVuZ3RoICogKCBmcHMgfHwgMS4wICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIC4uLmFzc3VtZSBza2VsZXRhbCBhbmltYXRpb25cclxuXHJcblx0XHRcdFx0dmFyIGJvbmVOYW1lID0gJy5ib25lc1snICsgYm9uZXNbIGggXS5uYW1lICsgJ10nO1xyXG5cclxuXHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxyXG5cdFx0XHRcdFx0XHRUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucG9zaXRpb24nLFxyXG5cdFx0XHRcdFx0XHRhbmltYXRpb25LZXlzLCAncG9zJywgdHJhY2tzICk7XHJcblxyXG5cdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXHJcblx0XHRcdFx0XHRcdFRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucXVhdGVybmlvbicsXHJcblx0XHRcdFx0XHRcdGFuaW1hdGlvbktleXMsICdyb3QnLCB0cmFja3MgKTtcclxuXHJcblx0XHRcdFx0YWRkTm9uZW1wdHlUcmFjayhcclxuXHRcdFx0XHRcdFx0VEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnNjYWxlJyxcclxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3NjbCcsIHRyYWNrcyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRyYWNrcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNsaXAgPSBuZXcgVEhSRUUuQW5pbWF0aW9uQ2xpcCggY2xpcE5hbWUsIGR1cmF0aW9uLCB0cmFja3MgKTtcclxuXHJcblx0XHRyZXR1cm4gY2xpcDtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi9BbmltYXRpb25NaXhlci5qc1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIFBsYXllciBmb3IgQW5pbWF0aW9uQ2xpcHMuXHJcbiAqXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKiBAYXV0aG9yIHRzY2h3XHJcbiAqL1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uTWl4ZXIgPSBmdW5jdGlvbiggcm9vdCApIHtcclxuXHJcblx0dGhpcy5fcm9vdCA9IHJvb3Q7XHJcblx0dGhpcy5faW5pdE1lbW9yeU1hbmFnZXIoKTtcclxuXHR0aGlzLl9hY2N1SW5kZXggPSAwO1xyXG5cclxuXHR0aGlzLnRpbWUgPSAwO1xyXG5cclxuXHR0aGlzLnRpbWVTY2FsZSA9IDEuMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BbmltYXRpb25NaXhlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5BbmltYXRpb25NaXhlcixcclxuXHJcblx0Ly8gcmV0dXJuIGFuIGFjdGlvbiBmb3IgYSBjbGlwIG9wdGlvbmFsbHkgdXNpbmcgYSBjdXN0b20gcm9vdCB0YXJnZXRcclxuXHQvLyBvYmplY3QgKHRoaXMgbWV0aG9kIGFsbG9jYXRlcyBhIGxvdCBvZiBkeW5hbWljIG1lbW9yeSBpbiBjYXNlIGFcclxuXHQvLyBwcmV2aW91c2x5IHVua25vd24gY2xpcC9yb290IGNvbWJpbmF0aW9uIGlzIHNwZWNpZmllZClcclxuXHRjbGlwQWN0aW9uOiBmdW5jdGlvbiggY2xpcCwgb3B0aW9uYWxSb290ICkge1xyXG5cclxuXHRcdHZhciByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXHJcblx0XHRcdHJvb3RVdWlkID0gcm9vdC51dWlkLFxyXG5cdFx0XHRjbGlwTmFtZSA9ICggdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnICkgPyBjbGlwIDogY2xpcC5uYW1lLFxyXG5cdFx0XHRjbGlwT2JqZWN0ID0gKCBjbGlwICE9PSBjbGlwTmFtZSApID8gY2xpcCA6IG51bGwsXHJcblxyXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF0sXHJcblx0XHRcdHByb3RvdHlwZUFjdGlvbjtcclxuXHJcblx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZXhpc3RpbmdBY3Rpb24gPVxyXG5cdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBleGlzdGluZ0FjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZXhpc3RpbmdBY3Rpb247XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB3ZSBrbm93IHRoZSBjbGlwLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHBhcnNlIGFsbFxyXG5cdFx0XHQvLyB0aGUgYmluZGluZ3MgYWdhaW4gYnV0IGNhbiBqdXN0IGNvcHlcclxuXHRcdFx0cHJvdG90eXBlQWN0aW9uID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zWyAwIF07XHJcblxyXG5cdFx0XHQvLyBhbHNvLCB0YWtlIHRoZSBjbGlwIGZyb20gdGhlIHByb3RvdHlwZSBhY3Rpb25cclxuXHRcdFx0Y2xpcE9iamVjdCA9IHByb3RvdHlwZUFjdGlvbi5fY2xpcDtcclxuXHJcblx0XHRcdGlmICggY2xpcCAhPT0gY2xpcE5hbWUgJiYgY2xpcCAhPT0gY2xpcE9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFx0XHRcIkRpZmZlcmVudCBjbGlwcyB3aXRoIHRoZSBzYW1lIG5hbWUgZGV0ZWN0ZWQhXCIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2xpcCBtdXN0IGJlIGtub3duIHdoZW4gc3BlY2lmaWVkIHZpYSBzdHJpbmdcclxuXHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdC8vIGFsbG9jYXRlIGFsbCByZXNvdXJjZXMgcmVxdWlyZWQgdG8gcnVuIGl0XHJcblx0XHR2YXIgbmV3QWN0aW9uID0gbmV3IFRIUkVFLlxyXG5cdFx0XHRcdEFuaW1hdGlvbk1peGVyLl9BY3Rpb24oIHRoaXMsIGNsaXBPYmplY3QsIG9wdGlvbmFsUm9vdCApO1xyXG5cclxuXHRcdHRoaXMuX2JpbmRBY3Rpb24oIG5ld0FjdGlvbiwgcHJvdG90eXBlQWN0aW9uICk7XHJcblxyXG5cdFx0Ly8gYW5kIG1ha2UgdGhlIGFjdGlvbiBrbm93biB0byB0aGUgbWVtb3J5IG1hbmFnZXJcclxuXHRcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKCBuZXdBY3Rpb24sIGNsaXBOYW1lLCByb290VXVpZCApO1xyXG5cclxuXHRcdHJldHVybiBuZXdBY3Rpb247XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGdldCBhbiBleGlzdGluZyBhY3Rpb25cclxuXHRleGlzdGluZ0FjdGlvbjogZnVuY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcclxuXHJcblx0XHR2YXIgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxyXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcclxuXHRcdFx0Y2xpcE5hbWUgPSAoIHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyApID8gY2xpcCA6IGNsaXAubmFtZSxcclxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwWyBjbGlwTmFtZSBdO1xyXG5cclxuXHRcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF0gfHwgbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGRlYWN0aXZhdGVzIGFsbCBwcmV2aW91c2x5IHNjaGVkdWxlZCBhY3Rpb25zXHJcblx0c3RvcEFsbEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxyXG5cdFx0XHRuQWN0aW9ucyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zLFxyXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxyXG5cdFx0XHRuQmluZGluZ3MgPSB0aGlzLl9uQWN0aXZlQmluZGluZ3M7XHJcblxyXG5cdFx0dGhpcy5fbkFjdGl2ZUFjdGlvbnMgPSAwO1xyXG5cdFx0dGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5BY3Rpb25zOyArKyBpICkge1xyXG5cclxuXHRcdFx0YWN0aW9uc1sgaSBdLnJlc2V0KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkJpbmRpbmdzOyArKyBpICkge1xyXG5cclxuXHRcdFx0YmluZGluZ3NbIGkgXS51c2VDb3VudCA9IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBhZHZhbmNlIHRoZSB0aW1lIGFuZCB1cGRhdGUgYXBwbHkgdGhlIGFuaW1hdGlvblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24oIGRlbHRhVGltZSApIHtcclxuXHJcblx0XHRkZWx0YVRpbWUgKj0gdGhpcy50aW1lU2NhbGU7XHJcblxyXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxyXG5cdFx0XHRuQWN0aW9ucyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zLFxyXG5cclxuXHRcdFx0dGltZSA9IHRoaXMudGltZSArPSBkZWx0YVRpbWUsXHJcblx0XHRcdHRpbWVEaXJlY3Rpb24gPSBNYXRoLnNpZ24oIGRlbHRhVGltZSApLFxyXG5cclxuXHRcdFx0YWNjdUluZGV4ID0gdGhpcy5fYWNjdUluZGV4IF49IDE7XHJcblxyXG5cdFx0Ly8gcnVuIGFjdGl2ZSBhY3Rpb25zXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuQWN0aW9uczsgKysgaSApIHtcclxuXHJcblx0XHRcdHZhciBhY3Rpb24gPSBhY3Rpb25zWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGFjdGlvbi5lbmFibGVkICkge1xyXG5cclxuXHRcdFx0XHRhY3Rpb24uX3VwZGF0ZSggdGltZSwgZGVsdGFUaW1lLCB0aW1lRGlyZWN0aW9uLCBhY2N1SW5kZXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXHJcblxyXG5cdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdG5CaW5kaW5ncyA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5CaW5kaW5nczsgKysgaSApIHtcclxuXHJcblx0XHRcdGJpbmRpbmdzWyBpIF0uYXBwbHkoIGFjY3VJbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJuIHRoaXMgbWl4ZXIncyByb290IHRhcmdldCBvYmplY3RcclxuXHRnZXRSb290OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fcm9vdDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciBjbGlwXHJcblx0dW5jYWNoZUNsaXA6IGZ1bmN0aW9uKCBjbGlwICkge1xyXG5cclxuXHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcclxuXHRcdFx0Y2xpcE5hbWUgPSBjbGlwLm5hbWUsXHJcblx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxyXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF07XHJcblxyXG5cdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ly8gbm90ZToganVzdCBjYWxsaW5nIF9yZW1vdmVJbmFjdGl2ZUFjdGlvbiB3b3VsZCBtZXNzIHVwIHRoZVxyXG5cdFx0XHQvLyBpdGVyYXRpb24gc3RhdGUgYW5kIGFsc28gcmVxdWlyZSB1cGRhdGluZyB0aGUgc3RhdGUgd2UgY2FuXHJcblx0XHRcdC8vIGp1c3QgdGhyb3cgYXdheVxyXG5cclxuXHRcdFx0dmFyIGFjdGlvbnNUb1JlbW92ZSA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGFjdGlvbnNUb1JlbW92ZS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBhY3Rpb24gPSBhY3Rpb25zVG9SZW1vdmVbIGkgXTtcclxuXHJcblx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XHJcblxyXG5cdFx0XHRcdHZhciBjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxyXG5cdFx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgYWN0aW9ucy5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XHJcblx0XHRcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcclxuXHJcblx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcclxuXHRcdFx0XHRhY3Rpb25zWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XHJcblx0XHRcdFx0YWN0aW9ucy5wb3AoKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbiggYWN0aW9uICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkZWxldGUgYWN0aW9uc0J5Q2xpcFsgY2xpcE5hbWUgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGZyZWUgYWxsIHJlc291cmNlcyBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgcm9vdCB0YXJnZXQgb2JqZWN0XHJcblx0dW5jYWNoZVJvb3Q6IGZ1bmN0aW9uKCByb290ICkge1xyXG5cclxuXHRcdHZhciByb290VXVpZCA9IHJvb3QudXVpZCxcclxuXHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGNsaXBOYW1lIGluIGFjdGlvbnNCeUNsaXAgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWN0aW9uQnlSb290ID0gYWN0aW9uc0J5Q2xpcFsgY2xpcE5hbWUgXS5hY3Rpb25CeVJvb3QsXHJcblx0XHRcdFx0YWN0aW9uID0gYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBhY3Rpb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXHJcblx0XHRcdGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcclxuXHJcblx0XHRpZiAoIGJpbmRpbmdCeU5hbWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciB0cmFja05hbWUgaW4gYmluZGluZ0J5TmFtZSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcclxuXHRcdFx0XHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHQvLyByZW1vdmUgYSB0YXJnZXRlZCBjbGlwIGZyb20gdGhlIGNhY2hlXHJcblx0dW5jYWNoZUFjdGlvbjogZnVuY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcclxuXHJcblx0XHR2YXIgYWN0aW9uID0gdGhpcy5leGlzdGluZ0FjdGlvbiggY2xpcCwgb3B0aW9uYWxSb290ICk7XHJcblxyXG5cdFx0aWYgKCBhY3Rpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkFuaW1hdGlvbk1peGVyLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uTWl4ZXIuX0FjdGlvbiA9XHJcblx0XHRmdW5jdGlvbiggbWl4ZXIsIGNsaXAsIGxvY2FsUm9vdCApIHtcclxuXHJcblx0dGhpcy5fbWl4ZXIgPSBtaXhlcjtcclxuXHR0aGlzLl9jbGlwID0gY2xpcDtcclxuXHR0aGlzLl9sb2NhbFJvb3QgPSBsb2NhbFJvb3QgfHwgbnVsbDtcclxuXHJcblx0dmFyIHRyYWNrcyA9IGNsaXAudHJhY2tzLFxyXG5cdFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXHJcblx0XHRpbnRlcnBvbGFudHMgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcclxuXHJcblx0dmFyIGludGVycG9sYW50U2V0dGluZ3MgPSB7XHJcblx0XHRcdGVuZGluZ1N0YXJ0OiBcdFRIUkVFLlplcm9DdXJ2YXR1cmVFbmRpbmcsXHJcblx0XHRcdGVuZGluZ0VuZDpcdFx0VEhSRUUuWmVyb0N1cnZhdHVyZUVuZGluZ1xyXG5cdH07XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSAhPT0gblRyYWNrczsgKysgaSApIHtcclxuXHJcblx0XHR2YXIgaW50ZXJwb2xhbnQgPSB0cmFja3NbIGkgXS5jcmVhdGVJbnRlcnBvbGFudCggbnVsbCApO1xyXG5cdFx0aW50ZXJwb2xhbnRzWyBpIF0gPSBpbnRlcnBvbGFudDtcclxuXHRcdGludGVycG9sYW50LnNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5nc1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3MgPSBpbnRlcnBvbGFudFNldHRpbmdzO1xyXG5cclxuXHR0aGlzLl9pbnRlcnBvbGFudHMgPSBpbnRlcnBvbGFudHM7XHQvLyBib3VuZCBieSB0aGUgbWl4ZXJcclxuXHJcblx0Ly8gaW5zaWRlOiBQcm9wZXJ0eU1peGVyIChtYW5hZ2VkIGJ5IHRoZSBtaXhlcilcclxuXHR0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzID0gbmV3IEFycmF5KCBuVHJhY2tzICk7XHJcblxyXG5cdHRoaXMuX2NhY2hlSW5kZXggPSBudWxsO1x0XHRcdC8vIGZvciB0aGUgbWVtb3J5IG1hbmFnZXJcclxuXHR0aGlzLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcdFx0Ly8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxyXG5cclxuXHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XHJcblx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xyXG5cclxuXHR0aGlzLmxvb3AgPSBUSFJFRS5Mb29wUmVwZWF0O1xyXG5cdHRoaXMuX2xvb3BDb3VudCA9IC0xO1xyXG5cclxuXHQvLyBnbG9iYWwgbWl4ZXIgdGltZSB3aGVuIHRoZSBhY3Rpb24gaXMgdG8gYmUgc3RhcnRlZFxyXG5cdC8vIGl0J3Mgc2V0IGJhY2sgdG8gJ251bGwnIHVwb24gc3RhcnQgb2YgdGhlIGFjdGlvblxyXG5cdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XHJcblxyXG5cdC8vIHNjYWxlZCBsb2NhbCB0aW1lIG9mIHRoZSBhY3Rpb25cclxuXHQvLyBnZXRzIGNsYW1wZWQgb3Igd3JhcHBlZCB0byAwLi5jbGlwLmR1cmF0aW9uIGFjY29yZGluZyB0byBsb29wXHJcblx0dGhpcy50aW1lID0gMDtcclxuXHJcblx0dGhpcy50aW1lU2NhbGUgPSAxO1xyXG5cdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IDE7XHJcblxyXG5cdHRoaXMud2VpZ2h0ID0gMTtcclxuXHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSAxO1xyXG5cclxuXHR0aGlzLnJlcGV0aXRpb25zID0gSW5maW5pdHk7IFx0XHQvLyBuby4gb2YgcmVwZXRpdGlvbnMgd2hlbiBsb29waW5nXHJcblxyXG5cdHRoaXMucGF1c2VkID0gZmFsc2U7XHRcdFx0XHQvLyBmYWxzZSAtPiB6ZXJvIGVmZmVjdGl2ZSB0aW1lIHNjYWxlXHJcblx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcdFx0XHRcdC8vIHRydWUgLT4gemVybyBlZmZlY3RpdmUgd2VpZ2h0XHJcblxyXG5cdHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgXHQ9IGZhbHNlO1x0Ly8ga2VlcCBmZWVkaW5nIHRoZSBsYXN0IGZyYW1lP1xyXG5cclxuXHR0aGlzLnplcm9TbG9wZUF0U3RhcnQgXHQ9IHRydWU7XHRcdC8vIGZvciBzbW9vdGggaW50ZXJwb2xhdGlvbiB3L28gc2VwYXJhdGVcclxuXHR0aGlzLnplcm9TbG9wZUF0RW5kXHRcdD0gdHJ1ZTtcdFx0Ly8gY2xpcHMgZm9yIHN0YXJ0LCBsb29wIGFuZCBlbmRcclxuXHJcbn07XHJcblxyXG5USFJFRS5BbmltYXRpb25NaXhlci5fQWN0aW9uLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkFuaW1hdGlvbk1peGVyLl9BY3Rpb24sXHJcblxyXG5cdC8vIFN0YXRlICYgU2NoZWR1bGluZ1xyXG5cclxuXHRwbGF5OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR0aGlzLl9taXhlci5fYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3RvcDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dGhpcy5fbWl4ZXIuX2RlYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5yZXNldCgpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyZXNldDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50aW1lID0gMDtcdFx0XHQvLyByZXN0YXJ0IGNsaXBcclxuXHRcdHRoaXMuX2xvb3BDb3VudCA9IC0xO1x0Ly8gZm9yZ2V0IHByZXZpb3VzIGxvb3BzXHJcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1x0Ly8gZm9yZ2V0IHNjaGVkdWxpbmdcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdG9wRmFkaW5nKCkuc3RvcFdhcnBpbmcoKTtcclxuXHJcblx0fSxcclxuXHJcblx0aXNSdW5uaW5nOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgc3RhcnQgPSB0aGlzLl9zdGFydFRpbWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZW5hYmxlZCAmJiAhIHRoaXMucGF1c2VkICYmIHRoaXMudGltZVNjYWxlICE9PSAwICYmXHJcblx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID09PSBudWxsICYmIHRoaXMuX21peGVyLl9pc0FjdGl2ZUFjdGlvbiggdGhpcyApXHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybiB0cnVlIHdoZW4gcGxheSBoYXMgYmVlbiBjYWxsZWRcclxuXHRpc1NjaGVkdWxlZDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX21peGVyLl9pc0FjdGl2ZUFjdGlvbiggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdGFydEF0OiBmdW5jdGlvbiggdGltZSApIHtcclxuXHJcblx0XHR0aGlzLl9zdGFydFRpbWUgPSB0aW1lO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRMb29wOiBmdW5jdGlvbiggbW9kZSwgcmVwZXRpdGlvbnMgKSB7XHJcblxyXG5cdFx0dGhpcy5sb29wID0gbW9kZTtcclxuXHRcdHRoaXMucmVwZXRpdGlvbnMgPSByZXBldGl0aW9ucztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gV2VpZ2h0XHJcblxyXG5cdC8vIHNldCB0aGUgd2VpZ2h0IHN0b3BwaW5nIGFueSBzY2hlZHVsZWQgZmFkaW5nXHJcblx0Ly8gYWx0aG91Z2ggLmVuYWJsZWQgPSBmYWxzZSB5aWVsZHMgYW4gZWZmZWN0aXZlIHdlaWdodCBvZiB6ZXJvLCB0aGlzXHJcblx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5lbmFibGVkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xyXG5cdHNldEVmZmVjdGl2ZVdlaWdodDogZnVuY3Rpb24oIHdlaWdodCApIHtcclxuXHJcblx0XHR0aGlzLndlaWdodCA9IHdlaWdodDtcclxuXHJcblx0XHQvLyBub3RlOiBzYW1lIGxvZ2ljIGFzIHdoZW4gdXBkYXRlZCBhdCBydW50aW1lXHJcblx0XHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB0aGlzLmVuYWJsZWQgPyB3ZWlnaHQgOiAwO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSB3ZWlnaHQgY29uc2lkZXJpbmcgZmFkaW5nIGFuZCAuZW5hYmxlZFxyXG5cdGdldEVmZmVjdGl2ZVdlaWdodDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVdlaWdodDtcclxuXHJcblx0fSxcclxuXHJcblx0ZmFkZUluOiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKCBkdXJhdGlvbiwgMCwgMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmYWRlT3V0OiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKCBkdXJhdGlvbiwgMSwgMCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zc0ZhZGVGcm9tOiBmdW5jdGlvbiggZmFkZU91dEFjdGlvbiwgZHVyYXRpb24sIHdhcnAgKSB7XHJcblxyXG5cdFx0dmFyIG1peGVyID0gdGhpcy5fbWl4ZXI7XHJcblxyXG5cdFx0ZmFkZU91dEFjdGlvbi5mYWRlT3V0KCBkdXJhdGlvbiApO1xyXG5cdFx0dGhpcy5mYWRlSW4oIGR1cmF0aW9uICk7XHJcblxyXG5cdFx0aWYoIHdhcnAgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFkZUluRHVyYXRpb24gPSB0aGlzLl9jbGlwLmR1cmF0aW9uLFxyXG5cdFx0XHRcdGZhZGVPdXREdXJhdGlvbiA9IGZhZGVPdXRBY3Rpb24uX2NsaXAuZHVyYXRpb24sXHJcblxyXG5cdFx0XHRcdHN0YXJ0RW5kUmF0aW8gPSBmYWRlT3V0RHVyYXRpb24gLyBmYWRlSW5EdXJhdGlvbixcclxuXHRcdFx0XHRlbmRTdGFydFJhdGlvID0gZmFkZUluRHVyYXRpb24gLyBmYWRlT3V0RHVyYXRpb247XHJcblxyXG5cdFx0XHRmYWRlT3V0QWN0aW9uLndhcnAoIDEuMCwgc3RhcnRFbmRSYXRpbywgZHVyYXRpb24gKTtcclxuXHRcdFx0dGhpcy53YXJwKCBlbmRTdGFydFJhdGlvLCAxLjAsIGR1cmF0aW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zc0ZhZGVUbzogZnVuY3Rpb24oIGZhZGVJbkFjdGlvbiwgZHVyYXRpb24sIHdhcnAgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGZhZGVJbkFjdGlvbi5jcm9zc0ZhZGVGcm9tKCB0aGlzLCBkdXJhdGlvbiwgd2FycCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdG9wRmFkaW5nOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgd2VpZ2h0SW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcclxuXHJcblx0XHRpZiAoIHdlaWdodEludGVycG9sYW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xyXG5cdFx0XHR0aGlzLl9taXhlci5fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoIHdlaWdodEludGVycG9sYW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBUaW1lIFNjYWxlIENvbnRyb2xcclxuXHJcblx0Ly8gc2V0IHRoZSB3ZWlnaHQgc3RvcHBpbmcgYW55IHNjaGVkdWxlZCB3YXJwaW5nXHJcblx0Ly8gYWx0aG91Z2ggLnBhdXNlZCA9IHRydWUgeWllbGRzIGFuIGVmZmVjdGl2ZSB0aW1lIHNjYWxlIG9mIHplcm8sIHRoaXNcclxuXHQvLyBtZXRob2QgZG9lcyAqbm90KiBjaGFuZ2UgLnBhdXNlZCwgYmVjYXVzZSBpdCB3b3VsZCBiZSBjb25mdXNpbmdcclxuXHRzZXRFZmZlY3RpdmVUaW1lU2NhbGU6IGZ1bmN0aW9uKCB0aW1lU2NhbGUgKSB7XHJcblxyXG5cdFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XHJcblx0XHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSB0aGlzLnBhdXNlZCA/IDAgOnRpbWVTY2FsZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm4gdGhlIHRpbWUgc2NhbGUgY29uc2lkZXJpbmcgd2FycGluZyBhbmQgLnBhdXNlZFxyXG5cdGdldEVmZmVjdGl2ZVRpbWVTY2FsZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RHVyYXRpb246IGZ1bmN0aW9uKCBkdXJhdGlvbiApIHtcclxuXHJcblx0XHR0aGlzLnRpbWVTY2FsZSA9IHRoaXMuX2NsaXAuZHVyYXRpb24gLyBkdXJhdGlvbjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzeW5jV2l0aDogZnVuY3Rpb24oIGFjdGlvbiApIHtcclxuXHJcblx0XHR0aGlzLnRpbWUgPSBhY3Rpb24udGltZTtcclxuXHRcdHRoaXMudGltZVNjYWxlID0gYWN0aW9uLnRpbWVTY2FsZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRoYWx0OiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMud2FycCggdGhpcy5fY3VycmVudFRpbWVTY2FsZSwgMCwgZHVyYXRpb24gKTtcclxuXHJcblx0fSxcclxuXHJcblx0d2FycDogZnVuY3Rpb24oIHN0YXJ0VGltZVNjYWxlLCBlbmRUaW1lU2NhbGUsIGR1cmF0aW9uICkge1xyXG5cclxuXHRcdHZhciBtaXhlciA9IHRoaXMuX21peGVyLCBub3cgPSBtaXhlci50aW1lLFxyXG5cdFx0XHRpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50LFxyXG5cclxuXHRcdFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XHJcblxyXG5cdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKSxcclxuXHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRpbWVzID0gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zLFxyXG5cdFx0XHR2YWx1ZXMgPSBpbnRlcnBvbGFudC5zYW1wbGVWYWx1ZXM7XHJcblxyXG5cdFx0dGltZXNbIDAgXSA9IG5vdztcclxuXHRcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcclxuXHJcblx0XHR2YWx1ZXNbIDAgXSA9IHN0YXJ0VGltZVNjYWxlIC8gdGltZVNjYWxlO1xyXG5cdFx0dmFsdWVzWyAxIF0gPSBlbmRUaW1lU2NhbGUgLyB0aW1lU2NhbGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN0b3BXYXJwaW5nOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdGltZVNjYWxlSW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcclxuXHJcblx0XHRpZiAoIHRpbWVTY2FsZUludGVycG9sYW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBudWxsO1xyXG5cdFx0XHR0aGlzLl9taXhlci5fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoIHRpbWVTY2FsZUludGVycG9sYW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBPYmplY3QgQWNjZXNzb3JzXHJcblxyXG5cdGdldE1peGVyOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fbWl4ZXI7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldENsaXA6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jbGlwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRSb290OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fbG9jYWxSb290IHx8IHRoaXMuX21peGVyLl9yb290O1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBJbnRlcm5hXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApIHtcclxuXHRcdC8vIGNhbGxlZCBieSB0aGUgbWl4ZXJcclxuXHJcblx0XHR2YXIgc3RhcnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lO1xyXG5cclxuXHRcdGlmICggc3RhcnRUaW1lICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Ly8gY2hlY2sgZm9yIHNjaGVkdWxlZCBzdGFydCBvZiBhY3Rpb25cclxuXHJcblx0XHRcdHZhciB0aW1lUnVubmluZyA9ICggdGltZSAtIHN0YXJ0VGltZSApICogdGltZURpcmVjdGlvbjtcclxuXHRcdFx0aWYgKCB0aW1lUnVubmluZyA8IDAgfHwgdGltZURpcmVjdGlvbiA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuOyAvLyB5ZXQgdG8gY29tZSAvIGRvbid0IGRlY2lkZSB3aGVuIGRlbHRhID0gMFxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc3RhcnRcclxuXHJcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7IC8vIHVuc2NoZWR1bGVcclxuXHRcdFx0ZGVsdGFUaW1lID0gdGltZURpcmVjdGlvbiAqIHRpbWVSdW5uaW5nO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhcHBseSB0aW1lIHNjYWxlIGFuZCBhZHZhbmNlIHRpbWVcclxuXHJcblx0XHRkZWx0YVRpbWUgKj0gdGhpcy5fdXBkYXRlVGltZVNjYWxlKCB0aW1lICk7XHJcblx0XHR2YXIgY2xpcFRpbWUgPSB0aGlzLl91cGRhdGVUaW1lKCBkZWx0YVRpbWUgKTtcclxuXHJcblx0XHQvLyBub3RlOiBfdXBkYXRlVGltZSBtYXkgZGlzYWJsZSB0aGUgYWN0aW9uIHJlc3VsdGluZyBpblxyXG5cdFx0Ly8gYW4gZWZmZWN0aXZlIHdlaWdodCBvZiAwXHJcblxyXG5cdFx0dmFyIHdlaWdodCA9IHRoaXMuX3VwZGF0ZVdlaWdodCggdGltZSApO1xyXG5cclxuXHRcdGlmICggd2VpZ2h0ID4gMCApIHtcclxuXHJcblx0XHRcdHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9pbnRlcnBvbGFudHM7XHJcblx0XHRcdHZhciBwcm9wZXJ0eU1peGVycyA9IHRoaXMuX3Byb3BlcnR5QmluZGluZ3M7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBpbnRlcnBvbGFudHMubGVuZ3RoOyBqICE9PSBtOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRpbnRlcnBvbGFudHNbIGogXS5ldmFsdWF0ZSggY2xpcFRpbWUgKTtcclxuXHRcdFx0XHRwcm9wZXJ0eU1peGVyc1sgaiBdLmFjY3VtdWxhdGUoIGFjY3VJbmRleCwgd2VpZ2h0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlV2VpZ2h0OiBmdW5jdGlvbiggdGltZSApIHtcclxuXHJcblx0XHR2YXIgd2VpZ2h0ID0gMDtcclxuXHJcblx0XHRpZiAoIHRoaXMuZW5hYmxlZCApIHtcclxuXHJcblx0XHRcdHdlaWdodCA9IHRoaXMud2VpZ2h0O1xyXG5cdFx0XHR2YXIgaW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcclxuXHJcblx0XHRcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUoIHRpbWUgKVsgMCBdO1xyXG5cclxuXHRcdFx0XHR3ZWlnaHQgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcclxuXHJcblx0XHRcdFx0aWYgKCB0aW1lID4gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zWyAxIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5zdG9wRmFkaW5nKCk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbnRlcnBvbGFudFZhbHVlID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gZmFkZWQgb3V0LCBkaXNhYmxlXHJcblx0XHRcdFx0XHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB3ZWlnaHQ7XHJcblx0XHRyZXR1cm4gd2VpZ2h0O1xyXG5cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlVGltZVNjYWxlOiBmdW5jdGlvbiggdGltZSApIHtcclxuXHJcblx0XHR2YXIgdGltZVNjYWxlID0gMDtcclxuXHJcblx0XHRpZiAoICEgdGhpcy5wYXVzZWQgKSB7XHJcblxyXG5cdFx0XHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcclxuXHJcblx0XHRcdHZhciBpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xyXG5cclxuXHRcdFx0aWYgKCBpbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGludGVycG9sYW50VmFsdWUgPSBpbnRlcnBvbGFudC5ldmFsdWF0ZSggdGltZSApWyAwIF07XHJcblxyXG5cdFx0XHRcdHRpbWVTY2FsZSAqPSBpbnRlcnBvbGFudFZhbHVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbIDEgXSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLnN0b3BXYXJwaW5nKCk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0aW1lU2NhbGUgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBtb3Rpb24gaGFzIGhhbHRlZCwgcGF1c2VcclxuXHRcdFx0XHRcdFx0dGhpcy5wYXVzZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHdhcnAgZG9uZSAtIGFwcGx5IGZpbmFsIHRpbWUgc2NhbGVcclxuXHRcdFx0XHRcdFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcclxuXHRcdHJldHVybiB0aW1lU2NhbGU7XHJcblxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVUaW1lOiBmdW5jdGlvbiggZGVsdGFUaW1lICkge1xyXG5cclxuXHRcdHZhciB0aW1lID0gdGhpcy50aW1lICsgZGVsdGFUaW1lO1xyXG5cclxuXHRcdGlmICggZGVsdGFUaW1lID09PSAwICkgcmV0dXJuIHRpbWU7XHJcblxyXG5cdFx0dmFyIGR1cmF0aW9uID0gdGhpcy5fY2xpcC5kdXJhdGlvbixcclxuXHJcblx0XHRcdGxvb3AgPSB0aGlzLmxvb3AsXHJcblx0XHRcdGxvb3BDb3VudCA9IHRoaXMuX2xvb3BDb3VudCxcclxuXHJcblx0XHRcdHBpbmdQb25nID0gZmFsc2U7XHJcblxyXG5cdFx0c3dpdGNoICggbG9vcCApIHtcclxuXHJcblx0XHRcdGNhc2UgVEhSRUUuTG9vcE9uY2U6XHJcblxyXG5cdFx0XHRcdGlmICggbG9vcENvdW50ID09PSAtMSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBqdXN0IHN0YXJ0ZWRcclxuXHJcblx0XHRcdFx0XHR0aGlzLmxvb3BDb3VudCA9IDA7XHJcblx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKCB0cnVlLCB0cnVlLCBmYWxzZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGltZSA+PSBkdXJhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHR0aW1lID0gZHVyYXRpb247XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdHRpbWUgPSAwO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgYnJlYWs7XHJcblxyXG5cdFx0XHRcdC8vIHJlYWNoZWQgdGhlIGVuZFxyXG5cclxuXHRcdFx0XHRpZiAoIHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgKSB0aGlzLnBhdXNlID0gdHJ1ZTtcclxuXHRcdFx0XHRlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XHJcblx0XHRcdFx0XHR0eXBlOiAnZmluaXNoZWQnLCBhY3Rpb246IHRoaXMsXHJcblx0XHRcdFx0XHRkaXJlY3Rpb246IGRlbHRhVGltZSA8IDAgPyAtMSA6IDFcclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBUSFJFRS5Mb29wUGluZ1Bvbmc6XHJcblxyXG5cdFx0XHRcdHBpbmdQb25nID0gdHJ1ZTtcclxuXHJcblx0XHRcdGNhc2UgVEhSRUUuTG9vcFJlcGVhdDpcclxuXHJcblx0XHRcdFx0aWYgKCBsb29wQ291bnQgPT09IC0xICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGp1c3Qgc3RhcnRlZFxyXG5cclxuXHRcdFx0XHRcdGlmICggZGVsdGFUaW1lID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGxvb3BDb3VudCA9IDA7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKFxyXG5cdFx0XHRcdFx0XHRcdFx0dHJ1ZSwgdGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgcGluZ1BvbmcgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gd2hlbiBsb29waW5nIGluIHJldmVyc2UgZGlyZWN0aW9uLCB0aGUgaW5pdGlhbFxyXG5cdFx0XHRcdFx0XHQvLyB0cmFuc2l0aW9uIHRocm91Z2ggemVybyBjb3VudHMgYXMgYSByZXBldGl0aW9uLFxyXG5cdFx0XHRcdFx0XHQvLyBzbyBsZWF2ZSBsb29wQ291bnQgYXQgLTFcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnJlcGV0aXRpb25zID09PSAwLCB0cnVlLCBwaW5nUG9uZyApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHRpbWUgPj0gZHVyYXRpb24gfHwgdGltZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gd3JhcCBhcm91bmRcclxuXHJcblx0XHRcdFx0XHR2YXIgbG9vcERlbHRhID0gTWF0aC5mbG9vciggdGltZSAvIGR1cmF0aW9uICk7IC8vIHNpZ25lZFxyXG5cdFx0XHRcdFx0dGltZSAtPSBkdXJhdGlvbiAqIGxvb3BEZWx0YTtcclxuXHJcblx0XHRcdFx0XHRsb29wQ291bnQgKz0gTWF0aC5hYnMoIGxvb3BEZWx0YSApO1xyXG5cclxuXHRcdFx0XHRcdHZhciBwZW5kaW5nID0gdGhpcy5yZXBldGl0aW9ucyAtIGxvb3BDb3VudDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHBlbmRpbmcgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gc3RvcCAoc3dpdGNoIHN0YXRlLCBjbGFtcCB0aW1lLCBmaXJlIGV2ZW50KVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmNsYW1wV2hlbkZpbmlzaGVkICkgdGhpcy5wYXVzZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdFx0dGltZSA9IGRlbHRhVGltZSA+IDAgPyBkdXJhdGlvbiA6IDA7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XHJcblx0XHRcdFx0XHRcdFx0dHlwZTogJ2ZpbmlzaGVkJywgYWN0aW9uOiB0aGlzLFxyXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbjogZGVsdGFUaW1lID4gMCA/IDEgOiAtMVxyXG5cdFx0XHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwZW5kaW5nID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gdHJhbnNpdGlvbiB0byBsYXN0IHJvdW5kXHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgYXRTdGFydCA9IGRlbHRhVGltZSA8IDA7XHJcblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGF0U3RhcnQsICEgYXRTdGFydCwgcGluZ1BvbmcgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggZmFsc2UsIGZhbHNlLCBwaW5nUG9uZyApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aGlzLl9sb29wQ291bnQgPSBsb29wQ291bnQ7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCgge1xyXG5cdFx0XHRcdFx0XHR0eXBlOiAnbG9vcCcsIGFjdGlvbjogdGhpcywgbG9vcERlbHRhOiBsb29wRGVsdGFcclxuXHRcdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGxvb3AgPT09IFRIUkVFLkxvb3BQaW5nUG9uZyAmJiAoIGxvb3BDb3VudCAmIDEgKSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBpbnZlcnQgdGltZSBmb3IgdGhlIFwicG9uZyByb3VuZFwiXHJcblxyXG5cdFx0XHRcdFx0dGhpcy50aW1lID0gdGltZTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gZHVyYXRpb24gLSB0aW1lO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnRpbWUgPSB0aW1lO1xyXG5cclxuXHRcdHJldHVybiB0aW1lO1xyXG5cclxuXHR9LFxyXG5cclxuXHRfc2V0RW5kaW5nczogZnVuY3Rpb24oIGF0U3RhcnQsIGF0RW5kLCBwaW5nUG9uZyApIHtcclxuXHJcblx0XHR2YXIgc2V0dGluZ3MgPSB0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzO1xyXG5cclxuXHRcdGlmICggcGluZ1BvbmcgKSB7XHJcblxyXG5cdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCBcdD0gVEhSRUUuWmVyb1Nsb3BlRW5kaW5nO1xyXG5cdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmRcdFx0PSBUSFJFRS5aZXJvU2xvcGVFbmRpbmc7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGFzc3VtaW5nIGZvciBMb29wT25jZSBhdFN0YXJ0ID09IGF0RW5kID09IHRydWVcclxuXHJcblx0XHRcdGlmICggYXRTdGFydCApIHtcclxuXHJcblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSB0aGlzLnplcm9TbG9wZUF0U3RhcnQgP1xyXG5cdFx0XHRcdFx0XHRUSFJFRS5aZXJvU2xvcGVFbmRpbmcgOiBUSFJFRS5aZXJvQ3VydmF0dXJlRW5kaW5nO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSBUSFJFRS5XcmFwQXJvdW5kRW5kaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBhdEVuZCApIHtcclxuXHJcblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kID0gdGhpcy56ZXJvU2xvcGVBdEVuZCA/XHJcblx0XHRcdFx0XHRcdFRIUkVFLlplcm9TbG9wZUVuZGluZyA6IFRIUkVFLlplcm9DdXJ2YXR1cmVFbmRpbmc7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmQgXHQgPSBUSFJFRS5XcmFwQXJvdW5kRW5kaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0X3NjaGVkdWxlRmFkaW5nOiBmdW5jdGlvbiggZHVyYXRpb24sIHdlaWdodE5vdywgd2VpZ2h0VGhlbiApIHtcclxuXHJcblx0XHR2YXIgbWl4ZXIgPSB0aGlzLl9taXhlciwgbm93ID0gbWl4ZXIudGltZSxcclxuXHRcdFx0aW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcclxuXHJcblx0XHRpZiAoIGludGVycG9sYW50ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0aW50ZXJwb2xhbnQgPSBtaXhlci5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpLFxyXG5cdFx0XHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IGludGVycG9sYW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXHJcblx0XHRcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcclxuXHJcblx0XHR0aW1lc1sgMCBdID0gbm93OyBcdFx0XHRcdHZhbHVlc1sgMCBdID0gd2VpZ2h0Tm93O1xyXG5cdFx0dGltZXNbIDEgXSA9IG5vdyArIGR1cmF0aW9uO1x0dmFsdWVzWyAxIF0gPSB3ZWlnaHRUaGVuO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gSW1wbGVtZW50YXRpb24gZGV0YWlsczpcclxuXHJcbk9iamVjdC5hc3NpZ24oIFRIUkVFLkFuaW1hdGlvbk1peGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRfYmluZEFjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiwgcHJvdG90eXBlQWN0aW9uICkge1xyXG5cclxuXHRcdHZhciByb290ID0gYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCxcclxuXHRcdFx0dHJhY2tzID0gYWN0aW9uLl9jbGlwLnRyYWNrcyxcclxuXHRcdFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXHJcblx0XHRcdGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzLFxyXG5cdFx0XHRpbnRlcnBvbGFudHMgPSBhY3Rpb24uX2ludGVycG9sYW50cyxcclxuXHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQsXHJcblx0XHRcdGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxyXG5cdFx0XHRiaW5kaW5nc0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xyXG5cclxuXHRcdGlmICggYmluZGluZ3NCeU5hbWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGJpbmRpbmdzQnlOYW1lID0ge307XHJcblx0XHRcdGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdID0gYmluZGluZ3NCeU5hbWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gblRyYWNrczsgKysgaSApIHtcclxuXHJcblx0XHRcdHZhciB0cmFjayA9IHRyYWNrc1sgaSBdLFxyXG5cdFx0XHRcdHRyYWNrTmFtZSA9IHRyYWNrLm5hbWUsXHJcblx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzQnlOYW1lWyB0cmFja05hbWUgXTtcclxuXHJcblx0XHRcdGlmICggYmluZGluZyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRiaW5kaW5nc1sgaSBdID0gYmluZGluZztcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGJpbmRpbmcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBleGlzdGluZyBiaW5kaW5nLCBtYWtlIHN1cmUgdGhlIGNhY2hlIGtub3dzXHJcblxyXG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nLl9jYWNoZUluZGV4ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0KysgYmluZGluZy5yZWZlcmVuY2VDb3VudDtcclxuXHRcdFx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBwYXRoID0gcHJvdG90eXBlQWN0aW9uICYmIHByb3RvdHlwZUFjdGlvbi5cclxuXHRcdFx0XHRcdFx0X3Byb3BlcnR5QmluZGluZ3NbIGkgXS5iaW5kaW5nLnBhcnNlZFBhdGg7XHJcblxyXG5cdFx0XHRcdGJpbmRpbmcgPSBuZXcgVEhSRUUuUHJvcGVydHlNaXhlcihcclxuXHRcdFx0XHRcdFx0VEhSRUUuUHJvcGVydHlCaW5kaW5nLmNyZWF0ZSggcm9vdCwgdHJhY2tOYW1lLCBwYXRoICksXHJcblx0XHRcdFx0XHRcdHRyYWNrLlZhbHVlVHlwZU5hbWUsIHRyYWNrLmdldFZhbHVlU2l6ZSgpICk7XHJcblxyXG5cdFx0XHRcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XHJcblx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XHJcblxyXG5cdFx0XHRcdGJpbmRpbmdzWyBpIF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aW50ZXJwb2xhbnRzWyBpIF0ucmVzdWx0QnVmZmVyID0gYmluZGluZy5idWZmZXI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRfYWN0aXZhdGVBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XHJcblxyXG5cdFx0aWYgKCAhIHRoaXMuX2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSApIHtcclxuXHJcblx0XHRcdGlmICggYWN0aW9uLl9jYWNoZUluZGV4ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyB0aGlzIGFjdGlvbiBoYXMgYmVlbiBmb3Jnb3R0ZW4gYnkgdGhlIGNhY2hlLCBidXQgdGhlIHVzZXJcclxuXHRcdFx0XHQvLyBhcHBlYXJzIHRvIGJlIHN0aWxsIHVzaW5nIGl0IC0+IHJlYmluZFxyXG5cclxuXHRcdFx0XHR2YXIgcm9vdFV1aWQgPSAoIGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QgKS51dWlkLFxyXG5cdFx0XHRcdFx0Y2xpcE5hbWUgPSBhY3Rpb24uX2NsaXAubmFtZSxcclxuXHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcE5hbWUgXTtcclxuXHJcblx0XHRcdFx0dGhpcy5fYmluZEFjdGlvbiggYWN0aW9uLFxyXG5cdFx0XHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCAmJiBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnNbIDAgXSApO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUFjdGlvbiggYWN0aW9uLCBjbGlwTmFtZSwgcm9vdFV1aWQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncztcclxuXHJcblx0XHRcdC8vIGluY3JlbWVudCByZWZlcmVuY2UgY291bnRzIC8gc29ydCBvdXQgc3RhdGVcclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggYmluZGluZy51c2VDb3VudCArKyA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl9sZW5kQmluZGluZyggYmluZGluZyApO1xyXG5cdFx0XHRcdFx0YmluZGluZy5zYXZlT3JpZ2luYWxTdGF0ZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl9sZW5kQWN0aW9uKCBhY3Rpb24gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdF9kZWFjdGl2YXRlQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5faXNBY3RpdmVBY3Rpb24oIGFjdGlvbiApICkge1xyXG5cclxuXHRcdFx0dmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xyXG5cclxuXHRcdFx0Ly8gZGVjcmVtZW50IHJlZmVyZW5jZSBjb3VudHMgLyBzb3J0IG91dCBzdGF0ZVxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCAtLSBiaW5kaW5nLnVzZUNvdW50ID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdGJpbmRpbmcucmVzdG9yZU9yaWdpbmFsU3RhdGUoKTtcclxuXHRcdFx0XHRcdHRoaXMuX3Rha2VCYWNrQmluZGluZyggYmluZGluZyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl90YWtlQmFja0FjdGlvbiggYWN0aW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBNZW1vcnkgbWFuYWdlclxyXG5cclxuXHRfaW5pdE1lbW9yeU1hbmFnZXI6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHRoaXMuX2FjdGlvbnMgPSBbXTsgLy8gJ25BY3RpdmVBY3Rpb25zJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXHJcblx0XHR0aGlzLl9uQWN0aXZlQWN0aW9ucyA9IDA7XHJcblxyXG5cdFx0dGhpcy5fYWN0aW9uc0J5Q2xpcCA9IHt9O1xyXG5cdFx0Ly8gaW5zaWRlOlxyXG5cdFx0Ly8ge1xyXG5cdFx0Ly8gXHRcdGtub3duQWN0aW9uczogQXJyYXk8IF9BY3Rpb24gPlx0LSB1c2VkIGFzIHByb3RvdHlwZXNcclxuXHRcdC8vIFx0XHRhY3Rpb25CeVJvb3Q6IF9BY3Rpb25cdFx0XHQtIGxvb2t1cFxyXG5cdFx0Ly8gfVxyXG5cclxuXHJcblx0XHR0aGlzLl9iaW5kaW5ncyA9IFtdOyAvLyAnbkFjdGl2ZUJpbmRpbmdzJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXHJcblx0XHR0aGlzLl9uQWN0aXZlQmluZGluZ3MgPSAwO1xyXG5cclxuXHRcdHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSA9IHt9OyAvLyBpbnNpZGU6IE1hcDwgbmFtZSwgUHJvcGVydHlNaXhlciA+XHJcblxyXG5cclxuXHRcdHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMgPSBbXTsgLy8gc2FtZSBnYW1lIGFzIGFib3ZlXHJcblx0XHR0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyA9IDA7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHR0aGlzLnN0YXRzID0ge1xyXG5cclxuXHRcdFx0YWN0aW9uczoge1xyXG5cdFx0XHRcdGdldCB0b3RhbCgpIHsgcmV0dXJuIHNjb3BlLl9hY3Rpb25zLmxlbmd0aDsgfSxcclxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7IHJldHVybiBzY29wZS5fbkFjdGl2ZUFjdGlvbnM7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0YmluZGluZ3M6IHtcclxuXHRcdFx0XHRnZXQgdG90YWwoKSB7IHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoOyB9LFxyXG5cdFx0XHRcdGdldCBpblVzZSgpIHsgcmV0dXJuIHNjb3BlLl9uQWN0aXZlQmluZGluZ3M7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0Y29udHJvbEludGVycG9sYW50czoge1xyXG5cdFx0XHRcdGdldCB0b3RhbCgpIHsgcmV0dXJuIHNjb3BlLl9jb250cm9sSW50ZXJwb2xhbnRzLmxlbmd0aDsgfSxcclxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7IHJldHVybiBzY29wZS5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHM7IH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIE1lbW9yeSBtYW5hZ2VtZW50IGZvciBfQWN0aW9uIG9iamVjdHNcclxuXHJcblx0X2lzQWN0aXZlQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xyXG5cclxuXHRcdHZhciBpbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcclxuXHRcdHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCA8IHRoaXMuX25BY3RpdmVBY3Rpb25zO1xyXG5cclxuXHR9LFxyXG5cclxuXHRfYWRkSW5hY3RpdmVBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24sIGNsaXBOYW1lLCByb290VXVpZCApIHtcclxuXHJcblx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXHJcblx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxyXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF07XHJcblxyXG5cdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB7XHJcblxyXG5cdFx0XHRcdGtub3duQWN0aW9uczogWyBhY3Rpb24gXSxcclxuXHRcdFx0XHRhY3Rpb25CeVJvb3Q6IHt9XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gMDtcclxuXHJcblx0XHRcdGFjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF0gPSBhY3Rpb25zRm9yQ2xpcDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dmFyIGtub3duQWN0aW9ucyA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcclxuXHJcblx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGtub3duQWN0aW9ucy5sZW5ndGg7XHJcblx0XHRcdGtub3duQWN0aW9ucy5wdXNoKCBhY3Rpb24gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gYWN0aW9ucy5sZW5ndGg7XHJcblx0XHRhY3Rpb25zLnB1c2goIGFjdGlvbiApO1xyXG5cclxuXHRcdGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXSA9IGFjdGlvbjtcclxuXHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUluYWN0aXZlQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xyXG5cclxuXHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcclxuXHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgYWN0aW9ucy5sZW5ndGggLSAxIF0sXHJcblx0XHRcdGNhY2hlSW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXg7XHJcblxyXG5cdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcclxuXHRcdGFjdGlvbnNbIGNhY2hlSW5kZXggXSA9IGxhc3RJbmFjdGl2ZUFjdGlvbjtcclxuXHRcdGFjdGlvbnMucG9wKCk7XHJcblxyXG5cdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gbnVsbDtcclxuXHJcblxyXG5cdFx0dmFyIGNsaXBOYW1lID0gYWN0aW9uLl9jbGlwLm5hbWUsXHJcblx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxyXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF0sXHJcblx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnMsXHJcblxyXG5cdFx0XHRsYXN0S25vd25BY3Rpb24gPVxyXG5cdFx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXBbIGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoIC0gMSBdLFxyXG5cclxuXHRcdFx0YnlDbGlwQ2FjaGVJbmRleCA9IGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleDtcclxuXHJcblx0XHRsYXN0S25vd25BY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBieUNsaXBDYWNoZUluZGV4O1xyXG5cdFx0a25vd25BY3Rpb25zRm9yQ2xpcFsgYnlDbGlwQ2FjaGVJbmRleCBdID0gbGFzdEtub3duQWN0aW9uO1xyXG5cdFx0a25vd25BY3Rpb25zRm9yQ2xpcC5wb3AoKTtcclxuXHJcblx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1xyXG5cclxuXHJcblx0XHR2YXIgYWN0aW9uQnlSb290ID0gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290LFxyXG5cdFx0XHRyb290VXVpZCA9ICggYWN0aW9ucy5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QgKS51dWlkO1xyXG5cclxuXHRcdGRlbGV0ZSBhY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XHJcblxyXG5cdFx0aWYgKCBrbm93bkFjdGlvbnNGb3JDbGlwLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwWyBjbGlwTmFtZSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKCBhY3Rpb24gKTtcclxuXHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XHJcblxyXG5cdFx0dmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCAtLSBiaW5kaW5nLnJlZmVyZW5jZUNvdW50ID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdF9sZW5kQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xyXG5cclxuXHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfCAgaW5hY3RpdmUgYWN0aW9ucyAgXVxyXG5cdFx0Ly8gWyAgYWN0aXZlIGFjdGlvbnMgPnwgaW5hY3RpdmUgYWN0aW9ucyBdXHJcblx0XHQvLyAgICAgICAgICAgICAgICAgcyAgICAgICAgYVxyXG5cdFx0Ly8gICAgICAgICAgICAgICAgICA8LXN3YXAtPlxyXG5cdFx0Ly8gICAgICAgICAgICAgICAgIGEgICAgICAgIHNcclxuXHJcblx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXHJcblx0XHRcdHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcclxuXHJcblx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVBY3Rpb25zICsrLFxyXG5cclxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGxhc3RBY3RpdmVJbmRleCBdO1xyXG5cclxuXHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcclxuXHRcdGFjdGlvbnNbIGxhc3RBY3RpdmVJbmRleCBdID0gYWN0aW9uO1xyXG5cclxuXHRcdGZpcnN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XHJcblx0XHRhY3Rpb25zWyBwcmV2SW5kZXggXSA9IGZpcnN0SW5hY3RpdmVBY3Rpb247XHJcblxyXG5cdH0sXHJcblxyXG5cdF90YWtlQmFja0FjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiApIHtcclxuXHJcblx0XHQvLyBbICBhY3RpdmUgYWN0aW9ucyAgfCBpbmFjdGl2ZSBhY3Rpb25zIF1cclxuXHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfDwgaW5hY3RpdmUgYWN0aW9ucyAgXVxyXG5cdFx0Ly8gICAgICAgIGEgICAgICAgIHNcclxuXHRcdC8vICAgICAgICAgPC1zd2FwLT5cclxuXHRcdC8vICAgICAgICBzICAgICAgICBhXHJcblxyXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxyXG5cdFx0XHRwcmV2SW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXHJcblxyXG5cdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcclxuXHJcblx0XHRcdGxhc3RBY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcclxuXHJcblx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XHJcblx0XHRhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGFjdGlvbjtcclxuXHJcblx0XHRsYXN0QWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xyXG5cdFx0YWN0aW9uc1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlQWN0aW9uO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgUHJvcGVydHlNaXhlciBvYmplY3RzXHJcblxyXG5cdF9hZGRJbmFjdGl2ZUJpbmRpbmc6IGZ1bmN0aW9uKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICkge1xyXG5cclxuXHRcdHZhciBiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcclxuXHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdLFxyXG5cclxuXHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcclxuXHJcblx0XHRpZiAoIGJpbmRpbmdCeU5hbWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGJpbmRpbmdCeU5hbWUgPSB7fTtcclxuXHRcdFx0YmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0gPSBiaW5kaW5nQnlOYW1lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXSA9IGJpbmRpbmc7XHJcblxyXG5cdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcclxuXHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmcgKTtcclxuXHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUluYWN0aXZlQmluZGluZzogZnVuY3Rpb24oIGJpbmRpbmcgKSB7XHJcblxyXG5cdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdHByb3BCaW5kaW5nID0gYmluZGluZy5iaW5kaW5nLFxyXG5cdFx0XHRyb290VXVpZCA9IHByb3BCaW5kaW5nLnJvb3ROb2RlLnV1aWQsXHJcblx0XHRcdHRyYWNrTmFtZSA9IHByb3BCaW5kaW5nLnBhdGgsXHJcblx0XHRcdGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxyXG5cdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0sXHJcblxyXG5cdFx0XHRsYXN0SW5hY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGJpbmRpbmdzLmxlbmd0aCAtIDEgXSxcclxuXHRcdFx0Y2FjaGVJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXg7XHJcblxyXG5cdFx0bGFzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XHJcblx0XHRiaW5kaW5nc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQmluZGluZztcclxuXHRcdGJpbmRpbmdzLnBvcCgpO1xyXG5cclxuXHRcdGRlbGV0ZSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcclxuXHJcblx0XHRyZW1vdmVfZW1wdHlfbWFwOiB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgXyBpbiBiaW5kaW5nQnlOYW1lICkgYnJlYWsgcmVtb3ZlX2VtcHR5X21hcDtcclxuXHJcblx0XHRcdGRlbGV0ZSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdF9sZW5kQmluZGluZzogZnVuY3Rpb24oIGJpbmRpbmcgKSB7XHJcblxyXG5cdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdHByZXZJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXgsXHJcblxyXG5cdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQmluZGluZ3MgKyssXHJcblxyXG5cdFx0XHRmaXJzdEluYWN0aXZlQmluZGluZyA9IGJpbmRpbmdzWyBsYXN0QWN0aXZlSW5kZXggXTtcclxuXHJcblx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xyXG5cdFx0YmluZGluZ3NbIGxhc3RBY3RpdmVJbmRleCBdID0gYmluZGluZztcclxuXHJcblx0XHRmaXJzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcclxuXHRcdGJpbmRpbmdzWyBwcmV2SW5kZXggXSA9IGZpcnN0SW5hY3RpdmVCaW5kaW5nO1xyXG5cclxuXHR9LFxyXG5cclxuXHRfdGFrZUJhY2tCaW5kaW5nOiBmdW5jdGlvbiggYmluZGluZyApIHtcclxuXHJcblx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcclxuXHRcdFx0cHJldkluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleCxcclxuXHJcblx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVCaW5kaW5ncyxcclxuXHJcblx0XHRcdGxhc3RBY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xyXG5cclxuXHRcdGJpbmRpbmcuX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XHJcblx0XHRiaW5kaW5nc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdGxhc3RBY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xyXG5cdFx0YmluZGluZ3NbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUJpbmRpbmc7XHJcblxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBvZiBJbnRlcnBvbGFudHMgZm9yIHdlaWdodCBhbmQgdGltZSBzY2FsZVxyXG5cclxuXHRfbGVuZENvbnRyb2xJbnRlcnBvbGFudDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXHJcblx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzICsrLFxyXG5cdFx0XHRpbnRlcnBvbGFudCA9IGludGVycG9sYW50c1sgbGFzdEFjdGl2ZUluZGV4IF07XHJcblxyXG5cdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aW50ZXJwb2xhbnQgPSBuZXcgVEhSRUUuTGluZWFySW50ZXJwb2xhbnQoXHJcblx0XHRcdFx0XHRuZXcgRmxvYXQzMkFycmF5KCAyICksIG5ldyBGbG9hdDMyQXJyYXkoIDIgKSxcclxuXHRcdFx0XHRcdFx0MSwgdGhpcy5fY29udHJvbEludGVycG9sYW50c1Jlc3VsdEJ1ZmZlciApO1xyXG5cclxuXHRcdFx0aW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xyXG5cdFx0XHRpbnRlcnBvbGFudHNbIGxhc3RBY3RpdmVJbmRleCBdID0gaW50ZXJwb2xhbnQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbnRlcnBvbGFudDtcclxuXHJcblx0fSxcclxuXHJcblx0X3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50OiBmdW5jdGlvbiggaW50ZXJwb2xhbnQgKSB7XHJcblxyXG5cdFx0dmFyIGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXHJcblx0XHRcdHByZXZJbmRleCA9IGludGVycG9sYW50Ll9fY2FjaGVJbmRleCxcclxuXHJcblx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzLFxyXG5cclxuXHRcdFx0bGFzdEFjdGl2ZUludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcclxuXHJcblx0XHRpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XHJcblx0XHRpbnRlcnBvbGFudHNbIGZpcnN0SW5hY3RpdmVJbmRleCBdID0gaW50ZXJwb2xhbnQ7XHJcblxyXG5cdFx0bGFzdEFjdGl2ZUludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcclxuXHRcdGludGVycG9sYW50c1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlSW50ZXJwb2xhbnQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdF9jb250cm9sSW50ZXJwb2xhbnRzUmVzdWx0QnVmZmVyOiBuZXcgRmxvYXQzMkFycmF5KCAxIClcclxuXHJcbn0gKTtcclxuXHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vQW5pbWF0aW9uT2JqZWN0R3JvdXAuanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIGdyb3VwIG9mIG9iamVjdHMgdGhhdCByZWNlaXZlcyBhIHNoYXJlZCBhbmltYXRpb24gc3RhdGUuXHJcbiAqXHJcbiAqIFVzYWdlOlxyXG4gKlxyXG4gKiBcdC1cdEFkZCBvYmplY3RzIHlvdSB3b3VsZCBvdGhlcndpc2UgcGFzcyBhcyAncm9vdCcgdG8gdGhlXHJcbiAqIFx0XHRjb25zdHJ1Y3RvciBvciB0aGUgLmNsaXBBY3Rpb24gbWV0aG9kIG9mIEFuaW1hdGlvbk1peGVyLlxyXG4gKlxyXG4gKiBcdC1cdEluc3RlYWQgcGFzcyB0aGlzIG9iamVjdCBhcyAncm9vdCcuXHJcbiAqXHJcbiAqIFx0LVx0WW91IGNhbiBhbHNvIGFkZCBhbmQgcmVtb3ZlIG9iamVjdHMgbGF0ZXIgd2hlbiB0aGUgbWl4ZXJcclxuICogXHRcdGlzIHJ1bm5pbmcuXHJcbiAqXHJcbiAqIE5vdGU6XHJcbiAqXHJcbiAqICBcdE9iamVjdHMgb2YgdGhpcyBjbGFzcyBhcHBlYXIgYXMgb25lIG9iamVjdCB0byB0aGUgbWl4ZXIsXHJcbiAqICBcdHNvIGNhY2hlIGNvbnRyb2wgb2YgdGhlIGluZGl2aWR1YWwgb2JqZWN0cyBtdXN0IGJlIGRvbmVcclxuICogIFx0b24gdGhlIGdyb3VwLlxyXG4gKlxyXG4gKiBMaW1pdGF0aW9uOlxyXG4gKlxyXG4gKiBcdC0gXHRUaGUgYW5pbWF0ZWQgcHJvcGVydGllcyBtdXN0IGJlIGNvbXBhdGlibGUgYW1vbmcgdGhlXHJcbiAqIFx0XHRhbGwgb2JqZWN0cyBpbiB0aGUgZ3JvdXAuXHJcbiAqXHJcbiAqICAtXHRBIHNpbmdsZSBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGNvbnRyb2xsZWQgdGhyb3VnaCBhXHJcbiAqICBcdHRhcmdldCBncm91cCBvciBkaXJlY3RseSwgYnV0IG5vdCBib3RoLlxyXG4gKlxyXG4gKiBAYXV0aG9yIHRzY2h3XHJcbiAqL1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uT2JqZWN0R3JvdXAgPSBmdW5jdGlvbiggdmFyX2FyZ3MgKSB7XHJcblxyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdC8vIGNhY2hlZCBvYmplY3RzIGZvbGxvd2VkIGJ5IHRoZSBhY3RpdmUgb25lc1xyXG5cdHRoaXMuX29iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XHJcblxyXG5cdHRoaXMubkNhY2hlZE9iamVjdHNfID0gMDtcdFx0XHQvLyB0aHJlc2hvbGRcclxuXHQvLyBub3RlOiByZWFkIGJ5IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGVcclxuXHJcblx0dmFyIGluZGljZXMgPSB7fTtcclxuXHR0aGlzLl9pbmRpY2VzQnlVVUlEID0gaW5kaWNlcztcdFx0Ly8gZm9yIGJvb2trZWVwaW5nXHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0aW5kaWNlc1sgYXJndW1lbnRzWyBpIF0udXVpZCBdID0gaTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLl9wYXRocyA9IFtdO1x0XHRcdFx0XHQvLyBpbnNpZGU6IHN0cmluZ1xyXG5cdHRoaXMuX3BhcnNlZFBhdGhzID0gW107XHRcdFx0XHQvLyBpbnNpZGU6IHsgd2UgZG9uJ3QgY2FyZSwgaGVyZSB9XHJcblx0dGhpcy5fYmluZGluZ3MgPSBbXTsgXHRcdFx0XHQvLyBpbnNpZGU6IEFycmF5PCBQcm9wZXJ0eUJpbmRpbmcgPlxyXG5cdHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCA9IHt9OyBcdC8vIGluc2lkZTogaW5kaWNlcyBpbiB0aGVzZSBhcnJheXNcclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0dGhpcy5zdGF0cyA9IHtcclxuXHJcblx0XHRvYmplY3RzOiB7XHJcblx0XHRcdGdldCB0b3RhbCgpIHsgcmV0dXJuIHNjb3BlLl9vYmplY3RzLmxlbmd0aDsgfSxcclxuXHRcdFx0Z2V0IGluVXNlKCkgeyByZXR1cm4gdGhpcy50b3RhbCAtIHNjb3BlLm5DYWNoZWRPYmplY3RzXzsgIH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0IGJpbmRpbmdzUGVyT2JqZWN0KCkgeyByZXR1cm4gc2NvcGUuX2JpbmRpbmdzLmxlbmd0aDsgfVxyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFuaW1hdGlvbk9iamVjdEdyb3VwLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkFuaW1hdGlvbk9iamVjdEdyb3VwLFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uKCB2YXJfYXJncyApIHtcclxuXHJcblx0XHR2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXHJcblx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXHJcblx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXHJcblx0XHRcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxyXG5cdFx0XHRwYXRocyA9IHRoaXMuX3BhdGhzLFxyXG5cdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxyXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxyXG5cdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdHZhciBvYmplY3QgPSBhcmd1bWVudHNbIGkgXSxcclxuXHRcdFx0XHR1dWlkID0gb2JqZWN0LnV1aWQsXHJcblx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHVua25vd24gb2JqZWN0IC0+IGFkZCBpdCB0byB0aGUgQUNUSVZFIHJlZ2lvblxyXG5cclxuXHRcdFx0XHRpbmRleCA9IG5PYmplY3RzICsrO1xyXG5cdFx0XHRcdGluZGljZXNCeVVVSURbIHV1aWQgXSA9IGluZGV4O1xyXG5cdFx0XHRcdG9iamVjdHMucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdGJpbmRpbmdzWyBqIF0ucHVzaChcclxuXHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuUHJvcGVydHlCaW5kaW5nKFxyXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0LCBwYXRoc1sgaiBdLCBwYXJzZWRQYXRoc1sgaiBdICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGtub3duT2JqZWN0ID0gb2JqZWN0c1sgaW5kZXggXTtcclxuXHJcblx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgdG8gdGhlIEFDVElWRSByZWdpb25cclxuXHJcblx0XHRcdFx0dmFyIGZpcnN0QWN0aXZlSW5kZXggPSAtLSBuQ2FjaGVkT2JqZWN0cyxcclxuXHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF07XHJcblxyXG5cdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RDYWNoZWRPYmplY3QudXVpZCBdID0gaW5kZXg7XHJcblx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RDYWNoZWRPYmplY3Q7XHJcblxyXG5cdFx0XHRcdGluZGljZXNCeVVVSURbIHV1aWQgXSA9IGZpcnN0QWN0aXZlSW5kZXg7XHJcblx0XHRcdFx0b2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdID0gb2JqZWN0O1xyXG5cclxuXHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXSxcclxuXHRcdFx0XHRcdFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdLFxyXG5cdFx0XHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NGb3JQYXRoWyBpbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGxhc3RDYWNoZWQ7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBzaW5jZSB3ZSBkbyBub3QgYm90aGVyIHRvIGNyZWF0ZSBuZXcgYmluZGluZ3NcclxuXHRcdFx0XHRcdFx0Ly8gZm9yIG9iamVjdHMgdGhhdCBhcmUgY2FjaGVkLCB0aGUgYmluZGluZyBtYXlcclxuXHRcdFx0XHRcdFx0Ly8gb3IgbWF5IG5vdCBleGlzdFxyXG5cclxuXHRcdFx0XHRcdFx0YmluZGluZyA9IG5ldyBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcoXHJcblx0XHRcdFx0XHRcdFx0XHRvYmplY3QsIHBhdGhzWyBqIF0sIHBhcnNlZFBhdGhzWyBqIF0gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3RzWyBpbmRleCBdICE9PSBrbm93bk9iamVjdCkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIkRpZmZlcmVudCBvYmplY3RzIHdpdGggdGhlIHNhbWUgVVVJRCBcIiArXHJcblx0XHRcdFx0XHRcdFwiZGV0ZWN0ZWQuIENsZWFuIHRoZSBjYWNoZXMgb3IgcmVjcmVhdGUgeW91ciBcIiArXHJcblx0XHRcdFx0XHRcdFwiaW5mcmFzdHJ1Y3R1cmUgd2hlbiByZWxvYWRpbmcgc2NlbmVzLi4uXCIgKTtcclxuXHJcblx0XHRcdH0gLy8gZWxzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgd2hlcmUgd2Ugd2FudCBpdCB0byBiZVxyXG5cclxuXHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xyXG5cclxuXHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlbW92ZTogZnVuY3Rpb24oIHZhcl9hcmdzICkge1xyXG5cclxuXHRcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcclxuXHRcdFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcclxuXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXHJcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxyXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcclxuXHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXTtcclxuXHJcblx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpbmRleCA+PSBuQ2FjaGVkT2JqZWN0cyApIHtcclxuXHJcblx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgaW50byB0aGUgQ0FDSEVEIHJlZ2lvblxyXG5cclxuXHRcdFx0XHR2YXIgbGFzdENhY2hlZEluZGV4ID0gbkNhY2hlZE9iamVjdHMgKyssXHJcblx0XHRcdFx0XHRmaXJzdEFjdGl2ZU9iamVjdCA9IG9iamVjdHNbIGxhc3RDYWNoZWRJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBmaXJzdEFjdGl2ZU9iamVjdC51dWlkIF0gPSBpbmRleDtcclxuXHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gZmlyc3RBY3RpdmVPYmplY3Q7XHJcblxyXG5cdFx0XHRcdGluZGljZXNCeVVVSURbIHV1aWQgXSA9IGxhc3RDYWNoZWRJbmRleDtcclxuXHRcdFx0XHRvYmplY3RzWyBsYXN0Q2FjaGVkSW5kZXggXSA9IG9iamVjdDtcclxuXHJcblx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXHJcblx0XHRcdFx0XHRcdGZpcnN0QWN0aXZlID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0Q2FjaGVkSW5kZXggXSxcclxuXHRcdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBmaXJzdEFjdGl2ZTtcclxuXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgbGFzdENhY2hlZEluZGV4IF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSAvLyBmb3IgYXJndW1lbnRzXHJcblxyXG5cdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gcmVtb3ZlICYgZm9yZ2V0XHJcblx0dW5jYWNoZTogZnVuY3Rpb24oIHZhcl9hcmdzICkge1xyXG5cclxuXHRcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcclxuXHRcdFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcclxuXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXHJcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxyXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcclxuXHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXTtcclxuXHJcblx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0ZGVsZXRlIGluZGljZXNCeVVVSURbIHV1aWQgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbmRleCA8IG5DYWNoZWRPYmplY3RzICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIG9iamVjdCBpcyBjYWNoZWQsIHNocmluayB0aGUgQ0FDSEVEIHJlZ2lvblxyXG5cclxuXHRcdFx0XHRcdHZhciBmaXJzdEFjdGl2ZUluZGV4ID0gLS0gbkNhY2hlZE9iamVjdHMsXHJcblx0XHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0sXHJcblx0XHRcdFx0XHRcdGxhc3RJbmRleCA9IC0tIG5PYmplY3RzLFxyXG5cdFx0XHRcdFx0XHRsYXN0T2JqZWN0ID0gb2JqZWN0c1sgbGFzdEluZGV4IF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gbGFzdCBjYWNoZWQgb2JqZWN0IHRha2VzIHRoaXMgb2JqZWN0J3MgcGxhY2VcclxuXHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RDYWNoZWRPYmplY3QudXVpZCBdID0gaW5kZXg7XHJcblx0XHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gbGFzdENhY2hlZE9iamVjdDtcclxuXHJcblx0XHRcdFx0XHQvLyBsYXN0IG9iamVjdCBnb2VzIHRvIHRoZSBhY3RpdmF0ZWQgc2xvdCBhbmQgcG9wXHJcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0T2JqZWN0LnV1aWQgXSA9IGZpcnN0QWN0aXZlSW5kZXg7XHJcblx0XHRcdFx0XHRvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBsYXN0T2JqZWN0O1xyXG5cdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTtcclxuXHJcblx0XHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXHJcblx0XHRcdFx0XHRcdFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdLFxyXG5cdFx0XHRcdFx0XHRcdGxhc3QgPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gbGFzdENhY2hlZDtcclxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBsYXN0O1xyXG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIG9iamVjdCBpcyBhY3RpdmUsIGp1c3Qgc3dhcCB3aXRoIHRoZSBsYXN0IGFuZCBwb3BcclxuXHJcblx0XHRcdFx0XHR2YXIgbGFzdEluZGV4ID0gLS0gbk9iamVjdHMsXHJcblx0XHRcdFx0XHRcdGxhc3RPYmplY3QgPSBvYmplY3RzWyBsYXN0SW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0T2JqZWN0LnV1aWQgXSA9IGluZGV4O1xyXG5cdFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RPYmplY3Q7XHJcblx0XHRcdFx0XHRvYmplY3RzLnBvcCgpO1xyXG5cclxuXHRcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXTtcclxuXHJcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdEluZGV4IF07XHJcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gLy8gY2FjaGVkIG9yIGFjdGl2ZVxyXG5cclxuXHRcdFx0fSAvLyBpZiBvYmplY3QgaXMga25vd25cclxuXHJcblx0XHR9IC8vIGZvciBhcmd1bWVudHNcclxuXHJcblx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBJbnRlcm5hbCBpbnRlcmZhY2UgdXNlZCBieSBiZWZyaWVuZGVkIFByb3BlcnR5QmluZGluZy5Db21wb3NpdGU6XHJcblxyXG5cdHN1YnNjcmliZV86IGZ1bmN0aW9uKCBwYXRoLCBwYXJzZWRQYXRoICkge1xyXG5cdFx0Ly8gcmV0dXJucyBhbiBhcnJheSBvZiBiaW5kaW5ncyBmb3IgdGhlIGdpdmVuIHBhdGggdGhhdCBpcyBjaGFuZ2VkXHJcblx0XHQvLyBhY2NvcmRpbmcgdG8gdGhlIGNvbnRhaW5lZCBvYmplY3RzIGluIHRoZSBncm91cFxyXG5cclxuXHRcdHZhciBpbmRpY2VzQnlQYXRoID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLFxyXG5cdFx0XHRpbmRleCA9IGluZGljZXNCeVBhdGhbIHBhdGggXSxcclxuXHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSByZXR1cm4gYmluZGluZ3NbIGluZGV4IF07XHJcblxyXG5cdFx0dmFyIHBhdGhzID0gdGhpcy5fcGF0aHMsXHJcblx0XHRcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXHJcblx0XHRcdG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxyXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxyXG5cdFx0XHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxyXG5cdFx0XHRiaW5kaW5nc0ZvclBhdGggPSBuZXcgQXJyYXkoIG5PYmplY3RzICk7XHJcblxyXG5cdFx0aW5kZXggPSBiaW5kaW5ncy5sZW5ndGg7XHJcblxyXG5cdFx0aW5kaWNlc0J5UGF0aFsgcGF0aCBdID0gaW5kZXg7XHJcblxyXG5cdFx0cGF0aHMucHVzaCggcGF0aCApO1xyXG5cdFx0cGFyc2VkUGF0aHMucHVzaCggcGFyc2VkUGF0aCApO1xyXG5cdFx0YmluZGluZ3MucHVzaCggYmluZGluZ3NGb3JQYXRoICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSBuQ2FjaGVkT2JqZWN0cyxcclxuXHRcdFx0XHRuID0gb2JqZWN0cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHR2YXIgb2JqZWN0ID0gb2JqZWN0c1sgaSBdO1xyXG5cclxuXHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpIF0gPVxyXG5cdFx0XHRcdFx0bmV3IFRIUkVFLlByb3BlcnR5QmluZGluZyggb2JqZWN0LCBwYXRoLCBwYXJzZWRQYXRoICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBiaW5kaW5nc0ZvclBhdGg7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVuc3Vic2NyaWJlXzogZnVuY3Rpb24oIHBhdGggKSB7XHJcblx0XHQvLyB0ZWxscyB0aGUgZ3JvdXAgdG8gZm9yZ2V0IGFib3V0IGEgcHJvcGVydHkgcGF0aCBhbmQgbm8gbG9uZ2VyXHJcblx0XHQvLyB1cGRhdGUgdGhlIGFycmF5IHByZXZpb3VzbHkgb2J0YWluZWQgd2l0aCAnc3Vic2NyaWJlXydcclxuXHJcblx0XHR2YXIgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCxcclxuXHRcdFx0aW5kZXggPSBpbmRpY2VzQnlQYXRoWyBwYXRoIF07XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIHBhdGhzID0gdGhpcy5fcGF0aHMsXHJcblx0XHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcclxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxyXG5cdFx0XHRcdGxhc3RCaW5kaW5nc0luZGV4ID0gYmluZGluZ3MubGVuZ3RoIC0gMSxcclxuXHRcdFx0XHRsYXN0QmluZGluZ3MgPSBiaW5kaW5nc1sgbGFzdEJpbmRpbmdzSW5kZXggXSxcclxuXHRcdFx0XHRsYXN0QmluZGluZ3NQYXRoID0gcGF0aFsgbGFzdEJpbmRpbmdzSW5kZXggXTtcclxuXHJcblx0XHRcdGluZGljZXNCeVBhdGhbIGxhc3RCaW5kaW5nc1BhdGggXSA9IGluZGV4O1xyXG5cclxuXHRcdFx0YmluZGluZ3NbIGluZGV4IF0gPSBsYXN0QmluZGluZ3M7XHJcblx0XHRcdGJpbmRpbmdzLnBvcCgpO1xyXG5cclxuXHRcdFx0cGFyc2VkUGF0aHNbIGluZGV4IF0gPSBwYXJzZWRQYXRoc1sgbGFzdEJpbmRpbmdzSW5kZXggXTtcclxuXHRcdFx0cGFyc2VkUGF0aHMucG9wKCk7XHJcblxyXG5cdFx0XHRwYXRoc1sgaW5kZXggXSA9IHBhdGhzWyBsYXN0QmluZGluZ3NJbmRleCBdO1xyXG5cdFx0XHRwYXRocy5wb3AoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL0FuaW1hdGlvblV0aWxzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0c2Nod1xyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICovXHJcblxyXG5USFJFRS5BbmltYXRpb25VdGlscyA9IHtcclxuXHJcblx0Ly8gc2FtZSBhcyBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCBhbHNvIHdvcmtzIG9uIHR5cGVkIGFycmF5c1xyXG5cdGFycmF5U2xpY2U6IGZ1bmN0aW9uKCBhcnJheSwgZnJvbSwgdG8gKSB7XHJcblxyXG5cdFx0aWYgKCBUSFJFRS5BbmltYXRpb25VdGlscy5pc1R5cGVkQXJyYXkoIGFycmF5ICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBhcnJheS5zdWJhcnJheSggZnJvbSwgdG8gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYXJyYXkuc2xpY2UoIGZyb20sIHRvICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGNvbnZlcnRzIGFuIGFycmF5IHRvIGEgc3BlY2lmaWMgdHlwZVxyXG5cdGNvbnZlcnRBcnJheTogZnVuY3Rpb24oIGFycmF5LCB0eXBlLCBmb3JjZUNsb25lICkge1xyXG5cclxuXHRcdGlmICggISBhcnJheSB8fCAvLyBsZXQgJ3VuZGVmaW5lZCcgYW5kICdudWxsJyBwYXNzXHJcblx0XHRcdFx0ISBmb3JjZUNsb25lICYmIGFycmF5LmNvbnN0cnVjdG9yID09PSB0eXBlICkgcmV0dXJuIGFycmF5O1xyXG5cclxuXHRcdGlmICggdHlwZW9mIHR5cGUuQllURVNfUEVSX0VMRU1FTlQgPT09ICdudW1iZXInICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyB0eXBlKCBhcnJheSApOyAvLyBjcmVhdGUgdHlwZWQgYXJyYXlcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcnJheSApOyAvLyBjcmVhdGUgQXJyYXlcclxuXHJcblx0fSxcclxuXHJcblx0aXNUeXBlZEFycmF5OiBmdW5jdGlvbiggb2JqZWN0ICkge1xyXG5cclxuXHRcdHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoIG9iamVjdCApICYmXHJcblx0XHRcdFx0ISAoIG9iamVjdCBpbnN0YW5jZW9mIERhdGFWaWV3ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgYW4gYXJyYXkgYnkgd2hpY2ggdGltZXMgYW5kIHZhbHVlcyBjYW4gYmUgc29ydGVkXHJcblx0Z2V0S2V5ZnJhbWVPcmRlcjogZnVuY3Rpb24oIHRpbWVzICkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNvbXBhcmVUaW1lKCBpLCBqICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRpbWVzWyBpIF0gLSB0aW1lc1sgaiBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbiA9IHRpbWVzLmxlbmd0aDtcclxuXHRcdHZhciByZXN1bHQgPSBuZXcgQXJyYXkoIG4gKTtcclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApIHJlc3VsdFsgaSBdID0gaTtcclxuXHJcblx0XHRyZXN1bHQuc29ydCggY29tcGFyZVRpbWUgKTtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyB1c2VzIHRoZSBhcnJheSBwcmV2aW91c2x5IHJldHVybmVkIGJ5ICdnZXRLZXlmcmFtZU9yZGVyJyB0byBzb3J0IGRhdGFcclxuXHRzb3J0ZWRBcnJheTogZnVuY3Rpb24oIHZhbHVlcywgc3RyaWRlLCBvcmRlciApIHtcclxuXHJcblx0XHR2YXIgblZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XHJcblx0XHR2YXIgcmVzdWx0ID0gbmV3IHZhbHVlcy5jb25zdHJ1Y3RvciggblZhbHVlcyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgZHN0T2Zmc2V0ID0gMDsgZHN0T2Zmc2V0ICE9PSBuVmFsdWVzOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIHNyY09mZnNldCA9IG9yZGVyWyBpIF0gKiBzdHJpZGU7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0cmVzdWx0WyBkc3RPZmZzZXQgKysgXSA9IHZhbHVlc1sgc3JjT2Zmc2V0ICsgaiBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBmdW5jdGlvbiBmb3IgcGFyc2luZyBBT1Mga2V5ZnJhbWUgZm9ybWF0c1xyXG5cdGZsYXR0ZW5KU09OOiBmdW5jdGlvbigganNvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHZhbHVlUHJvcGVydHlOYW1lICkge1xyXG5cclxuXHRcdHZhciBpID0gMSwga2V5ID0ganNvbktleXNbIDAgXTtcclxuXHJcblx0XHR3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICYmIGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxyXG5cclxuXHRcdHZhciB2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcclxuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxyXG5cclxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcclxuXHJcblx0XHRcdGRvIHtcclxuXHJcblx0XHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xyXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2guYXBwbHkoIHZhbHVlcywgdmFsdWUgKTsgLy8gcHVzaCBhbGwgZWxlbWVudHNcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xyXG5cclxuXHRcdFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdmFsdWUudG9BcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHQvLyAuLi5hc3N1bWUgVEhSRUUuTWF0aC1pc2hcclxuXHJcblx0XHRcdGRvIHtcclxuXHJcblx0XHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xyXG5cdFx0XHRcdFx0dmFsdWUudG9BcnJheSggdmFsdWVzLCB2YWx1ZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcclxuXHJcblx0XHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIG90aGVyd2lzZSBwdXNoIGFzLWlzXHJcblxyXG5cdFx0XHRkbyB7XHJcblxyXG5cdFx0XHRcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGltZXMucHVzaCgga2V5LnRpbWUgKTtcclxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XHJcblxyXG5cdFx0XHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vS2V5ZnJhbWVUcmFjay5qc1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEEgdGltZWQgc2VxdWVuY2Ugb2Yga2V5ZnJhbWVzIGZvciBhIHNwZWNpZmljIHByb3BlcnR5LlxyXG4gKlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICogQGF1dGhvciB0c2Nod1xyXG4gKi9cclxuXHJcblRIUkVFLktleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdGlmKCBuYW1lID09PSB1bmRlZmluZWQgKSB0aHJvdyBuZXcgRXJyb3IoIFwidHJhY2sgbmFtZSBpcyB1bmRlZmluZWRcIiApO1xyXG5cclxuXHRpZiggdGltZXMgPT09IHVuZGVmaW5lZCB8fCB0aW1lcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcIm5vIGtleWZyYW1lcyBpbiB0cmFjayBuYW1lZCBcIiArIG5hbWUgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuXHR0aGlzLnRpbWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0aW1lcywgdGhpcy5UaW1lQnVmZmVyVHlwZSApO1xyXG5cdHRoaXMudmFsdWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB2YWx1ZXMsIHRoaXMuVmFsdWVCdWZmZXJUeXBlICk7XHJcblxyXG5cdHRoaXMuc2V0SW50ZXJwb2xhdGlvbiggaW50ZXJwb2xhdGlvbiB8fCB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICk7XHJcblxyXG5cdHRoaXMudmFsaWRhdGUoKTtcclxuXHR0aGlzLm9wdGltaXplKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5LZXlmcmFtZVRyYWNrLFxyXG5cclxuXHRUaW1lQnVmZmVyVHlwZTogRmxvYXQzMkFycmF5LFxyXG5cdFZhbHVlQnVmZmVyVHlwZTogRmxvYXQzMkFycmF5LFxyXG5cclxuXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogVEhSRUUuSW50ZXJwb2xhdGVMaW5lYXIsXHJcblxyXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlOiBmdW5jdGlvbiggcmVzdWx0ICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuRGlzY3JldGVJbnRlcnBvbGFudChcclxuXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogZnVuY3Rpb24oIHJlc3VsdCApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLkxpbmVhckludGVycG9sYW50KFxyXG5cdFx0XHRcdHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOiBmdW5jdGlvbiggcmVzdWx0ICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuQ3ViaWNJbnRlcnBvbGFudChcclxuXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEludGVycG9sYXRpb246IGZ1bmN0aW9uKCBpbnRlcnBvbGF0aW9uICkge1xyXG5cclxuXHRcdHZhciBmYWN0b3J5TWV0aG9kID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdHN3aXRjaCAoIGludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0XHRjYXNlIFRIUkVFLkludGVycG9sYXRlRGlzY3JldGU6XHJcblxyXG5cdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgVEhSRUUuSW50ZXJwb2xhdGVMaW5lYXI6XHJcblxyXG5cdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIFRIUkVFLkludGVycG9sYXRlU21vb3RoOlxyXG5cclxuXHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGZhY3RvcnlNZXRob2QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBtZXNzYWdlID0gXCJ1bnN1cHBvcnRlZCBpbnRlcnBvbGF0aW9uIGZvciBcIiArXHJcblx0XHRcdFx0XHR0aGlzLlZhbHVlVHlwZU5hbWUgKyBcIiBrZXlmcmFtZSB0cmFjayBuYW1lZCBcIiArIHRoaXMubmFtZTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCwgdW5sZXNzIHRoZSBkZWZhdWx0IGl0c2VsZiBpcyBtZXNzZWQgdXBcclxuXHRcdFx0XHRpZiAoIGludGVycG9sYXRpb24gIT09IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5zZXRJbnRlcnBvbGF0aW9uKCB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7IC8vIGZhdGFsLCBpbiB0aGlzIGNhc2VcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCBtZXNzYWdlICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9IGZhY3RvcnlNZXRob2Q7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEludGVycG9sYXRpb246IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHN3aXRjaCAoIHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgKSB7XHJcblxyXG5cdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU6XHJcblxyXG5cdFx0XHRcdHJldHVybiBUSFJFRS5JbnRlcnBvbGF0ZURpc2NyZXRlO1xyXG5cclxuXHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjpcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRIUkVFLkludGVycG9sYXRlTGluZWFyO1xyXG5cclxuXHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDpcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRIUkVFLkludGVycG9sYXRlU21vb3RoO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0VmFsdWVTaXplOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoIC8gdGhpcy50aW1lcy5sZW5ndGg7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIG1vdmUgYWxsIGtleWZyYW1lcyBlaXRoZXIgZm9yd2FyZHMgb3IgYmFja3dhcmRzIGluIHRpbWVcclxuXHRzaGlmdDogZnVuY3Rpb24oIHRpbWVPZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYoIHRpbWVPZmZzZXQgIT09IDAuMCApIHtcclxuXHJcblx0XHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXM7XHJcblxyXG5cdFx0XHRmb3IoIHZhciBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0dGltZXNbIGkgXSArPSB0aW1lT2Zmc2V0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gc2NhbGUgYWxsIGtleWZyYW1lIHRpbWVzIGJ5IGEgZmFjdG9yICh1c2VmdWwgZm9yIGZyYW1lIDwtPiBzZWNvbmRzIGNvbnZlcnNpb25zKVxyXG5cdHNjYWxlOiBmdW5jdGlvbiggdGltZVNjYWxlICkge1xyXG5cclxuXHRcdGlmKCB0aW1lU2NhbGUgIT09IDEuMCApIHtcclxuXHJcblx0XHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXM7XHJcblxyXG5cdFx0XHRmb3IoIHZhciBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0dGltZXNbIGkgXSAqPSB0aW1lU2NhbGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyByZW1vdmVzIGtleWZyYW1lcyBiZWZvcmUgYW5kIGFmdGVyIGFuaW1hdGlvbiB3aXRob3V0IGNoYW5naW5nIGFueSB2YWx1ZXMgd2l0aGluIHRoZSByYW5nZSBbc3RhcnRUaW1lLCBlbmRUaW1lXS5cclxuXHQvLyBJTVBPUlRBTlQ6IFdlIGRvIG5vdCBzaGlmdCBhcm91bmQga2V5cyB0byB0aGUgc3RhcnQgb2YgdGhlIHRyYWNrIHRpbWUsIGJlY2F1c2UgZm9yIGludGVycG9sYXRlZCBrZXlzIHRoaXMgd2lsbCBjaGFuZ2UgdGhlaXIgdmFsdWVzXHJcblx0dHJpbTogZnVuY3Rpb24oIHN0YXJ0VGltZSwgZW5kVGltZSApIHtcclxuXHJcblx0XHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzLFxyXG5cdFx0XHRuS2V5cyA9IHRpbWVzLmxlbmd0aCxcclxuXHRcdFx0ZnJvbSA9IDAsXHJcblx0XHRcdHRvID0gbktleXMgLSAxO1xyXG5cclxuXHRcdHdoaWxlICggZnJvbSAhPT0gbktleXMgJiYgdGltZXNbIGZyb20gXSA8IHN0YXJ0VGltZSApICsrIGZyb207XHJcblx0XHR3aGlsZSAoIHRvICE9PSAtMSAmJiB0aW1lc1sgdG8gXSA+IGVuZFRpbWUgKSAtLSB0bztcclxuXHJcblx0XHQrKyB0bzsgLy8gaW5jbHVzaXZlIC0+IGV4Y2x1c2l2ZSBib3VuZFxyXG5cclxuXHRcdGlmKCBmcm9tICE9PSAwIHx8IHRvICE9PSBuS2V5cyApIHtcclxuXHJcblx0XHRcdC8vIGVtcHR5IHRyYWNrcyBhcmUgZm9yYmlkZGVuLCBzbyBrZWVwIGF0IGxlYXN0IG9uZSBrZXlmcmFtZVxyXG5cdFx0XHRpZiAoIGZyb20gPj0gdG8gKSB0byA9IE1hdGgubWF4KCB0byAsIDEgKSwgZnJvbSA9IHRvIC0gMTtcclxuXHJcblx0XHRcdHZhciBzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xyXG5cdFx0XHR0aGlzLnRpbWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdGltZXMsIGZyb20sIHRvICk7XHJcblx0XHRcdHRoaXMudmFsdWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuXHJcblx0XHRcdFx0XHRhcnJheVNsaWNlKCB0aGlzLnZhbHVlcywgZnJvbSAqIHN0cmlkZSwgdG8gKiBzdHJpZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGVuc3VyZSB3ZSBkbyBub3QgZ2V0IGEgR2FyYmFnZUluR2FyYmFnZU91dCBzaXR1YXRpb24sIG1ha2Ugc3VyZSB0cmFja3MgYXJlIGF0IGxlYXN0IG1pbmltYWxseSB2aWFibGVcclxuXHR2YWxpZGF0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHZhbGlkID0gdHJ1ZTtcclxuXHJcblx0XHR2YXIgdmFsdWVTaXplID0gdGhpcy5nZXRWYWx1ZVNpemUoKTtcclxuXHRcdGlmICggdmFsdWVTaXplIC0gTWF0aC5mbG9vciggdmFsdWVTaXplICkgIT09IDAgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcImludmFsaWQgdmFsdWUgc2l6ZSBpbiB0cmFja1wiLCB0aGlzICk7XHJcblx0XHRcdHZhbGlkID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXMsXHJcblx0XHRcdHZhbHVlcyA9IHRoaXMudmFsdWVzLFxyXG5cclxuXHRcdFx0bktleXMgPSB0aW1lcy5sZW5ndGg7XHJcblxyXG5cdFx0aWYoIG5LZXlzID09PSAwICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggXCJ0cmFjayBpcyBlbXB0eVwiLCB0aGlzICk7XHJcblx0XHRcdHZhbGlkID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmV2VGltZSA9IG51bGw7XHJcblxyXG5cdFx0Zm9yKCB2YXIgaSA9IDA7IGkgIT09IG5LZXlzOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGN1cnJUaW1lID0gdGltZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggdHlwZW9mIGN1cnJUaW1lID09PSAnbnVtYmVyJyAmJiBpc05hTiggY3VyclRpbWUgKSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJ0aW1lIGlzIG5vdCBhIHZhbGlkIG51bWJlclwiLCB0aGlzLCBpLCBjdXJyVGltZSApO1xyXG5cdFx0XHRcdHZhbGlkID0gZmFsc2U7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiggcHJldlRpbWUgIT09IG51bGwgJiYgcHJldlRpbWUgPiBjdXJyVGltZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJvdXQgb2Ygb3JkZXIga2V5c1wiLCB0aGlzLCBpLCBjdXJyVGltZSwgcHJldlRpbWUgKTtcclxuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cHJldlRpbWUgPSBjdXJyVGltZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB2YWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGlmICggVEhSRUUuQW5pbWF0aW9uVXRpbHMuaXNUeXBlZEFycmF5KCB2YWx1ZXMgKSApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJ2YWx1ZSBpcyBub3QgYSB2YWxpZCBudW1iZXJcIiwgdGhpcywgaSwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2YWxpZDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gcmVtb3ZlcyBlcXVpdmFsZW50IHNlcXVlbnRpYWwga2V5cyBhcyBjb21tb24gaW4gbW9ycGggdGFyZ2V0IHNlcXVlbmNlc1xyXG5cdC8vICgwLDAsMCwwLDEsMSwxLDAsMCwwLDAsMCwwLDApIC0tPiAoMCwwLDEsMSwwLDApXHJcblx0b3B0aW1pemU6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXMsXHJcblx0XHRcdHZhbHVlcyA9IHRoaXMudmFsdWVzLFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpLFxyXG5cclxuXHRcdFx0d3JpdGVJbmRleCA9IDE7XHJcblxyXG5cdFx0Zm9yKCB2YXIgaSA9IDEsIG4gPSB0aW1lcy5sZW5ndGggLSAxOyBpIDw9IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHR2YXIga2VlcCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0dmFyIHRpbWUgPSB0aW1lc1sgaSBdO1xyXG5cdFx0XHR2YXIgdGltZU5leHQgPSB0aW1lc1sgaSArIDEgXTtcclxuXHJcblx0XHRcdC8vIHJlbW92ZSBhZGphY2VudCBrZXlmcmFtZXMgc2NoZWR1bGVkIGF0IHRoZSBzYW1lIHRpbWVcclxuXHJcblx0XHRcdGlmICggdGltZSAhPT0gdGltZU5leHQgJiYgKCBpICE9PSAxIHx8IHRpbWUgIT09IHRpbWVbIDAgXSApICkge1xyXG5cclxuXHRcdFx0XHQvLyByZW1vdmUgdW5uZWNlc3Nhcnkga2V5ZnJhbWVzIHNhbWUgYXMgdGhlaXIgbmVpZ2hib3JzXHJcblx0XHRcdFx0dmFyIG9mZnNldCA9IGkgKiBzdHJpZGUsXHJcblx0XHRcdFx0XHRvZmZzZXRQID0gb2Zmc2V0IC0gc3RyaWRlLFxyXG5cdFx0XHRcdFx0b2Zmc2V0TiA9IG9mZnNldCArIHN0cmlkZTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gdmFsdWVzWyBvZmZzZXQgKyBqIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdmFsdWVzWyBvZmZzZXRQICsgaiBdIHx8XHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0TiArIGogXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGtlZXAgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGluLXBsYWNlIGNvbXBhY3Rpb25cclxuXHJcblx0XHRcdGlmICgga2VlcCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBpICE9PSB3cml0ZUluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdHRpbWVzWyB3cml0ZUluZGV4IF0gPSB0aW1lc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciByZWFkT2Zmc2V0ID0gaSAqIHN0cmlkZSxcclxuXHRcdFx0XHRcdFx0d3JpdGVPZmZzZXQgPSB3cml0ZUluZGV4ICogc3RyaWRlO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFsdWVzWyB3cml0ZU9mZnNldCArIGogXSA9IHZhbHVlc1sgcmVhZE9mZnNldCArIGogXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdCsrIHdyaXRlSW5kZXg7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggd3JpdGVJbmRleCAhPT0gdGltZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dGhpcy50aW1lcyA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHRpbWVzLCAwLCB3cml0ZUluZGV4ICk7XHJcblx0XHRcdHRoaXMudmFsdWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdmFsdWVzLCAwLCB3cml0ZUluZGV4ICogc3RyaWRlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gU3RhdGljIG1ldGhvZHM6XHJcblxyXG5PYmplY3QuYXNzaWduKCBUSFJFRS5LZXlmcmFtZVRyYWNrLCB7XHJcblxyXG5cdC8vIFNlcmlhbGl6YXRpb24gKGluIHN0YXRpYyBjb250ZXh0LCBiZWNhdXNlIG9mIGNvbnN0cnVjdG9yIGludm9jYXRpb25cclxuXHQvLyBhbmQgYXV0b21hdGljIGludm9jYXRpb24gb2YgLnRvSlNPTik6XHJcblxyXG5cdHBhcnNlOiBmdW5jdGlvbigganNvbiApIHtcclxuXHJcblx0XHRpZigganNvbi50eXBlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwidHJhY2sgdHlwZSB1bmRlZmluZWQsIGNhbiBub3QgcGFyc2VcIiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdHJhY2tUeXBlID0gVEhSRUUuS2V5ZnJhbWVUcmFjay5fZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZSgganNvbi50eXBlICk7XHJcblxyXG5cdFx0aWYgKCBqc29uLnRpbWVzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oIFwibGVnYWN5IEpTT04gZm9ybWF0IGRldGVjdGVkLCBjb252ZXJ0aW5nXCIgKTtcclxuXHJcblx0XHRcdHZhciB0aW1lcyA9IFtdLCB2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdFRIUkVFLkFuaW1hdGlvblV0aWxzLmZsYXR0ZW5KU09OKCBqc29uLmtleXMsIHRpbWVzLCB2YWx1ZXMsICd2YWx1ZScgKTtcclxuXHJcblx0XHRcdGpzb24udGltZXMgPSB0aW1lcztcclxuXHRcdFx0anNvbi52YWx1ZXMgPSB2YWx1ZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRlcml2ZWQgY2xhc3NlcyBjYW4gZGVmaW5lIGEgc3RhdGljIHBhcnNlIG1ldGhvZFxyXG5cdFx0aWYgKCB0cmFja1R5cGUucGFyc2UgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cmFja1R5cGUucGFyc2UoIGpzb24gKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gYnkgZGVmYXVsdCwgd2UgYXNzc3VtZSBhIGNvbnN0cnVjdG9yIGNvbXBhdGlibGUgd2l0aCB0aGUgYmFzZVxyXG5cdFx0XHRyZXR1cm4gbmV3IHRyYWNrVHlwZShcclxuXHRcdFx0XHRcdGpzb24ubmFtZSwganNvbi50aW1lcywganNvbi52YWx1ZXMsIGpzb24uaW50ZXJwb2xhdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dG9KU09OOiBmdW5jdGlvbiggdHJhY2sgKSB7XHJcblxyXG5cdFx0dmFyIHRyYWNrVHlwZSA9IHRyYWNrLmNvbnN0cnVjdG9yO1xyXG5cclxuXHRcdHZhciBqc29uO1xyXG5cclxuXHRcdC8vIGRlcml2ZWQgY2xhc3NlcyBjYW4gZGVmaW5lIGEgc3RhdGljIHRvSlNPTiBtZXRob2RcclxuXHRcdGlmICggdHJhY2tUeXBlLnRvSlNPTiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0anNvbiA9IHRyYWNrVHlwZS50b0pTT04oIHRyYWNrICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGJ5IGRlZmF1bHQsIHdlIGFzc3VtZSB0aGUgZGF0YSBjYW4gYmUgc2VyaWFsaXplZCBhcy1pc1xyXG5cdFx0XHRqc29uID0ge1xyXG5cclxuXHRcdFx0XHQnbmFtZSc6IHRyYWNrLm5hbWUsXHJcblx0XHRcdFx0J3RpbWVzJzogVEhSRUUuQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0cmFjay50aW1lcywgQXJyYXkgKSxcclxuXHRcdFx0XHQndmFsdWVzJzogVEhSRUUuQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0cmFjay52YWx1ZXMsIEFycmF5IClcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR2YXIgaW50ZXJwb2xhdGlvbiA9IHRyYWNrLmdldEludGVycG9sYXRpb24oKTtcclxuXHJcblx0XHRcdGlmICggaW50ZXJwb2xhdGlvbiAhPT0gdHJhY2suRGVmYXVsdEludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdGpzb24uaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGpzb24udHlwZSA9IHRyYWNrLlZhbHVlVHlwZU5hbWU7IC8vIG1hbmRhdG9yeVxyXG5cclxuXHRcdHJldHVybiBqc29uO1xyXG5cclxuXHR9LFxyXG5cclxuXHRfZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZTogZnVuY3Rpb24oIHR5cGVOYW1lICkge1xyXG5cclxuXHRcdHN3aXRjaCggdHlwZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcclxuXHJcblx0XHRcdGNhc2UgXCJzY2FsYXJcIjpcclxuXHRcdFx0Y2FzZSBcImRvdWJsZVwiOlxyXG5cdFx0XHRjYXNlIFwiZmxvYXRcIjpcclxuXHRcdFx0Y2FzZSBcIm51bWJlclwiOlxyXG5cdFx0XHRjYXNlIFwiaW50ZWdlclwiOlxyXG5cclxuXHRcdFx0XHRyZXR1cm4gVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjaztcclxuXHJcblx0XHRcdGNhc2UgXCJ2ZWN0b3JcIjpcclxuXHRcdFx0Y2FzZSBcInZlY3RvcjJcIjpcclxuXHRcdFx0Y2FzZSBcInZlY3RvcjNcIjpcclxuXHRcdFx0Y2FzZSBcInZlY3RvcjRcIjpcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2s7XHJcblxyXG5cdFx0XHRjYXNlIFwiY29sb3JcIjpcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRIUkVFLkNvbG9yS2V5ZnJhbWVUcmFjaztcclxuXHJcblx0XHRcdGNhc2UgXCJxdWF0ZXJuaW9uXCI6XHJcblxyXG5cdFx0XHRcdHJldHVybiBUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcclxuXHJcblx0XHRcdGNhc2UgXCJib29sXCI6XHJcblx0XHRcdGNhc2UgXCJib29sZWFuXCI6XHJcblxyXG5cdFx0XHRcdHJldHVybiBUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjaztcclxuXHJcblx0XHRcdGNhc2UgXCJzdHJpbmdcIjpcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2s7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiVW5zdXBwb3J0ZWQgdHlwZU5hbWU6IFwiICsgdHlwZU5hbWUgKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL1Byb3BlcnR5QmluZGluZy5qc1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEEgcmVmZXJlbmNlIHRvIGEgcmVhbCBwcm9wZXJ0eSBpbiB0aGUgc2NlbmUgZ3JhcGguXHJcbiAqXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKiBAYXV0aG9yIHRzY2h3XHJcbiAqL1xyXG5cclxuVEhSRUUuUHJvcGVydHlCaW5kaW5nID0gZnVuY3Rpb24gKCByb290Tm9kZSwgcGF0aCwgcGFyc2VkUGF0aCApIHtcclxuXHJcblx0dGhpcy5wYXRoID0gcGF0aDtcclxuXHR0aGlzLnBhcnNlZFBhdGggPSBwYXJzZWRQYXRoIHx8XHJcblx0XHRcdFRIUkVFLlByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSggcGF0aCApO1xyXG5cclxuXHR0aGlzLm5vZGUgPSBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoXHJcblx0XHRcdHJvb3ROb2RlLCB0aGlzLnBhcnNlZFBhdGgubm9kZU5hbWUgKSB8fCByb290Tm9kZTtcclxuXHJcblx0dGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlByb3BlcnR5QmluZGluZy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcsXHJcblxyXG5cdGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZV91bmJvdW5kKCB0YXJnZXRBcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMuYmluZCgpO1xyXG5cdFx0dGhpcy5nZXRWYWx1ZSggdGFyZ2V0QXJyYXksIG9mZnNldCApO1xyXG5cclxuXHRcdC8vIE5vdGU6IFRoaXMgY2xhc3MgdXNlcyBhIFN0YXRlIHBhdHRlcm4gb24gYSBwZXItbWV0aG9kIGJhc2lzOlxyXG5cdFx0Ly8gJ2JpbmQnIHNldHMgJ3RoaXMuZ2V0VmFsdWUnIC8gJ3NldFZhbHVlJyBhbmQgc2hhZG93cyB0aGVcclxuXHRcdC8vIHByb3RvdHlwZSB2ZXJzaW9uIG9mIHRoZXNlIG1ldGhvZHMgd2l0aCBvbmUgdGhhdCByZXByZXNlbnRzXHJcblx0XHQvLyB0aGUgYm91bmQgc3RhdGUuIFdoZW4gdGhlIHByb3BlcnR5IGlzIG5vdCBmb3VuZCwgdGhlIG1ldGhvZHNcclxuXHRcdC8vIGJlY29tZSBuby1vcHMuXHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZV91bmJvdW5kKCBzb3VyY2VBcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMuYmluZCgpO1xyXG5cdFx0dGhpcy5zZXRWYWx1ZSggc291cmNlQXJyYXksIG9mZnNldCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBjcmVhdGUgZ2V0dGVyIC8gc2V0dGVyIHBhaXIgZm9yIGEgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoXHJcblx0YmluZDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHRhcmdldE9iamVjdCA9IHRoaXMubm9kZSxcclxuXHRcdFx0cGFyc2VkUGF0aCA9IHRoaXMucGFyc2VkUGF0aCxcclxuXHJcblx0XHRcdG9iamVjdE5hbWUgPSBwYXJzZWRQYXRoLm9iamVjdE5hbWUsXHJcblx0XHRcdHByb3BlcnR5TmFtZSA9IHBhcnNlZFBhdGgucHJvcGVydHlOYW1lLFxyXG5cdFx0XHRwcm9wZXJ0eUluZGV4ID0gcGFyc2VkUGF0aC5wcm9wZXJ0eUluZGV4O1xyXG5cclxuXHRcdGlmICggISB0YXJnZXRPYmplY3QgKSB7XHJcblxyXG5cdFx0XHR0YXJnZXRPYmplY3QgPSBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoXHJcblx0XHRcdFx0XHR0aGlzLnJvb3ROb2RlLCBwYXJzZWRQYXRoLm5vZGVOYW1lICkgfHwgdGhpcy5yb290Tm9kZTtcclxuXHJcblx0XHRcdHRoaXMubm9kZSA9IHRhcmdldE9iamVjdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0IGZhaWwgc3RhdGUgc28gd2UgY2FuIGp1c3QgJ3JldHVybicgb24gZXJyb3JcclxuXHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLl9nZXRWYWx1ZV91bmF2YWlsYWJsZTtcclxuXHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmF2YWlsYWJsZTtcclxuXHJcbiBcdFx0Ly8gZW5zdXJlIHRoZXJlIGlzIGEgdmFsdWUgbm9kZVxyXG5cdFx0aWYgKCAhIHRhcmdldE9iamVjdCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiICB0cnlpbmcgdG8gdXBkYXRlIG5vZGUgZm9yIHRyYWNrOiBcIiArIHRoaXMucGF0aCArIFwiIGJ1dCBpdCB3YXNuJ3QgZm91bmQuXCIgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiggb2JqZWN0TmFtZSApIHtcclxuXHJcblx0XHRcdHZhciBvYmplY3RJbmRleCA9IHBhcnNlZFBhdGgub2JqZWN0SW5kZXg7XHJcblxyXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2VzIHdlcmUgd2UgbmVlZCB0byByZWFjaCBkZWVwZXIgaW50byB0aGUgaGllcmFyY2h5IHRvIGdldCB0aGUgZmFjZSBtYXRlcmlhbHMuLi4uXHJcblx0XHRcdHN3aXRjaCAoIG9iamVjdE5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ21hdGVyaWFscyc6XHJcblxyXG5cdFx0XHRcdFx0aWYoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsJywgdGhpcyApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwubWF0ZXJpYWxzIGFzIG5vZGUubWF0ZXJpYWwgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFscyBhcnJheScsIHRoaXMgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdib25lcyc6XHJcblxyXG5cdFx0XHRcdFx0aWYoICEgdGFyZ2V0T2JqZWN0LnNrZWxldG9uICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIGJvbmVzIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIHNrZWxldG9uJywgdGhpcyApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIHBvdGVudGlhbCBmdXR1cmUgb3B0aW1pemF0aW9uOiBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXJcclxuXHRcdFx0XHRcdC8vIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cclxuXHJcblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Quc2tlbGV0b24uYm9uZXM7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGFyZ2V0T2JqZWN0Lmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0W2ldLm5hbWUgPT09IG9iamVjdEluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvYmplY3RJbmRleCA9IGk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0WyBvYmplY3ROYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBvYmplY3ROYW1lIG9mIG5vZGUsIHVuZGVmaW5lZCcsIHRoaXMgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3RbIG9iamVjdE5hbWUgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdEluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmKCB0YXJnZXRPYmplY3RbIG9iamVjdEluZGV4IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgdHJ5aW5nIHRvIGJpbmQgdG8gb2JqZWN0SW5kZXggb2Ygb2JqZWN0TmFtZSwgYnV0IGlzIHVuZGVmaW5lZDpcIiwgdGhpcywgdGFyZ2V0T2JqZWN0ICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0WyBvYmplY3RJbmRleCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXNvbHZlIHByb3BlcnR5XHJcblx0XHR2YXIgbm9kZVByb3BlcnR5ID0gdGFyZ2V0T2JqZWN0WyBwcm9wZXJ0eU5hbWUgXTtcclxuXHJcblx0XHRpZiAoICEgbm9kZVByb3BlcnR5ICkge1xyXG5cclxuXHRcdFx0dmFyIG5vZGVOYW1lID0gcGFyc2VkUGF0aC5ub2RlTmFtZTtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiICB0cnlpbmcgdG8gdXBkYXRlIHByb3BlcnR5IGZvciB0cmFjazogXCIgKyBub2RlTmFtZSArXHJcblx0XHRcdFx0XHQnLicgKyBwcm9wZXJ0eU5hbWUgKyBcIiBidXQgaXQgd2Fzbid0IGZvdW5kLlwiLCB0YXJnZXRPYmplY3QgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBkZXRlcm1pbmUgdmVyc2lvbmluZyBzY2hlbWVcclxuXHRcdHZhciB2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk5vbmU7XHJcblxyXG5cdFx0aWYgKCB0YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCApIHsgLy8gbWF0ZXJpYWxcclxuXHJcblx0XHRcdHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTmVlZHNVcGRhdGU7XHJcblx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQgKSB7IC8vIG5vZGUgdHJhbnNmb3JtXHJcblxyXG5cdFx0XHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XHJcblx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBkZXRlcm1pbmUgaG93IHRoZSBwcm9wZXJ0eSBnZXRzIGJvdW5kXHJcblx0XHR2YXIgYmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkRpcmVjdDtcclxuXHJcblx0XHRpZiAoIHByb3BlcnR5SW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0Ly8gYWNjZXNzIGEgc3ViIGVsZW1lbnQgb2YgdGhlIHByb3BlcnR5IGFycmF5IChvbmx5IHByaW1pdGl2ZXMgYXJlIHN1cHBvcnRlZCByaWdodCBub3cpXHJcblxyXG5cdFx0XHRpZiAoIHByb3BlcnR5TmFtZSA9PT0gXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIiApIHtcclxuXHRcdFx0XHQvLyBwb3RlbnRpYWwgb3B0aW1pemF0aW9uLCBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXIsIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cclxuXHJcblx0XHRcdFx0Ly8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxyXG5cdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhc3VzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeScsIHRoaXMgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2FzdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cycsIHRoaXMgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGUuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdC5nZW9tZXRyeS5tb3JwaFRhcmdldHNbaV0ubmFtZSA9PT0gcHJvcGVydHlJbmRleCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHByb3BlcnR5SW5kZXggPSBpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5BcnJheUVsZW1lbnQ7XHJcblxyXG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XHJcblx0XHRcdHRoaXMucHJvcGVydHlJbmRleCA9IHByb3BlcnR5SW5kZXg7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbm9kZVByb3BlcnR5LmZyb21BcnJheSAhPT0gdW5kZWZpbmVkICYmIG5vZGVQcm9wZXJ0eS50b0FycmF5ICE9PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdC8vIG11c3QgdXNlIGNvcHkgZm9yIE9iamVjdDNELkV1bGVyL1F1YXRlcm5pb25cclxuXHJcblx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5IYXNGcm9tVG9BcnJheTtcclxuXHJcblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBub2RlUHJvcGVydHkubGVuZ3RoICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuRW50aXJlQXJyYXk7XHJcblxyXG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZWxlY3QgZ2V0dGVyIC8gc2V0dGVyXHJcblx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5HZXR0ZXJCeUJpbmRpbmdUeXBlWyBiaW5kaW5nVHlwZSBdO1xyXG5cdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuU2V0dGVyQnlCaW5kaW5nVHlwZUFuZFZlcnNpb25pbmdbIGJpbmRpbmdUeXBlIF1bIHZlcnNpb25pbmcgXTtcclxuXHJcblx0fSxcclxuXHJcblx0dW5iaW5kOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR0aGlzLm5vZGUgPSBudWxsO1xyXG5cclxuXHRcdC8vIGJhY2sgdG8gdGhlIHByb3RvdHlwZSB2ZXJzaW9uIG9mIGdldFZhbHVlIC8gc2V0VmFsdWVcclxuXHRcdC8vIG5vdGU6IGF2b2lkaW5nIHRvIG11dGF0ZSB0aGUgc2hhcGUgb2YgJ3RoaXMnIHZpYSAnZGVsZXRlJ1xyXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYm91bmQ7XHJcblx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5ib3VuZDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5hc3NpZ24oIFRIUkVFLlByb3BlcnR5QmluZGluZy5wcm90b3R5cGUsIHsgLy8gcHJvdG90eXBlLCBjb250aW51ZWRcclxuXHJcblx0Ly8gdGhlc2UgYXJlIHVzZWQgdG8gXCJiaW5kXCIgYSBub25leGlzdGVudCBwcm9wZXJ0eVxyXG5cdF9nZXRWYWx1ZV91bmF2YWlsYWJsZTogZnVuY3Rpb24oKSB7fSxcclxuXHRfc2V0VmFsdWVfdW5hdmFpbGFibGU6IGZ1bmN0aW9uKCkge30sXHJcblxyXG5cdC8vIGluaXRpYWwgc3RhdGUgb2YgdGhlc2UgbWV0aG9kcyB0aGF0IGNhbGxzICdiaW5kJ1xyXG5cdF9nZXRWYWx1ZV91bmJvdW5kOiBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLmdldFZhbHVlLFxyXG5cdF9zZXRWYWx1ZV91bmJvdW5kOiBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLnNldFZhbHVlLFxyXG5cclxuXHRCaW5kaW5nVHlwZToge1xyXG5cdFx0RGlyZWN0OiAwLFxyXG5cdFx0RW50aXJlQXJyYXk6IDEsXHJcblx0XHRBcnJheUVsZW1lbnQ6IDIsXHJcblx0XHRIYXNGcm9tVG9BcnJheTogM1xyXG5cdH0sXHJcblxyXG5cdFZlcnNpb25pbmc6IHtcclxuXHRcdE5vbmU6IDAsXHJcblx0XHROZWVkc1VwZGF0ZTogMSxcclxuXHRcdE1hdHJpeFdvcmxkTmVlZHNVcGRhdGU6IDJcclxuXHR9LFxyXG5cclxuXHRHZXR0ZXJCeUJpbmRpbmdUeXBlOiBbXHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWVfZGlyZWN0KCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF07XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRmdW5jdGlvbiBnZXRWYWx1ZV9hcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgc291cmNlID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc291cmNlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKysgXSA9IHNvdXJjZVsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWVfYXJyYXlFbGVtZW50KCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWVfdG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkudG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdF0sXHJcblxyXG5cdFNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nOiBbXHJcblxyXG5cdFx0W1xyXG5cdFx0XHQvLyBEaXJlY3RcclxuXHJcblx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2RpcmVjdCggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubm9kZVsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcclxuXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xyXG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdF0sIFtcclxuXHJcblx0XHRcdC8vIEVudGlyZUFycmF5XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdF0sIFtcclxuXHJcblx0XHRcdC8vIEFycmF5RWxlbWVudFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlFbGVtZW50KCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XSwgW1xyXG5cclxuXHRcdFx0Ly8gSGFzVG9Gcm9tQXJyYXlcclxuXHJcblx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2Zyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcclxuXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xyXG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdF1cclxuXHJcblx0XVxyXG5cclxufSApO1xyXG5cclxuVEhSRUUuUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZSA9XHJcblx0XHRmdW5jdGlvbiggdGFyZ2V0R3JvdXAsIHBhdGgsIG9wdGlvbmFsUGFyc2VkUGF0aCApIHtcclxuXHJcblx0dmFyIHBhcnNlZFBhdGggPSBvcHRpb25hbFBhcnNlZFBhdGggfHxcclxuXHRcdFx0VEhSRUUuUHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lKCBwYXRoICk7XHJcblxyXG5cdHRoaXMuX3RhcmdldEdyb3VwID0gdGFyZ2V0R3JvdXA7XHJcblx0dGhpcy5fYmluZGluZ3MgPSB0YXJnZXRHcm91cC5zdWJzY3JpYmVfKCBwYXRoLCBwYXJzZWRQYXRoICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlLFxyXG5cclxuXHRnZXRWYWx1ZTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5iaW5kKCk7IC8vIGJpbmQgYWxsIGJpbmRpbmdcclxuXHJcblx0XHR2YXIgZmlyc3RWYWxpZEluZGV4ID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxyXG5cdFx0XHRiaW5kaW5nID0gdGhpcy5fYmluZGluZ3NbIGZpcnN0VmFsaWRJbmRleCBdO1xyXG5cclxuXHRcdC8vIGFuZCBvbmx5IGNhbGwgLmdldFZhbHVlIG9uIHRoZSBmaXJzdFxyXG5cdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSBiaW5kaW5nLmdldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFZhbHVlOiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0XHRuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0YmluZGluZ3NbIGkgXS5zZXRWYWx1ZSggYXJyYXksIG9mZnNldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0YmluZDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXHJcblx0XHRcdFx0biA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdGJpbmRpbmdzWyBpIF0uYmluZCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dW5iaW5kOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0XHRuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0YmluZGluZ3NbIGkgXS51bmJpbmQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Qcm9wZXJ0eUJpbmRpbmcuY3JlYXRlID0gZnVuY3Rpb24oIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKSB7XHJcblxyXG5cdGlmICggISAoIHJvb3QgaW5zdGFuY2VvZiBUSFJFRS5BbmltYXRpb25PYmplY3RHcm91cCApICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuUHJvcGVydHlCaW5kaW5nKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Qcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUgPSBmdW5jdGlvbiggdHJhY2tOYW1lICkge1xyXG5cclxuXHQvLyBtYXRjaGVzIHN0cmluZ3MgaW4gdGhlIGZvcm0gb2Y6XHJcblx0Ly8gICAgbm9kZU5hbWUucHJvcGVydHlcclxuXHQvLyAgICBub2RlTmFtZS5wcm9wZXJ0eVthY2Nlc3Nvcl1cclxuXHQvLyAgICBub2RlTmFtZS5tYXRlcmlhbC5wcm9wZXJ0eVthY2Nlc3Nvcl1cclxuXHQvLyAgICB1dWlkLnByb3BlcnR5W2FjY2Vzc29yXVxyXG5cdC8vICAgIHV1aWQub2JqZWN0TmFtZVtvYmplY3RJbmRleF0ucHJvcGVydHlOYW1lW3Byb3BlcnR5SW5kZXhdXHJcblx0Ly8gICAgcGFyZW50TmFtZS9ub2RlTmFtZS5wcm9wZXJ0eVxyXG5cdC8vICAgIHBhcmVudE5hbWUvcGFyZW50TmFtZS9ub2RlTmFtZS5wcm9wZXJ0eVtpbmRleF1cclxuXHQvL1x0ICAuYm9uZVtBcm1hdHVyZS5ERUZfY29nXS5wb3NpdGlvblxyXG5cdC8vIGNyZWF0ZWQgYW5kIHRlc3RlZCB2aWEgaHR0cHM6Ly9yZWdleDEwMS5jb20vI2phdmFzY3JpcHRcclxuXHJcblx0dmFyIHJlID0gL14oKFtcXHddK1xcLykqKShbXFx3LVxcZF0rKT8oXFwuKFtcXHddKykoXFxbKFtcXHdcXGRcXFtcXF1cXF8uIF0rKVxcXSk/KT8oXFwuKFtcXHcuXSspKFxcWyhbXFx3XFxkXFxbXFxdXFxfLiBdKylcXF0pPykkLztcclxuXHR2YXIgbWF0Y2hlcyA9IHJlLmV4ZWModHJhY2tOYW1lKTtcclxuXHJcblx0aWYoICEgbWF0Y2hlcyApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvciggXCJjYW5ub3QgcGFyc2UgdHJhY2tOYW1lIGF0IGFsbDogXCIgKyB0cmFja05hbWUgKTtcclxuXHR9XHJcblxyXG4gICAgaWYgKG1hdGNoZXMuaW5kZXggPT09IHJlLmxhc3RJbmRleCkge1xyXG4gICAgICAgIHJlLmxhc3RJbmRleCsrO1xyXG4gICAgfVxyXG5cclxuXHR2YXIgcmVzdWx0cyA9IHtcclxuXHRcdC8vIGRpcmVjdG9yeU5hbWU6IG1hdGNoZXNbMV0sIC8vICh0c2NodykgY3VycmVudGx5IHVudXNlZFxyXG5cdFx0bm9kZU5hbWU6IG1hdGNoZXNbM10sIFx0Ly8gYWxsb3dlZCB0byBiZSBudWxsLCBzcGVjaWZpZWQgcm9vdCBub2RlLlxyXG5cdFx0b2JqZWN0TmFtZTogbWF0Y2hlc1s1XSxcclxuXHRcdG9iamVjdEluZGV4OiBtYXRjaGVzWzddLFxyXG5cdFx0cHJvcGVydHlOYW1lOiBtYXRjaGVzWzldLFxyXG5cdFx0cHJvcGVydHlJbmRleDogbWF0Y2hlc1sxMV1cdC8vIGFsbG93ZWQgdG8gYmUgbnVsbCwgc3BlY2lmaWVzIHRoYXQgdGhlIHdob2xlIHByb3BlcnR5IGlzIHNldC5cclxuXHR9O1xyXG5cclxuXHRpZiggcmVzdWx0cy5wcm9wZXJ0eU5hbWUgPT09IG51bGwgfHwgcmVzdWx0cy5wcm9wZXJ0eU5hbWUubGVuZ3RoID09PSAwICkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcImNhbiBub3QgcGFyc2UgcHJvcGVydHlOYW1lIGZyb20gdHJhY2tOYW1lOiBcIiArIHRyYWNrTmFtZSApO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlc3VsdHM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlID0gZnVuY3Rpb24oIHJvb3QsIG5vZGVOYW1lICkge1xyXG5cclxuXHRpZiggISBub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gXCJcIiB8fCBub2RlTmFtZSA9PT0gXCJyb290XCIgfHwgbm9kZU5hbWUgPT09IFwiLlwiIHx8IG5vZGVOYW1lID09PSAtMSB8fCBub2RlTmFtZSA9PT0gcm9vdC5uYW1lIHx8IG5vZGVOYW1lID09PSByb290LnV1aWQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHJvb3Q7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gc2VhcmNoIGludG8gc2tlbGV0b24gYm9uZXMuXHJcblx0aWYoIHJvb3Quc2tlbGV0b24gKSB7XHJcblxyXG5cdFx0dmFyIHNlYXJjaFNrZWxldG9uID0gZnVuY3Rpb24oIHNrZWxldG9uICkge1xyXG5cclxuXHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBza2VsZXRvbi5ib25lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbaV07XHJcblxyXG5cdFx0XHRcdGlmKCBib25lLm5hbWUgPT09IG5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBib25lO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGJvbmUgPSBzZWFyY2hTa2VsZXRvbiggcm9vdC5za2VsZXRvbiApO1xyXG5cclxuXHRcdGlmKCBib25lICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGJvbmU7XHJcblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gc2VhcmNoIGludG8gbm9kZSBzdWJ0cmVlLlxyXG5cdGlmKCByb290LmNoaWxkcmVuICkge1xyXG5cclxuXHRcdHZhciBzZWFyY2hOb2RlU3VidHJlZSA9IGZ1bmN0aW9uKCBjaGlsZHJlbiApIHtcclxuXHJcblx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XHJcblxyXG5cdFx0XHRcdGlmKCBjaGlsZE5vZGUubmFtZSA9PT0gbm9kZU5hbWUgfHwgY2hpbGROb2RlLnV1aWQgPT09IG5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBjaGlsZE5vZGU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHNlYXJjaE5vZGVTdWJ0cmVlKCBjaGlsZE5vZGUuY2hpbGRyZW4gKTtcclxuXHJcblx0XHRcdFx0aWYoIHJlc3VsdCApIHJldHVybiByZXN1bHQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBzdWJUcmVlTm9kZSA9IHNlYXJjaE5vZGVTdWJ0cmVlKCByb290LmNoaWxkcmVuICk7XHJcblxyXG5cdFx0aWYoIHN1YlRyZWVOb2RlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHN1YlRyZWVOb2RlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbnVsbDtcclxuXHJcbn1cclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi9Qcm9wZXJ0eU1peGVyLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQnVmZmVyZWQgc2NlbmUgZ3JhcGggcHJvcGVydHkgdGhhdCBhbGxvd3Mgd2VpZ2h0ZWQgYWNjdW11bGF0aW9uLlxyXG4gKlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICogQGF1dGhvciB0c2Nod1xyXG4gKi9cclxuXHJcblRIUkVFLlByb3BlcnR5TWl4ZXIgPSBmdW5jdGlvbiAoIGJpbmRpbmcsIHR5cGVOYW1lLCB2YWx1ZVNpemUgKSB7XHJcblxyXG5cdHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XHJcblx0dGhpcy52YWx1ZVNpemUgPSB2YWx1ZVNpemU7XHJcblxyXG5cdHZhciBidWZmZXJUeXBlID0gRmxvYXQ2NEFycmF5LFxyXG5cdFx0bWl4RnVuY3Rpb247XHJcblxyXG5cdHN3aXRjaCAoIHR5cGVOYW1lICkge1xyXG5cclxuXHRcdGNhc2UgJ3F1YXRlcm5pb24nOlx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fc2xlcnA7XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ3N0cmluZyc6XHJcblx0XHRjYXNlICdib29sJzpcclxuXHJcblx0XHRcdGJ1ZmZlclR5cGUgPSBBcnJheSxcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9zZWxlY3Q7XHRcdGJyZWFrO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHRcdFx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fbGVycDtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmJ1ZmZlciA9IG5ldyBidWZmZXJUeXBlKCB2YWx1ZVNpemUgKiA0ICk7XHJcblx0Ly8gbGF5b3V0OiBbIGluY29taW5nIHwgYWNjdTAgfCBhY2N1MSB8IG9yaWcgXVxyXG5cdC8vXHJcblx0Ly8gaW50ZXJwb2xhdG9ycyBjYW4gdXNlIC5idWZmZXIgYXMgdGhlaXIgLnJlc3VsdFxyXG5cdC8vIHRoZSBkYXRhIHRoZW4gZ29lcyB0byAnaW5jb21pbmcnXHJcblx0Ly9cclxuXHQvLyAnYWNjdTAnIGFuZCAnYWNjdTEnIGFyZSB1c2VkIGZyYW1lLWludGVybGVhdmVkIGZvclxyXG5cdC8vIHRoZSBjdW11bGF0aXZlIHJlc3VsdCBhbmQgYXJlIGNvbXBhcmVkIHRvIGRldGVjdFxyXG5cdC8vIGNoYW5nZXNcclxuXHQvL1xyXG5cdC8vICdvcmlnJyBzdG9yZXMgdGhlIG9yaWdpbmFsIHN0YXRlIG9mIHRoZSBwcm9wZXJ0eVxyXG5cclxuXHR0aGlzLl9taXhCdWZmZXJSZWdpb24gPSBtaXhGdW5jdGlvbjtcclxuXHJcblx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcclxuXHJcblx0dGhpcy51c2VDb3VudCA9IDA7XHJcblx0dGhpcy5yZWZlcmVuY2VDb3VudCA9IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUHJvcGVydHlNaXhlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Qcm9wZXJ0eU1peGVyLFxyXG5cclxuXHQvLyBhY2N1bXVsYXRlIGRhdGEgaW4gdGhlICdpbmNvbWluZycgcmVnaW9uIGludG8gJ2FjY3U8aT4nXHJcblx0YWNjdW11bGF0ZTogZnVuY3Rpb24oIGFjY3VJbmRleCwgd2VpZ2h0ICkge1xyXG5cclxuXHRcdC8vIG5vdGU6IGhhcHBpbHkgYWNjdW11bGF0aW5nIG5vdGhpbmcgd2hlbiB3ZWlnaHQgPSAwLCB0aGUgY2FsbGVyIGtub3dzXHJcblx0XHQvLyB0aGUgd2VpZ2h0IGFuZCBzaG91bGRuJ3QgaGF2ZSBtYWRlIHRoZSBjYWxsIGluIHRoZSBmaXJzdCBwbGFjZVxyXG5cclxuXHRcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcclxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXHJcblx0XHRcdG9mZnNldCA9IGFjY3VJbmRleCAqIHN0cmlkZSArIHN0cmlkZSxcclxuXHJcblx0XHRcdGN1cnJlbnRXZWlnaHQgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHQ7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50V2VpZ2h0ID09PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gYWNjdU4gOj0gaW5jb21pbmcgKiB3ZWlnaHRcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRidWZmZXJbIG9mZnNldCArIGkgXSA9IGJ1ZmZlclsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3VycmVudFdlaWdodCA9IHdlaWdodDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gYWNjdU4gOj0gYWNjdU4gKyBpbmNvbWluZyAqIHdlaWdodFxyXG5cclxuXHRcdFx0Y3VycmVudFdlaWdodCArPSB3ZWlnaHQ7XHJcblx0XHRcdHZhciBtaXggPSB3ZWlnaHQgLyBjdXJyZW50V2VpZ2h0O1xyXG5cdFx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb24oIGJ1ZmZlciwgb2Zmc2V0LCAwLCBtaXgsIHN0cmlkZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSBjdXJyZW50V2VpZ2h0O1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBhcHBseSB0aGUgc3RhdGUgb2YgJ2FjY3U8aT4nIHRvIHRoZSBiaW5kaW5nIHdoZW4gYWNjdXMgZGlmZmVyXHJcblx0YXBwbHk6IGZ1bmN0aW9uKCBhY2N1SW5kZXggKSB7XHJcblxyXG5cdFx0dmFyIHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxyXG5cdFx0XHRidWZmZXIgPSB0aGlzLmJ1ZmZlcixcclxuXHRcdFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlLFxyXG5cclxuXHRcdFx0d2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0LFxyXG5cclxuXHRcdFx0YmluZGluZyA9IHRoaXMuYmluZGluZztcclxuXHJcblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xyXG5cclxuXHRcdGlmICggd2VpZ2h0IDwgMSApIHtcclxuXHJcblx0XHRcdC8vIGFjY3VOIDo9IGFjY3VOICsgb3JpZ2luYWwgKiAoIDEgLSBjdW11bGF0aXZlV2VpZ2h0IClcclxuXHJcblx0XHRcdHZhciBvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gc3RyaWRlICogMztcclxuXHJcblx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbihcclxuXHRcdFx0XHRcdGJ1ZmZlciwgb2Zmc2V0LCBvcmlnaW5hbFZhbHVlT2Zmc2V0LCAxIC0gd2VpZ2h0LCBzdHJpZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSBzdHJpZGUsIGUgPSBzdHJpZGUgKyBzdHJpZGU7IGkgIT09IGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGJ1ZmZlclsgaSBdICE9PSBidWZmZXJbIGkgKyBzdHJpZGUgXSApIHtcclxuXHJcblx0XHRcdFx0Ly8gdmFsdWUgaGFzIGNoYW5nZWQgLT4gdXBkYXRlIHNjZW5lIGdyYXBoXHJcblxyXG5cdFx0XHRcdGJpbmRpbmcuc2V0VmFsdWUoIGJ1ZmZlciwgb2Zmc2V0ICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHQvLyByZW1lbWJlciB0aGUgc3RhdGUgb2YgdGhlIGJvdW5kIHByb3BlcnR5IGFuZCBjb3B5IGl0IHRvIGJvdGggYWNjdXNcclxuXHRzYXZlT3JpZ2luYWxTdGF0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XHJcblxyXG5cdFx0dmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcclxuXHJcblx0XHRcdG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiAzO1xyXG5cclxuXHRcdGJpbmRpbmcuZ2V0VmFsdWUoIGJ1ZmZlciwgb3JpZ2luYWxWYWx1ZU9mZnNldCApO1xyXG5cclxuXHRcdC8vIGFjY3VbMC4uMV0gOj0gb3JpZyAtLSBpbml0aWFsbHkgZGV0ZWN0IGNoYW5nZXMgYWdhaW5zdCB0aGUgb3JpZ2luYWxcclxuXHRcdGZvciAoIHZhciBpID0gc3RyaWRlLCBlID0gb3JpZ2luYWxWYWx1ZU9mZnNldDsgaSAhPT0gZTsgKysgaSApIHtcclxuXHJcblx0XHRcdGJ1ZmZlclsgaSBdID0gYnVmZmVyWyBvcmlnaW5hbFZhbHVlT2Zmc2V0ICsgKCBpICUgc3RyaWRlICkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gYXBwbHkgdGhlIHN0YXRlIHByZXZpb3VzbHkgdGFrZW4gdmlhICdzYXZlT3JpZ2luYWxTdGF0ZScgdG8gdGhlIGJpbmRpbmdcclxuXHRyZXN0b3JlT3JpZ2luYWxTdGF0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIG9yaWdpbmFsVmFsdWVPZmZzZXQgPSB0aGlzLnZhbHVlU2l6ZSAqIDM7XHJcblx0XHR0aGlzLmJpbmRpbmcuc2V0VmFsdWUoIHRoaXMuYnVmZmVyLCBvcmlnaW5hbFZhbHVlT2Zmc2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBtaXggZnVuY3Rpb25zXHJcblxyXG5cdF9zZWxlY3Q6IGZ1bmN0aW9uKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XHJcblxyXG5cdFx0aWYgKCB0ID49IDAuNSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRidWZmZXJbIGRzdE9mZnNldCArIGkgXSA9IGJ1ZmZlclsgc3JjT2Zmc2V0ICsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0X3NsZXJwOiBmdW5jdGlvbiggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlICkge1xyXG5cclxuXHRcdFRIUkVFLlF1YXRlcm5pb24uc2xlcnBGbGF0KCBidWZmZXIsIGRzdE9mZnNldCxcclxuXHRcdFx0XHRidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBzcmNPZmZzZXQsIHQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0X2xlcnA6IGZ1bmN0aW9uKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XHJcblxyXG5cdFx0dmFyIHMgPSAxIC0gdDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcclxuXHJcblx0XHRcdHZhciBqID0gZHN0T2Zmc2V0ICsgaTtcclxuXHJcblx0XHRcdGJ1ZmZlclsgaiBdID0gYnVmZmVyWyBqIF0gKiBzICsgYnVmZmVyWyBzcmNPZmZzZXQgKyBpIF0gKiB0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvQm9vbGVhbktleWZyYW1lVHJhY2suanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIFRyYWNrIG9mIEJvb2xlYW4ga2V5ZnJhbWUgdmFsdWVzLlxyXG4gKlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICogQGF1dGhvciB0c2Nod1xyXG4gKi9cclxuXHJcblRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrID0gZnVuY3Rpb24gKCBuYW1lLCB0aW1lcywgdmFsdWVzICkge1xyXG5cclxuXHRUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxyXG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2ssXHJcblxyXG5cdFZhbHVlVHlwZU5hbWU6ICdib29sJyxcclxuXHRWYWx1ZUJ1ZmZlclR5cGU6IEFycmF5LFxyXG5cclxuXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogVEhSRUUuSW50ZXBvbGF0ZURpc2NyZXRlLFxyXG5cclxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6IHVuZGVmaW5lZCxcclxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHVuZGVmaW5lZFxyXG5cclxuXHQvLyBOb3RlOiBBY3R1YWxseSB0aGlzIHRyYWNrIGNvdWxkIGhhdmUgYSBvcHRpbWl6ZWQgLyBjb21wcmVzc2VkXHJcblx0Ly8gcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgdmFsdWUgYW5kIGEgY3VzdG9tIGludGVycG9sYW50IHRoYXRcclxuXHQvLyBjb21wdXRlcyBcImZpcnN0VmFsdWUgXiBpc09kZCggaW5kZXggKVwiLlxyXG5cclxufSApO1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL3RyYWNrcy9OdW1iZXJLZXlmcmFtZVRyYWNrLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSBUcmFjayBvZiBudW1lcmljIGtleWZyYW1lIHZhbHVlcy5cclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqIEBhdXRob3IgdHNjaHdcclxuICovXHJcblxyXG5USFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrID0gZnVuY3Rpb24gKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xyXG5cclxuXHRUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9XHJcblx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBUSFJFRS5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrLFxyXG5cclxuXHRWYWx1ZVR5cGVOYW1lOiAnbnVtYmVyJyxcclxuXHJcblx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxyXG5cclxuXHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcclxuXHJcbn0gKTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvUXVhdGVybmlvbktleWZyYW1lVHJhY2suanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIFRyYWNrIG9mIHF1YXRlcm5pb24ga2V5ZnJhbWUgdmFsdWVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICogQGF1dGhvciB0c2Nod1xyXG4gKi9cclxuXHJcblRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrID0gZnVuY3Rpb24gKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xyXG5cclxuXHRUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxyXG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2ssXHJcblxyXG5cdFZhbHVlVHlwZU5hbWU6ICdxdWF0ZXJuaW9uJyxcclxuXHJcblx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxyXG5cclxuXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogVEhSRUUuSW50ZXJwb2xhdGVMaW5lYXIsXHJcblxyXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogZnVuY3Rpb24oIHJlc3VsdCApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudChcclxuXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdW5kZWZpbmVkIC8vIG5vdCB5ZXQgaW1wbGVtZW50ZWRcclxuXHJcbn0gKTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvU3RyaW5nS2V5ZnJhbWVUcmFjay5qc1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEEgVHJhY2sgdGhhdCBpbnRlcnBvbGF0ZXMgU3RyaW5nc1xyXG4gKlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICogQGF1dGhvciB0c2Nod1xyXG4gKi9cclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFRIUkVFLktleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlID1cclxuXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2ssXHJcblxyXG5cdFZhbHVlVHlwZU5hbWU6ICdzdHJpbmcnLFxyXG5cdFZhbHVlQnVmZmVyVHlwZTogQXJyYXksXHJcblxyXG5cdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBUSFJFRS5JbnRlcG9sYXRlRGlzY3JldGUsXHJcblxyXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdW5kZWZpbmVkLFxyXG5cclxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHVuZGVmaW5lZFxyXG5cclxufSApO1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL3RyYWNrcy9WZWN0b3JLZXlmcmFtZVRyYWNrLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSBUcmFjayBvZiB2ZWN0b3JlZCBrZXlmcmFtZSB2YWx1ZXMuXHJcbiAqXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKiBAYXV0aG9yIHRzY2h3XHJcbiAqL1xyXG5cclxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcclxuXHJcblx0VEhSRUUuS2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxyXG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjayxcclxuXHJcblx0VmFsdWVUeXBlTmFtZTogJ3ZlY3RvcidcclxuXHJcblx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxyXG5cclxuXHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcclxuXHJcbn0gKTtcclxuXHJcbi8vIEZpbGU6c3JjL2F1ZGlvL0F1ZGlvLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BdWRpbyA9IGZ1bmN0aW9uICggbGlzdGVuZXIgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0F1ZGlvJztcclxuXHJcblx0dGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcclxuXHR0aGlzLnNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuXHR0aGlzLnNvdXJjZS5vbmVuZGVkID0gdGhpcy5vbkVuZGVkLmJpbmQoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuXHR0aGlzLmdhaW4uY29ubmVjdCggbGlzdGVuZXIuZ2V0SW5wdXQoKSApO1xyXG5cclxuXHR0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuc3RhcnRUaW1lID0gMDtcclxuXHR0aGlzLnBsYXliYWNrUmF0ZSA9IDE7XHJcblx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IHRydWU7XHJcblx0dGhpcy5zb3VyY2VUeXBlID0gJ2VtcHR5JztcclxuXHJcblx0dGhpcy5maWx0ZXIgPSBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BdWRpbztcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRPdXRwdXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLmdhaW47XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoIGZpbGUgKSB7XHJcblxyXG5cdHZhciBidWZmZXIgPSBuZXcgVEhSRUUuQXVkaW9CdWZmZXIoIHRoaXMuY29udGV4dCApO1xyXG5cdGJ1ZmZlci5sb2FkKCBmaWxlICk7XHJcblxyXG5cdHRoaXMuc2V0QnVmZmVyKCBidWZmZXIgKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldE5vZGVTb3VyY2UgPSBmdW5jdGlvbiAoIGF1ZGlvTm9kZSApIHtcclxuXHJcblx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSBmYWxzZTtcclxuXHR0aGlzLnNvdXJjZVR5cGUgPSAnYXVkaW9Ob2RlJztcclxuXHR0aGlzLnNvdXJjZSA9IGF1ZGlvTm9kZTtcclxuXHR0aGlzLmNvbm5lY3QoKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldEJ1ZmZlciA9IGZ1bmN0aW9uICggYXVkaW9CdWZmZXIgKSB7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdGF1ZGlvQnVmZmVyLm9uUmVhZHkoIGZ1bmN0aW9uKCBidWZmZXIgKSB7XHJcblxyXG5cdFx0c2NvcGUuc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuXHRcdHNjb3BlLnNvdXJjZVR5cGUgPSAnYnVmZmVyJztcclxuXHRcdGlmICggc2NvcGUuYXV0b3BsYXkgKSBzY29wZS5wbGF5KCk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IEF1ZGlvIGlzIGFscmVhZHkgcGxheWluZy4nICk7XHJcblx0XHRyZXR1cm47XHJcblxyXG5cdH1cclxuXHJcblx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xyXG5cdFx0cmV0dXJuO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcblxyXG5cdHNvdXJjZS5idWZmZXIgPSB0aGlzLnNvdXJjZS5idWZmZXI7XHJcblx0c291cmNlLmxvb3AgPSB0aGlzLnNvdXJjZS5sb29wO1xyXG5cdHNvdXJjZS5vbmVuZGVkID0gdGhpcy5zb3VyY2Uub25lbmRlZDtcclxuXHRzb3VyY2Uuc3RhcnQoIDAsIHRoaXMuc3RhcnRUaW1lICk7XHJcblx0c291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xyXG5cclxuXHR0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcblxyXG5cdHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cclxuXHR0aGlzLmNvbm5lY3QoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcclxuXHRcdHJldHVybjtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnNvdXJjZS5zdG9wKCk7XHJcblx0dGhpcy5zdGFydFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcclxuXHRcdHJldHVybjtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnNvdXJjZS5zdG9wKCk7XHJcblx0dGhpcy5zdGFydFRpbWUgPSAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xyXG5cclxuXHRcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZmlsdGVyICk7XHJcblx0XHR0aGlzLmZpbHRlci5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dGhpcy5zb3VyY2UuY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGlmICggdGhpcy5maWx0ZXIgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0dGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcclxuXHRcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0RmlsdGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5maWx0ZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldEZpbHRlciA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHZhbHVlID0gbnVsbDtcclxuXHJcblx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHR0aGlzLmRpc2Nvbm5lY3QoKTtcclxuXHRcdHRoaXMuZmlsdGVyID0gdmFsdWU7XHJcblx0XHR0aGlzLmNvbm5lY3QoKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLmZpbHRlciA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcclxuXHRcdHJldHVybjtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnBsYXliYWNrUmF0ZSA9IHZhbHVlO1xyXG5cclxuXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xyXG5cclxuXHRcdHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMucGxheWJhY2tSYXRlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5vbkVuZGVkID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XHJcblx0XHRyZXR1cm47XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5zb3VyY2UubG9vcCA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRMb29wID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXMuc291cmNlLmxvb3A7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHR0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9hdWRpby9BdWRpb0FuYWx5c2VyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BdWRpb0FuYWx5c2VyID0gZnVuY3Rpb24gKCBhdWRpbywgZmZ0U2l6ZSApIHtcclxuXHJcblx0dGhpcy5hbmFseXNlciA9IGF1ZGlvLmNvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcclxuXHR0aGlzLmFuYWx5c2VyLmZmdFNpemUgPSBmZnRTaXplICE9PSB1bmRlZmluZWQgPyBmZnRTaXplIDogMjA0ODtcclxuXHJcblx0dGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoIHRoaXMuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQgKTtcclxuXHJcblx0YXVkaW8uZ2V0T3V0cHV0KCkuY29ubmVjdCggdGhpcy5hbmFseXNlciApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvQW5hbHlzZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQXVkaW9BbmFseXNlcixcclxuXHJcblx0Z2V0RGF0YTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoIHRoaXMuZGF0YSApO1xyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2F1ZGlvL0F1ZGlvQnVmZmVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BdWRpb0J1ZmZlciA9IGZ1bmN0aW9uICggY29udGV4dCApIHtcclxuXHJcblx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuXHR0aGlzLnJlYWR5ID0gZmFsc2U7XHJcblx0dGhpcy5yZWFkeUNhbGxiYWNrcyA9IFtdO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvQnVmZmVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCBmaWxlICkge1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cdHJlcXVlc3Qub3BlbiggJ0dFVCcsIGZpbGUsIHRydWUgKTtcclxuXHRyZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcblx0cmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoIGUgKSB7XHJcblxyXG5cdFx0c2NvcGUuY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoIHRoaXMucmVzcG9uc2UsIGZ1bmN0aW9uICggYnVmZmVyICkge1xyXG5cclxuXHRcdFx0c2NvcGUuYnVmZmVyID0gYnVmZmVyO1xyXG5cdFx0XHRzY29wZS5yZWFkeSA9IHRydWU7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzY29wZS5yZWFkeUNhbGxiYWNrcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLnJlYWR5Q2FsbGJhY2tzWyBpIF0oIHNjb3BlLmJ1ZmZlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2NvcGUucmVhZHlDYWxsYmFja3MgPSBbXTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH07XHJcblx0cmVxdWVzdC5zZW5kKCk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvQnVmZmVyLnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0aWYgKCB0aGlzLnJlYWR5ICkge1xyXG5cclxuXHRcdGNhbGxiYWNrKCB0aGlzLmJ1ZmZlciApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMucmVhZHlDYWxsYmFja3MucHVzaCggY2FsbGJhY2sgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2F1ZGlvL1Bvc2l0aW9uYWxBdWRpby5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvID0gZnVuY3Rpb24gKCBsaXN0ZW5lciApIHtcclxuXHJcblx0VEhSRUUuQXVkaW8uY2FsbCggdGhpcywgbGlzdGVuZXIgKTtcclxuXHJcblx0dGhpcy5wYW5uZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XHJcblx0dGhpcy5wYW5uZXIuY29ubmVjdCggdGhpcy5nYWluICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkF1ZGlvLnByb3RvdHlwZSApO1xyXG5USFJFRS5Qb3NpdGlvbmFsQXVkaW8ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9zaXRpb25hbEF1ZGlvO1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZS5nZXRPdXRwdXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLnBhbm5lcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb3NpdGlvbmFsQXVkaW8ucHJvdG90eXBlLnNldFJlZkRpc3RhbmNlID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0dGhpcy5wYW5uZXIucmVmRGlzdGFuY2UgPSB2YWx1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb3NpdGlvbmFsQXVkaW8ucHJvdG90eXBlLmdldFJlZkRpc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZS5zZXRSb2xsb2ZmRmFjdG9yID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0dGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvciA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUuZ2V0Um9sbG9mZkZhY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3I7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZS5zZXREaXN0YW5jZU1vZGVsID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0dGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbCA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUuZ2V0RGlzdGFuY2VNb2RlbCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMucGFubmVyLmRpc3RhbmNlTW9kZWw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZS5zZXRNYXhEaXN0YW5jZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdHRoaXMucGFubmVyLm1heERpc3RhbmNlID0gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZS5nZXRNYXhEaXN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcclxuXHJcblx0XHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcclxuXHJcblx0XHRwb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR0aGlzLnBhbm5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xyXG5cclxuXHR9O1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9hdWRpby9BdWRpb0xpc3RlbmVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BdWRpb0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdBdWRpb0xpc3RlbmVyJztcclxuXHJcblx0dGhpcy5jb250ZXh0ID0gbmV3ICggd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0ICkoKTtcclxuXHJcblx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuXHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XHJcblxyXG5cdHRoaXMuZmlsdGVyID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkF1ZGlvTGlzdGVuZXI7XHJcblxyXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5nZXRJbnB1dCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMuZ2FpbjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5yZW1vdmVGaWx0ZXIgPSBmdW5jdGlvbiAoICkge1xyXG5cclxuXHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xyXG5cclxuXHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xyXG5cdFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XHJcblx0XHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XHJcblx0XHR0aGlzLmZpbHRlciA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5zZXRGaWx0ZXIgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xyXG5cclxuXHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xyXG5cdFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuZmlsdGVyID0gdmFsdWU7XHJcblx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuZmlsdGVyICk7XHJcblx0dGhpcy5maWx0ZXIuY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUuZ2V0RmlsdGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5maWx0ZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUuc2V0TWFzdGVyVm9sdW1lID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0dGhpcy5nYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5nZXRNYXN0ZXJWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblx0dmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0dmFyIG9yaWVudGF0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcclxuXHJcblx0XHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcclxuXHJcblx0XHR2YXIgbGlzdGVuZXIgPSB0aGlzLmNvbnRleHQubGlzdGVuZXI7XHJcblx0XHR2YXIgdXAgPSB0aGlzLnVwO1xyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKTtcclxuXHJcblx0XHRvcmllbnRhdGlvbi5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuXHRcdGxpc3RlbmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XHJcblx0XHRsaXN0ZW5lci5zZXRPcmllbnRhdGlvbiggb3JpZW50YXRpb24ueCwgb3JpZW50YXRpb24ueSwgb3JpZW50YXRpb24ueiwgdXAueCwgdXAueSwgdXAueiApO1xyXG5cclxuXHR9O1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9jYW1lcmFzL0NhbWVyYS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4qL1xyXG5cclxuVEhSRUUuQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdDYW1lcmEnO1xyXG5cclxuXHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DYW1lcmE7XHJcblxyXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmdldFdvcmxkRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5sb29rQXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IGNhbWVyYXMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxyXG5cclxuXHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0bTEubG9va0F0KCB0aGlzLnBvc2l0aW9uLCB2ZWN0b3IsIHRoaXMudXAgKTtcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSggc291cmNlLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBzb3VyY2UucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jYW1lcmFzL0N1YmVDYW1lcmEuanNcclxuXHJcbi8qKlxyXG4gKiBDYW1lcmEgZm9yIHJlbmRlcmluZyBjdWJlIG1hcHNcclxuICpcdC0gcmVuZGVycyBzY2VuZSBpbnRvIGF4aXMtYWxpZ25lZCBjdWJlXHJcbiAqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3ViZUNhbWVyYSA9IGZ1bmN0aW9uICggbmVhciwgZmFyLCBjdWJlUmVzb2x1dGlvbiApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnQ3ViZUNhbWVyYSc7XHJcblxyXG5cdHZhciBmb3YgPSA5MCwgYXNwZWN0ID0gMTtcclxuXHJcblx0dmFyIGNhbWVyYVBYID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhUFgudXAuc2V0KCAwLCAtIDEsIDAgKTtcclxuXHRjYW1lcmFQWC5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICkgKTtcclxuXHR0aGlzLmFkZCggY2FtZXJhUFggKTtcclxuXHJcblx0dmFyIGNhbWVyYU5YID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhTlgudXAuc2V0KCAwLCAtIDEsIDAgKTtcclxuXHRjYW1lcmFOWC5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAtIDEsIDAsIDAgKSApO1xyXG5cdHRoaXMuYWRkKCBjYW1lcmFOWCApO1xyXG5cclxuXHR2YXIgY2FtZXJhUFkgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRjYW1lcmFQWS51cC5zZXQoIDAsIDAsIDEgKTtcclxuXHRjYW1lcmFQWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcclxuXHR0aGlzLmFkZCggY2FtZXJhUFkgKTtcclxuXHJcblx0dmFyIGNhbWVyYU5ZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtIDEgKTtcclxuXHRjYW1lcmFOWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKSApO1xyXG5cdHRoaXMuYWRkKCBjYW1lcmFOWSApO1xyXG5cclxuXHR2YXIgY2FtZXJhUFogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRjYW1lcmFQWi51cC5zZXQoIDAsIC0gMSwgMCApO1xyXG5cdGNhbWVyYVBaLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKSApO1xyXG5cdHRoaXMuYWRkKCBjYW1lcmFQWiApO1xyXG5cclxuXHR2YXIgY2FtZXJhTlogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRjYW1lcmFOWi51cC5zZXQoIDAsIC0gMSwgMCApO1xyXG5cdGNhbWVyYU5aLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApICk7XHJcblx0dGhpcy5hZGQoIGNhbWVyYU5aICk7XHJcblxyXG5cdHZhciBvcHRpb25zID0geyBmb3JtYXQ6IFRIUkVFLlJHQkZvcm1hdCwgbWFnRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIG1pbkZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyIH07XHJcblxyXG5cdHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSggY3ViZVJlc29sdXRpb24sIGN1YmVSZXNvbHV0aW9uLCBvcHRpb25zICk7XHJcblxyXG5cdHRoaXMudXBkYXRlQ3ViZU1hcCA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0dmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xyXG5cdFx0dmFyIGdlbmVyYXRlTWlwbWFwcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAwO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFgsIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDE7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWCwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMjtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBZLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAzO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlksIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDQ7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWiwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDU7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWiwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBudWxsICk7XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ3ViZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdWJlQ2FtZXJhO1xyXG5cclxuLy8gRmlsZTpzcmMvY2FtZXJhcy9PcnRob2dyYXBoaWNDYW1lcmEuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSA9IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdPcnRob2dyYXBoaWNDYW1lcmEnO1xyXG5cclxuXHR0aGlzLnpvb20gPSAxO1xyXG5cclxuXHR0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdHRoaXMucmlnaHQgPSByaWdodDtcclxuXHR0aGlzLnRvcCA9IHRvcDtcclxuXHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcclxuXHJcblx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAwLjE7XHJcblx0dGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAyMDAwO1xyXG5cclxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhO1xyXG5cclxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZHggPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvICggMiAqIHRoaXMuem9vbSApO1xyXG5cdHZhciBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XHJcblx0dmFyIGN4ID0gKCB0aGlzLnJpZ2h0ICsgdGhpcy5sZWZ0ICkgLyAyO1xyXG5cdHZhciBjeSA9ICggdGhpcy50b3AgKyB0aGlzLmJvdHRvbSApIC8gMjtcclxuXHJcblx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VPcnRob2dyYXBoaWMoIGN4IC0gZHgsIGN4ICsgZHgsIGN5ICsgZHksIGN5IC0gZHksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmxlZnQgPSBzb3VyY2UubGVmdDtcclxuXHR0aGlzLnJpZ2h0ID0gc291cmNlLnJpZ2h0O1xyXG5cdHRoaXMudG9wID0gc291cmNlLnRvcDtcclxuXHR0aGlzLmJvdHRvbSA9IHNvdXJjZS5ib3R0b207XHJcblx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XHJcblx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xyXG5cclxuXHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XHJcblxyXG5cdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XHJcblx0ZGF0YS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcclxuXHRkYXRhLm9iamVjdC5yaWdodCA9IHRoaXMucmlnaHQ7XHJcblx0ZGF0YS5vYmplY3QudG9wID0gdGhpcy50b3A7XHJcblx0ZGF0YS5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b207XHJcblx0ZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcclxuXHRkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgZ3JlZ2dtYW4gLyBodHRwOi8vZ2FtZXMuZ3JlZ2dtYW4uY29tL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqL1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgPSBmdW5jdGlvbiAoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQZXJzcGVjdGl2ZUNhbWVyYSc7XHJcblxyXG5cdHRoaXMuZm9jYWxMZW5ndGggPSAxMDtcclxuXHR0aGlzLnpvb20gPSAxO1xyXG5cclxuXHR0aGlzLmZvdiA9IGZvdiAhPT0gdW5kZWZpbmVkID8gZm92IDogNTA7XHJcblx0dGhpcy5hc3BlY3QgPSBhc3BlY3QgIT09IHVuZGVmaW5lZCA/IGFzcGVjdCA6IDE7XHJcblx0dGhpcy5uZWFyID0gbmVhciAhPT0gdW5kZWZpbmVkID8gbmVhciA6IDAuMTtcclxuXHR0aGlzLmZhciA9IGZhciAhPT0gdW5kZWZpbmVkID8gZmFyIDogMjAwMDtcclxuXHJcblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYTtcclxuXHJcblxyXG4vKipcclxuICogVXNlcyBGb2NhbCBMZW5ndGggKGluIG1tKSB0byBlc3RpbWF0ZSBhbmQgc2V0IEZPVlxyXG4gKiAzNW1tIChmdWxsLWZyYW1lKSBjYW1lcmEgaXMgdXNlZCBpZiBmcmFtZSBzaXplIGlzIG5vdCBzcGVjaWZpZWQ7XHJcbiAqIEZvcm11bGEgYmFzZWQgb24gaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcclxuICovXHJcblxyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZyYW1lSGVpZ2h0ICkge1xyXG5cclxuXHRpZiAoIGZyYW1lSGVpZ2h0ID09PSB1bmRlZmluZWQgKSBmcmFtZUhlaWdodCA9IDI0O1xyXG5cclxuXHR0aGlzLmZvdiA9IDIgKiBUSFJFRS5NYXRoLnJhZFRvRGVnKCBNYXRoLmF0YW4oIGZyYW1lSGVpZ2h0IC8gKCBmb2NhbExlbmd0aCAqIDIgKSApICk7XHJcblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXHJcbiAqIG11bHRpLW1vbml0b3IvbXVsdGktbWFjaGluZSBzZXR1cHMuXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXHJcbiAqIHRoZSBtb25pdG9ycyBhcmUgaW4gZ3JpZCBsaWtlIHRoaXNcclxuICpcclxuICogICArLS0tKy0tLSstLS0rXHJcbiAqICAgfCBBIHwgQiB8IEMgfFxyXG4gKiAgICstLS0rLS0tKy0tLStcclxuICogICB8IEQgfCBFIHwgRiB8XHJcbiAqICAgKy0tLSstLS0rLS0tK1xyXG4gKlxyXG4gKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXHJcbiAqXHJcbiAqICAgdmFyIHcgPSAxOTIwO1xyXG4gKiAgIHZhciBoID0gMTA4MDtcclxuICogICB2YXIgZnVsbFdpZHRoID0gdyAqIDM7XHJcbiAqICAgdmFyIGZ1bGxIZWlnaHQgPSBoICogMjtcclxuICpcclxuICogICAtLUEtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAwLCB3LCBoICk7XHJcbiAqICAgLS1CLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xyXG4gKiAgIC0tQy0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDAsIHcsIGggKTtcclxuICogICAtLUQtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAxLCB3LCBoICk7XHJcbiAqICAgLS1FLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xyXG4gKiAgIC0tRi0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDEsIHcsIGggKTtcclxuICpcclxuICogICBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxyXG4gKi9cclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5zZXRWaWV3T2Zmc2V0ID0gZnVuY3Rpb24gKCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdHRoaXMuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xyXG5cdHRoaXMuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XHJcblx0dGhpcy54ID0geDtcclxuXHR0aGlzLnkgPSB5O1xyXG5cdHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZm92ID0gVEhSRUUuTWF0aC5yYWRUb0RlZyggMiAqIE1hdGguYXRhbiggTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIHRoaXMuZm92ICkgKiAwLjUgKSAvIHRoaXMuem9vbSApICk7XHJcblxyXG5cdGlmICggdGhpcy5mdWxsV2lkdGggKSB7XHJcblxyXG5cdFx0dmFyIGFzcGVjdCA9IHRoaXMuZnVsbFdpZHRoIC8gdGhpcy5mdWxsSGVpZ2h0O1xyXG5cdFx0dmFyIHRvcCA9IE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApICogdGhpcy5uZWFyO1xyXG5cdFx0dmFyIGJvdHRvbSA9IC0gdG9wO1xyXG5cdFx0dmFyIGxlZnQgPSBhc3BlY3QgKiBib3R0b207XHJcblx0XHR2YXIgcmlnaHQgPSBhc3BlY3QgKiB0b3A7XHJcblx0XHR2YXIgd2lkdGggPSBNYXRoLmFicyggcmlnaHQgLSBsZWZ0ICk7XHJcblx0XHR2YXIgaGVpZ2h0ID0gTWF0aC5hYnMoIHRvcCAtIGJvdHRvbSApO1xyXG5cclxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlRnJ1c3R1bShcclxuXHRcdFx0bGVmdCArIHRoaXMueCAqIHdpZHRoIC8gdGhpcy5mdWxsV2lkdGgsXHJcblx0XHRcdGxlZnQgKyAoIHRoaXMueCArIHRoaXMud2lkdGggKSAqIHdpZHRoIC8gdGhpcy5mdWxsV2lkdGgsXHJcblx0XHRcdHRvcCAtICggdGhpcy55ICsgdGhpcy5oZWlnaHQgKSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcclxuXHRcdFx0dG9wIC0gdGhpcy55ICogaGVpZ2h0IC8gdGhpcy5mdWxsSGVpZ2h0LFxyXG5cdFx0XHR0aGlzLm5lYXIsXHJcblx0XHRcdHRoaXMuZmFyXHJcblx0XHQpO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoIGZvdiwgdGhpcy5hc3BlY3QsIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5mb2NhbExlbmd0aCA9IHNvdXJjZS5mb2NhbExlbmd0aDtcclxuXHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcclxuXHJcblx0dGhpcy5mb3YgPSBzb3VyY2UuZm92O1xyXG5cdHRoaXMuYXNwZWN0ID0gc291cmNlLmFzcGVjdDtcclxuXHR0aGlzLm5lYXIgPSBzb3VyY2UubmVhcjtcclxuXHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XHJcblxyXG5cdGRhdGEub2JqZWN0LmZvY2FsTGVuZ3RoID0gdGhpcy5mb2NhbExlbmd0aDtcclxuXHRkYXRhLm9iamVjdC56b29tID0gdGhpcy56b29tO1xyXG5cclxuXHRkYXRhLm9iamVjdC5mb3YgPSB0aGlzLmZvdjtcclxuXHRkYXRhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcclxuXHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xyXG5cdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jYW1lcmFzL1N0ZXJlb0NhbWVyYS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3RlcmVvQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnU3RlcmVvQ2FtZXJhJztcclxuXHJcblx0dGhpcy5hc3BlY3QgPSAxO1xyXG5cclxuXHR0aGlzLmNhbWVyYUwgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoKTtcclxuXHR0aGlzLmNhbWVyYUwubGF5ZXJzLmVuYWJsZSggMSApO1xyXG5cdHRoaXMuY2FtZXJhTC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuY2FtZXJhUiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgpO1xyXG5cdHRoaXMuY2FtZXJhUi5sYXllcnMuZW5hYmxlKCAyICk7XHJcblx0dGhpcy5jYW1lcmFSLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TdGVyZW9DYW1lcmEucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuU3RlcmVvQ2FtZXJhLFxyXG5cclxuXHR1cGRhdGU6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBmb2NhbExlbmd0aCwgZm92LCBhc3BlY3QsIG5lYXIsIGZhcjtcclxuXHJcblx0XHR2YXIgZXllUmlnaHQgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdFx0dmFyIGV5ZUxlZnQgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHR2YXIgbmVlZHNVcGRhdGUgPSBmb2NhbExlbmd0aCAhPT0gY2FtZXJhLmZvY2FsTGVuZ3RoIHx8IGZvdiAhPT0gY2FtZXJhLmZvdiB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhc3BlY3QgIT09IGNhbWVyYS5hc3BlY3QgKiB0aGlzLmFzcGVjdCB8fCBuZWFyICE9PSBjYW1lcmEubmVhciB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmYXIgIT09IGNhbWVyYS5mYXI7XHJcblxyXG5cdFx0XHRpZiAoIG5lZWRzVXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHRmb2NhbExlbmd0aCA9IGNhbWVyYS5mb2NhbExlbmd0aDtcclxuXHRcdFx0XHRmb3YgPSBjYW1lcmEuZm92O1xyXG5cdFx0XHRcdGFzcGVjdCA9IGNhbWVyYS5hc3BlY3QgKiB0aGlzLmFzcGVjdDtcclxuXHRcdFx0XHRuZWFyID0gY2FtZXJhLm5lYXI7XHJcblx0XHRcdFx0ZmFyID0gY2FtZXJhLmZhcjtcclxuXHJcblx0XHRcdFx0Ly8gT2ZmLWF4aXMgc3RlcmVvc2NvcGljIGVmZmVjdCBiYXNlZCBvblxyXG5cdFx0XHRcdC8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9zdGVyZW9ncmFwaGljcy9zdGVyZW9yZW5kZXIvXHJcblxyXG5cdFx0XHRcdHZhciBwcm9qZWN0aW9uTWF0cml4ID0gY2FtZXJhLnByb2plY3Rpb25NYXRyaXguY2xvbmUoKTtcclxuXHRcdFx0XHR2YXIgZXllU2VwID0gMC4wNjQgLyAyO1xyXG5cdFx0XHRcdHZhciBleWVTZXBPblByb2plY3Rpb24gPSBleWVTZXAgKiBuZWFyIC8gZm9jYWxMZW5ndGg7XHJcblx0XHRcdFx0dmFyIHltYXggPSBuZWFyICogTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIGZvdiAqIDAuNSApICk7XHJcblx0XHRcdFx0dmFyIHhtaW4sIHhtYXg7XHJcblxyXG5cdFx0XHRcdC8vIHRyYW5zbGF0ZSB4T2Zmc2V0XHJcblxyXG5cdFx0XHRcdGV5ZUxlZnQuZWxlbWVudHNbIDEyIF0gPSAtIGV5ZVNlcDtcclxuXHRcdFx0XHRleWVSaWdodC5lbGVtZW50c1sgMTIgXSA9IGV5ZVNlcDtcclxuXHJcblx0XHRcdFx0Ly8gZm9yIGxlZnQgZXllXHJcblxyXG5cdFx0XHRcdHhtaW4gPSAtIHltYXggKiBhc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XHJcblx0XHRcdFx0eG1heCA9IHltYXggKiBhc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XHJcblxyXG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBuZWFyIC8gKCB4bWF4IC0geG1pbiApO1xyXG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDggXSA9ICggeG1heCArIHhtaW4gKSAvICggeG1heCAtIHhtaW4gKTtcclxuXHJcblx0XHRcdFx0dGhpcy5jYW1lcmFMLnByb2plY3Rpb25NYXRyaXguY29weSggcHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHQvLyBmb3IgcmlnaHQgZXllXHJcblxyXG5cdFx0XHRcdHhtaW4gPSAtIHltYXggKiBhc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XHJcblx0XHRcdFx0eG1heCA9IHltYXggKiBhc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XHJcblxyXG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBuZWFyIC8gKCB4bWF4IC0geG1pbiApO1xyXG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDggXSA9ICggeG1heCArIHhtaW4gKSAvICggeG1heCAtIHhtaW4gKTtcclxuXHJcblx0XHRcdFx0dGhpcy5jYW1lcmFSLnByb2plY3Rpb25NYXRyaXguY29weSggcHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5jYW1lcmFMLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLm11bHRpcGx5KCBleWVMZWZ0ICk7XHJcblx0XHRcdHRoaXMuY2FtZXJhUi5tYXRyaXhXb3JsZC5jb3B5KCBjYW1lcmEubWF0cml4V29ybGQgKS5tdWx0aXBseSggZXllUmlnaHQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9ICkoKVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xpZ2h0cy9MaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0xpZ2h0JztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcclxuXHR0aGlzLmludGVuc2l0eSA9IGludGVuc2l0eSAhPT0gdW5kZWZpbmVkID8gaW50ZW5zaXR5IDogMTtcclxuXHJcblx0dGhpcy5yZWNlaXZlU2hhZG93ID0gdW5kZWZpbmVkO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5MaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaWdodDtcclxuXHJcblRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cdHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0dmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcblx0ZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xyXG5cdGRhdGEub2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xyXG5cclxuXHRpZiAoIHRoaXMuZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0Lmdyb3VuZENvbG9yID0gdGhpcy5ncm91bmRDb2xvci5nZXRIZXgoKTtcclxuXHJcblx0aWYgKCB0aGlzLmRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XHJcblx0aWYgKCB0aGlzLmFuZ2xlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5hbmdsZSA9IHRoaXMuYW5nbGU7XHJcblx0aWYgKCB0aGlzLmRlY2F5ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5kZWNheSA9IHRoaXMuZGVjYXk7XHJcblx0aWYgKCB0aGlzLmV4cG9uZW50ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQ7XHJcblxyXG5cdHJldHVybiBkYXRhO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xpZ2h0cy9MaWdodFNoYWRvdy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGlnaHRTaGFkb3cgPSBmdW5jdGlvbiAoIGNhbWVyYSApIHtcclxuXHJcblx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdHRoaXMuYmlhcyA9IDA7XHJcblx0dGhpcy5yYWRpdXMgPSAxO1xyXG5cclxuXHR0aGlzLm1hcFNpemUgPSBuZXcgVEhSRUUuVmVjdG9yMiggNTEyLCA1MTIgKTtcclxuXHJcblx0dGhpcy5tYXAgPSBudWxsO1xyXG5cdHRoaXMubWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaWdodFNoYWRvdy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5MaWdodFNoYWRvdyxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5jYW1lcmEgPSBzb3VyY2UuY2FtZXJhLmNsb25lKCk7XHJcblxyXG5cdFx0dGhpcy5iaWFzID0gc291cmNlLmJpYXM7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHNvdXJjZS5yYWRpdXM7XHJcblxyXG5cdFx0dGhpcy5tYXBTaXplLmNvcHkoIHNvdXJjZS5tYXBTaXplICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL0FtYmllbnRMaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQW1iaWVudExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5ICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdBbWJpZW50TGlnaHQnO1xyXG5cclxuXHR0aGlzLmNhc3RTaGFkb3cgPSB1bmRlZmluZWQ7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQW1iaWVudExpZ2h0O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL0RpcmVjdGlvbmFsTGlnaHQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XHJcblxyXG5cdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xyXG5cclxuXHR0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xyXG5cdHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblxyXG5cdHRoaXMuc2hhZG93ID0gbmV3IFRIUkVFLkxpZ2h0U2hhZG93KCBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCAtIDUsIDUsIDUsIC0gNSwgMC41LCA1MDAgKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGlyZWN0aW9uYWxMaWdodDtcclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMudGFyZ2V0ID0gc291cmNlLnRhcmdldC5jbG9uZSgpO1xyXG5cclxuXHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL0hlbWlzcGhlcmVMaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ID0gZnVuY3Rpb24gKCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgc2t5Q29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnSGVtaXNwaGVyZUxpZ2h0JztcclxuXHJcblx0dGhpcy5jYXN0U2hhZG93ID0gdW5kZWZpbmVkO1xyXG5cclxuXHR0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xyXG5cdHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdHRoaXMuZ3JvdW5kQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGdyb3VuZENvbG9yICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSGVtaXNwaGVyZUxpZ2h0O1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmdyb3VuZENvbG9yLmNvcHkoIHNvdXJjZS5ncm91bmRDb2xvciApO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9saWdodHMvUG9pbnRMaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuXHJcblRIUkVFLlBvaW50TGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBkZWNheSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnUG9pbnRMaWdodCc7XHJcblxyXG5cdHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcclxuXHR0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7XHQvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXHJcblxyXG5cdHRoaXMuc2hhZG93ID0gbmV3IFRIUkVFLkxpZ2h0U2hhZG93KCBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIDkwLCAxLCAwLjUsIDUwMCApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcclxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludExpZ2h0O1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcclxuXHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xyXG5cclxuXHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL1Nwb3RMaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIGV4cG9uZW50LCBkZWNheSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnU3BvdExpZ2h0JztcclxuXHJcblx0dGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcclxuXHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHR0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XHJcblx0dGhpcy5hbmdsZSA9ICggYW5nbGUgIT09IHVuZGVmaW5lZCApID8gYW5nbGUgOiBNYXRoLlBJIC8gMztcclxuXHR0aGlzLmV4cG9uZW50ID0gKCBleHBvbmVudCAhPT0gdW5kZWZpbmVkICkgPyBleHBvbmVudCA6IDEwO1xyXG5cdHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTtcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cclxuXHJcblx0dGhpcy5zaGFkb3cgPSBuZXcgVEhSRUUuTGlnaHRTaGFkb3coIG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggNTAsIDEsIDAuNSwgNTAwICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcG90TGlnaHQ7XHJcblxyXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XHJcblx0dGhpcy5hbmdsZSA9IHNvdXJjZS5hbmdsZTtcclxuXHR0aGlzLmV4cG9uZW50ID0gc291cmNlLmV4cG9uZW50O1xyXG5cdHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XHJcblxyXG5cdHRoaXMudGFyZ2V0ID0gc291cmNlLnRhcmdldC5jbG9uZSgpO1xyXG5cclxuXHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9DYWNoZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2FjaGUgPSB7XHJcblxyXG5cdGVuYWJsZWQ6IGZhbHNlLFxyXG5cclxuXHRmaWxlczoge30sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCBrZXksIGZpbGUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQWRkaW5nIGtleTonLCBrZXkgKTtcclxuXHJcblx0XHR0aGlzLmZpbGVzWyBrZXkgXSA9IGZpbGU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldDogZnVuY3Rpb24gKCBrZXkgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQ2hlY2tpbmcga2V5OicsIGtleSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpbGVzWyBrZXkgXTtcclxuXHJcblx0fSxcclxuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoIGtleSApIHtcclxuXHJcblx0XHRkZWxldGUgdGhpcy5maWxlc1sga2V5IF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsZWFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5maWxlcyA9IHt9O1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9Mb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxvYWRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5vbkxvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdHRoaXMub25Mb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHR0aGlzLm9uTG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge307XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkxvYWRlcixcclxuXHJcblx0Y3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcclxuXHJcblx0ZXh0cmFjdFVybEJhc2U6IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuXHRcdHZhciBwYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XHJcblxyXG5cdFx0aWYgKCBwYXJ0cy5sZW5ndGggPT09IDEgKSByZXR1cm4gJy4vJztcclxuXHJcblx0XHRwYXJ0cy5wb3AoKTtcclxuXHJcblx0XHRyZXR1cm4gcGFydHMuam9pbiggJy8nICkgKyAnLyc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGluaXRNYXRlcmlhbHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKSB7XHJcblxyXG5cdFx0dmFyIGFycmF5ID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbWF0ZXJpYWxzLmxlbmd0aDsgKysgaSApIHtcclxuXHJcblx0XHRcdGFycmF5WyBpIF0gPSB0aGlzLmNyZWF0ZU1hdGVyaWFsKCBtYXRlcmlhbHNbIGkgXSwgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0Y3JlYXRlTWF0ZXJpYWw6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBjb2xvciwgdGV4dHVyZUxvYWRlciwgbWF0ZXJpYWxMb2FkZXI7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbSwgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICkge1xyXG5cclxuXHRcdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcclxuXHRcdFx0aWYgKCB0ZXh0dXJlTG9hZGVyID09PSB1bmRlZmluZWQgKSB0ZXh0dXJlTG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKTtcclxuXHRcdFx0aWYgKCBtYXRlcmlhbExvYWRlciA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxMb2FkZXIgPSBuZXcgVEhSRUUuTWF0ZXJpYWxMb2FkZXIoKTtcclxuXHJcblx0XHRcdC8vIGNvbnZlcnQgZnJvbSBvbGQgbWF0ZXJpYWwgZm9ybWF0XHJcblxyXG5cdFx0XHR2YXIgdGV4dHVyZXMgPSB7fTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBwYXRoLCByZXBlYXQsIG9mZnNldCwgd3JhcCwgYW5pc290cm9weSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGZ1bGxQYXRoID0gdGV4dHVyZVBhdGggKyBwYXRoO1xyXG5cdFx0XHRcdHZhciBsb2FkZXIgPSBUSFJFRS5Mb2FkZXIuSGFuZGxlcnMuZ2V0KCBmdWxsUGF0aCApO1xyXG5cclxuXHRcdFx0XHR2YXIgdGV4dHVyZTtcclxuXHJcblx0XHRcdFx0aWYgKCBsb2FkZXIgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZSA9IGxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmVMb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIGNyb3NzT3JpZ2luICk7XHJcblx0XHRcdFx0XHR0ZXh0dXJlID0gdGV4dHVyZUxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcmVwZWF0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KCByZXBlYXQgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHJlcGVhdFsgMCBdICE9PSAxICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cdFx0XHRcdFx0aWYgKCByZXBlYXRbIDEgXSAhPT0gMSApIHRleHR1cmUud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSggb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB3cmFwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB3cmFwWyAwIF0gPT09ICdyZXBlYXQnICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cdFx0XHRcdFx0aWYgKCB3cmFwWyAwIF0gPT09ICdtaXJyb3InICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB3cmFwWyAxIF0gPT09ICdyZXBlYXQnICkgdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cdFx0XHRcdFx0aWYgKCB3cmFwWyAxIF0gPT09ICdtaXJyb3InICkgdGV4dHVyZS53cmFwVCA9IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBhbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gYW5pc290cm9weTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgdXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdFx0XHRcdHRleHR1cmVzWyB1dWlkIF0gPSB0ZXh0dXJlO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdXVpZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHR2YXIganNvbiA9IHtcclxuXHRcdFx0XHR1dWlkOiBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpLFxyXG5cdFx0XHRcdHR5cGU6ICdNZXNoTGFtYmVydE1hdGVyaWFsJ1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gbSApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZhbHVlID0gbVsgbmFtZSBdO1xyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xyXG5cdFx0XHRcdFx0Y2FzZSAnRGJnQ29sb3InOlxyXG5cdFx0XHRcdFx0Y2FzZSAnRGJnSW5kZXgnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnb3B0aWNhbERlbnNpdHknOlxyXG5cdFx0XHRcdFx0Y2FzZSAnaWxsdW1pbmF0aW9uJzpcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdEYmdOYW1lJzpcclxuXHRcdFx0XHRcdFx0anNvbi5uYW1lID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnYmxlbmRpbmcnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmJsZW5kaW5nID0gVEhSRUVbIHZhbHVlIF07XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnY29sb3JBbWJpZW50JzpcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiBjb2xvckFtYmllbnQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCcgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdjb2xvckRpZmZ1c2UnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmNvbG9yID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ2NvbG9yU3BlY3VsYXInOlxyXG5cdFx0XHRcdFx0XHRqc29uLnNwZWN1bGFyID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ2NvbG9yRW1pc3NpdmUnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmVtaXNzaXZlID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ3NwZWN1bGFyQ29lZic6XHJcblx0XHRcdFx0XHRcdGpzb24uc2hpbmluZXNzID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnc2hhZGluZyc6XHJcblx0XHRcdFx0XHRcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ2Jhc2ljJyApIGpzb24udHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XHJcblx0XHRcdFx0XHRcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3Bob25nJyApIGpzb24udHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZSc6XHJcblx0XHRcdFx0XHRcdGpzb24ubWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcERpZmZ1c2VSZXBlYXQsIG0ubWFwRGlmZnVzZU9mZnNldCwgbS5tYXBEaWZmdXNlV3JhcCwgbS5tYXBEaWZmdXNlQW5pc290cm9weSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2VSZXBlYXQnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZU9mZnNldCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlV3JhcCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlQW5pc290cm9weSc6XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHQnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmxpZ2h0TWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCwgbS5tYXBMaWdodEFuaXNvdHJvcHkgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdtYXBMaWdodFJlcGVhdCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBMaWdodE9mZnNldCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBMaWdodFdyYXAnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHRBbmlzb3Ryb3B5JzpcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBTyc6XHJcblx0XHRcdFx0XHRcdGpzb24uYW9NYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQU9SZXBlYXQsIG0ubWFwQU9PZmZzZXQsIG0ubWFwQU9XcmFwLCBtLm1hcEFPQW5pc290cm9weSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEFPUmVwZWF0JzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEFPT2Zmc2V0JzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEFPV3JhcCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBT0FuaXNvdHJvcHknOlxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXAnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmJ1bXBNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQnVtcFJlcGVhdCwgbS5tYXBCdW1wT2Zmc2V0LCBtLm1hcEJ1bXBXcmFwLCBtLm1hcEJ1bXBBbmlzb3Ryb3B5ICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFNjYWxlJzpcclxuXHRcdFx0XHRcdFx0anNvbi5idW1wU2NhbGUgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdtYXBCdW1wUmVwZWF0JzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBPZmZzZXQnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFdyYXAnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcEFuaXNvdHJvcHknOlxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbCc6XHJcblx0XHRcdFx0XHRcdGpzb24ubm9ybWFsTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcE5vcm1hbFJlcGVhdCwgbS5tYXBOb3JtYWxPZmZzZXQsIG0ubWFwTm9ybWFsV3JhcCwgbS5tYXBOb3JtYWxBbmlzb3Ryb3B5ICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsRmFjdG9yJzpcclxuXHRcdFx0XHRcdFx0anNvbi5ub3JtYWxTY2FsZSA9IFsgdmFsdWUsIHZhbHVlIF07XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsUmVwZWF0JzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbE9mZnNldCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxXcmFwJzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbEFuaXNvdHJvcHknOlxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyJzpcclxuXHRcdFx0XHRcdFx0anNvbi5zcGVjdWxhck1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBTcGVjdWxhclJlcGVhdCwgbS5tYXBTcGVjdWxhck9mZnNldCwgbS5tYXBTcGVjdWxhcldyYXAsIG0ubWFwU3BlY3VsYXJBbmlzb3Ryb3B5ICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJSZXBlYXQnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJPZmZzZXQnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJXcmFwJzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyQW5pc290cm9weSc6XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGEnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmFscGhhTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEFscGhhUmVwZWF0LCBtLm1hcEFscGhhT2Zmc2V0LCBtLm1hcEFscGhhV3JhcCwgbS5tYXBBbHBoYUFuaXNvdHJvcHkgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYVJlcGVhdCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYU9mZnNldCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYVdyYXAnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGFBbmlzb3Ryb3B5JzpcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdmbGlwU2lkZWQnOlxyXG5cdFx0XHRcdFx0XHRqc29uLnNpZGUgPSBUSFJFRS5CYWNrU2lkZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdkb3VibGVTaWRlZCc6XHJcblx0XHRcdFx0XHRcdGpzb24uc2lkZSA9IFRIUkVFLkRvdWJsZVNpZGU7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbmN5JzpcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiB0cmFuc3BhcmVuY3kgaGFzIGJlZW4gcmVuYW1lZCB0byBvcGFjaXR5JyApO1xyXG5cdFx0XHRcdFx0XHRqc29uLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdkZXB0aFRlc3QnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnZGVwdGhXcml0ZSc6XHJcblx0XHRcdFx0XHRjYXNlICdjb2xvcldyaXRlJzpcclxuXHRcdFx0XHRcdGNhc2UgJ29wYWNpdHknOlxyXG5cdFx0XHRcdFx0Y2FzZSAncmVmbGVjdGl2aXR5JzpcclxuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW50JzpcclxuXHRcdFx0XHRcdGNhc2UgJ3Zpc2libGUnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnd2lyZWZyYW1lJzpcclxuXHRcdFx0XHRcdFx0anNvblsgbmFtZSBdID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAndmVydGV4Q29sb3JzJzpcclxuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIGpzb24udmVydGV4Q29sb3JzID0gVEhSRUUuVmVydGV4Q29sb3JzO1xyXG5cdFx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSAnZmFjZScgKSBqc29uLnZlcnRleENvbG9ycyA9IFRIUkVFLkZhY2VDb2xvcnM7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkxvYWRlci5jcmVhdGVNYXRlcmlhbDogVW5zdXBwb3J0ZWQnLCBuYW1lLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGpzb24udHlwZSA9PT0gJ01lc2hCYXNpY01hdGVyaWFsJyApIGRlbGV0ZSBqc29uLmVtaXNzaXZlO1xyXG5cdFx0XHRpZiAoIGpzb24udHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyApIGRlbGV0ZSBqc29uLnNwZWN1bGFyO1xyXG5cclxuXHRcdFx0aWYgKCBqc29uLm9wYWNpdHkgPCAxICkganNvbi50cmFuc3BhcmVudCA9IHRydWU7XHJcblxyXG5cdFx0XHRtYXRlcmlhbExvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcclxuXHJcblx0XHRcdHJldHVybiBtYXRlcmlhbExvYWRlci5wYXJzZSgganNvbiApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0gKSgpXHJcblxyXG59O1xyXG5cclxuVEhSRUUuTG9hZGVyLkhhbmRsZXJzID0ge1xyXG5cclxuXHRoYW5kbGVyczogW10sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCByZWdleCwgbG9hZGVyICkge1xyXG5cclxuXHRcdHRoaXMuaGFuZGxlcnMucHVzaCggcmVnZXgsIGxvYWRlciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQ6IGZ1bmN0aW9uICggZmlsZSApIHtcclxuXHJcblx0XHR2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcclxuXHJcblx0XHRcdHZhciByZWdleCA9IGhhbmRsZXJzWyBpIF07XHJcblx0XHRcdHZhciBsb2FkZXIgID0gaGFuZGxlcnNbIGkgKyAxIF07XHJcblxyXG5cdFx0XHRpZiAoIHJlZ2V4LnRlc3QoIGZpbGUgKSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGxvYWRlcjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL1hIUkxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuWEhSTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5YSFJMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuWEhSTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5wYXRoICE9PSB1bmRlZmluZWQgKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHR2YXIgY2FjaGVkID0gVEhSRUUuQ2FjaGUuZ2V0KCB1cmwgKTtcclxuXHJcblx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBvbkxvYWQgKSB7XHJcblxyXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0XHRvbkxvYWQoIGNhY2hlZCApO1xyXG5cclxuXHRcdFx0XHR9LCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FjaGVkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cdFx0cmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKCAndGV4dC9wbGFpbicgKTtcclxuXHRcdHJlcXVlc3Qub3BlbiggJ0dFVCcsIHVybCwgdHJ1ZSApO1xyXG5cclxuXHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3BvbnNlID0gZXZlbnQudGFyZ2V0LnJlc3BvbnNlO1xyXG5cclxuXHRcdFx0VEhSRUUuQ2FjaGUuYWRkKCB1cmwsIHJlc3BvbnNlICk7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuc3RhdHVzID09PSAyMDAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCByZXNwb25zZSApO1xyXG5cclxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5zdGF0dXMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgcmV0dXJuIEhUVFAgU3RhdHVzIDAgd2hlbiB1c2luZyBub24taHR0cCBwcm90b2NvbFxyXG5cdFx0XHRcdC8vIGUuZy4gJ2ZpbGU6Ly8nIG9yICdkYXRhOi8vJy4gSGFuZGxlIGFzIHN1Y2Nlc3MuXHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlhIUkxvYWRlcjogSFRUUCBTdGF0dXMgMCByZWNlaXZlZC4nICk7XHJcblxyXG5cdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCByZXNwb25zZSApO1xyXG5cclxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcclxuXHJcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sIGZhbHNlICk7XHJcblxyXG5cdFx0aWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRcdG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XHJcblxyXG5cdFx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xyXG5cclxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xyXG5cclxuXHRcdH0sIGZhbHNlICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnJlc3BvbnNlVHlwZSAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcclxuXHRcdGlmICggdGhpcy53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCApIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XHJcblxyXG5cdFx0cmVxdWVzdC5zZW5kKCBudWxsICk7XHJcblxyXG5cdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xyXG5cclxuXHRcdHJldHVybiByZXF1ZXN0O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMucGF0aCA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSZXNwb25zZVR5cGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5yZXNwb25zZVR5cGUgPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0V2l0aENyZWRlbnRpYWxzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0ZvbnRMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZvbnRMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZvbnRMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRm9udExvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XHJcblxyXG5cdFx0XHRvbkxvYWQoIG5ldyBUSFJFRS5Gb250KCBKU09OLnBhcnNlKCB0ZXh0LnN1YnN0cmluZyggNjUsIHRleHQubGVuZ3RoIC0gMiApICkgKSApO1xyXG5cclxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvSW1hZ2VMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkltYWdlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbWFnZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5JbWFnZUxvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkICkgdXJsID0gdGhpcy5wYXRoICsgdXJsO1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGNhY2hlZCA9IFRIUkVFLkNhY2hlLmdldCggdXJsICk7XHJcblxyXG5cdFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcblx0XHRcdGlmICggb25Mb2FkICkge1xyXG5cclxuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdFx0b25Mb2FkKCBjYWNoZWQgKTtcclxuXHJcblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0XHR9LCAwICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2ltZycgKTtcclxuXHJcblx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRUSFJFRS5DYWNoZS5hZGQoIHVybCwgdGhpcyApO1xyXG5cclxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRoaXMgKTtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblxyXG5cdFx0fSwgZmFsc2UgKTtcclxuXHJcblx0XHRpZiAoIG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRcdG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XHJcblxyXG5cdFx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcclxuXHJcblx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG5cclxuXHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcblx0XHRpbWFnZS5zcmMgPSB1cmw7XHJcblxyXG5cdFx0cmV0dXJuIGltYWdlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5wYXRoID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0pTT05Mb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkpTT05Mb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdGlmICggdHlwZW9mIG1hbmFnZXIgPT09ICdib29sZWFuJyApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5KU09OTG9hZGVyOiBzaG93U3RhdHVzIHBhcmFtZXRlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gY29uc3RydWN0b3IuJyApO1xyXG5cdFx0bWFuYWdlciA9IHVuZGVmaW5lZDtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcblx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkpTT05Mb2FkZXIsXHJcblxyXG5cdC8vIERlcHJlY2F0ZWRcclxuXHJcblx0Z2V0IHN0YXR1c0RvbUVsZW1lbnQgKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fc3RhdHVzRG9tRWxlbWVudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGhpcy5fc3RhdHVzRG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IC5zdGF0dXNEb21FbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3N0YXR1c0RvbUVsZW1lbnQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlUGF0aCA9IHRoaXMudGV4dHVyZVBhdGggJiYgKCB0eXBlb2YgdGhpcy50ZXh0dXJlUGF0aCA9PT0gXCJzdHJpbmdcIiApID8gdGhpcy50ZXh0dXJlUGF0aCA6IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuZXh0cmFjdFVybEJhc2UoIHVybCApO1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XHJcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XHJcblxyXG5cdFx0XHR2YXIganNvbiA9IEpTT04ucGFyc2UoIHRleHQgKTtcclxuXHRcdFx0dmFyIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcclxuXHJcblx0XHRcdGlmICggbWV0YWRhdGEgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHR5cGUgPSBtZXRhZGF0YS50eXBlO1xyXG5cclxuXHRcdFx0XHRpZiAoIHR5cGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLk9iamVjdExvYWRlciBpbnN0ZWFkLicgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3NjZW5lJyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuU2NlbmVMb2FkZXIgaW5zdGVhZC4nICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBvYmplY3QgPSBzY29wZS5wYXJzZSgganNvbiwgdGV4dHVyZVBhdGggKTtcclxuXHRcdFx0b25Mb2FkKCBvYmplY3QuZ2VvbWV0cnksIG9iamVjdC5tYXRlcmlhbHMgKTtcclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZVBhdGggKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCksXHJcblx0XHRzY2FsZSA9ICgganNvbi5zY2FsZSAhPT0gdW5kZWZpbmVkICkgPyAxLjAgLyBqc29uLnNjYWxlIDogMS4wO1xyXG5cclxuXHRcdHBhcnNlTW9kZWwoIHNjYWxlICk7XHJcblxyXG5cdFx0cGFyc2VTa2luKCk7XHJcblx0XHRwYXJzZU1vcnBoaW5nKCBzY2FsZSApO1xyXG5cdFx0cGFyc2VBbmltYXRpb25zKCk7XHJcblxyXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZU1vZGVsKCBzY2FsZSApIHtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGlzQml0U2V0KCB2YWx1ZSwgcG9zaXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB2YWx1ZSAmICggMSA8PCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGksIGosIGZpLFxyXG5cclxuXHRcdFx0b2Zmc2V0LCB6TGVuZ3RoLFxyXG5cclxuXHRcdGNvbG9ySW5kZXgsIG5vcm1hbEluZGV4LCB1dkluZGV4LCBtYXRlcmlhbEluZGV4LFxyXG5cclxuXHRcdFx0dHlwZSxcclxuXHRcdFx0aXNRdWFkLFxyXG5cdFx0XHRoYXNNYXRlcmlhbCxcclxuXHRcdFx0aGFzRmFjZVZlcnRleFV2LFxyXG5cdFx0XHRoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLFxyXG5cdFx0XHRoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcixcclxuXHJcblx0XHR2ZXJ0ZXgsIGZhY2UsIGZhY2VBLCBmYWNlQiwgaGV4LCBub3JtYWwsXHJcblxyXG5cdFx0XHR1dkxheWVyLCB1diwgdSwgdixcclxuXHJcblx0XHRcdGZhY2VzID0ganNvbi5mYWNlcyxcclxuXHRcdFx0dmVydGljZXMgPSBqc29uLnZlcnRpY2VzLFxyXG5cdFx0XHRub3JtYWxzID0ganNvbi5ub3JtYWxzLFxyXG5cdFx0XHRjb2xvcnMgPSBqc29uLmNvbG9ycyxcclxuXHJcblx0XHRcdG5VdkxheWVycyA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24udXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGRpc3JlZ2FyZCBlbXB0eSBhcnJheXNcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBqc29uLnV2c1sgaSBdLmxlbmd0aCApIG5VdkxheWVycyArKztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2Zmc2V0ID0gMDtcclxuXHRcdFx0ekxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aDtcclxuXHJcblx0XHRcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0dmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcclxuXHRcdFx0XHR2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xyXG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2Zmc2V0ID0gMDtcclxuXHRcdFx0ekxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcclxuXHJcblx0XHRcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0dHlwZSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblxyXG5cdFx0XHRcdGlzUXVhZCAgICAgICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMCApO1xyXG5cdFx0XHRcdGhhc01hdGVyaWFsICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMSApO1xyXG5cdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhVdiAgICAgPSBpc0JpdFNldCggdHlwZSwgMyApO1xyXG5cdFx0XHRcdGhhc0ZhY2VOb3JtYWwgICAgICAgPSBpc0JpdFNldCggdHlwZSwgNCApO1xyXG5cdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBpc0JpdFNldCggdHlwZSwgNSApO1xyXG5cdFx0XHRcdGhhc0ZhY2VDb2xvclx0ICAgICA9IGlzQml0U2V0KCB0eXBlLCA2ICk7XHJcblx0XHRcdFx0aGFzRmFjZVZlcnRleENvbG9yICA9IGlzQml0U2V0KCB0eXBlLCA3ICk7XHJcblxyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwidHlwZVwiLCB0eXBlLCBcImJpdHNcIiwgaXNRdWFkLCBoYXNNYXRlcmlhbCwgaGFzRmFjZVZlcnRleFV2LCBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLCBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcik7XHJcblxyXG5cdFx0XHRcdGlmICggaXNRdWFkICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2VBID0gbmV3IFRIUkVFLkZhY2UzKCk7XHJcblx0XHRcdFx0XHRmYWNlQS5hID0gZmFjZXNbIG9mZnNldCBdO1xyXG5cdFx0XHRcdFx0ZmFjZUEuYiA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XHJcblx0XHRcdFx0XHRmYWNlQS5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcclxuXHJcblx0XHRcdFx0XHRmYWNlQiA9IG5ldyBUSFJFRS5GYWNlMygpO1xyXG5cdFx0XHRcdFx0ZmFjZUIuYSA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XHJcblx0XHRcdFx0XHRmYWNlQi5iID0gZmFjZXNbIG9mZnNldCArIDIgXTtcclxuXHRcdFx0XHRcdGZhY2VCLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldCArPSA0O1xyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdFx0XHRmYWNlQS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHRcdFx0XHRcdFx0ZmFjZUIubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxyXG5cclxuXHRcdFx0XHRcdGZpID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdID0gW107XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgNDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xyXG5cdFx0XHRcdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIHYgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGogIT09IDIgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmICggaiAhPT0gMCApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0ucHVzaCggdXYgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XHJcblxyXG5cdFx0XHRcdFx0XHRmYWNlQS5ub3JtYWwuc2V0KFxyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRmYWNlQi5ub3JtYWwuY29weSggZmFjZUEubm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0ZmFjZUEuY29sb3Iuc2V0SGV4KCBoZXggKTtcclxuXHRcdFx0XHRcdFx0ZmFjZUIuY29sb3Iuc2V0SGV4KCBoZXggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VBICk7XHJcblx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQiApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoKTtcclxuXHRcdFx0XHRcdGZhY2UuYSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdGZhY2UuYiA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGhhc01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXHJcblxyXG5cdFx0XHRcdFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dXZJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcclxuXHRcdFx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuXHRcdFx0XHRcdFx0ZmFjZS5ub3JtYWwuc2V0KFxyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdFx0ZmFjZS5jb2xvci5zZXRIZXgoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdFx0XHRmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICkgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZVNraW4oKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5mbHVlbmNlc1BlclZlcnRleCA9ICgganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4ICE9PSB1bmRlZmluZWQgKSA/IGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCA6IDI7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24uc2tpbldlaWdodHMgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB4ID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5za2luV2VpZ2h0c1sgaSBdO1xyXG5cdFx0XHRcdFx0dmFyIHkgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMSBdIDogMDtcclxuXHRcdFx0XHRcdHZhciB6ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDIgXSA6IDA7XHJcblx0XHRcdFx0XHR2YXIgdyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAzIF0gOiAwO1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCB4LCB5LCB6LCB3ICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYSA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2tpbkluZGljZXNbIGkgXTtcclxuXHRcdFx0XHRcdHZhciBiID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDEgXSA6IDA7XHJcblx0XHRcdFx0XHR2YXIgYyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDIgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAyIF0gOiAwO1xyXG5cdFx0XHRcdFx0dmFyIGQgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMyBdIDogMDtcclxuXHJcblx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggYSwgYiwgYywgZCApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCAmJiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoIHx8IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAhPT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1doZW4gc2tpbm5pbmcsIG51bWJlciBvZiB2ZXJ0aWNlcyAoJyArIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCArICcpLCBza2luSW5kaWNlcyAoJyArXHJcblx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKyAnKSwgYW5kIHNraW5XZWlnaHRzICgnICsgZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICsgJykgc2hvdWxkIG1hdGNoLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIHBhcnNlTW9ycGhpbmcoIHNjYWxlICkge1xyXG5cclxuXHRcdFx0aWYgKCBqc29uLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdID0ge307XHJcblx0XHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS5uYW1lID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS5uYW1lO1xyXG5cdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZHN0VmVydGljZXMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcclxuXHRcdFx0XHRcdHZhciBzcmNWZXJ0aWNlcyA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIHYgPSAwLCB2bCA9IHNyY1ZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0XHRcdFx0dmVydGV4LnggPSBzcmNWZXJ0aWNlc1sgdiBdICogc2NhbGU7XHJcblx0XHRcdFx0XHRcdHZlcnRleC55ID0gc3JjVmVydGljZXNbIHYgKyAxIF0gKiBzY2FsZTtcclxuXHRcdFx0XHRcdFx0dmVydGV4LnogPSBzcmNWZXJ0aWNlc1sgdiArIDIgXSAqIHNjYWxlO1xyXG5cclxuXHRcdFx0XHRcdFx0ZHN0VmVydGljZXMucHVzaCggdmVydGV4ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGpzb24ubW9ycGhDb2xvcnMgIT09IHVuZGVmaW5lZCAmJiBqc29uLm1vcnBoQ29sb3JzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IFwibW9ycGhDb2xvcnNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2luZyB0aGVtIGFzIGZhY2UgY29sb3JzLicgKTtcclxuXHJcblx0XHRcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblx0XHRcdFx0dmFyIG1vcnBoQ29sb3JzID0ganNvbi5tb3JwaENvbG9yc1sgMCBdLmNvbG9ycztcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlc1sgaSBdLmNvbG9yLmZyb21BcnJheSggbW9ycGhDb2xvcnMsIGkgKiAzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb25zKCkge1xyXG5cclxuXHRcdFx0dmFyIG91dHB1dEFuaW1hdGlvbnMgPSBbXTtcclxuXHJcblx0XHRcdC8vIHBhcnNlIG9sZCBzdHlsZSBCb25lL0hpZXJhcmNoeSBhbmltYXRpb25zXHJcblx0XHRcdHZhciBhbmltYXRpb25zID0gW107XHJcblxyXG5cdFx0XHRpZiAoIGpzb24uYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb24gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICgganNvbi5hbmltYXRpb25zICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICgganNvbi5hbmltYXRpb25zLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0XHRhbmltYXRpb25zID0gYW5pbWF0aW9ucy5jb25jYXQoIGpzb24uYW5pbWF0aW9ucyApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb25zICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY2xpcCA9IFRIUkVFLkFuaW1hdGlvbkNsaXAucGFyc2VBbmltYXRpb24oIGFuaW1hdGlvbnNbIGkgXSwgZ2VvbWV0cnkuYm9uZXMgKTtcclxuXHRcdFx0XHRpZiAoIGNsaXAgKSBvdXRwdXRBbmltYXRpb25zLnB1c2goIGNsaXAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHBhcnNlIGltcGxpY2l0IG1vcnBoIGFuaW1hdGlvbnNcclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBhbiBhcHByb3ByYWl0ZSBGUFMgaXMgZm9yIG1vcnBoIHRhcmdldCBhbmltYXRpb25zIC0tIGRlZmF1bHRpbmcgdG8gMTAsIGJ1dCByZWFsbHkgaXQgaXMgY29tcGxldGVseSBhcmJpdHJhcnkuXHJcblx0XHRcdFx0dmFyIG1vcnBoQW5pbWF0aW9uQ2xpcHMgPSBUSFJFRS5BbmltYXRpb25DbGlwLkNyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMsIDEwICk7XHJcblx0XHRcdFx0b3V0cHV0QW5pbWF0aW9ucyA9IG91dHB1dEFuaW1hdGlvbnMuY29uY2F0KCBtb3JwaEFuaW1hdGlvbkNsaXBzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG91dHB1dEFuaW1hdGlvbnMubGVuZ3RoID4gMCApIGdlb21ldHJ5LmFuaW1hdGlvbnMgPSBvdXRwdXRBbmltYXRpb25zO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCBqc29uLm1hdGVyaWFscyA9PT0gdW5kZWZpbmVkIHx8IGpzb24ubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSB9O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gVEhSRUUuTG9hZGVyLnByb3RvdHlwZS5pbml0TWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZVBhdGgsIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHJcblx0XHRcdHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSwgbWF0ZXJpYWxzOiBtYXRlcmlhbHMgfTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0xvYWRpbmdNYW5hZ2VyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Mb2FkaW5nTWFuYWdlciA9IGZ1bmN0aW9uICggb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgaXNMb2FkaW5nID0gZmFsc2UsIGl0ZW1zTG9hZGVkID0gMCwgaXRlbXNUb3RhbCA9IDA7XHJcblxyXG5cdHRoaXMub25TdGFydCA9IHVuZGVmaW5lZDtcclxuXHR0aGlzLm9uTG9hZCA9IG9uTG9hZDtcclxuXHR0aGlzLm9uUHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xyXG5cdHRoaXMub25FcnJvciA9IG9uRXJyb3I7XHJcblxyXG5cdHRoaXMuaXRlbVN0YXJ0ID0gZnVuY3Rpb24gKCB1cmwgKSB7XHJcblxyXG5cdFx0aXRlbXNUb3RhbCArKztcclxuXHJcblx0XHRpZiAoIGlzTG9hZGluZyA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNjb3BlLm9uU3RhcnQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUub25TdGFydCggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpc0xvYWRpbmcgPSB0cnVlO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbiAoIHVybCApIHtcclxuXHJcblx0XHRpdGVtc0xvYWRlZCArKztcclxuXHJcblx0XHRpZiAoIHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHNjb3BlLm9uUHJvZ3Jlc3MoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpdGVtc0xvYWRlZCA9PT0gaXRlbXNUb3RhbCApIHtcclxuXHJcblx0XHRcdGlzTG9hZGluZyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0aWYgKCBzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUub25Mb2FkKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLml0ZW1FcnJvciA9IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuXHRcdGlmICggc2NvcGUub25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0c2NvcGUub25FcnJvciggdXJsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlciA9IG5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlcigpO1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9CdWZmZXJHZW9tZXRyeUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XHJcblxyXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHRcdHZhciBpbmRleCA9IGpzb24uZGF0YS5pbmRleDtcclxuXHJcblx0XHR2YXIgVFlQRURfQVJSQVlTID0ge1xyXG5cdFx0XHQnSW50OEFycmF5JzogSW50OEFycmF5LFxyXG5cdFx0XHQnVWludDhBcnJheSc6IFVpbnQ4QXJyYXksXHJcblx0XHRcdCdVaW50OENsYW1wZWRBcnJheSc6IFVpbnQ4Q2xhbXBlZEFycmF5LFxyXG5cdFx0XHQnSW50MTZBcnJheSc6IEludDE2QXJyYXksXHJcblx0XHRcdCdVaW50MTZBcnJheSc6IFVpbnQxNkFycmF5LFxyXG5cdFx0XHQnSW50MzJBcnJheSc6IEludDMyQXJyYXksXHJcblx0XHRcdCdVaW50MzJBcnJheSc6IFVpbnQzMkFycmF5LFxyXG5cdFx0XHQnRmxvYXQzMkFycmF5JzogRmxvYXQzMkFycmF5LFxyXG5cdFx0XHQnRmxvYXQ2NEFycmF5JzogRmxvYXQ2NEFycmF5XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciB0eXBlZEFycmF5ID0gbmV3IFRZUEVEX0FSUkFZU1sgaW5kZXgudHlwZSBdKCBpbmRleC5hcnJheSApO1xyXG5cdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgMSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0ganNvbi5kYXRhLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cdFx0XHR2YXIgdHlwZWRBcnJheSA9IG5ldyBUWVBFRF9BUlJBWVNbIGF0dHJpYnV0ZS50eXBlIF0oIGF0dHJpYnV0ZS5hcnJheSApO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCBrZXksIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIGF0dHJpYnV0ZS5pdGVtU2l6ZSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XHJcblxyXG5cdFx0aWYgKCBncm91cHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGdyb3Vwcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBib3VuZGluZ1NwaGVyZSA9IGpzb24uZGF0YS5ib3VuZGluZ1NwaGVyZTtcclxuXHJcblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdGlmICggYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNlbnRlci5mcm9tQXJyYXkoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBjZW50ZXIsIGJvdW5kaW5nU3BoZXJlLnJhZGl1cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL01hdGVyaWFsTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NYXRlcmlhbExvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblx0dGhpcy50ZXh0dXJlcyA9IHt9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1hdGVyaWFsTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdGVyaWFsTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XHJcblxyXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRUZXh0dXJlczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnRleHR1cmVzID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFRleHR1cmU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVzO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0ZXJpYWxMb2FkZXI6IFVuZGVmaW5lZCB0ZXh0dXJlJywgbmFtZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZXNbIG5hbWUgXTtcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUVbIGpzb24udHlwZSBdO1xyXG5cclxuXHRcdGlmICgganNvbi51dWlkICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51dWlkID0ganNvbi51dWlkO1xyXG5cdFx0aWYgKCBqc29uLm5hbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5hbWUgPSBqc29uLm5hbWU7XHJcblx0XHRpZiAoIGpzb24uY29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNvbG9yLnNldEhleCgganNvbi5jb2xvciApO1xyXG5cdFx0aWYgKCBqc29uLnJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucm91Z2huZXNzID0ganNvbi5yb3VnaG5lc3M7XHJcblx0XHRpZiAoIGpzb24ubWV0YWxuZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tZXRhbG5lc3MgPSBqc29uLm1ldGFsbmVzcztcclxuXHRcdGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KCBqc29uLmVtaXNzaXZlICk7XHJcblx0XHRpZiAoIGpzb24uc3BlY3VsYXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyLnNldEhleCgganNvbi5zcGVjdWxhciApO1xyXG5cdFx0aWYgKCBqc29uLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hpbmluZXNzID0ganNvbi5zaGluaW5lc3M7XHJcblx0XHRpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVuaWZvcm1zID0ganNvbi51bmlmb3JtcztcclxuXHRcdGlmICgganNvbi52ZXJ0ZXhTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IGpzb24udmVydGV4U2hhZGVyO1xyXG5cdFx0aWYgKCBqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGpzb24uZnJhZ21lbnRTaGFkZXI7XHJcblx0XHRpZiAoIGpzb24udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcclxuXHRcdGlmICgganNvbi5zaGFkaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGFkaW5nID0ganNvbi5zaGFkaW5nO1xyXG5cdFx0aWYgKCBqc29uLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XHJcblx0XHRpZiAoIGpzb24uc2lkZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2lkZSA9IGpzb24uc2lkZTtcclxuXHRcdGlmICgganNvbi5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5vcGFjaXR5ID0ganNvbi5vcGFjaXR5O1xyXG5cdFx0aWYgKCBqc29uLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XHJcblx0XHRpZiAoIGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYVRlc3QgPSBqc29uLmFscGhhVGVzdDtcclxuXHRcdGlmICgganNvbi5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoVGVzdCA9IGpzb24uZGVwdGhUZXN0O1xyXG5cdFx0aWYgKCBqc29uLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBqc29uLmRlcHRoV3JpdGU7XHJcblx0XHRpZiAoIGpzb24uY29sb3JXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3JXcml0ZSA9IGpzb24uY29sb3JXcml0ZTtcclxuXHRcdGlmICgganNvbi53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZSA9IGpzb24ud2lyZWZyYW1lO1xyXG5cdFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0ganNvbi53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG5cdFx0Ly8gZm9yIFBvaW50c01hdGVyaWFsXHJcblx0XHRpZiAoIGpzb24uc2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZSA9IGpzb24uc2l6ZTtcclxuXHRcdGlmICgganNvbi5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGpzb24uc2l6ZUF0dGVudWF0aW9uO1xyXG5cclxuXHRcdC8vIG1hcHNcclxuXHJcblx0XHRpZiAoIGpzb24ubWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24ubWFwICk7XHJcblxyXG5cdFx0aWYgKCBqc29uLmFscGhhTWFwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5hbHBoYU1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5hbHBoYU1hcCApO1xyXG5cdFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbi5idW1wTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmJ1bXBNYXAgKTtcclxuXHRcdGlmICgganNvbi5idW1wU2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBTY2FsZSA9IGpzb24uYnVtcFNjYWxlO1xyXG5cclxuXHRcdGlmICgganNvbi5ub3JtYWxNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5vcm1hbE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5ub3JtYWxNYXAgKTtcclxuXHRcdGlmICgganNvbi5ub3JtYWxTY2FsZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIG5vcm1hbFNjYWxlID0ganNvbi5ub3JtYWxTY2FsZTtcclxuXHJcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbm9ybWFsU2NhbGUgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdC8vIEJsZW5kZXIgZXhwb3J0ZXIgdXNlZCB0byBleHBvcnQgYSBzY2FsYXIuIFNlZSAjNzQ1OVxyXG5cclxuXHRcdFx0XHRub3JtYWxTY2FsZSA9IFsgbm9ybWFsU2NhbGUsIG5vcm1hbFNjYWxlIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCkuZnJvbUFycmF5KCBub3JtYWxTY2FsZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uZGlzcGxhY2VtZW50TWFwICk7XHJcblx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50U2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlID0ganNvbi5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRCaWFzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzID0ganNvbi5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuXHRcdGlmICgganNvbi5yb3VnaG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdWdobmVzc01hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5yb3VnaG5lc3NNYXAgKTtcclxuXHRcdGlmICgganNvbi5tZXRhbG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1ldGFsbmVzc01hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5tZXRhbG5lc3NNYXAgKTtcclxuXHJcblx0XHRpZiAoIGpzb24uZW1pc3NpdmVNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmVtaXNzaXZlTWFwICk7XHJcblx0XHRpZiAoIGpzb24uZW1pc3NpdmVJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ID0ganNvbi5lbWlzc2l2ZUludGVuc2l0eTtcclxuXHJcblx0XHRpZiAoIGpzb24uc3BlY3VsYXJNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLnNwZWN1bGFyTWFwICk7XHJcblxyXG5cdFx0aWYgKCBqc29uLmVudk1hcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwuZW52TWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmVudk1hcCApO1xyXG5cdFx0XHRtYXRlcmlhbC5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbi5yZWZsZWN0aXZpdHkgKSBtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSBqc29uLnJlZmxlY3Rpdml0eTtcclxuXHJcblx0XHRpZiAoIGpzb24ubGlnaHRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmxpZ2h0TWFwICk7XHJcblx0XHRpZiAoIGpzb24ubGlnaHRNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5ID0ganNvbi5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0XHRpZiAoIGpzb24uYW9NYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmFvTWFwICk7XHJcblx0XHRpZiAoIGpzb24uYW9NYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0ganNvbi5hb01hcEludGVuc2l0eTtcclxuXHJcblx0XHQvLyBNdWx0aU1hdGVyaWFsXHJcblxyXG5cdFx0aWYgKCBqc29uLm1hdGVyaWFscyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5tYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwubWF0ZXJpYWxzLnB1c2goIHRoaXMucGFyc2UoIGpzb24ubWF0ZXJpYWxzWyBpIF0gKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL09iamVjdExvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuT2JqZWN0TG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHR0aGlzLnRleHR1cmVQYXRoID0gJyc7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuT2JqZWN0TG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk9iamVjdExvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMudGV4dHVyZVBhdGggPT09ICcnICkge1xyXG5cclxuXHRcdFx0dGhpcy50ZXh0dXJlUGF0aCA9IHVybC5zdWJzdHJpbmcoIDAsIHVybC5sYXN0SW5kZXhPZiggJy8nICkgKyAxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICksIG9uTG9hZCApO1xyXG5cclxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlUGF0aCA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKCBqc29uLmdlb21ldHJpZXMgKTtcclxuXHJcblx0XHR2YXIgaW1hZ2VzID0gdGhpcy5wYXJzZUltYWdlcygganNvbi5pbWFnZXMsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0XHR2YXIgdGV4dHVyZXMgID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcclxuXHRcdHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcclxuXHJcblx0XHR2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdCgganNvbi5vYmplY3QsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApO1xyXG5cclxuXHRcdGlmICgganNvbi5hbmltYXRpb25zICkge1xyXG5cclxuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucygganNvbi5hbmltYXRpb25zICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbi5pbWFnZXMgPT09IHVuZGVmaW5lZCB8fCBqc29uLmltYWdlcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJpZXMgPSB7fTtcclxuXHJcblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBnZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5KU09OTG9hZGVyKCk7XHJcblx0XHRcdHZhciBidWZmZXJHZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcigpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZ2VvbWV0cnk7XHJcblx0XHRcdFx0dmFyIGRhdGEgPSBqc29uWyBpIF07XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlICdQbGFuZUdlb21ldHJ5JzpcclxuXHRcdFx0XHRcdGNhc2UgJ1BsYW5lQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUVbIGRhdGEudHlwZSBdKFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEud2lkdGgsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHNcclxuXHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ0JveEdlb21ldHJ5JzpcclxuXHRcdFx0XHRcdGNhc2UgJ0N1YmVHZW9tZXRyeSc6IC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlXHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0LFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGVwdGgsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5kZXB0aFNlZ21lbnRzXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdDaXJjbGVHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdDeWxpbmRlckdlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXNUb3AsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXNCb3R0b20sXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEub3BlbkVuZGVkLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdTcGhlcmVHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdTcGhlcmVCdWZmZXJHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdEb2RlY2FoZWRyb25HZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLmRldGFpbFxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnSWNvc2FoZWRyb25HZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGV0YWlsXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdPY3RhaGVkcm9uR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGV0YWlsXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdUZXRyYWhlZHJvbkdlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5kZXRhaWxcclxuXHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1JpbmdHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5SaW5nR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5pbm5lclJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLm91dGVyUmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdUb3J1c0dlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJlLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5hcmNcclxuXHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1RvcnVzS25vdEdlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudHViZSxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudHVidWxhclNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnEsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTY2FsZVxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnTGF0aGVHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5MYXRoZUdlb21ldHJ5KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucG9pbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuc2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5waGlTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaUxlbmd0aFxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBidWZmZXJHZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBnZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YS5kYXRhLCB0aGlzLnRleHR1cmVQYXRoICkuZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlIFwiJyArIGRhdGEudHlwZSArICdcIicgKTtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyaWVzWyBkYXRhLnV1aWQgXSA9IGdlb21ldHJ5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2VvbWV0cmllcztcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZXMgKSB7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFscyA9IHt9O1xyXG5cclxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5NYXRlcmlhbExvYWRlcigpO1xyXG5cdFx0XHRsb2FkZXIuc2V0VGV4dHVyZXMoIHRleHR1cmVzICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IGxvYWRlci5wYXJzZSgganNvblsgaSBdICk7XHJcblx0XHRcdFx0bWF0ZXJpYWxzWyBtYXRlcmlhbC51dWlkIF0gPSBtYXRlcmlhbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFscztcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VBbmltYXRpb25zOiBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0dmFyIGFuaW1hdGlvbnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjbGlwID0gVEhSRUUuQW5pbWF0aW9uQ2xpcC5wYXJzZSgganNvblsgaSBdICk7XHJcblxyXG5cdFx0XHRhbmltYXRpb25zLnB1c2goIGNsaXAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFuaW1hdGlvbnM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHBhcnNlSW1hZ2VzOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cdFx0dmFyIGltYWdlcyA9IHt9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGxvYWRJbWFnZSggdXJsICkge1xyXG5cclxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dmFyIG1hbmFnZXIgPSBuZXcgVEhSRUUuTG9hZGluZ01hbmFnZXIoIG9uTG9hZCApO1xyXG5cclxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggbWFuYWdlciApO1xyXG5cdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGltYWdlID0ganNvblsgaSBdO1xyXG5cdFx0XHRcdHZhciBwYXRoID0gL14oXFwvXFwvKXwoW2Etel0rOihcXC9cXC8pPykvaS50ZXN0KCBpbWFnZS51cmwgKSA/IGltYWdlLnVybCA6IHNjb3BlLnRleHR1cmVQYXRoICsgaW1hZ2UudXJsO1xyXG5cclxuXHRcdFx0XHRpbWFnZXNbIGltYWdlLnV1aWQgXSA9IGxvYWRJbWFnZSggcGF0aCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW1hZ2VzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJzZVRleHR1cmVzOiBmdW5jdGlvbiAoIGpzb24sIGltYWdlcyApIHtcclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZUNvbnN0YW50KCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdGlmICggdHlwZW9mKCB2YWx1ZSApID09PSAnbnVtYmVyJyApIHJldHVybiB2YWx1ZTtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlci5wYXJzZVRleHR1cmU6IENvbnN0YW50IHNob3VsZCBiZSBpbiBudW1lcmljIGZvcm0uJywgdmFsdWUgKTtcclxuXHJcblx0XHRcdHJldHVybiBUSFJFRVsgdmFsdWUgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRleHR1cmVzID0ge307XHJcblxyXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBkYXRhID0ganNvblsgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEuaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IE5vIFwiaW1hZ2VcIiBzcGVjaWZpZWQgZm9yJywgZGF0YS51dWlkICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGltYWdlJywgZGF0YS5pbWFnZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGltYWdlc1sgZGF0YS5pbWFnZSBdICk7XHJcblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcclxuXHJcblx0XHRcdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubmFtZSA9IGRhdGEubmFtZTtcclxuXHRcdFx0XHRpZiAoIGRhdGEubWFwcGluZyAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYXBwaW5nID0gcGFyc2VDb25zdGFudCggZGF0YS5tYXBwaW5nICk7XHJcblx0XHRcdFx0aWYgKCBkYXRhLm9mZnNldCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5vZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggZGF0YS5vZmZzZXRbIDAgXSwgZGF0YS5vZmZzZXRbIDEgXSApO1xyXG5cdFx0XHRcdGlmICggZGF0YS5yZXBlYXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUucmVwZWF0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGRhdGEucmVwZWF0WyAwIF0sIGRhdGEucmVwZWF0WyAxIF0gKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1pbkZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWluRmlsdGVyICk7XHJcblx0XHRcdFx0aWYgKCBkYXRhLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYWdGaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hZ0ZpbHRlciApO1xyXG5cdFx0XHRcdGlmICggZGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBkYXRhLmFuaXNvdHJvcHk7XHJcblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBkYXRhLndyYXAgKSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAwIF0gKTtcclxuXHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDEgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRleHR1cmVzWyBkYXRhLnV1aWQgXSA9IHRleHR1cmU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlcztcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VPYmplY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0XHR2YXIgb2JqZWN0O1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gZ2V0R2VvbWV0cnkoIG5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cmllc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGdlb21ldHJpZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGdldE1hdGVyaWFsKCBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWxzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIG5hbWUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbWF0ZXJpYWxzWyBuYW1lIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ1NjZW5lJzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU2NlbmUoKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnUGVyc3BlY3RpdmVDYW1lcmEnOlxyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ09ydGhvZ3JhcGhpY0NhbWVyYSc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggZGF0YS5sZWZ0LCBkYXRhLnJpZ2h0LCBkYXRhLnRvcCwgZGF0YS5ib3R0b20sIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnQW1iaWVudExpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmRlY2F5ICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlNwb3RMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuYW5nbGUsIGRhdGEuZXhwb25lbnQsIGRhdGEuZGVjYXkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmdyb3VuZENvbG9yLCBkYXRhLmludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdNZXNoJzpcclxuXHJcblx0XHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApO1xyXG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvbmVzICYmIGdlb21ldHJ5LmJvbmVzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU2tpbm5lZE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdMT0QnOlxyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5MT0QoKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnTGluZSc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkxpbmUoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICksIGRhdGEubW9kZSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdQb2ludENsb3VkJzpcclxuXHRcdFx0XHRjYXNlICdQb2ludHMnOlxyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5Qb2ludHMoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnU3ByaXRlJzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU3ByaXRlKCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ0dyb3VwJzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuR3JvdXAoKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC51dWlkID0gZGF0YS51dWlkO1xyXG5cclxuXHRcdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5uYW1lID0gZGF0YS5uYW1lO1xyXG5cdFx0XHRpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1hdHJpeC5mcm9tQXJyYXkoIGRhdGEubWF0cml4ICk7XHJcblx0XHRcdFx0bWF0cml4LmRlY29tcG9zZSggb2JqZWN0LnBvc2l0aW9uLCBvYmplY3QucXVhdGVybmlvbiwgb2JqZWN0LnNjYWxlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIGRhdGEucG9zaXRpb24gKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5yb3RhdGlvbi5mcm9tQXJyYXkoIGRhdGEucm90YXRpb24gKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEuc2NhbGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zY2FsZS5mcm9tQXJyYXkoIGRhdGEuc2NhbGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZGF0YS5jYXN0U2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuY2FzdFNoYWRvdyA9IGRhdGEuY2FzdFNoYWRvdztcclxuXHRcdFx0aWYgKCBkYXRhLnJlY2VpdmVTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gZGF0YS5yZWNlaXZlU2hhZG93O1xyXG5cclxuXHRcdFx0aWYgKCBkYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xyXG5cdFx0XHRpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG9iamVjdC51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XHJcblxyXG5cdFx0XHRpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGNoaWxkIGluIGRhdGEuY2hpbGRyZW4gKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0LmFkZCggdGhpcy5wYXJzZU9iamVjdCggZGF0YS5jaGlsZHJlblsgY2hpbGQgXSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBkYXRhLnR5cGUgPT09ICdMT0QnICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbGV2ZWxzID0gZGF0YS5sZXZlbHM7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzWyBsIF07XHJcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBvYmplY3QuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ3V1aWQnLCBsZXZlbC5vYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNoaWxkICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QuYWRkTGV2ZWwoIGNoaWxkLCBsZXZlbC5kaXN0YW5jZSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0oKVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvVGV4dHVyZUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoKTtcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xyXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBpbWFnZSApIHtcclxuXHJcblx0XHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZTtcclxuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvQ3ViZVRleHR1cmVMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJlVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmxzLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtdICk7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcclxuXHJcblx0XHR2YXIgbG9hZGVkID0gMDtcclxuXHJcblx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcclxuXHJcblx0XHRcdGxvYWRlci5sb2FkKCB1cmxzWyBpIF0sIGZ1bmN0aW9uICggaW1hZ2UgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuaW1hZ2VzWyBpIF0gPSBpbWFnZTtcclxuXHJcblx0XHRcdFx0bG9hZGVkICsrO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRsb2FkVGV4dHVyZSggaSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMucGF0aCA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9CaW5hcnlUZXh0dXJlTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBOaWtvcyBNLiAvIGh0dHBzOi8vZ2l0aHViLmNvbS9mb28xMjMvXHJcbiAqXHJcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gbG9hZCBnZW5lcmljIGJpbmFyeSB0ZXh0dXJlcyBmb3JtYXRzIChyZ2JlLCBoZHIsIC4uLilcclxuICovXHJcblxyXG5USFJFRS5EYXRhVGV4dHVyZUxvYWRlciA9IFRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxuXHQvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xyXG5cdHRoaXMuX3BhcnNlciA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoKTtcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XHJcblxyXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGV4RGF0YSA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciApO1xyXG5cclxuXHRcdFx0aWYgKCAhIHRleERhdGEgKSByZXR1cm47XHJcblxyXG5cdFx0XHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5pbWFnZSApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IHRleERhdGEuaW1hZ2U7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZGF0YSApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGEud2lkdGg7XHJcblx0XHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhLmhlaWdodDtcclxuXHRcdFx0XHR0ZXh0dXJlLmltYWdlLmRhdGEgPSB0ZXhEYXRhLmRhdGE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0ZXh0dXJlLndyYXBTID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBTID8gdGV4RGF0YS53cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblx0XHRcdHRleHR1cmUud3JhcFQgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFQgPyB0ZXhEYXRhLndyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuXHJcblx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1hZ0ZpbHRlciA/IHRleERhdGEubWFnRmlsdGVyIDogVEhSRUUuTGluZWFyRmlsdGVyO1xyXG5cdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taW5GaWx0ZXIgPyB0ZXhEYXRhLm1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcclxuXHJcblx0XHRcdHRleHR1cmUuYW5pc290cm9weSA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5hbmlzb3Ryb3B5ID8gdGV4RGF0YS5hbmlzb3Ryb3B5IDogMTtcclxuXHJcblx0XHRcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmZvcm1hdCApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhLmZvcm1hdDtcclxuXHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEudHlwZSApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS50eXBlID0gdGV4RGF0YS50eXBlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEubWlwbWFwcyApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YS5taXBtYXBzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCAxID09PSB0ZXhEYXRhLm1pcG1hcENvdW50ICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUsIHRleERhdGEgKTtcclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9Db21wcmVzc2VkVGV4dHVyZUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqXHJcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gYmxvY2sgYmFzZWQgdGV4dHVyZXMgbG9hZGVyIChkZHMsIHB2ciwgLi4uKVxyXG4gKi9cclxuXHJcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcblx0Ly8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcclxuXHR0aGlzLl9wYXJzZXIgPSBudWxsO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBpbWFnZXMgPSBbXTtcclxuXHJcblx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSgpO1xyXG5cdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlcztcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XHJcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIGkgKSB7XHJcblxyXG5cdFx0XHRsb2FkZXIubG9hZCggdXJsWyBpIF0sIGZ1bmN0aW9uICggYnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcclxuXHJcblx0XHRcdFx0aW1hZ2VzWyBpIF0gPSB7XHJcblx0XHRcdFx0XHR3aWR0aDogdGV4RGF0YXMud2lkdGgsXHJcblx0XHRcdFx0XHRoZWlnaHQ6IHRleERhdGFzLmhlaWdodCxcclxuXHRcdFx0XHRcdGZvcm1hdDogdGV4RGF0YXMuZm9ybWF0LFxyXG5cdFx0XHRcdFx0bWlwbWFwczogdGV4RGF0YXMubWlwbWFwc1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGxvYWRlZCArPSAxO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxIClcclxuXHRcdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XHJcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdXJsICkgKSB7XHJcblxyXG5cdFx0XHR2YXIgbG9hZGVkID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB1cmwubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdGxvYWRUZXh0dXJlKCBpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBERFMgZmlsZVxyXG5cclxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleERhdGFzLmlzQ3ViZW1hcCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgZmFjZXMgPSB0ZXhEYXRhcy5taXBtYXBzLmxlbmd0aCAvIHRleERhdGFzLm1pcG1hcENvdW50O1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBmID0gMDsgZiA8IGZhY2VzOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0gPSB7IG1pcG1hcHMgOiBbXSB9O1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGV4RGF0YXMubWlwbWFwQ291bnQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLm1pcG1hcHMucHVzaCggdGV4RGF0YXMubWlwbWFwc1sgZiAqIHRleERhdGFzLm1pcG1hcENvdW50ICsgaSBdICk7XHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xyXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XHJcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcclxuXHRcdFx0XHRcdHRleHR1cmUubWlwbWFwcyA9IHRleERhdGFzLm1pcG1hcHM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcclxuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5wYXRoID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk1hdGVyaWFsID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLk1hdGVyaWFsSWRDb3VudCArKyB9ICk7XHJcblxyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cdHRoaXMudHlwZSA9ICdNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMuc2lkZSA9IFRIUkVFLkZyb250U2lkZTtcclxuXHJcblx0dGhpcy5vcGFjaXR5ID0gMTtcclxuXHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuYmxlbmRpbmcgPSBUSFJFRS5Ob3JtYWxCbGVuZGluZztcclxuXHJcblx0dGhpcy5ibGVuZFNyYyA9IFRIUkVFLlNyY0FscGhhRmFjdG9yO1xyXG5cdHRoaXMuYmxlbmREc3QgPSBUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yO1xyXG5cdHRoaXMuYmxlbmRFcXVhdGlvbiA9IFRIUkVFLkFkZEVxdWF0aW9uO1xyXG5cdHRoaXMuYmxlbmRTcmNBbHBoYSA9IG51bGw7XHJcblx0dGhpcy5ibGVuZERzdEFscGhhID0gbnVsbDtcclxuXHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XHJcblxyXG5cdHRoaXMuZGVwdGhGdW5jID0gVEhSRUUuTGVzc0VxdWFsRGVwdGg7XHJcblx0dGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xyXG5cdHRoaXMuZGVwdGhXcml0ZSA9IHRydWU7XHJcblxyXG5cdHRoaXMuY29sb3JXcml0ZSA9IHRydWU7XHJcblxyXG5cdHRoaXMucHJlY2lzaW9uID0gbnVsbDsgLy8gb3ZlcnJpZGUgdGhlIHJlbmRlcmVyJ3MgZGVmYXVsdCBwcmVjaXNpb24gZm9yIHRoaXMgbWF0ZXJpYWxcclxuXHJcblx0dGhpcy5wb2x5Z29uT2Zmc2V0ID0gZmFsc2U7XHJcblx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcclxuXHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XHJcblxyXG5cdHRoaXMuYWxwaGFUZXN0ID0gMDtcclxuXHJcblx0dGhpcy5vdmVyZHJhdyA9IDA7IC8vIE92ZXJkcmF3biBwaXhlbHMgKHR5cGljYWxseSBiZXR3ZWVuIDAgYW5kIDEpIGZvciBmaXhpbmcgYW50aWFsaWFzaW5nIGdhcHMgaW4gQ2FudmFzUmVuZGVyZXJcclxuXHJcblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdGVyaWFsLFxyXG5cclxuXHRnZXQgbmVlZHNVcGRhdGUgKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9uZWVkc1VwZGF0ZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IG5lZWRzVXBkYXRlICggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5fbmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0VmFsdWVzOiBmdW5jdGlvbiAoIHZhbHVlcyApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlcyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdGZvciAoIHZhciBrZXkgaW4gdmFsdWVzICkge1xyXG5cclxuXHRcdFx0dmFyIG5ld1ZhbHVlID0gdmFsdWVzWyBrZXkgXTtcclxuXHJcblx0XHRcdGlmICggbmV3VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLk1hdGVyaWFsOiAnXCIgKyBrZXkgKyBcIicgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZC5cIiApO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXNbIGtleSBdO1xyXG5cclxuXHRcdFx0aWYgKCBjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLlwiICsgdGhpcy50eXBlICsgXCI6ICdcIiArIGtleSArIFwiJyBpcyBub3QgYSBwcm9wZXJ0eSBvZiB0aGlzIG1hdGVyaWFsLlwiICk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkge1xyXG5cclxuXHRcdFx0XHRjdXJyZW50VmFsdWUuc2V0KCBuZXdWYWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyAmJiBuZXdWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgKSB7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5jb3B5KCBuZXdWYWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICgga2V5ID09PSAnb3ZlcmRyYXcnICkge1xyXG5cclxuXHRcdFx0XHQvLyBlbnN1cmUgb3ZlcmRyYXcgaXMgYmFja3dhcmRzLWNvbXBhdGlibGUgd2l0aCBsZWdhY3kgYm9vbGVhbiB0eXBlXHJcblx0XHRcdFx0dGhpc1sga2V5IF0gPSBOdW1iZXIoIG5ld1ZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzWyBrZXkgXSA9IG5ld1ZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdFx0dmFyIGlzUm9vdCA9IG1ldGEgPT09IHVuZGVmaW5lZDtcclxuXHJcblx0XHRpZiAoIGlzUm9vdCApIHtcclxuXHJcblx0XHRcdG1ldGEgPSB7XHJcblx0XHRcdFx0dGV4dHVyZXM6IHt9LFxyXG5cdFx0XHRcdGltYWdlczoge31cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdG1ldGFkYXRhOiB7XHJcblx0XHRcdFx0dmVyc2lvbjogNC40LFxyXG5cdFx0XHRcdHR5cGU6ICdNYXRlcmlhbCcsXHJcblx0XHRcdFx0Z2VuZXJhdG9yOiAnTWF0ZXJpYWwudG9KU09OJ1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIHN0YW5kYXJkIE1hdGVyaWFsIHNlcmlhbGl6YXRpb25cclxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcclxuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcclxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcclxuXHJcblx0XHRpZiAoIHRoaXMuY29sb3IgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xyXG5cclxuXHRcdGlmICggdGhpcy5yb3VnaG5lc3MgIT09IDAuNSApIGRhdGEucm91Z2huZXNzID0gdGhpcy5yb3VnaG5lc3M7XHJcblx0XHRpZiAoIHRoaXMubWV0YWxuZXNzICE9PSAwLjUgKSBkYXRhLm1ldGFsbmVzcyA9IHRoaXMubWV0YWxuZXNzO1xyXG5cclxuXHRcdGlmICggdGhpcy5lbWlzc2l2ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkgZGF0YS5lbWlzc2l2ZSA9IHRoaXMuZW1pc3NpdmUuZ2V0SGV4KCk7XHJcblx0XHRpZiAoIHRoaXMuc3BlY3VsYXIgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyLmdldEhleCgpO1xyXG5cdFx0aWYgKCB0aGlzLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcclxuXHJcblx0XHRpZiAoIHRoaXMubWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubWFwID0gdGhpcy5tYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdGlmICggdGhpcy5hbHBoYU1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLmFscGhhTWFwID0gdGhpcy5hbHBoYU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0aWYgKCB0aGlzLmxpZ2h0TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblx0XHRpZiAoIHRoaXMuYnVtcE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdFx0ZGF0YS5idW1wU2NhbGUgPSB0aGlzLmJ1bXBTY2FsZTtcclxuXHJcblx0XHR9XHJcblx0XHRpZiAoIHRoaXMubm9ybWFsTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGRhdGEubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdFx0ZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGUudG9BcnJheSgpO1xyXG5cclxuXHRcdH1cclxuXHRcdGlmICggdGhpcy5kaXNwbGFjZW1lbnRNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xyXG5cclxuXHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmRpc3BsYWNlbWVudE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0XHRkYXRhLmRpc3BsYWNlbWVudFNjYWxlID0gdGhpcy5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRCaWFzID0gdGhpcy5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuXHRcdH1cclxuXHRcdGlmICggdGhpcy5yb3VnaG5lc3NNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5yb3VnaG5lc3NNYXAgPSB0aGlzLnJvdWdobmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0aWYgKCB0aGlzLm1ldGFsbmVzc01hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLm1ldGFsbmVzc01hcCA9IHRoaXMubWV0YWxuZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmVtaXNzaXZlTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEuZW1pc3NpdmVNYXAgPSB0aGlzLmVtaXNzaXZlTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblx0XHRpZiAoIHRoaXMuc3BlY3VsYXJNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHJcblx0XHRpZiAoIHRoaXMuZW52TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGRhdGEuZW52TWFwID0gdGhpcy5lbnZNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdFx0ZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTsgLy8gU2NhbGUgYmVoaW5kIGVudk1hcFxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplID0gdGhpcy5zaXplO1xyXG5cdFx0aWYgKCB0aGlzLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplQXR0ZW51YXRpb24gPSB0aGlzLnNpemVBdHRlbnVhdGlvbjtcclxuXHJcblx0XHRpZiAoIHRoaXMudmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgJiYgdGhpcy52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkgZGF0YS52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcclxuXHRcdGlmICggdGhpcy5zaGFkaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zaGFkaW5nICE9PSBUSFJFRS5TbW9vdGhTaGFkaW5nICkgZGF0YS5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xyXG5cdFx0aWYgKCB0aGlzLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ibGVuZGluZyAhPT0gVEhSRUUuTm9ybWFsQmxlbmRpbmcgKSBkYXRhLmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcclxuXHRcdGlmICggdGhpcy5zaWRlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zaWRlICE9PSBUSFJFRS5Gcm9udFNpZGUgKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm9wYWNpdHkgPCAxICkgZGF0YS5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xyXG5cdFx0aWYgKCB0aGlzLnRyYW5zcGFyZW50ID09PSB0cnVlICkgZGF0YS50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XHJcblx0XHRpZiAoIHRoaXMuYWxwaGFUZXN0ID4gMCApIGRhdGEuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3Q7XHJcblx0XHRpZiAoIHRoaXMud2lyZWZyYW1lID09PSB0cnVlICkgZGF0YS53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcclxuXHRcdGlmICggdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPiAxICkgZGF0YS53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcblx0XHQvLyBUT0RPOiBDb3BpZWQgZnJvbSBPYmplY3QzRC50b0pTT05cclxuXHJcblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlICggY2FjaGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmFsdWVzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIGNhY2hlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZGF0YSA9IGNhY2hlWyBrZXkgXTtcclxuXHRcdFx0XHRkZWxldGUgZGF0YS5tZXRhZGF0YTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaCggZGF0YSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpc1Jvb3QgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XHJcblx0XHRcdHZhciBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgZGF0YS50ZXh0dXJlcyA9IHRleHR1cmVzO1xyXG5cdFx0XHRpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgZGF0YS5pbWFnZXMgPSBpbWFnZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblxyXG5cdFx0dGhpcy5zaWRlID0gc291cmNlLnNpZGU7XHJcblxyXG5cdFx0dGhpcy5vcGFjaXR5ID0gc291cmNlLm9wYWNpdHk7XHJcblx0XHR0aGlzLnRyYW5zcGFyZW50ID0gc291cmNlLnRyYW5zcGFyZW50O1xyXG5cclxuXHRcdHRoaXMuYmxlbmRpbmcgPSBzb3VyY2UuYmxlbmRpbmc7XHJcblxyXG5cdFx0dGhpcy5ibGVuZFNyYyA9IHNvdXJjZS5ibGVuZFNyYztcclxuXHRcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XHJcblx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBzb3VyY2UuYmxlbmRFcXVhdGlvbjtcclxuXHRcdHRoaXMuYmxlbmRTcmNBbHBoYSA9IHNvdXJjZS5ibGVuZFNyY0FscGhhO1xyXG5cdFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XHJcblx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uQWxwaGE7XHJcblxyXG5cdFx0dGhpcy5kZXB0aEZ1bmMgPSBzb3VyY2UuZGVwdGhGdW5jO1xyXG5cdFx0dGhpcy5kZXB0aFRlc3QgPSBzb3VyY2UuZGVwdGhUZXN0O1xyXG5cdFx0dGhpcy5kZXB0aFdyaXRlID0gc291cmNlLmRlcHRoV3JpdGU7XHJcblxyXG5cdFx0dGhpcy5jb2xvcldyaXRlID0gc291cmNlLmNvbG9yV3JpdGU7XHJcblxyXG5cdFx0dGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xyXG5cclxuXHRcdHRoaXMucG9seWdvbk9mZnNldCA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0O1xyXG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gc291cmNlLnBvbHlnb25PZmZzZXRGYWN0b3I7XHJcblx0XHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XHJcblxyXG5cdFx0dGhpcy5hbHBoYVRlc3QgPSBzb3VyY2UuYWxwaGFUZXN0O1xyXG5cclxuXHRcdHRoaXMub3ZlcmRyYXcgPSBzb3VyY2Uub3ZlcmRyYXc7XHJcblxyXG5cdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAndXBkYXRlJyB9ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTWF0ZXJpYWxJZENvdW50ID0gMDtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqICBsaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAqICBsaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD5cclxuICpcclxuICogIGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnTGluZUJhc2ljTWF0ZXJpYWwnO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cclxuXHR0aGlzLmxpbmV3aWR0aCA9IDE7XHJcblx0dGhpcy5saW5lY2FwID0gJ3JvdW5kJztcclxuXHR0aGlzLmxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbDtcclxuXHJcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cclxuXHR0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XHJcblx0dGhpcy5saW5lY2FwID0gc291cmNlLmxpbmVjYXA7XHJcblx0dGhpcy5saW5lam9pbiA9IHNvdXJjZS5saW5lam9pbjtcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xyXG5cclxuXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9MaW5lRGFzaGVkTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2NhbGU6IDxmbG9hdD4sXHJcbiAqICBkYXNoU2l6ZTogPGZsb2F0PixcclxuICogIGdhcFNpemU6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9yc1xyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnTGluZURhc2hlZE1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHJcblx0dGhpcy5saW5ld2lkdGggPSAxO1xyXG5cclxuXHR0aGlzLnNjYWxlID0gMTtcclxuXHR0aGlzLmRhc2hTaXplID0gMztcclxuXHR0aGlzLmdhcFNpemUgPSAxO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLmZvZyA9IHRydWU7XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsO1xyXG5cclxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cdFxyXG5cdHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcclxuXHJcblx0dGhpcy5zY2FsZSA9IHNvdXJjZS5zY2FsZTtcclxuXHR0aGlzLmRhc2hTaXplID0gc291cmNlLmRhc2hTaXplO1xyXG5cdHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdHRoaXMuZm9nID0gc291cmNlLmZvZztcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hCYXNpY01hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGVtaXNzaXZlXHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5hb01hcCA9IG51bGw7XHJcblx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IG51bGw7XHJcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xyXG5cdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XHJcblxyXG5cdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XHJcblxyXG5cdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XHJcblxyXG5cdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcclxuXHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcclxuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XHJcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xyXG5cclxuXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcblx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoTGFtYmVydE1hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICBlbWlzc2l2ZTogPGhleD4sXHJcbiAqICBlbWlzc2l2ZUludGVuc2l0eTogPGZsb2F0PlxyXG4gKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXHJcbiAqXHJcbiAqICBza2lubmluZzogPGJvb2w+LFxyXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXHJcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcclxuICpcclxuICpcdGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxyXG5cclxuXHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMubGlnaHRNYXAgPSBudWxsO1xyXG5cdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdHRoaXMuYW9NYXAgPSBudWxsO1xyXG5cdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcclxuXHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IG51bGw7XHJcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbDtcclxuXHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblxyXG5cdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcblx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcclxuXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xyXG5cclxuXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xyXG5cdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XHJcblxyXG5cdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XHJcblx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcclxuXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xyXG5cclxuXHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xyXG5cclxuXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XHJcblx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcclxuXHJcblx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcblx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaFBob25nTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgc3BlY3VsYXI6IDxoZXg+LFxyXG4gKiAgc2hpbmluZXNzOiA8ZmxvYXQ+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cclxuICpcclxuICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cclxuICpcclxuICogIGVtaXNzaXZlOiA8aGV4PixcclxuICogIGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqICBlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqICBidW1wU2NhbGU6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqICBub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxyXG4gKlxyXG4gKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXHJcbiAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcclxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxyXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxyXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcclxuICpcclxuICogIHNraW5uaW5nOiA8Ym9vbD4sXHJcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcclxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxyXG4gKlxyXG4gKlx0Zm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcclxuXHR0aGlzLnNwZWN1bGFyID0gbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApO1xyXG5cdHRoaXMuc2hpbmluZXNzID0gMzA7XHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5saWdodE1hcCA9IG51bGw7XHJcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0dGhpcy5hb01hcCA9IG51bGw7XHJcblx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcclxuXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xyXG5cdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xyXG5cdHRoaXMuYnVtcFNjYWxlID0gMTtcclxuXHJcblx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xyXG5cdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XHJcblx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XHJcblx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcclxuXHJcblx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IG51bGw7XHJcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDtcclxuXHJcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cdHRoaXMuc3BlY3VsYXIuY29weSggc291cmNlLnNwZWN1bGFyICk7XHJcblx0dGhpcy5zaGluaW5lc3MgPSBzb3VyY2Uuc2hpbmluZXNzO1xyXG5cclxuXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG5cdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XHJcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcclxuXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuXHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xyXG5cdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XHJcblx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcclxuXHJcblx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XHJcblx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xyXG5cclxuXHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XHJcblx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xyXG5cdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XHJcblxyXG5cdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XHJcblxyXG5cdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcclxuXHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcclxuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XHJcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xyXG5cclxuXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcblx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaFN0YW5kYXJkTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIHJvdWdobmVzczogPGZsb2F0PixcclxuICogIG1ldGFsbmVzczogPGZsb2F0PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICBlbWlzc2l2ZTogPGhleD4sXHJcbiAqICBlbWlzc2l2ZUludGVuc2l0eTogPGZsb2F0PlxyXG4gKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgbm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcclxuICpcclxuICogIGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxyXG4gKiAgZGlzcGxhY2VtZW50QmlhczogPGZsb2F0PixcclxuICpcclxuICogIHJvdWdobmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIG1ldGFsbmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgZW52TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHRmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxyXG5cdHRoaXMucm91Z2huZXNzID0gMC41O1xyXG5cdHRoaXMubWV0YWxuZXNzID0gMC41O1xyXG5cclxuXHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMubGlnaHRNYXAgPSBudWxsO1xyXG5cdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdHRoaXMuYW9NYXAgPSBudWxsO1xyXG5cdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcclxuXHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5idW1wTWFwID0gbnVsbDtcclxuXHR0aGlzLmJ1bXBTY2FsZSA9IDE7XHJcblxyXG5cdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcclxuXHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcclxuXHJcblx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xyXG5cdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xyXG5cdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XHJcblxyXG5cdHRoaXMucm91Z2huZXNzTWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5tZXRhbG5lc3NNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5lbnZNYXAgPSBudWxsO1xyXG5cdHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gMS4wO1xyXG5cclxuXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XHJcblxyXG5cdHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcclxuXHJcblx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHR0aGlzLnJvdWdobmVzcyA9IHNvdXJjZS5yb3VnaG5lc3M7XHJcblx0dGhpcy5tZXRhbG5lc3MgPSBzb3VyY2UubWV0YWxuZXNzO1xyXG5cclxuXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG5cdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XHJcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcclxuXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuXHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xyXG5cdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XHJcblx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcclxuXHJcblx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XHJcblx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xyXG5cclxuXHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XHJcblx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xyXG5cdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdHRoaXMucm91Z2huZXNzTWFwID0gc291cmNlLnJvdWdobmVzc01hcDtcclxuXHJcblx0dGhpcy5tZXRhbG5lc3NNYXAgPSBzb3VyY2UubWV0YWxuZXNzTWFwO1xyXG5cclxuXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XHJcblx0dGhpcy5lbnZNYXBJbnRlbnNpdHkgPSBzb3VyY2UuZW52TWFwSW50ZW5zaXR5O1xyXG5cclxuXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdHRoaXMuZm9nID0gc291cmNlLmZvZztcclxuXHJcblx0dGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoRGVwdGhNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ01lc2hEZXB0aE1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hOb3JtYWxNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmcsXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ01lc2hOb3JtYWxNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbDtcclxuXHJcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL011bHRpTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk11bHRpTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIG1hdGVyaWFscyApIHtcclxuXHJcblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ011bHRpTWF0ZXJpYWwnO1xyXG5cclxuXHR0aGlzLm1hdGVyaWFscyA9IG1hdGVyaWFscyBpbnN0YW5jZW9mIEFycmF5ID8gbWF0ZXJpYWxzIDogW107XHJcblxyXG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTXVsdGlNYXRlcmlhbC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5NdWx0aU1hdGVyaWFsLFxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0XHR2YXIgb3V0cHV0ID0ge1xyXG5cdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdHZlcnNpb246IDQuMixcclxuXHRcdFx0XHR0eXBlOiAnbWF0ZXJpYWwnLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ01hdGVyaWFsRXhwb3J0ZXInXHJcblx0XHRcdH0sXHJcblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcclxuXHRcdFx0dHlwZTogdGhpcy50eXBlLFxyXG5cdFx0XHRtYXRlcmlhbHM6IFtdXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBtYXRlcmlhbHMgPSB0aGlzLm1hdGVyaWFscztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBtYXRlcmlhbCA9IG1hdGVyaWFsc1sgaSBdLnRvSlNPTiggbWV0YSApO1xyXG5cdFx0XHRkZWxldGUgbWF0ZXJpYWwubWV0YWRhdGE7XHJcblxyXG5cdFx0XHRvdXRwdXQubWF0ZXJpYWxzLnB1c2goIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG91dHB1dC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xyXG5cclxuXHRcdHJldHVybiBvdXRwdXQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm1hdGVyaWFscy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5tYXRlcmlhbHMucHVzaCggdGhpcy5tYXRlcmlhbHNbIGkgXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG1hdGVyaWFsLnZpc2libGUgPSB0aGlzLnZpc2libGU7XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1BvaW50c01hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBzaXplOiA8ZmxvYXQ+LFxyXG4gKiAgc2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHZlcnRleENvbG9yczogPGJvb2w+LFxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLlBvaW50c01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQb2ludHNNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5zaXplID0gMTtcclxuXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XHJcblxyXG5cdHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRzTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuXHR0aGlzLnNpemUgPSBzb3VyY2Uuc2l6ZTtcclxuXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcblx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvU2hhZGVyTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgZGVmaW5lczogeyBcImxhYmVsXCIgOiBcInZhbHVlXCIgfSxcclxuICogIHVuaWZvcm1zOiB7IFwicGFyYW1ldGVyMVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sIFwicGFyYW1ldGVyMlwiOiB7IHR5cGU6IFwiaVwiIHZhbHVlMjogMiB9IH0sXHJcbiAqXHJcbiAqICBmcmFnbWVudFNoYWRlcjogPHN0cmluZz4sXHJcbiAqICB2ZXJ0ZXhTaGFkZXI6IDxzdHJpbmc+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBsaWdodHM6IDxib29sPixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHRmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1NoYWRlck1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5kZWZpbmVzID0ge307XHJcblx0dGhpcy51bmlmb3JtcyA9IHt9O1xyXG5cclxuXHR0aGlzLnZlcnRleFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn0nO1xyXG5cdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xcbn0nO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR0aGlzLmxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cclxuXHR0aGlzLmZvZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGZvZ1xyXG5cclxuXHR0aGlzLmxpZ2h0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGxpZ2h0c1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzOyAvLyBzZXQgdG8gdXNlIFwiY29sb3JcIiBhdHRyaWJ1dGUgc3RyZWFtXHJcblxyXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBza2lubmluZyBhdHRyaWJ1dGUgc3RyZWFtc1xyXG5cclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIHRhcmdldHNcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0dGhpcy5leHRlbnNpb25zID0ge1xyXG5cdFx0ZGVyaXZhdGl2ZXM6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGRlcml2YXRpdmVzXHJcblx0XHRmcmFnRGVwdGg6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGZyYWdtZW50IGRlcHRoIHZhbHVlc1xyXG5cdFx0ZHJhd0J1ZmZlcnM6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGRyYXcgYnVmZmVyc1xyXG5cdFx0c2hhZGVyVGV4dHVyZUxPRDogZmFsc2UgLy8gc2V0IHRvIHVzZSBzaGFkZXIgdGV4dHVyZSBMT0RcclxuXHR9O1xyXG5cclxuXHQvLyBXaGVuIHJlbmRlcmVkIGdlb21ldHJ5IGRvZXNuJ3QgaW5jbHVkZSB0aGVzZSBhdHRyaWJ1dGVzIGJ1dCB0aGUgbWF0ZXJpYWwgZG9lcyxcclxuXHQvLyB1c2UgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaW4gV2ViR0wuIFRoaXMgYXZvaWRzIGVycm9ycyB3aGVuIGJ1ZmZlciBkYXRhIGlzIG1pc3NpbmcuXHJcblx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xyXG5cdFx0J2NvbG9yJzogWyAxLCAxLCAxIF0sXHJcblx0XHQndXYnOiBbIDAsIDAgXSxcclxuXHRcdCd1djInOiBbIDAsIDAgXVxyXG5cdH07XHJcblxyXG5cdHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcclxuXHJcblx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TaGFkZXJNYXRlcmlhbDogYXR0cmlidXRlcyBzaG91bGQgbm93IGJlIGRlZmluZWQgaW4gVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2hhZGVyTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5mcmFnbWVudFNoYWRlciA9IHNvdXJjZS5mcmFnbWVudFNoYWRlcjtcclxuXHR0aGlzLnZlcnRleFNoYWRlciA9IHNvdXJjZS52ZXJ0ZXhTaGFkZXI7XHJcblxyXG5cdHRoaXMudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBzb3VyY2UudW5pZm9ybXMgKTtcclxuXHJcblx0dGhpcy5kZWZpbmVzID0gc291cmNlLmRlZmluZXM7XHJcblxyXG5cdHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cclxuXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xyXG5cclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xyXG5cclxuXHR0aGlzLmV4dGVuc2lvbnMgPSBzb3VyY2UuZXh0ZW5zaW9ucztcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0dmFyIGRhdGEgPSBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcblx0ZGF0YS51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XHJcblx0ZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcclxuXHRkYXRhLmZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNoYWRlcjtcclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1Jhd1NoYWRlck1hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuU2hhZGVyTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnUmF3U2hhZGVyTWF0ZXJpYWwnO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5SYXdTaGFkZXJNYXRlcmlhbDtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9TcHJpdGVNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHR1dk9mZnNldDogbmV3IFRIUkVFLlZlY3RvcjIoKSxcclxuICpcdHV2U2NhbGU6IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcbiAqXHJcbiAqICBmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1Nwcml0ZU1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMucm90YXRpb24gPSAwO1xyXG5cclxuXHR0aGlzLmZvZyA9IGZhbHNlO1xyXG5cclxuXHQvLyBzZXQgcGFyYW1ldGVyc1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcHJpdGVNYXRlcmlhbDtcclxuXHJcblRIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcblx0dGhpcy5yb3RhdGlvbiA9IHNvdXJjZS5yb3RhdGlvbjtcclxuXHJcblx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9UZXh0dXJlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xyXG4gKi9cclxuXHJcblRIUkVFLlRleHR1cmUgPSBmdW5jdGlvbiAoIGltYWdlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuVGV4dHVyZUlkQ291bnQgKysgfSApO1xyXG5cclxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHR0aGlzLnNvdXJjZUZpbGUgPSAnJztcclxuXHJcblx0dGhpcy5pbWFnZSA9IGltYWdlICE9PSB1bmRlZmluZWQgPyBpbWFnZSA6IFRIUkVFLlRleHR1cmUuREVGQVVMVF9JTUFHRTtcclxuXHR0aGlzLm1pcG1hcHMgPSBbXTtcclxuXHJcblx0dGhpcy5tYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IFRIUkVFLlRleHR1cmUuREVGQVVMVF9NQVBQSU5HO1xyXG5cclxuXHR0aGlzLndyYXBTID0gd3JhcFMgIT09IHVuZGVmaW5lZCA/IHdyYXBTIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuXHR0aGlzLndyYXBUID0gd3JhcFQgIT09IHVuZGVmaW5lZCA/IHdyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuXHJcblx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xyXG5cclxuXHR0aGlzLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyBhbmlzb3Ryb3B5IDogMTtcclxuXHJcblx0dGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFRIUkVFLlJHQkFGb3JtYXQ7XHJcblx0dGhpcy50eXBlID0gdHlwZSAhPT0gdW5kZWZpbmVkID8gdHlwZSA6IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGU7XHJcblxyXG5cdHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcclxuXHR0aGlzLnJlcGVhdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XHJcblxyXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcclxuXHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZTtcclxuXHR0aGlzLmZsaXBZID0gdHJ1ZTtcclxuXHR0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7IC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxyXG5cclxuXHR0aGlzLnZlcnNpb24gPSAwO1xyXG5cdHRoaXMub25VcGRhdGUgPSBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRleHR1cmUuREVGQVVMVF9JTUFHRSA9IHVuZGVmaW5lZDtcclxuVEhSRUUuVGV4dHVyZS5ERUZBVUxUX01BUFBJTkcgPSBUSFJFRS5VVk1hcHBpbmc7XHJcblxyXG5USFJFRS5UZXh0dXJlLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmUsXHJcblxyXG5cdHNldCBuZWVkc1VwZGF0ZSAoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLmltYWdlID0gc291cmNlLmltYWdlO1xyXG5cdFx0dGhpcy5taXBtYXBzID0gc291cmNlLm1pcG1hcHMuc2xpY2UoIDAgKTtcclxuXHJcblx0XHR0aGlzLm1hcHBpbmcgPSBzb3VyY2UubWFwcGluZztcclxuXHJcblx0XHR0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xyXG5cdFx0dGhpcy53cmFwVCA9IHNvdXJjZS53cmFwVDtcclxuXHJcblx0XHR0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XHJcblx0XHR0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XHJcblxyXG5cdFx0dGhpcy5hbmlzb3Ryb3B5ID0gc291cmNlLmFuaXNvdHJvcHk7XHJcblxyXG5cdFx0dGhpcy5mb3JtYXQgPSBzb3VyY2UuZm9ybWF0O1xyXG5cdFx0dGhpcy50eXBlID0gc291cmNlLnR5cGU7XHJcblxyXG5cdFx0dGhpcy5vZmZzZXQuY29weSggc291cmNlLm9mZnNldCApO1xyXG5cdFx0dGhpcy5yZXBlYXQuY29weSggc291cmNlLnJlcGVhdCApO1xyXG5cclxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gc291cmNlLmdlbmVyYXRlTWlwbWFwcztcclxuXHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBseUFscGhhO1xyXG5cdFx0dGhpcy5mbGlwWSA9IHNvdXJjZS5mbGlwWTtcclxuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gc291cmNlLnVucGFja0FsaWdubWVudDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdFx0aWYgKCBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXREYXRhVVJMKCBpbWFnZSApIHtcclxuXHJcblx0XHRcdHZhciBjYW52YXM7XHJcblxyXG5cdFx0XHRpZiAoIGltYWdlLnRvRGF0YVVSTCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjYW52YXMgPSBpbWFnZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0XHRcdFx0Y2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XHJcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuXHJcblx0XHRcdFx0Y2FudmFzLmdldENvbnRleHQoICcyZCcgKS5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGNhbnZhcy53aWR0aCA+IDIwNDggfHwgY2FudmFzLmhlaWdodCA+IDIwNDggKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvanBlZycsIDAuNiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9wbmcnICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvdXRwdXQgPSB7XHJcblx0XHRcdG1ldGFkYXRhOiB7XHJcblx0XHRcdFx0dmVyc2lvbjogNC40LFxyXG5cdFx0XHRcdHR5cGU6ICdUZXh0dXJlJyxcclxuXHRcdFx0XHRnZW5lcmF0b3I6ICdUZXh0dXJlLnRvSlNPTidcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcclxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxyXG5cclxuXHRcdFx0bWFwcGluZzogdGhpcy5tYXBwaW5nLFxyXG5cclxuXHRcdFx0cmVwZWF0OiBbIHRoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnkgXSxcclxuXHRcdFx0b2Zmc2V0OiBbIHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnkgXSxcclxuXHRcdFx0d3JhcDogWyB0aGlzLndyYXBTLCB0aGlzLndyYXBUIF0sXHJcblxyXG5cdFx0XHRtaW5GaWx0ZXI6IHRoaXMubWluRmlsdGVyLFxyXG5cdFx0XHRtYWdGaWx0ZXI6IHRoaXMubWFnRmlsdGVyLFxyXG5cdFx0XHRhbmlzb3Ryb3B5OiB0aGlzLmFuaXNvdHJvcHlcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCB0aGlzLmltYWdlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHQvLyBUT0RPOiBNb3ZlIHRvIFRIUkVFLkltYWdlXHJcblxyXG5cdFx0XHR2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xyXG5cclxuXHRcdFx0aWYgKCBpbWFnZS51dWlkID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGltYWdlLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpOyAvLyBVR0hcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtZXRhLmltYWdlc1sgaW1hZ2UudXVpZCBdID0ge1xyXG5cdFx0XHRcdFx0dXVpZDogaW1hZ2UudXVpZCxcclxuXHRcdFx0XHRcdHVybDogZ2V0RGF0YVVSTCggaW1hZ2UgKVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvdXRwdXQuaW1hZ2UgPSBpbWFnZS51dWlkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSA9IG91dHB1dDtcclxuXHJcblx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zZm9ybVV2OiBmdW5jdGlvbiAoIHV2ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5tYXBwaW5nICE9PSBUSFJFRS5VVk1hcHBpbmcgKSAgcmV0dXJuO1xyXG5cclxuXHRcdHV2Lm11bHRpcGx5KCB0aGlzLnJlcGVhdCApO1xyXG5cdFx0dXYuYWRkKCB0aGlzLm9mZnNldCApO1xyXG5cclxuXHRcdGlmICggdXYueCA8IDAgfHwgdXYueCA+IDEgKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLndyYXBTICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLlJlcGVhdFdyYXBwaW5nOlxyXG5cclxuXHRcdFx0XHRcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZzpcclxuXHJcblx0XHRcdFx0XHR1di54ID0gdXYueCA8IDAgPyAwIDogMTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueCApICUgMiApID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dXYueCA9IE1hdGguY2VpbCggdXYueCApIC0gdXYueDtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdXYueSA8IDAgfHwgdXYueSA+IDEgKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLndyYXBUICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLlJlcGVhdFdyYXBwaW5nOlxyXG5cclxuXHRcdFx0XHRcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZzpcclxuXHJcblx0XHRcdFx0XHR1di55ID0gdXYueSA8IDAgPyAwIDogMTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueSApICUgMiApID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dXYueSA9IE1hdGguY2VpbCggdXYueSApIC0gdXYueTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5mbGlwWSApIHtcclxuXHJcblx0XHRcdHV2LnkgPSAxIC0gdXYueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuVGV4dHVyZUlkQ291bnQgPSAwO1xyXG5cclxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvQ2FudmFzVGV4dHVyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2FudmFzVGV4dHVyZSA9IGZ1bmN0aW9uICggY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcblx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2FudmFzVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5USFJFRS5DYW52YXNUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNhbnZhc1RleHR1cmU7XHJcblxyXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9DdWJlVGV4dHVyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3ViZVRleHR1cmUgPSBmdW5jdGlvbiAoIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRtYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IFRIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZztcclxuXHJcblx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xyXG5cclxuXHR0aGlzLmltYWdlcyA9IGltYWdlcztcclxuXHR0aGlzLmZsaXBZID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3ViZVRleHR1cmU7XHJcblxyXG5USFJFRS5DdWJlVGV4dHVyZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmltYWdlcyA9IHNvdXJjZS5pbWFnZXM7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3RleHR1cmVzL0NvbXByZXNzZWRUZXh0dXJlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZSA9IGZ1bmN0aW9uICggbWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xyXG5cclxuXHR0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcblx0dGhpcy5taXBtYXBzID0gbWlwbWFwcztcclxuXHJcblx0Ly8gbm8gZmxpcHBpbmcgZm9yIGN1YmUgdGV4dHVyZXNcclxuXHQvLyAoYWxzbyBmbGlwcGluZyBkb2Vzbid0IHdvcmsgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMgKVxyXG5cclxuXHR0aGlzLmZsaXBZID0gZmFsc2U7XHJcblxyXG5cdC8vIGNhbid0IGdlbmVyYXRlIG1pcG1hcHMgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXNcclxuXHQvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXHJcblxyXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XHJcblxyXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9EYXRhVGV4dHVyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRGF0YVRleHR1cmUgPSBmdW5jdGlvbiAoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcclxuXHJcblx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcblx0dGhpcy5pbWFnZSA9IHsgZGF0YTogZGF0YSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG5cclxuXHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogVEhSRUUuTmVhcmVzdEZpbHRlcjtcclxuXHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogVEhSRUUuTmVhcmVzdEZpbHRlcjtcclxuXHRcclxuXHR0aGlzLmZsaXBZID0gZmFsc2U7XHJcblx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGF0YVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuRGF0YVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGF0YVRleHR1cmU7XHJcblxyXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9WaWRlb1RleHR1cmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlZpZGVvVGV4dHVyZSA9IGZ1bmN0aW9uICggdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcclxuXHJcblx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XHJcblxyXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuXHJcblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHVwZGF0ZSApO1xyXG5cclxuXHRcdGlmICggdmlkZW8ucmVhZHlTdGF0ZSA9PT0gdmlkZW8uSEFWRV9FTk9VR0hfREFUQSApIHtcclxuXHJcblx0XHRcdHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVmlkZW9UZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XHJcblRIUkVFLlZpZGVvVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5WaWRlb1RleHR1cmU7XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL0dyb3VwLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Hcm91cCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnR3JvdXAnO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5Hcm91cC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Hcm91cDtcclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Qb2ludHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlBvaW50cyA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQb2ludHMnO1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2ludHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLlBvaW50cy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludHM7XHJcblxyXG5USFJFRS5Qb2ludHMucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XHJcblx0dmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcblx0XHR2YXIgb2JqZWN0ID0gdGhpcztcclxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblx0XHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xyXG5cdFx0dmFyIHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZDtcclxuXHJcblx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XHJcblx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XHJcblx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xyXG5cclxuXHRcdHZhciBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICggKCB0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnogKSAvIDMgKTtcclxuXHRcdHZhciBsb2NhbFRocmVzaG9sZFNxID0gbG9jYWxUaHJlc2hvbGQgKiBsb2NhbFRocmVzaG9sZDtcclxuXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gdGVzdFBvaW50KCBwb2ludCwgaW5kZXggKSB7XHJcblxyXG5cdFx0XHR2YXIgcmF5UG9pbnREaXN0YW5jZVNxID0gcmF5LmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApO1xyXG5cclxuXHRcdFx0aWYgKCByYXlQb2ludERpc3RhbmNlU3EgPCBsb2NhbFRocmVzaG9sZFNxICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW50ZXJzZWN0UG9pbnQgPSByYXkuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQgKTtcclxuXHRcdFx0XHRpbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdFBvaW50ICk7XHJcblxyXG5cdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuXHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuXHRcdFx0XHRcdGRpc3RhbmNlVG9SYXk6IE1hdGguc3FydCggcmF5UG9pbnREaXN0YW5jZVNxICksXHJcblx0XHRcdFx0XHRwb2ludDogaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcclxuXHRcdFx0XHRcdGluZGV4OiBpbmRleCxcclxuXHRcdFx0XHRcdGZhY2U6IG51bGwsXHJcblx0XHRcdFx0XHRvYmplY3Q6IG9iamVjdFxyXG5cclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGEgPSBpbmRpY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0cG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XHJcblxyXG5cdFx0XHRcdFx0dGVzdFBvaW50KCBwb3NpdGlvbiwgYSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0cG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKiAzICk7XHJcblxyXG5cdFx0XHRcdFx0dGVzdFBvaW50KCBwb3NpdGlvbiwgaSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGVzdFBvaW50KCB2ZXJ0aWNlc1sgaSBdLCBpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxufSgpICk7XHJcblxyXG5USFJFRS5Qb2ludHMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MaW5lLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5MaW5lID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG1vZGUgKSB7XHJcblxyXG5cdGlmICggbW9kZSA9PT0gMSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaW5lOiBwYXJhbWV0ZXIgVEhSRUUuTGluZVBpZWNlcyBubyBsb25nZXIgc3VwcG9ydGVkLiBDcmVhdGVkIFRIUkVFLkxpbmVTZWdtZW50cyBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiBuZXcgVEhSRUUuTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0fVxyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdMaW5lJztcclxuXHJcblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTGluZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lO1xyXG5cclxuVEhSRUUuTGluZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0dmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcclxuXHR2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdHZhciBwcmVjaXNpb24gPSByYXljYXN0ZXIubGluZVByZWNpc2lvbjtcclxuXHRcdHZhciBwcmVjaXNpb25TcSA9IHByZWNpc2lvbiAqIHByZWNpc2lvbjtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XHJcblx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XHJcblx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xyXG5cclxuXHRcdHZhciB2U3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHZFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIGludGVyU2VnbWVudCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgaW50ZXJSYXkgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHN0ZXAgPSB0aGlzIGluc3RhbmNlb2YgVEhSRUUuTGluZVNlZ21lbnRzID8gMiA6IDE7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aCAtIDE7IGkgPCBsOyBpICs9IHN0ZXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGEgPSBpbmRpY2VzWyBpIF07XHJcblx0XHRcdFx0XHR2YXIgYiA9IGluZGljZXNbIGkgKyAxIF07XHJcblxyXG5cdFx0XHRcdFx0dlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xyXG5cdFx0XHRcdFx0dkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXHJcblxyXG5cdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XHJcblxyXG5cdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xyXG5cdFx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcclxuXHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxyXG5cdFx0XHRcdFx0XHRpbmRleDogaSxcclxuXHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcclxuXHRcdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxyXG5cdFx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcclxuXHJcblx0XHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcclxuXHJcblx0XHRcdFx0XHR2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICk7XHJcblx0XHRcdFx0XHR2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCAzICogaSArIDMgKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXHJcblxyXG5cdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XHJcblxyXG5cdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xyXG5cdFx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcclxuXHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxyXG5cdFx0XHRcdFx0XHRpbmRleDogaSxcclxuXHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcclxuXHRcdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxyXG5cdFx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcclxuXHJcblx0XHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblx0XHRcdHZhciBuYlZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbmJWZXJ0aWNlcyAtIDE7IGkgKz0gc3RlcCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cclxuXHJcblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcblx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cclxuXHRcdFx0XHRcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxyXG5cdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxyXG5cdFx0XHRcdFx0aW5kZXg6IGksXHJcblx0XHRcdFx0XHRmYWNlOiBudWxsLFxyXG5cdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxyXG5cdFx0XHRcdFx0b2JqZWN0OiB0aGlzXHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLkxpbmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gREVQUkVDQVRFRFxyXG5cclxuVEhSRUUuTGluZVN0cmlwID0gMDtcclxuVEhSRUUuTGluZVBpZWNlcyA9IDE7XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xpbmVTZWdtZW50cy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGluZVNlZ21lbnRzID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xyXG5USFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZVNlZ21lbnRzO1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9NZXNoLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnTWVzaCc7XHJcblxyXG5cdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xyXG5cclxuXHR0aGlzLmRyYXdNb2RlID0gVEhSRUUuVHJpYW5nbGVzRHJhd01vZGU7XHJcblxyXG5cdHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoO1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUuc2V0RHJhd01vZGUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHR0aGlzLmRyYXdNb2RlID0gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTW9ycGhUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0QmFzZSA9IC0gMTtcclxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xyXG5cclxuXHRcdGZvciAoIHZhciBtID0gMCwgbWwgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZS5nZXRNb3JwaFRhcmdldEluZGV4QnlOYW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRpZiAoIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXTtcclxuXHJcblx0fVxyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU6IG1vcnBoIHRhcmdldCAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyAwLicgKTtcclxuXHJcblx0cmV0dXJuIDA7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLk1lc2gucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XHJcblx0dmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcblx0dmFyIHZBID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdkIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciB0ZW1wQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHRlbXBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdGVtcEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHR2YXIgdXZBID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgdXZCID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgdXZDID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0dmFyIGJhcnljb29yZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIGludGVyc2VjdGlvblBvaW50V29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRmdW5jdGlvbiB1dkludGVyc2VjdGlvbiggcG9pbnQsIHAxLCBwMiwgcDMsIHV2MSwgdXYyLCB1djMgKSB7XHJcblxyXG5cdFx0VEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgcDEsIHAyLCBwMywgYmFyeWNvb3JkICk7XHJcblxyXG5cdFx0dXYxLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueCApO1xyXG5cdFx0dXYyLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueSApO1xyXG5cdFx0dXYzLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueiApO1xyXG5cclxuXHRcdHV2MS5hZGQoIHV2MiApLmFkZCggdXYzICk7XHJcblxyXG5cdFx0cmV0dXJuIHV2MS5jbG9uZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKCBvYmplY3QsIHJheWNhc3RlciwgcmF5LCBwQSwgcEIsIHBDLCBwb2ludCApIHtcclxuXHJcblx0XHR2YXIgaW50ZXJzZWN0O1xyXG5cdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgKSB7XHJcblxyXG5cdFx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBDLCBwQiwgcEEsIHRydWUsIHBvaW50ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEEsIHBCLCBwQywgbWF0ZXJpYWwuc2lkZSAhPT0gVEhSRUUuRG91YmxlU2lkZSwgcG9pbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpbnRlcnNlY3QgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNvcHkoIHBvaW50ICk7XHJcblx0XHRpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCApO1xyXG5cclxuXHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNsb25lKCksXHJcblx0XHRcdG9iamVjdDogb2JqZWN0XHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9ucywgdXZzLCBhLCBiLCBjICkge1xyXG5cclxuXHRcdHZBLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xyXG5cdFx0dkIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XHJcblx0XHR2Qy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYyAqIDMgKTtcclxuXHJcblx0XHR2YXIgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHZBLCB2QiwgdkMsIGludGVyc2VjdGlvblBvaW50ICk7XHJcblxyXG5cdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XHJcblxyXG5cdFx0XHRpZiAoIHV2cyApIHtcclxuXHJcblx0XHRcdFx0dXZBLmZyb21BcnJheSggdXZzLCBhICogMiApO1xyXG5cdFx0XHRcdHV2Qi5mcm9tQXJyYXkoIHV2cywgYiAqIDIgKTtcclxuXHRcdFx0XHR1dkMuZnJvbUFycmF5KCB1dnMsIGMgKiAyICk7XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdGlvbi51diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgIHZBLCB2QiwgdkMsICB1dkEsIHV2QiwgdXZDICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB2QSwgdkIsIHZDICkgKTtcclxuXHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbnRlcnNlY3Rpb247XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cdFx0dmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcclxuXHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcclxuXHRcdHNwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0aWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggbWF0cml4V29ybGQgKTtcclxuXHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XHJcblxyXG5cdFx0Ly8gQ2hlY2sgYm91bmRpbmdCb3ggYmVmb3JlIGNvbnRpbnVpbmdcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0aWYgKCByYXkuaW50ZXJzZWN0c0JveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB1dnMsIGludGVyc2VjdGlvbjtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHR2YXIgYSwgYiwgYztcclxuXHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dXZzID0gYXR0cmlidXRlcy51di5hcnJheTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdGEgPSBpbmRpY2VzWyBpIF07XHJcblx0XHRcdFx0XHRiID0gaW5kaWNlc1sgaSArIDEgXTtcclxuXHRcdFx0XHRcdGMgPSBpbmRpY2VzWyBpICsgMiBdO1xyXG5cclxuXHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbnMsIHV2cywgYSwgYiwgYyApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGkgLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBpbmRpY2VzIGJ1ZmZlciBzZW1hbnRpY3NcclxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSA5ICkge1xyXG5cclxuXHRcdFx0XHRcdGEgPSBpIC8gMztcclxuXHRcdFx0XHRcdGIgPSBhICsgMTtcclxuXHRcdFx0XHRcdGMgPSBhICsgMjtcclxuXHJcblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb25zLCB1dnMsIGEsIGIsIGMgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5pbmRleCA9IGE7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBwb3NpdGlvbnMgYnVmZmVyIHNlbWFudGljc1xyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHR2YXIgZnZBLCBmdkIsIGZ2QztcclxuXHRcdFx0dmFyIGlzRmFjZU1hdGVyaWFsID0gbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NdWx0aU1hdGVyaWFsO1xyXG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyBtYXRlcmlhbC5tYXRlcmlhbHMgOiBudWxsO1xyXG5cclxuXHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblx0XHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG5cdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHRcdFx0aWYgKCBmYWNlVmVydGV4VXZzLmxlbmd0aCA+IDAgKSB1dnMgPSBmYWNlVmVydGV4VXZzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IGZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBmIF07XHJcblx0XHRcdFx0dmFyIGZhY2VNYXRlcmlhbCA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gbWF0ZXJpYWxzWyBmYWNlLm1hdGVyaWFsSW5kZXggXSA6IG1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRpZiAoIGZhY2VNYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGZ2QSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRmdkIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0ZnZDID0gdmVydGljZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGZhY2VNYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcclxuXHRcdFx0XHRcdHZhciBtb3JwaEluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcclxuXHJcblx0XHRcdFx0XHR2QS5zZXQoIDAsIDAsIDAgKTtcclxuXHRcdFx0XHRcdHZCLnNldCggMCwgMCwgMCApO1xyXG5cdFx0XHRcdFx0dkMuc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIHQgPSAwLCB0bCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IHQgPCB0bDsgdCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbIHQgXTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggaW5mbHVlbmNlID09PSAwICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdGFyZ2V0cyA9IG1vcnBoVGFyZ2V0c1sgdCBdLnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRcdFx0dkEuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQS5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmEgXSwgZnZBICksIGluZmx1ZW5jZSApO1xyXG5cdFx0XHRcdFx0XHR2Qi5hZGRTY2FsZWRWZWN0b3IoIHRlbXBCLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYiBdLCBmdkIgKSwgaW5mbHVlbmNlICk7XHJcblx0XHRcdFx0XHRcdHZDLmFkZFNjYWxlZFZlY3RvciggdGVtcEMuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5jIF0sIGZ2QyApLCBpbmZsdWVuY2UgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dkEuYWRkKCBmdkEgKTtcclxuXHRcdFx0XHRcdHZCLmFkZCggZnZCICk7XHJcblx0XHRcdFx0XHR2Qy5hZGQoIGZ2QyApO1xyXG5cclxuXHRcdFx0XHRcdGZ2QSA9IHZBO1xyXG5cdFx0XHRcdFx0ZnZCID0gdkI7XHJcblx0XHRcdFx0XHRmdkMgPSB2QztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCByYXksIGZ2QSwgZnZCLCBmdkMsIGludGVyc2VjdGlvblBvaW50ICk7XHJcblxyXG5cdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggdXZzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHV2c19mID0gdXZzWyBmIF07XHJcblx0XHRcdFx0XHRcdHV2QS5jb3B5KCB1dnNfZlsgMCBdICk7XHJcblx0XHRcdFx0XHRcdHV2Qi5jb3B5KCB1dnNfZlsgMSBdICk7XHJcblx0XHRcdFx0XHRcdHV2Qy5jb3B5KCB1dnNfZlsgMiBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24udXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsIGZ2QSwgZnZCLCBmdkMsIHV2QSwgdXZCLCB1dkMgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2UgPSBmYWNlO1xyXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGY7XHJcblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxufSgpICk7XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvQm9uZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLkJvbmUgPSBmdW5jdGlvbiAoIHNraW4gKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0JvbmUnO1xyXG5cclxuXHR0aGlzLnNraW4gPSBza2luO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJvbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkJvbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm9uZTtcclxuXHJcblRIUkVFLkJvbmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHRcclxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHRcclxuXHR0aGlzLnNraW4gPSBzb3VyY2Uuc2tpbjtcclxuXHRcclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL1NrZWxldG9uLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtaWNoYWVsIGd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cclxuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuU2tlbGV0b24gPSBmdW5jdGlvbiAoIGJvbmVzLCBib25lSW52ZXJzZXMsIHVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG5cdHRoaXMudXNlVmVydGV4VGV4dHVyZSA9IHVzZVZlcnRleFRleHR1cmUgIT09IHVuZGVmaW5lZCA/IHVzZVZlcnRleFRleHR1cmUgOiB0cnVlO1xyXG5cclxuXHR0aGlzLmlkZW50aXR5TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0Ly8gY29weSB0aGUgYm9uZSBhcnJheVxyXG5cclxuXHRib25lcyA9IGJvbmVzIHx8IFtdO1xyXG5cclxuXHR0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoIDAgKTtcclxuXHJcblx0Ly8gY3JlYXRlIGEgYm9uZSB0ZXh0dXJlIG9yIGFuIGFycmF5IG9mIGZsb2F0c1xyXG5cclxuXHRpZiAoIHRoaXMudXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcblx0XHQvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXHJcblx0XHQvLyAgICAgIFJHQkEgUkdCQSBSR0JBIFJHQkEgKD0+IGNvbHVtbjEsIGNvbHVtbjIsIGNvbHVtbjMsIGNvbHVtbjQpXHJcblx0XHQvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICogNCBwaXhlbHMgPSAgKDggKiA4KVxyXG5cdFx0Ly8gICAgICAgMTZ4MTYgcGl4ZWwgdGV4dHVyZSBtYXggICA2NCBib25lcyAqIDQgcGl4ZWxzID0gKDE2ICogMTYpXHJcblx0XHQvLyAgICAgICAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IGJvbmVzICogNCBwaXhlbHMgPSAoMzIgKiAzMilcclxuXHRcdC8vICAgICAgIDY0eDY0IHBpeGVsIHRleHR1cmUgbWF4IDEwMjQgYm9uZXMgKiA0IHBpeGVscyA9ICg2NCAqIDY0KVxyXG5cclxuXHRcdFxyXG5cdFx0dmFyIHNpemUgPSBNYXRoLnNxcnQoIHRoaXMuYm9uZXMubGVuZ3RoICogNCApOyAvLyA0IHBpeGVscyBuZWVkZWQgZm9yIDEgbWF0cml4XHJcblx0XHRzaXplID0gVEhSRUUuTWF0aC5uZXh0UG93ZXJPZlR3byggTWF0aC5jZWlsKCBzaXplICkgKTtcclxuXHRcdHNpemUgPSBNYXRoLm1heCggc2l6ZSwgNCApO1xyXG5cclxuXHRcdHRoaXMuYm9uZVRleHR1cmVXaWR0aCA9IHNpemU7XHJcblx0XHR0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0ID0gc2l6ZTtcclxuXHJcblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZVRleHR1cmVXaWR0aCAqIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXHJcblx0XHR0aGlzLmJvbmVUZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCB0aGlzLmJvbmVNYXRyaWNlcywgdGhpcy5ib25lVGV4dHVyZVdpZHRoLCB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0LCBUSFJFRS5SR0JBRm9ybWF0LCBUSFJFRS5GbG9hdFR5cGUgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogdGhpcy5ib25lcy5sZW5ndGggKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyB1c2UgdGhlIHN1cHBsaWVkIGJvbmUgaW52ZXJzZXMgb3IgY2FsY3VsYXRlIHRoZSBpbnZlcnNlc1xyXG5cclxuXHRpZiAoIGJvbmVJbnZlcnNlcyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHRoaXMuY2FsY3VsYXRlSW52ZXJzZXMoKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID09PSBib25lSW52ZXJzZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBib25lSW52ZXJzZXMuc2xpY2UoIDAgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tlbGV0b24gYm9uSW52ZXJzZXMgaXMgdGhlIHdyb25nIGxlbmd0aC4nICk7XHJcblxyXG5cdFx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goIG5ldyBUSFJFRS5NYXRyaXg0KCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUuY2FsY3VsYXRlSW52ZXJzZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuYm9uZUludmVyc2VzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuXHRcdHZhciBpbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuYm9uZXNbIGIgXSApIHtcclxuXHJcblx0XHRcdGludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5ib25lc1sgYiBdLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goIGludmVyc2UgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5wb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgYm9uZTtcclxuXHJcblx0Ly8gcmVjb3ZlciB0aGUgYmluZC10aW1lIHdvcmxkIG1hdHJpY2VzXHJcblxyXG5cdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuXHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XHJcblxyXG5cdFx0aWYgKCBib25lICkge1xyXG5cclxuXHRcdFx0Ym9uZS5tYXRyaXhXb3JsZC5nZXRJbnZlcnNlKCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIGNvbXB1dGUgdGhlIGxvY2FsIG1hdHJpY2VzLCBwb3NpdGlvbnMsIHJvdGF0aW9ucyBhbmQgc2NhbGVzXHJcblxyXG5cdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuXHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XHJcblxyXG5cdFx0aWYgKCBib25lICkge1xyXG5cclxuXHRcdFx0aWYgKCBib25lLnBhcmVudCApIHtcclxuXHJcblx0XHRcdFx0Ym9uZS5tYXRyaXguZ2V0SW52ZXJzZSggYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRib25lLm1hdHJpeC5tdWx0aXBseSggYm9uZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ym9uZS5tYXRyaXguY29weSggYm9uZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ym9uZS5tYXRyaXguZGVjb21wb3NlKCBib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBvZmZzZXRNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xyXG5cclxuXHRcdC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxyXG5cclxuXHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZSB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBvcmlnaW5hbCB0cmFuc2Zvcm1cclxuXHJcblx0XHRcdHZhciBtYXRyaXggPSB0aGlzLmJvbmVzWyBiIF0gPyB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgOiB0aGlzLmlkZW50aXR5TWF0cml4O1xyXG5cclxuXHRcdFx0b2Zmc2V0TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5ib25lSW52ZXJzZXNbIGIgXSApO1xyXG5cdFx0XHRvZmZzZXRNYXRyaXguZmxhdHRlblRvQXJyYXlPZmZzZXQoIHRoaXMuYm9uZU1hdHJpY2VzLCBiICogMTYgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59ICkoKTtcclxuXHJcblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5Ta2VsZXRvbiggdGhpcy5ib25lcywgdGhpcy5ib25lSW52ZXJzZXMsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvU2tpbm5lZE1lc2guanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cclxuICovXHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsLCB1c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnU2tpbm5lZE1lc2gnO1xyXG5cclxuXHR0aGlzLmJpbmRNb2RlID0gXCJhdHRhY2hlZFwiO1xyXG5cdHRoaXMuYmluZE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdC8vIGluaXQgYm9uZXNcclxuXHJcblx0Ly8gVE9ETzogcmVtb3ZlIGJvbmUgY3JlYXRpb24gYXMgdGhlcmUgaXMgbm8gcmVhc29uIChvdGhlciB0aGFuXHJcblx0Ly8gY29udmVuaWVuY2UpIGZvciBUSFJFRS5Ta2lubmVkTWVzaCB0byBkbyB0aGlzLlxyXG5cclxuXHR2YXIgYm9uZXMgPSBbXTtcclxuXHJcblx0aWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuYm9uZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHR2YXIgYm9uZSwgZ2JvbmU7XHJcblxyXG5cdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrIGIgKSB7XHJcblxyXG5cdFx0XHRnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcclxuXHJcblx0XHRcdGJvbmUgPSBuZXcgVEhSRUUuQm9uZSggdGhpcyApO1xyXG5cdFx0XHRib25lcy5wdXNoKCBib25lICk7XHJcblxyXG5cdFx0XHRib25lLm5hbWUgPSBnYm9uZS5uYW1lO1xyXG5cdFx0XHRib25lLnBvc2l0aW9uLmZyb21BcnJheSggZ2JvbmUucG9zICk7XHJcblx0XHRcdGJvbmUucXVhdGVybmlvbi5mcm9tQXJyYXkoIGdib25lLnJvdHEgKTtcclxuXHRcdFx0aWYgKCBnYm9uZS5zY2wgIT09IHVuZGVmaW5lZCApIGJvbmUuc2NhbGUuZnJvbUFycmF5KCBnYm9uZS5zY2wgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrIGIgKSB7XHJcblxyXG5cdFx0XHRnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcclxuXHJcblx0XHRcdGlmICggZ2JvbmUucGFyZW50ICE9PSAtIDEgJiYgZ2JvbmUucGFyZW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRib25lc1sgZ2JvbmUucGFyZW50IF0uYWRkKCBib25lc1sgYiBdICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLmFkZCggYm9uZXNbIGIgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XHJcblxyXG5cdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHR0aGlzLmJpbmQoIG5ldyBUSFJFRS5Ta2VsZXRvbiggYm9uZXMsIHVuZGVmaW5lZCwgdXNlVmVydGV4VGV4dHVyZSApLCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNraW5uZWRNZXNoO1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiggc2tlbGV0b24sIGJpbmRNYXRyaXggKSB7XHJcblxyXG5cdHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcclxuXHJcblx0aWYgKCBiaW5kTWF0cml4ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcclxuXHJcblx0XHRiaW5kTWF0cml4ID0gdGhpcy5tYXRyaXhXb3JsZDtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xyXG5cdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggYmluZE1hdHJpeCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5wb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLnNrZWxldG9uLnBvc2UoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUubm9ybWFsaXplU2tpbldlaWdodHMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGlmICggdGhpcy5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHN3ID0gdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0c1sgaSBdO1xyXG5cclxuXHRcdFx0dmFyIHNjYWxlID0gMS4wIC8gc3cubGVuZ3RoTWFuaGF0dGFuKCk7XHJcblxyXG5cdFx0XHRpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcclxuXHJcblx0XHRcdFx0c3cubXVsdGlwbHlTY2FsYXIoIHNjYWxlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzdy5zZXQoIDEsIDAsIDAsIDAgKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoIHRoaXMuZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgdmVjID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcblx0XHR2YXIgc2tpbldlaWdodCA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luV2VpZ2h0O1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNraW5XZWlnaHQuY291bnQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ZWMueCA9IHNraW5XZWlnaHQuZ2V0WCggaSApO1xyXG5cdFx0XHR2ZWMueSA9IHNraW5XZWlnaHQuZ2V0WSggaSApO1xyXG5cdFx0XHR2ZWMueiA9IHNraW5XZWlnaHQuZ2V0WiggaSApO1xyXG5cdFx0XHR2ZWMudyA9IHNraW5XZWlnaHQuZ2V0VyggaSApO1xyXG5cclxuXHRcdFx0dmFyIHNjYWxlID0gMS4wIC8gdmVjLmxlbmd0aE1hbmhhdHRhbigpO1xyXG5cclxuXHRcdFx0aWYgKCBzY2FsZSAhPT0gSW5maW5pdHkgKSB7XHJcblxyXG5cdFx0XHRcdHZlYy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZlYy5zZXQoIDEsIDAsIDAsIDAgKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNraW5XZWlnaHQuc2V0WFlaVyggaSwgdmVjLngsIHZlYy55LCB2ZWMueiwgdmVjLncgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSBmdW5jdGlvbiggZm9yY2UgKSB7XHJcblxyXG5cdFRIUkVFLk1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIHRydWUgKTtcclxuXHJcblx0aWYgKCB0aGlzLmJpbmRNb2RlID09PSBcImF0dGFjaGVkXCIgKSB7XHJcblxyXG5cdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdH0gZWxzZSBpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiZGV0YWNoZWRcIiApIHtcclxuXHJcblx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMuYmluZE1hdHJpeCApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNraW5uZWRNZXNoIHVucmVjb2duaXplZCBiaW5kTW9kZTogJyArIHRoaXMuYmluZE1vZGUgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApLmNvcHkoIHRoaXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xPRC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTE9EID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdMT0QnO1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xyXG5cdFx0bGV2ZWxzOiB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdHZhbHVlOiBbXVxyXG5cdFx0fSxcclxuXHRcdG9iamVjdHM6IHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxPRDogLm9iamVjdHMgaGFzIGJlZW4gcmVuYW1lZCB0byAubGV2ZWxzLicgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5sZXZlbHM7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSApO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkxPRC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MT0Q7XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLmFkZExldmVsID0gZnVuY3Rpb24gKCBvYmplY3QsIGRpc3RhbmNlICkge1xyXG5cclxuXHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XHJcblxyXG5cdGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XHJcblxyXG5cdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcclxuXHJcblx0Zm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcclxuXHJcblx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBsIF0uZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0bGV2ZWxzLnNwbGljZSggbCwgMCwgeyBkaXN0YW5jZTogZGlzdGFuY2UsIG9iamVjdDogb2JqZWN0IH0gKTtcclxuXHJcblx0dGhpcy5hZGQoIG9iamVjdCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UgPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdGlmICggZGlzdGFuY2UgPCBsZXZlbHNbIGkgXS5kaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbGV2ZWxzWyBpIC0gMSBdLm9iamVjdDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcblx0XHRtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBtYXRyaXhQb3NpdGlvbiApO1xyXG5cclxuXHRcdHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XHJcblxyXG5cdH07XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIGNhbWVyYSApIHtcclxuXHJcblx0XHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XHJcblxyXG5cdFx0aWYgKCBsZXZlbHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0dmFyIGRpc3RhbmNlID0gdjEuZGlzdGFuY2VUbyggdjIgKTtcclxuXHJcblx0XHRcdGxldmVsc1sgMCBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlID49IGxldmVsc1sgaSBdLmRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0XHRcdGxldmVsc1sgaSAtIDEgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0bGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn0oKTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIGZhbHNlICk7XHJcblxyXG5cdHZhciBsZXZlbHMgPSBzb3VyY2UubGV2ZWxzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcclxuXHJcblx0XHR0aGlzLmFkZExldmVsKCBsZXZlbC5vYmplY3QuY2xvbmUoKSwgbGV2ZWwuZGlzdGFuY2UgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0dmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcblx0ZGF0YS5vYmplY3QubGV2ZWxzID0gW107XHJcblxyXG5cdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XHJcblxyXG5cdFx0ZGF0YS5vYmplY3QubGV2ZWxzLnB1c2goIHtcclxuXHRcdFx0b2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcclxuXHRcdFx0ZGlzdGFuY2U6IGxldmVsLmRpc3RhbmNlXHJcblx0XHR9ICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9TcHJpdGUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNwcml0ZSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWyAwLCAxLCAyLCAgMCwgMiwgMyBdICk7XHJcblx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggWyAtIDAuNSwgLSAwLjUsIDAsICAgMC41LCAtIDAuNSwgMCwgICAwLjUsIDAuNSwgMCwgICAtIDAuNSwgMC41LCAwIF0gKTtcclxuXHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggWyAwLCAwLCAgIDEsIDAsICAgMSwgMSwgICAwLCAxIF0gKTtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xyXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIFNwcml0ZSggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdTcHJpdGUnO1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHRcdHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKCk7XHJcblxyXG5cdH07XHJcblxyXG59ICkoKTtcclxuXHJcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwcml0ZTtcclxuXHJcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdHZhciBkaXN0YW5jZVNxID0gcmF5Y2FzdGVyLnJheS5kaXN0YW5jZVNxVG9Qb2ludCggbWF0cml4UG9zaXRpb24gKTtcclxuXHRcdHZhciBndWVzc1NpemVTcSA9IHRoaXMuc2NhbGUueCAqIHRoaXMuc2NhbGUueTtcclxuXHJcblx0XHRpZiAoIGRpc3RhbmNlU3EgPiBndWVzc1NpemVTcSApIHtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aW50ZXJzZWN0cy5wdXNoKCB7XHJcblxyXG5cdFx0XHRkaXN0YW5jZTogTWF0aC5zcXJ0KCBkaXN0YW5jZVNxICksXHJcblx0XHRcdHBvaW50OiB0aGlzLnBvc2l0aW9uLFxyXG5cdFx0XHRmYWNlOiBudWxsLFxyXG5cdFx0XHRvYmplY3Q6IHRoaXNcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH07XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuVEhSRUUuUGFydGljbGUgPSBUSFJFRS5TcHJpdGU7XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xlbnNGbGFyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubGVuc0ZsYXJlcyA9IFtdO1xyXG5cclxuXHR0aGlzLnBvc2l0aW9uU2NyZWVuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLmN1c3RvbVVwZGF0ZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xyXG5cclxuXHRpZiAoIHRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHR0aGlzLmFkZCggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGVuc0ZsYXJlO1xyXG5cclxuXHJcbi8qXHJcbiAqIEFkZDogYWRkcyBhbm90aGVyIGZsYXJlXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IsIG9wYWNpdHkgKSB7XHJcblxyXG5cdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IC0gMTtcclxuXHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XHJcblx0aWYgKCBvcGFjaXR5ID09PSB1bmRlZmluZWQgKSBvcGFjaXR5ID0gMTtcclxuXHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHRpZiAoIGJsZW5kaW5nID09PSB1bmRlZmluZWQgKSBibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xyXG5cclxuXHRkaXN0YW5jZSA9IE1hdGgubWluKCBkaXN0YW5jZSwgTWF0aC5tYXgoIDAsIGRpc3RhbmNlICkgKTtcclxuXHJcblx0dGhpcy5sZW5zRmxhcmVzLnB1c2goIHtcclxuXHRcdHRleHR1cmU6IHRleHR1cmUsXHQvLyBUSFJFRS5UZXh0dXJlXHJcblx0XHRzaXplOiBzaXplLCBcdFx0Ly8gc2l6ZSBpbiBwaXhlbHMgKC0xID0gdXNlIHRleHR1cmUud2lkdGgpXHJcblx0XHRkaXN0YW5jZTogZGlzdGFuY2UsIFx0Ly8gZGlzdGFuY2UgKDAtMSkgZnJvbSBsaWdodCBzb3VyY2UgKDA9YXQgbGlnaHQgc291cmNlKVxyXG5cdFx0eDogMCwgeTogMCwgejogMCxcdC8vIHNjcmVlbiBwb3NpdGlvbiAoLTEgPT4gMSkgeiA9IDAgaXMgaW4gZnJvbnQgeiA9IDEgaXMgYmFja1xyXG5cdFx0c2NhbGU6IDEsIFx0XHQvLyBzY2FsZVxyXG5cdFx0cm90YXRpb246IDAsIFx0XHQvLyByb3RhdGlvblxyXG5cdFx0b3BhY2l0eTogb3BhY2l0eSxcdC8vIG9wYWNpdHlcclxuXHRcdGNvbG9yOiBjb2xvcixcdFx0Ly8gY29sb3JcclxuXHRcdGJsZW5kaW5nOiBibGVuZGluZ1x0Ly8gYmxlbmRpbmdcclxuXHR9ICk7XHJcblxyXG59O1xyXG5cclxuLypcclxuICogVXBkYXRlIGxlbnMgZmxhcmVzIHVwZGF0ZSBwb3NpdGlvbnMgb24gYWxsIGZsYXJlcyBiYXNlZCBvbiB0aGUgc2NyZWVuIHBvc2l0aW9uXHJcbiAqIFNldCBteUxlbnNGbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayB0byBhbHRlciB0aGUgZmxhcmVzIGluIHlvdXIgcHJvamVjdCBzcGVjaWZpYyB3YXkuXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS51cGRhdGVMZW5zRmxhcmVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZiwgZmwgPSB0aGlzLmxlbnNGbGFyZXMubGVuZ3RoO1xyXG5cdHZhciBmbGFyZTtcclxuXHR2YXIgdmVjWCA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICogMjtcclxuXHR2YXIgdmVjWSA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICogMjtcclxuXHJcblx0Zm9yICggZiA9IDA7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRmbGFyZSA9IHRoaXMubGVuc0ZsYXJlc1sgZiBdO1xyXG5cclxuXHRcdGZsYXJlLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyB2ZWNYICogZmxhcmUuZGlzdGFuY2U7XHJcblx0XHRmbGFyZS55ID0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICsgdmVjWSAqIGZsYXJlLmRpc3RhbmNlO1xyXG5cclxuXHRcdGZsYXJlLndhbnRlZFJvdGF0aW9uID0gZmxhcmUueCAqIE1hdGguUEkgKiAwLjI1O1xyXG5cdFx0ZmxhcmUucm90YXRpb24gKz0gKCBmbGFyZS53YW50ZWRSb3RhdGlvbiAtIGZsYXJlLnJvdGF0aW9uICkgKiAwLjI1O1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNvdXJjZS5wb3NpdGlvblNjcmVlbiApO1xyXG5cdHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSBzb3VyY2UuY3VzdG9tVXBkYXRlQ2FsbGJhY2s7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5sZW5zRmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dGhpcy5sZW5zRmxhcmVzLnB1c2goIHNvdXJjZS5sZW5zRmxhcmVzWyBpIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9zY2VuZXMvU2NlbmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNjZW5lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdTY2VuZSc7XHJcblxyXG5cdHRoaXMuZm9nID0gbnVsbDtcclxuXHR0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsO1xyXG5cclxuXHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlOyAvLyBjaGVja2VkIGJ5IHRoZSByZW5kZXJlclxyXG5cclxufTtcclxuXHJcblRIUkVFLlNjZW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5TY2VuZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TY2VuZTtcclxuXHJcblRIUkVFLlNjZW5lLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRpZiAoIHNvdXJjZS5mb2cgIT09IG51bGwgKSB0aGlzLmZvZyA9IHNvdXJjZS5mb2cuY2xvbmUoKTtcclxuXHRpZiAoIHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKTtcclxuXHJcblx0dGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3NjZW5lcy9Gb2cuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZvZyA9IGZ1bmN0aW9uICggY29sb3IsIG5lYXIsIGZhciApIHtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XHJcblxyXG5cdHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMTtcclxuXHR0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDEwMDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRm9nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5Gb2coIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9zY2VuZXMvRm9nRXhwMi5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRm9nRXhwMiA9IGZ1bmN0aW9uICggY29sb3IsIGRlbnNpdHkgKSB7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xyXG5cdHRoaXMuZGVuc2l0eSA9ICggZGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBkZW5zaXR5IDogMC4wMDAyNTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Gb2dFeHAyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5Gb2dFeHAyKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLmRlbnNpdHkgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay5qc1xyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmsgPSB7fTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhbWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZVdiApLmc7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYXRlc3RfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYXRlc3RfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBBTFBIQVRFU1RcXG5cdGlmICggZGlmZnVzZUNvbG9yLmEgPCBBTFBIQVRFU1QgKSBkaXNjYXJkO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW1iaWVudF9wYXJzLmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYW1iaWVudF9wYXJzJyBdID0gXCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxudmVjMyBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGFtYmllbnRMaWdodENvbG9yICkge1xcblx0cmV0dXJuIFBJICogYW1iaWVudExpZ2h0Q29sb3I7XFxufVxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW9tYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhb21hcF9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9ICggdGV4dHVyZTJEKCBhb01hcCwgdlV2MiApLnIgLSAxLjAgKSAqIGFvTWFwSW50ZW5zaXR5ICsgMS4wO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW9tYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FvbWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGFvTWFwO1xcblx0dW5pZm9ybSBmbG9hdCBhb01hcEludGVuc2l0eTtcXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2JlZ2luX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2JlZ2luX3ZlcnRleCcgXSA9IFwiXFxudmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMoIHBvc2l0aW9uICk7XFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9iZWdpbm5vcm1hbF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdiZWdpbm5vcm1hbF92ZXJ0ZXgnIF0gPSBcIlxcbnZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7XFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9ic2Rmcy5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2JzZGZzJyBdID0gXCJmbG9hdCBjYWxjTGlnaHRBdHRlbnVhdGlvbiggY29uc3QgaW4gZmxvYXQgbGlnaHREaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgY3V0b2ZmRGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGRlY2F5RXhwb25lbnQgKSB7XFxuXHRpZiAoIGRlY2F5RXhwb25lbnQgPiAwLjAgKSB7XFxuXHQgIHJldHVybiBwb3coIHNhdHVyYXRlKCAtbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICsgMS4wICksIGRlY2F5RXhwb25lbnQgKTtcXG5cdH1cXG5cdHJldHVybiAxLjA7XFxufVxcbnZlYzMgQlJERl9EaWZmdXNlX0xhbWJlcnQoIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yICkge1xcblx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBkaWZmdXNlQ29sb3I7XFxufVxcbnZlYzMgRl9TY2hsaWNrKCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IGRvdExIICkge1xcblx0ZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLTUuNTU0NzMgKiBkb3RMSCAtIDYuOTgzMTYgKSAqIGRvdExIICk7XFxuXHRyZXR1cm4gKCAxLjAgLSBzcGVjdWxhckNvbG9yICkgKiBmcmVzbmVsICsgc3BlY3VsYXJDb2xvcjtcXG59XFxuZmxvYXQgR19HR1hfU21pdGgoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7XFxuXHRmbG9hdCBhMiA9IGFscGhhICogYWxwaGE7XFxuXHRmbG9hdCBnbCA9IGRvdE5MICsgcG93KCBhMiArICggMS4wIC0gYTIgKSAqIGRvdE5MICogZG90TkwsIDAuNSApO1xcblx0ZmxvYXQgZ3YgPSBkb3ROViArIHBvdyggYTIgKyAoIDEuMCAtIGEyICkgKiBkb3ROViAqIGRvdE5WLCAwLjUgKTtcXG5cdHJldHVybiAxLjAgLyAoIGdsICogZ3YgKTtcXG59XFxuZmxvYXQgRF9HR1goIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cdGZsb2F0IGEyID0gYWxwaGEgKiBhbHBoYTtcXG5cdGZsb2F0IGRlbm9tID0gZG90TkggKiBkb3ROSCAqICggYTIgLSAxLjAgKSArIDEuMDtcXG5cdHJldHVybiBSRUNJUFJPQ0FMX1BJICogYTIgLyAoIGRlbm9tICogZGVub20gKTtcXG59XFxudmVjMyBCUkRGX1NwZWN1bGFyX0dHWCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBpbmNpZGVudExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cdGZsb2F0IGFscGhhID0gcm91Z2huZXNzICogcm91Z2huZXNzO1xcblx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiArIGdlb21ldHJ5LnZpZXdEaXIgKTtcXG5cdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaGFsZkRpciApICk7XFxuXHRmbG9hdCBkb3RMSCA9IHNhdHVyYXRlKCBkb3QoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uLCBoYWxmRGlyICkgKTtcXG5cdHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgZG90TEggKTtcXG5cdGZsb2F0IEcgPSBHX0dHWF9TbWl0aCggYWxwaGEsIGRvdE5MLCBkb3ROViApO1xcblx0ZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTtcXG5cdHJldHVybiBGICogKCBHICogRCApO1xcbn1cXG52ZWMzIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXG5cdGNvbnN0IHZlYzQgYzAgPSB2ZWM0KCAtIDEsIC0gMC4wMjc1LCAtIDAuNTcyLCAwLjAyMiApO1xcblx0Y29uc3QgdmVjNCBjMSA9IHZlYzQoIDEsIDAuMDQyNSwgMS4wNCwgLSAwLjA0ICk7XFxuXHR2ZWM0IHIgPSByb3VnaG5lc3MgKiBjMCArIGMxO1xcblx0ZmxvYXQgYTAwNCA9IG1pbiggci54ICogci54LCBleHAyKCAtIDkuMjggKiBkb3ROViApICkgKiByLnggKyByLnk7XFxuXHR2ZWMyIEFCID0gdmVjMiggLTEuMDQsIDEuMDQgKSAqIGEwMDQgKyByLnp3O1xcblx0cmV0dXJuIHNwZWN1bGFyQ29sb3IgKiBBQi54ICsgQUIueTtcXG59XFxuZmxvYXQgR19CbGlublBob25nX0ltcGxpY2l0KCApIHtcXG5cdHJldHVybiAwLjI1O1xcbn1cXG5mbG9hdCBEX0JsaW5uUGhvbmcoIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XFxuXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqICggc2hpbmluZXNzICogMC41ICsgMS4wICkgKiBwb3coIGRvdE5ILCBzaGluaW5lc3MgKTtcXG59XFxudmVjMyBCUkRGX1NwZWN1bGFyX0JsaW5uUGhvbmcoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgaW5jaWRlbnRMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzaGluaW5lc3MgKSB7XFxuXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICsgZ2VvbWV0cnkudmlld0RpciApO1xcblx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGhhbGZEaXIgKSApO1xcblx0ZmxvYXQgZG90TEggPSBzYXR1cmF0ZSggZG90KCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiwgaGFsZkRpciApICk7XFxuXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxuXHRmbG9hdCBHID0gR19CbGlublBob25nX0ltcGxpY2l0KCApO1xcblx0ZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcblx0cmV0dXJuIEYgKiAoIEcgKiBEICk7XFxufVxcbmZsb2F0IEdHWFJvdWdobmVzc1RvQmxpbm5FeHBvbmVudCggY29uc3QgaW4gZmxvYXQgZ2d4Um91Z2huZXNzICkge1xcblx0cmV0dXJuICggMi4wIC8gc3F1YXJlKCBnZ3hSb3VnaG5lc3MgKyAwLjAwMDEgKSAtIDIuMCApO1xcbn1cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2J1bXBtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2J1bXBtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9CVU1QTUFQXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcblx0dW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XFxuXHR2ZWMyIGRIZHh5X2Z3ZCgpIHtcXG5cdFx0dmVjMiBkU1RkeCA9IGRGZHgoIHZVdiApO1xcblx0XHR2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XFxuXHRcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXG5cdFx0ZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeCApLnggLSBIbGw7XFxuXHRcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblx0XHRyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG5cdH1cXG5cdHZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHkgKSB7XFxuXHRcdHZlYzMgdlNpZ21hWCA9IGRGZHgoIHN1cmZfcG9zICk7XFxuXHRcdHZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zICk7XFxuXHRcdHZlYzMgdk4gPSBzdXJmX25vcm07XFxuXHRcdHZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTtcXG5cdFx0dmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1xcblx0XHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApO1xcblx0XHR2ZWMzIHZHcmFkID0gc2lnbiggZkRldCApICogKCBkSGR4eS54ICogUjEgKyBkSGR4eS55ICogUjIgKTtcXG5cdFx0cmV0dXJuIG5vcm1hbGl6ZSggYWJzKCBmRGV0ICkgKiBzdXJmX25vcm0gLSB2R3JhZCApO1xcblx0fVxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblx0ZGlmZnVzZUNvbG9yLnJnYiAqPSB2Q29sb3I7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cdHZDb2xvci54eXogPSBjb2xvci54eXo7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb21tb24uZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb21tb24nIF0gPSBcIiNkZWZpbmUgUEkgMy4xNDE1OVxcbiNkZWZpbmUgUEkyIDYuMjgzMThcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkgMC4zMTgzMDk4ODYxOFxcbiNkZWZpbmUgUkVDSVBST0NBTF9QSTIgMC4xNTkxNTQ5NFxcbiNkZWZpbmUgTE9HMiAxLjQ0MjY5NVxcbiNkZWZpbmUgRVBTSUxPTiAxZS02XFxuI2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNkZWZpbmUgd2hpdGVDb21wbGltZW50KGEpICggMS4wIC0gc2F0dXJhdGUoIGEgKSApXFxuZmxvYXQgc3F1YXJlKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4OyB9XFxuZmxvYXQgYXZlcmFnZSggY29uc3QgaW4gdmVjMyBjb2xvciApIHsgcmV0dXJuIGRvdCggY29sb3IsIHZlYzMoIDAuMzMzMyApICk7IH1cXG5zdHJ1Y3QgSW5jaWRlbnRMaWdodCB7XFxuXHR2ZWMzIGNvbG9yO1xcblx0dmVjMyBkaXJlY3Rpb247XFxufTtcXG5zdHJ1Y3QgUmVmbGVjdGVkTGlnaHQge1xcblx0dmVjMyBkaXJlY3REaWZmdXNlO1xcblx0dmVjMyBkaXJlY3RTcGVjdWxhcjtcXG5cdHZlYzMgaW5kaXJlY3REaWZmdXNlO1xcblx0dmVjMyBpbmRpcmVjdFNwZWN1bGFyO1xcbn07XFxuc3RydWN0IEdlb21ldHJpY0NvbnRleHQge1xcblx0dmVjMyBwb3NpdGlvbjtcXG5cdHZlYzMgbm9ybWFsO1xcblx0dmVjMyB2aWV3RGlyO1xcbn07XFxudmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cdHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApO1xcbn1cXG52ZWMzIGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cdHJldHVybiBub3JtYWxpemUoICggdmVjNCggZGlyLCAwLjAgKSAqIG1hdHJpeCApLnh5eiApO1xcbn1cXG52ZWMzIHByb2plY3RPblBsYW5lKGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblx0ZmxvYXQgZGlzdGFuY2UgPSBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludCAtIHBvaW50T25QbGFuZSApO1xcblx0cmV0dXJuIC0gZGlzdGFuY2UgKiBwbGFuZU5vcm1hbCArIHBvaW50O1xcbn1cXG5mbG9hdCBzaWRlT2ZQbGFuZSggaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXHRyZXR1cm4gc2lnbiggZG90KCBwb2ludCAtIHBvaW50T25QbGFuZSwgcGxhbmVOb3JtYWwgKSApO1xcbn1cXG52ZWMzIGxpbmVQbGFuZUludGVyc2VjdCggaW4gdmVjMyBwb2ludE9uTGluZSwgaW4gdmVjMyBsaW5lRGlyZWN0aW9uLCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cdHJldHVybiBsaW5lRGlyZWN0aW9uICogKCBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludE9uUGxhbmUgLSBwb2ludE9uTGluZSApIC8gZG90KCBwbGFuZU5vcm1hbCwgbGluZURpcmVjdGlvbiApICkgKyBwb2ludE9uTGluZTtcXG59XFxudmVjMyBpbnB1dFRvTGluZWFyKCBpbiB2ZWMzIGEgKSB7XFxuXHQjaWZkZWYgR0FNTUFfSU5QVVRcXG5cdFx0cmV0dXJuIHBvdyggYSwgdmVjMyggZmxvYXQoIEdBTU1BX0ZBQ1RPUiApICkgKTtcXG5cdCNlbHNlXFxuXHRcdHJldHVybiBhO1xcblx0I2VuZGlmXFxufVxcbnZlYzMgbGluZWFyVG9PdXRwdXQoIGluIHZlYzMgYSApIHtcXG5cdCNpZmRlZiBHQU1NQV9PVVRQVVRcXG5cdFx0cmV0dXJuIHBvdyggYSwgdmVjMyggMS4wIC8gZmxvYXQoIEdBTU1BX0ZBQ1RPUiApICkgKTtcXG5cdCNlbHNlXFxuXHRcdHJldHVybiBhO1xcblx0I2VuZGlmXFxufVxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGVmYXVsdG5vcm1hbF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkZWZhdWx0bm9ybWFsX3ZlcnRleCcgXSA9IFwiI2lmZGVmIEZMSVBfU0lERURcXG5cdG9iamVjdE5vcm1hbCA9IC1vYmplY3ROb3JtYWw7XFxuI2VuZGlmXFxudmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIG9iamVjdE5vcm1hbDtcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Rpc3BsYWNlbWVudG1hcF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkaXNwbGFjZW1lbnRtYXBfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblx0dHJhbnNmb3JtZWQgKz0gbm9ybWFsICogKCB0ZXh0dXJlMkQoIGRpc3BsYWNlbWVudE1hcCwgdXYgKS54ICogZGlzcGxhY2VtZW50U2NhbGUgKyBkaXNwbGFjZW1lbnRCaWFzICk7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXNwbGFjZW1lbnRNYXA7XFxuXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudFNjYWxlO1xcblx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRCaWFzO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW1pc3NpdmVtYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbWlzc2l2ZW1hcF9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblx0dmVjNCBlbWlzc2l2ZUNvbG9yID0gdGV4dHVyZTJEKCBlbWlzc2l2ZU1hcCwgdlV2ICk7XFxuXHRlbWlzc2l2ZUNvbG9yLnJnYiA9IGlucHV0VG9MaW5lYXIoIGVtaXNzaXZlQ29sb3IucmdiICk7XFxuXHR0b3RhbEVtaXNzaXZlTGlnaHQgKj0gZW1pc3NpdmVDb2xvci5yZ2I7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblx0XHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXHRcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cdFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cdFx0XHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cdFx0I2Vsc2VcXG5cdFx0XHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblx0XHQjZW5kaWZcXG5cdCNlbHNlXFxuXHRcdHZlYzMgcmVmbGVjdFZlYyA9IHZSZWZsZWN0O1xcblx0I2VuZGlmXFxuXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXHRcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxuXHQjZWxzZVxcblx0XHRmbG9hdCBmbGlwTm9ybWFsID0gMS4wO1xcblx0I2VuZGlmXFxuXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblx0XHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKSApO1xcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxuXHRcdHZlYzIgc2FtcGxlVVY7XFxuXHRcdHNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueSAqIDAuNSArIDAuNSApO1xcblx0XHRzYW1wbGVVVi54ID0gYXRhbiggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueiwgZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXHRcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgc2FtcGxlVVYgKTtcXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuXHRcdHZlYzMgcmVmbGVjdFZpZXcgPSBmbGlwTm9ybWFsICogbm9ybWFsaXplKCh2aWV3TWF0cml4ICogdmVjNCggcmVmbGVjdFZlYywgMC4wICkpLnh5eiArIHZlYzMoMC4wLDAuMCwxLjApKTtcXG5cdFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSApO1xcblx0I2VuZGlmXFxuXHRlbnZDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCBlbnZDb2xvci54eXogKTtcXG5cdCNpZmRlZiBFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFlcXG5cdFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX01JWCApXFxuXHRcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX0FERCApXFxuXHRcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXG5cdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBTVEFOREFSRCApXFxuXHR1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG5cdHVuaWZvcm0gZmxvYXQgZW52TWFwSW50ZW5zdGl5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfRU5WTUFQXFxuXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblx0XHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG5cdCNlbHNlXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cdCNlbmRpZlxcblx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggU1RBTkRBUkQgKVxcblx0XHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cdCNlbHNlXFxuXHRcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3BhcnNfdmVydGV4JyBdID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmICEgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSAmJiAhIGRlZmluZWQoIFBIT05HICkgJiYgISBkZWZpbmVkKCBTVEFOREFSRCApXFxuXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfdmVydGV4JyBdID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmICEgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSAmJiAhIGRlZmluZWQoIFBIT05HICkgJiYgISBkZWZpbmVkKCBTVEFOREFSRCApXFxuXHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXHRcdHZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXHQjZWxzZVxcblx0XHR2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2ZvZ19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0RlcHRoRVhUIC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXHQjZWxzZVxcblx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXHQjZW5kaWZcXG5cdCNpZmRlZiBGT0dfRVhQMlxcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSB3aGl0ZUNvbXBsaW1lbnQoIGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApICk7XFxuXHQjZWxzZVxcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XFxuXHQjZW5kaWZcXG5cdFxcblx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZm9nX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cdHVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcXG5cdCNpZmRlZiBGT0dfRVhQMlxcblx0XHR1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XFxuXHQjZWxzZVxcblx0XHR1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nRmFyO1xcblx0I2VuZGlmXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0bWFwX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gUEkgKiB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxuXHR1bmlmb3JtIGZsb2F0IGxpZ2h0TWFwSW50ZW5zaXR5O1xcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX2xhbWJlcnRfdmVydGV4JyBdID0gXCJ2ZWMzIGRpZmZ1c2UgPSB2ZWMzKCAxLjAgKTtcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcbmdlb21ldHJ5LnBvc2l0aW9uID0gbXZQb3NpdGlvbi54eXo7XFxuZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcbmdlb21ldHJ5LnZpZXdEaXIgPSBub3JtYWxpemUoIC1tdlBvc2l0aW9uLnh5eiApO1xcbkdlb21ldHJpY0NvbnRleHQgYmFja0dlb21ldHJ5O1xcbmJhY2tHZW9tZXRyeS5wb3NpdGlvbiA9IGdlb21ldHJ5LnBvc2l0aW9uO1xcbmJhY2tHZW9tZXRyeS5ub3JtYWwgPSAtZ2VvbWV0cnkubm9ybWFsO1xcbmJhY2tHZW9tZXRyeS52aWV3RGlyID0gZ2VvbWV0cnkudmlld0RpcjtcXG52TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cdHZMaWdodEJhY2sgPSB2ZWMzKCAwLjAgKTtcXG4jZW5kaWZcXG5JbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xcbmZsb2F0IGRvdE5MO1xcbnZlYzMgZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cdFx0ZGlyZWN0TGlnaHQgPSBnZXRQb2ludERpcmVjdExpZ2h0KCBwb2ludExpZ2h0c1sgaSBdLCBnZW9tZXRyeSApO1xcblx0XHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cdFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cdFx0dkxpZ2h0RnJvbnQgKz0gc2F0dXJhdGUoIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cdFx0XHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cdFx0I2VuZGlmXFxuXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cdFx0ZGlyZWN0TGlnaHQgPSBnZXRTcG90RGlyZWN0TGlnaHQoIHNwb3RMaWdodHNbIGkgXSwgZ2VvbWV0cnkgKTtcXG5cdFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxuXHRcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IFBJICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXHRcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXHRcdFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLWRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXHRcdCNlbmRpZlxcblx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblx0XHRkaXJlY3RMaWdodCA9IGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHQoIGRpcmVjdGlvbmFsTGlnaHRzWyBpIF0sIGdlb21ldHJ5ICk7XFxuXHRcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xcblx0XHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblx0XHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblx0XHRcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC1kb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblx0XHQjZW5kaWZcXG5cdH1cXG4jZW5kaWZcXG4jaWYgTlVNX0hFTUlfTElHSFRTID4gMFxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblx0XHR2TGlnaHRGcm9udCArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5ICk7XFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cdFx0XHR2TGlnaHRCYWNrICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgYmFja0dlb21ldHJ5ICk7XFxuXHRcdCNlbmRpZlxcblx0fVxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3BhcnMuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGFycycgXSA9IFwiI2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHQge1xcblx0XHR2ZWMzIGRpcmVjdGlvbjtcXG5cdFx0dmVjMyBjb2xvcjtcXG5cdFx0aW50IHNoYWRvdztcXG5cdFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cdFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblx0XHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXHR9O1xcblx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHRzWyBOVU1fRElSX0xJR0hUUyBdO1xcblx0SW5jaWRlbnRMaWdodCBnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0KCBjb25zdCBpbiBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnkgKSB7XFxuXHRcdEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxuXHRcdGRpcmVjdExpZ2h0LmNvbG9yID0gZGlyZWN0aW9uYWxMaWdodC5jb2xvcjtcXG5cdFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247XFxuXHRcdHJldHVybiBkaXJlY3RMaWdodDtcXG5cdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cdHN0cnVjdCBQb2ludExpZ2h0IHtcXG5cdFx0dmVjMyBwb3NpdGlvbjtcXG5cdFx0dmVjMyBjb2xvcjtcXG5cdFx0ZmxvYXQgZGlzdGFuY2U7XFxuXHRcdGZsb2F0IGRlY2F5O1xcblx0XHRpbnQgc2hhZG93O1xcblx0XHRmbG9hdCBzaGFkb3dCaWFzO1xcblx0XHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXHRcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cdH07XFxuXHR1bmlmb3JtIFBvaW50TGlnaHQgcG9pbnRMaWdodHNbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cdEluY2lkZW50TGlnaHQgZ2V0UG9pbnREaXJlY3RMaWdodCggY29uc3QgaW4gUG9pbnRMaWdodCBwb2ludExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5ICkge1xcblx0XHRJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBwb2ludExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnkucG9zaXRpb247XFxuXHRcdGRpcmVjdExpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblx0XHRkaXJlY3RMaWdodC5jb2xvciA9IHBvaW50TGlnaHQuY29sb3I7XFxuXHRcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgcG9pbnRMaWdodC5kaXN0YW5jZSwgcG9pbnRMaWdodC5kZWNheSApO1xcblx0XHRyZXR1cm4gZGlyZWN0TGlnaHQ7XFxuXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cdHN0cnVjdCBTcG90TGlnaHQge1xcblx0XHR2ZWMzIHBvc2l0aW9uO1xcblx0XHR2ZWMzIGRpcmVjdGlvbjtcXG5cdFx0dmVjMyBjb2xvcjtcXG5cdFx0ZmxvYXQgZGlzdGFuY2U7XFxuXHRcdGZsb2F0IGRlY2F5O1xcblx0XHRmbG9hdCBhbmdsZUNvcztcXG5cdFx0ZmxvYXQgZXhwb25lbnQ7XFxuXHRcdGludCBzaGFkb3c7XFxuXHRcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXHRcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cdFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblx0fTtcXG5cdHVuaWZvcm0gU3BvdExpZ2h0IHNwb3RMaWdodHNbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblx0SW5jaWRlbnRMaWdodCBnZXRTcG90RGlyZWN0TGlnaHQoIGNvbnN0IGluIFNwb3RMaWdodCBzcG90TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnkgKSB7XFxuXHRcdEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxuXHRcdHZlYzMgbFZlY3RvciA9IHNwb3RMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xcblx0XHRkaXJlY3RMaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cdFx0ZmxvYXQgc3BvdEVmZmVjdCA9IGRvdCggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBzcG90TGlnaHQuZGlyZWN0aW9uICk7XFxuXHRcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodC5hbmdsZUNvcyApIHtcXG5cdFx0XHRmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHQuZGlyZWN0aW9uLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cdFx0XHRzcG90RWZmZWN0ID0gc2F0dXJhdGUoIHBvdyggc2F0dXJhdGUoIHNwb3RFZmZlY3QgKSwgc3BvdExpZ2h0LmV4cG9uZW50ICkgKTtcXG5cdFx0XHRkaXJlY3RMaWdodC5jb2xvciA9IHNwb3RMaWdodC5jb2xvcjtcXG5cdFx0XHRkaXJlY3RMaWdodC5jb2xvciAqPSAoIHNwb3RFZmZlY3QgKiBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHNwb3RMaWdodC5kaXN0YW5jZSwgc3BvdExpZ2h0LmRlY2F5ICkgKTtcXG5cdFx0fSBlbHNlIHtcXG5cdFx0XHRkaXJlY3RMaWdodC5jb2xvciA9IHZlYzMoIDAuMCApO1xcblx0XHR9XFxuXHRcdHJldHVybiBkaXJlY3RMaWdodDtcXG5cdH1cXG4jZW5kaWZcXG4jaWYgTlVNX0hFTUlfTElHSFRTID4gMFxcblx0c3RydWN0IEhlbWlzcGhlcmVMaWdodCB7XFxuXHRcdHZlYzMgZGlyZWN0aW9uO1xcblx0XHR2ZWMzIHNreUNvbG9yO1xcblx0XHR2ZWMzIGdyb3VuZENvbG9yO1xcblx0fTtcXG5cdHVuaWZvcm0gSGVtaXNwaGVyZUxpZ2h0IGhlbWlzcGhlcmVMaWdodHNbIE5VTV9IRU1JX0xJR0hUUyBdO1xcblx0dmVjMyBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBIZW1pc3BoZXJlTGlnaHQgaGVtaUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5ICkge1xcblx0XHRmbG9hdCBkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBoZW1pTGlnaHQuZGlyZWN0aW9uICk7XFxuXHRcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90TkwgKyAwLjU7XFxuXHRcdHJldHVybiBQSSAqIG1peCggaGVtaUxpZ2h0Lmdyb3VuZENvbG9yLCBoZW1pTGlnaHQuc2t5Q29sb3IsIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXHR9XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBTVEFOREFSRCApXFxuXHR2ZWMzIGdldExpZ2h0UHJvYmVJbmRpcmVjdElycmFkaWFuY2UoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXG5cdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblx0XHRcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxuXHRcdCNlbHNlXFxuXHRcdFx0ZmxvYXQgZmxpcE5vcm1hbCA9IDEuMDtcXG5cdFx0I2VuZGlmXFxuXHRcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBnZW9tZXRyeS5ub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cdFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cdFx0XHR2ZWMzIHF1ZXJ5VmVjID0gZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiB3b3JsZE5vcm1hbC54LCB3b3JsZE5vcm1hbC55eiApO1xcblx0XHRcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXG5cdFx0XHRcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZUxvZEVYVCggZW52TWFwLCBxdWVyeVZlYywgZmxvYXQoIG1heE1JUExldmVsICkgKTtcXG5cdFx0XHQjZWxzZVxcblx0XHRcdFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHF1ZXJ5VmVjLCBmbG9hdCggbWF4TUlQTGV2ZWwgKSApO1xcblx0XHRcdCNlbmRpZlxcblx0XHQjZWxzZVxcblx0XHRcdHZlYzMgZW52TWFwQ29sb3IgPSB2ZWMzKCAwLjAgKTtcXG5cdFx0I2VuZGlmXFxuXHRcdGVudk1hcENvbG9yLnJnYiA9IGlucHV0VG9MaW5lYXIoIGVudk1hcENvbG9yLnJnYiApO1xcblx0XHRyZXR1cm4gUEkgKiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxuXHR9XFxuXHRmbG9hdCBnZXRTcGVjdWxhck1JUExldmVsKCBjb25zdCBpbiBmbG9hdCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxuXHRcdGZsb2F0IG1heE1JUExldmVsU2NhbGFyID0gZmxvYXQoIG1heE1JUExldmVsICk7XFxuXHRcdGZsb2F0IGRlc2lyZWRNSVBMZXZlbCA9IG1heE1JUExldmVsU2NhbGFyIC0gMC43OTI0OCAtIDAuNSAqIGxvZzIoIHNxdWFyZSggYmxpbm5TaGluaW5lc3NFeHBvbmVudCApICsgMS4wICk7XFxuXHRcdHJldHVybiBjbGFtcCggZGVzaXJlZE1JUExldmVsLCAwLjAsIG1heE1JUExldmVsU2NhbGFyICk7XFxuXHR9XFxuXHR2ZWMzIGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBmbG9hdCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxuXHRcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXHRcdFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggLWdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCApO1xcblx0XHQjZWxzZVxcblx0XHRcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIC1nZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblx0XHQjZW5kaWZcXG5cdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblx0XHRcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxuXHRcdCNlbHNlXFxuXHRcdFx0ZmxvYXQgZmxpcE5vcm1hbCA9IDEuMDtcXG5cdFx0I2VuZGlmXFxuXHRcdHJlZmxlY3RWZWMgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCByZWZsZWN0VmVjLCB2aWV3TWF0cml4ICk7XFxuXHRcdGZsb2F0IHNwZWN1bGFyTUlQTGV2ZWwgPSBnZXRTcGVjdWxhck1JUExldmVsKCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBtYXhNSVBMZXZlbCApO1xcblx0XHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblx0XHRcdHZlYzMgcXVlcnlSZWZsZWN0VmVjID0gZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKTtcXG5cdFx0XHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxuXHRcdFx0XHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVMb2RFWFQoIGVudk1hcCwgcXVlcnlSZWZsZWN0VmVjLCBzcGVjdWxhck1JUExldmVsICk7XFxuXHRcdFx0I2Vsc2VcXG5cdFx0XHRcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBxdWVyeVJlZmxlY3RWZWMsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cdFx0XHQjZW5kaWZcXG5cdFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxuXHRcdFx0dmVjMiBzYW1wbGVVVjtcXG5cdFx0XHRzYW1wbGVVVi55ID0gc2F0dXJhdGUoIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnkgKiAwLjUgKyAwLjUgKTtcXG5cdFx0XHRzYW1wbGVVVi54ID0gYXRhbiggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueiwgZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXHRcdFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcblx0XHRcdFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRExvZEVYVCggZW52TWFwLCBzYW1wbGVVViwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblx0XHRcdCNlbHNlXFxuXHRcdFx0XHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHNhbXBsZVVWLCBzcGVjdWxhck1JUExldmVsICk7XFxuXHRcdFx0I2VuZGlmXFxuXHRcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuXHRcdFx0dmVjMyByZWZsZWN0VmlldyA9IGZsaXBOb3JtYWwgKiBub3JtYWxpemUoKHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSkueHl6ICsgdmVjMygwLjAsMC4wLDEuMCkpO1xcblx0XHRcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXG5cdFx0XHRcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkRMb2RFWFQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cdFx0XHQjZWxzZVxcblx0XHRcdFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblx0XHRcdCNlbmRpZlxcblx0XHQjZW5kaWZcXG5cdFx0ZW52TWFwQ29sb3IucmdiID0gaW5wdXRUb0xpbmVhciggZW52TWFwQ29sb3IucmdiICk7XFxuXHRcdHJldHVybiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxuXHR9XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfZnJhZ21lbnQnIF0gPSBcIkJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbDtcXG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiO1xcbm1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhcjtcXG5tYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyA9IHNoaW5pbmVzcztcXG5tYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoID0gc3BlY3VsYXJTdHJlbmd0aDtcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2VuZGlmXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuc3RydWN0IEJsaW5uUGhvbmdNYXRlcmlhbCB7XFxuXHR2ZWMzXHRkaWZmdXNlQ29sb3I7XFxuXHR2ZWMzXHRzcGVjdWxhckNvbG9yO1xcblx0ZmxvYXRcdHNwZWN1bGFyU2hpbmluZXNzO1xcblx0ZmxvYXRcdHNwZWN1bGFyU3RyZW5ndGg7XFxufTtcXG52b2lkIFJFX0RpcmVjdF9CbGlublBob25nKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXHR2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIFBJICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxuXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9TcGVjdWxhcl9CbGlublBob25nKCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzICkgKiBtYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcdFx0XHRcdFJFX0RpcmVjdF9CbGlublBob25nXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcdFx0UkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmdcXG4jZGVmaW5lIE1hdGVyaWFsX0xpZ2h0UHJvYmVMT0QoIG1hdGVyaWFsIClcdCgwKVxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3BhcnNfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3N0YW5kYXJkX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3N0YW5kYXJkX2ZyYWdtZW50JyBdID0gXCJTdGFuZGFyZE1hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIDEuMCAtIG1ldGFsbmVzc0ZhY3RvciApO1xcbm1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzID0gY2xhbXAoIHJvdWdobmVzc0ZhY3RvciwgMC4wNCwgMS4wICk7XFxubWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggMC4wNCApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19zdGFuZGFyZF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3N0YW5kYXJkX3BhcnNfZnJhZ21lbnQnIF0gPSBcInN0cnVjdCBTdGFuZGFyZE1hdGVyaWFsIHtcXG5cdHZlYzNcdGRpZmZ1c2VDb2xvcjtcXG5cdGZsb2F0XHRzcGVjdWxhclJvdWdobmVzcztcXG5cdHZlYzNcdHNwZWN1bGFyQ29sb3I7XFxufTtcXG52b2lkIFJFX0RpcmVjdF9TdGFuZGFyZCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gU3RhbmRhcmRNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG5cdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0dHWCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9TdGFuZGFyZCggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBTdGFuZGFyZE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0U3BlY3VsYXJfU3RhbmRhcmQoIGNvbnN0IGluIHZlYzMgcmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFN0YW5kYXJkTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSByYWRpYW5jZSAqIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKTtcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcdFx0XHRcdFJFX0RpcmVjdF9TdGFuZGFyZFxcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXHRcdFJFX0luZGlyZWN0RGlmZnVzZV9TdGFuZGFyZFxcbiNkZWZpbmUgUkVfSW5kaXJlY3RTcGVjdWxhclx0XHRSRV9JbmRpcmVjdFNwZWN1bGFyX1N0YW5kYXJkXFxuI2RlZmluZSBNYXRlcmlhbF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApICAgR0dYUm91Z2huZXNzVG9CbGlubkV4cG9uZW50KCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfdGVtcGxhdGUuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfdGVtcGxhdGUnIF0gPSBcIlxcbkdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnk7XFxuZ2VvbWV0cnkucG9zaXRpb24gPSAtIHZWaWV3UG9zaXRpb247XFxuZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsO1xcbmdlb21ldHJ5LnZpZXdEaXIgPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG5JbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xcbiNpZiAoIE5VTV9QT0lOVF9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXHRcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xcblx0XHRkaXJlY3RMaWdodCA9IGdldFBvaW50RGlyZWN0TGlnaHQoIHBvaW50TGlnaHQsIGdlb21ldHJ5ICk7XFxuXHRcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXHRcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGJvb2woIHBvaW50TGlnaHQuc2hhZG93ICkgPyBnZXRQb2ludFNoYWRvdyggcG9pbnRTaGFkb3dNYXBbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dNYXBTaXplLCBwb2ludExpZ2h0LnNoYWRvd0JpYXMsIHBvaW50TGlnaHQuc2hhZG93UmFkaXVzLCB2UG9pbnRTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXHRcdCNlbmRpZlxcblx0XHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXHR9XFxuI2VuZGlmXFxuI2lmICggTlVNX1NQT1RfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXHRTcG90TGlnaHQgc3BvdExpZ2h0O1xcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblx0XHRzcG90TGlnaHQgPSBzcG90TGlnaHRzWyBpIF07XFxuXHRcdGRpcmVjdExpZ2h0ID0gZ2V0U3BvdERpcmVjdExpZ2h0KCBzcG90TGlnaHQsIGdlb21ldHJ5ICk7XFxuXHRcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXHRcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGJvb2woIHNwb3RMaWdodC5zaGFkb3cgKSA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHQuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0LnNoYWRvd0JpYXMsIHNwb3RMaWdodC5zaGFkb3dSYWRpdXMsIHZTcG90U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblx0XHQjZW5kaWZcXG5cdFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblx0fVxcbiNlbmRpZlxcbiNpZiAoIE5VTV9ESVJfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7XFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXG5cdFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07XFxuXHRcdGRpcmVjdExpZ2h0ID0gZ2V0RGlyZWN0aW9uYWxEaXJlY3RMaWdodCggZGlyZWN0aW9uYWxMaWdodCwgZ2VvbWV0cnkgKTtcXG5cdFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cdFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYm9vbCggZGlyZWN0aW9uYWxMaWdodC5zaGFkb3cgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXHRcdCNlbmRpZlxcblx0XHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXHR9XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXFxuXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcblx0XHRpcnJhZGlhbmNlICs9IFBJICogdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblx0I2VuZGlmXFxuXHQjaWYgKCBOVU1fSEVNSV9MSUdIVFMgPiAwIClcXG5cdFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblx0XHRcdGlycmFkaWFuY2UgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBnZW9tZXRyeSApO1xcblx0XHR9XFxuXHQjZW5kaWZcXG5cdFJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXFxuXHR2ZWMzIHJhZGlhbmNlID0gZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoIGdlb21ldHJ5LCBNYXRlcmlhbF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApLCA4ICk7XFxuXHRSRV9JbmRpcmVjdFNwZWN1bGFyKCByYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50JyBdID0gXCJcXG5cdG91dGdvaW5nTGlnaHQgPSBsaW5lYXJUb091dHB1dCggb3V0Z29pbmdMaWdodCApO1xcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9mcmFnbWVudCcgXSA9IFwiI2lmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGKSAmJiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRl9FWFQpXFxuXHRnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKHZGcmFnRGVwdGgpICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblx0XHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXHRcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cdCNlbmRpZlxcblx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXHRnbF9Qb3NpdGlvbi56ID0gbG9nMihtYXgoIEVQU0lMT04sIGdsX1Bvc2l0aW9uLncgKyAxLjAgKSkgKiBsb2dEZXB0aEJ1ZkZDO1xcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cdFx0dkZyYWdEZXB0aCA9IDEuMCArIGdsX1Bvc2l0aW9uLnc7XFxuXHQjZWxzZVxcblx0XHRnbF9Qb3NpdGlvbi56ID0gKGdsX1Bvc2l0aW9uLnogLSAxLjApICogZ2xfUG9zaXRpb24udztcXG5cdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01BUFxcblx0dmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcblx0dGV4ZWxDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCB0ZXhlbENvbG9yLnh5eiApO1xcblx0ZGlmZnVzZUNvbG9yICo9IHRleGVsQ29sb3I7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01BUFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX3BhcnRpY2xlX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01BUFxcblx0ZGlmZnVzZUNvbG9yICo9IHRleHR1cmUyRCggbWFwLCB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5ICk7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFydGljbGVfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01BUFxcblx0dW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21ldGFsbmVzc21hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21ldGFsbmVzc21hcF9mcmFnbWVudCcgXSA9IFwiZmxvYXQgbWV0YWxuZXNzRmFjdG9yID0gbWV0YWxuZXNzO1xcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxuXHR2ZWM0IHRleGVsTWV0YWxuZXNzID0gdGV4dHVyZTJEKCBtZXRhbG5lc3NNYXAsIHZVdiApO1xcblx0bWV0YWxuZXNzRmFjdG9yICo9IHRleGVsTWV0YWxuZXNzLnI7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgbWV0YWxuZXNzTWFwO1xcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGhub3JtYWxfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGhub3JtYWxfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX01PUlBITk9STUFMU1xcblx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwwIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXG5cdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMSAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDIgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwzIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBodGFyZ2V0X3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XFxuXHQjZWxzZVxcblx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG5cdCNlbmRpZlxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGh0YXJnZXRfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ0IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDUgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA1IF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ3IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xcblx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9ub3JtYWxfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdub3JtYWxfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBGTEFUX1NIQURFRFxcblx0dmVjMyBmZHggPSBkRmR4KCB2Vmlld1Bvc2l0aW9uICk7XFxuXHR2ZWMzIGZkeSA9IGRGZHkoIHZWaWV3UG9zaXRpb24gKTtcXG5cdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggZmR4LCBmZHkgKSApO1xcbiNlbHNlXFxuXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1xcblx0I2lmZGVmIERPVUJMRV9TSURFRFxcblx0XHRub3JtYWwgPSBub3JtYWwgKiAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1xcblx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG5cdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblx0bm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCkgKTtcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuXHR2ZWMzIHBlcnR1cmJOb3JtYWwyQXJiKCB2ZWMzIGV5ZV9wb3MsIHZlYzMgc3VyZl9ub3JtICkge1xcblx0XHR2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcXG5cdFx0dmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7XFxuXHRcdHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XFxuXHRcdHZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XFxuXHRcdHZlYzMgUyA9IG5vcm1hbGl6ZSggcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcXG5cdFx0dmVjMyBUID0gbm9ybWFsaXplKCAtcTAgKiBzdDEucyArIHExICogc3QwLnMgKTtcXG5cdFx0dmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcXG5cdFx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cdFx0bWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcXG5cdFx0bWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XFxuXHRcdHJldHVybiBub3JtYWxpemUoIHRzbiAqIG1hcE4gKTtcXG5cdH1cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3Byb2plY3RfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAncHJvamVjdF92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHNraW5uZWQ7XFxuI2Vsc2VcXG5cdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG4jZW5kaWZcXG5nbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvcm91Z2huZXNzbWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAncm91Z2huZXNzbWFwX2ZyYWdtZW50JyBdID0gXCJmbG9hdCByb3VnaG5lc3NGYWN0b3IgPSByb3VnaG5lc3M7XFxuI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcXG5cdHZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlV2ICk7XFxuXHRyb3VnaG5lc3NGYWN0b3IgKj0gdGV4ZWxSb3VnaG5lc3MucjtcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3JvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAncm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCByb3VnaG5lc3NNYXA7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgTlVNX0RJUl9MSUdIVFMgXTtcXG5cdFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUUyBdO1xcblx0I2VuZGlmXFxuXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBzcG90U2hhZG93TWFwWyBOVU1fU1BPVF9MSUdIVFMgXTtcXG5cdFx0dmFyeWluZyB2ZWM0IHZTcG90U2hhZG93Q29vcmRbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblx0I2VuZGlmXFxuXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgcG9pbnRTaGFkb3dNYXBbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cdFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRTIF07XFxuXHQjZW5kaWZcXG5cdGZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XFxuXHRcdGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcXG5cdFx0cmV0dXJuIGRvdCggcmdiYV9kZXB0aCwgYml0X3NoaWZ0ICk7XFxuXHR9XFxuXHRmbG9hdCB0ZXh0dXJlMkRDb21wYXJlKCBzYW1wbGVyMkQgZGVwdGhzLCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICkge1xcblx0XHRyZXR1cm4gc3RlcCggY29tcGFyZSwgdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggZGVwdGhzLCB1diApICkgKTtcXG5cdH1cXG5cdGZsb2F0IHRleHR1cmUyRFNoYWRvd0xlcnAoIHNhbXBsZXIyRCBkZXB0aHMsIHZlYzIgc2l6ZSwgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHtcXG5cdFx0Y29uc3QgdmVjMiBvZmZzZXQgPSB2ZWMyKCAwLjAsIDEuMCApO1xcblx0XHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2l6ZTtcXG5cdFx0dmVjMiBjZW50cm9pZFVWID0gZmxvb3IoIHV2ICogc2l6ZSArIDAuNSApIC8gc2l6ZTtcXG5cdFx0ZmxvYXQgbGIgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueHgsIGNvbXBhcmUgKTtcXG5cdFx0ZmxvYXQgbHQgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueHksIGNvbXBhcmUgKTtcXG5cdFx0ZmxvYXQgcmIgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueXgsIGNvbXBhcmUgKTtcXG5cdFx0ZmxvYXQgcnQgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueXksIGNvbXBhcmUgKTtcXG5cdFx0dmVjMiBmID0gZnJhY3QoIHV2ICogc2l6ZSArIDAuNSApO1xcblx0XHRmbG9hdCBhID0gbWl4KCBsYiwgbHQsIGYueSApO1xcblx0XHRmbG9hdCBiID0gbWl4KCByYiwgcnQsIGYueSApO1xcblx0XHRmbG9hdCBjID0gbWl4KCBhLCBiLCBmLnggKTtcXG5cdFx0cmV0dXJuIGM7XFxuXHR9XFxuXHRmbG9hdCBnZXRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkge1xcblx0XHRzaGFkb3dDb29yZC54eXogLz0gc2hhZG93Q29vcmQudztcXG5cdFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzO1xcblx0XHRidmVjNCBpbkZydXN0dW1WZWMgPSBidmVjNCAoIHNoYWRvd0Nvb3JkLnggPj0gMC4wLCBzaGFkb3dDb29yZC54IDw9IDEuMCwgc2hhZG93Q29vcmQueSA+PSAwLjAsIHNoYWRvd0Nvb3JkLnkgPD0gMS4wICk7XFxuXHRcdGJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcXG5cdFx0YnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcblx0XHRib29sIGZydXN0dW1UZXN0ID0gYWxsKCBmcnVzdHVtVGVzdFZlYyApO1xcblx0XHRpZiAoIGZydXN0dW1UZXN0ICkge1xcblx0XHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5cdFx0XHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXG5cdFx0XHRmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblx0XHRcdGZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXHRcdFx0ZmxvYXQgZHgxID0gKyB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cdFx0XHRmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblx0XHRcdHJldHVybiAoXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApXFxuXHRcdFx0KSAqICggMS4wIC8gOS4wICk7XFxuXHRcdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXG5cdFx0XHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXG5cdFx0XHRmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblx0XHRcdGZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXHRcdFx0ZmxvYXQgZHgxID0gKyB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cdFx0XHRmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblx0XHRcdHJldHVybiAoXFxuXHRcdFx0XHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cdFx0XHRcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cdFx0XHRcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cdFx0XHRcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApXFxuXHRcdFx0KSAqICggMS4wIC8gOS4wICk7XFxuXHRcdCNlbHNlXFxuXHRcdFx0cmV0dXJuIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKTtcXG5cdFx0I2VuZGlmXFxuXHRcdH1cXG5cdFx0cmV0dXJuIDEuMDtcXG5cdH1cXG5cdHZlYzIgY3ViZVRvVVYoIHZlYzMgdiwgZmxvYXQgdGV4ZWxTaXplWSApIHtcXG5cdFx0dmVjMyBhYnNWID0gYWJzKCB2ICk7XFxuXHRcdGZsb2F0IHNjYWxlVG9DdWJlID0gMS4wIC8gbWF4KCBhYnNWLngsIG1heCggYWJzVi55LCBhYnNWLnogKSApO1xcblx0XHRhYnNWICo9IHNjYWxlVG9DdWJlO1xcblx0XHR2ICo9IHNjYWxlVG9DdWJlICogKCAxLjAgLSAyLjAgKiB0ZXhlbFNpemVZICk7XFxuXHRcdHZlYzIgcGxhbmFyID0gdi54eTtcXG5cdFx0ZmxvYXQgYWxtb3N0QVRleGVsID0gMS41ICogdGV4ZWxTaXplWTtcXG5cdFx0ZmxvYXQgYWxtb3N0T25lID0gMS4wIC0gYWxtb3N0QVRleGVsO1xcblx0XHRpZiAoIGFic1YueiA+PSBhbG1vc3RPbmUgKSB7XFxuXHRcdFx0aWYgKCB2LnogPiAwLjAgKVxcblx0XHRcdFx0cGxhbmFyLnggPSA0LjAgLSB2Lng7XFxuXHRcdH0gZWxzZSBpZiAoIGFic1YueCA+PSBhbG1vc3RPbmUgKSB7XFxuXHRcdFx0ZmxvYXQgc2lnblggPSBzaWduKCB2LnggKTtcXG5cdFx0XHRwbGFuYXIueCA9IHYueiAqIHNpZ25YICsgMi4wICogc2lnblg7XFxuXHRcdH0gZWxzZSBpZiAoIGFic1YueSA+PSBhbG1vc3RPbmUgKSB7XFxuXHRcdFx0ZmxvYXQgc2lnblkgPSBzaWduKCB2LnkgKTtcXG5cdFx0XHRwbGFuYXIueCA9IHYueCArIDIuMCAqIHNpZ25ZICsgMi4wO1xcblx0XHRcdHBsYW5hci55ID0gdi56ICogc2lnblkgLSAyLjA7XFxuXHRcdH1cXG5cdFx0cmV0dXJuIHZlYzIoIDAuMTI1LCAwLjI1ICkgKiBwbGFuYXIgKyB2ZWMyKCAwLjM3NSwgMC43NSApO1xcblx0fVxcblx0ZmxvYXQgZ2V0UG9pbnRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkge1xcblx0XHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXG5cdFx0dmVjMyBsaWdodFRvUG9zaXRpb24gPSBzaGFkb3dDb29yZC54eXo7XFxuXHRcdHZlYzMgYmQzRCA9IG5vcm1hbGl6ZSggbGlnaHRUb1Bvc2l0aW9uICk7XFxuXHRcdGZsb2F0IGRwID0gKCBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApIC0gc2hhZG93QmlhcyApIC8gMTAwMC4wO1xcblx0XHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblx0XHRcdHZlYzMgb2Zmc2V0ID0gdmVjMyggLSAxLCAwLCAxICkgKiBzaGFkb3dSYWRpdXMgKiAyLjAgKiB0ZXhlbFNpemUueTtcXG5cdFx0XHRyZXR1cm4gKFxcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC56enosIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC56eHosIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHosIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54enosIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC56engsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC56eHgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54engsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC56enksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC56eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh6eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnp5eiwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eiwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnp5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl6eiwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eiwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl6eCwgdGV4ZWxTaXplLnkgKSwgZHAgKVxcblx0XHRcdCkgKiAoIDEuMCAvIDIxLjAgKTtcXG5cdFx0I2Vsc2VcXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKTtcXG5cdFx0I2VuZGlmXFxuXHR9XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXHRcdHVuaWZvcm0gbWF0NCBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgTlVNX0RJUl9MSUdIVFMgXTtcXG5cdFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUUyBdO1xcblx0I2VuZGlmXFxuXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblx0XHR1bmlmb3JtIG1hdDQgc3BvdFNoYWRvd01hdHJpeFsgTlVNX1NQT1RfTElHSFRTIF07XFxuXHRcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVFMgXTtcXG5cdCNlbmRpZlxcblx0I2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXHRcdHVuaWZvcm0gbWF0NCBwb2ludFNoYWRvd01hdHJpeFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblx0XHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXG5cdFx0dkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSA9IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcblx0fVxcblx0I2VuZGlmXFxuXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblx0XHR2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gPSBzcG90U2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcblx0fVxcblx0I2VuZGlmXFxuXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXHRcdHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gPSBwb2ludFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cdH1cXG5cdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFza19wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFza19wYXJzX2ZyYWdtZW50JyBdID0gXCJmbG9hdCBnZXRTaGFkb3dNYXNrKCkge1xcblx0ZmxvYXQgc2hhZG93ID0gMS4wO1xcblx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cdERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodDtcXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblx0XHRkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodHNbIGkgXTtcXG5cdFx0c2hhZG93ICo9IGJvb2woIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93ICkgPyBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93TWFwU2l6ZSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblx0fVxcblx0I2VuZGlmXFxuXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblx0U3BvdExpZ2h0IHNwb3RMaWdodDtcXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cdFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdO1xcblx0XHRzaGFkb3cgKj0gYm9vbCggc3BvdExpZ2h0LnNoYWRvdyApID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodC5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHQuc2hhZG93Qmlhcywgc3BvdExpZ2h0LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXHR9XFxuXHQjZW5kaWZcXG5cdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblx0UG9pbnRMaWdodCBwb2ludExpZ2h0O1xcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cdFx0cG9pbnRMaWdodCA9IHBvaW50TGlnaHRzWyBpIF07XFxuXHRcdHNoYWRvdyAqPSBib29sKCBwb2ludExpZ2h0LnNoYWRvdyApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblx0fVxcblx0I2VuZGlmXFxuXHQjZW5kaWZcXG5cdHJldHVybiBzaGFkb3c7XFxufVxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbmJhc2VfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbmJhc2VfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXHRtYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTtcXG5cdG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcblx0bWF0NCBib25lTWF0WiA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC56ICk7XFxuXHRtYXQ0IGJvbmVNYXRXID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LncgKTtcXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5uaW5nX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5pbmdfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcblx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXhJbnZlcnNlO1xcblx0I2lmZGVmIEJPTkVfVEVYVFVSRVxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcXG5cdFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVXaWR0aDtcXG5cdFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVIZWlnaHQ7XFxuXHRcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cdFx0XHRmbG9hdCBqID0gaSAqIDQuMDtcXG5cdFx0XHRmbG9hdCB4ID0gbW9kKCBqLCBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApICk7XFxuXHRcdFx0ZmxvYXQgeSA9IGZsb29yKCBqIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcblx0XHRcdGZsb2F0IGR4ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKTtcXG5cdFx0XHRmbG9hdCBkeSA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZUhlaWdodCApO1xcblx0XHRcdHkgPSBkeSAqICggeSArIDAuNSApO1xcblx0XHRcdHZlYzQgdjEgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDAuNSApLCB5ICkgKTtcXG5cdFx0XHR2ZWM0IHYyID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAxLjUgKSwgeSApICk7XFxuXHRcdFx0dmVjNCB2MyA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMi41ICksIHkgKSApO1xcblx0XHRcdHZlYzQgdjQgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDMuNSApLCB5ICkgKTtcXG5cdFx0XHRtYXQ0IGJvbmUgPSBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApO1xcblx0XHRcdHJldHVybiBib25lO1xcblx0XHR9XFxuXHQjZWxzZVxcblx0XHR1bmlmb3JtIG1hdDQgYm9uZUdsb2JhbE1hdHJpY2VzWyBNQVhfQk9ORVMgXTtcXG5cdFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblx0XHRcdG1hdDQgYm9uZSA9IGJvbmVHbG9iYWxNYXRyaWNlc1sgaW50KGkpIF07XFxuXHRcdFx0cmV0dXJuIGJvbmU7XFxuXHRcdH1cXG5cdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5pbmdfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5pbmdfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXHR2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XFxuXHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcXG5cdHNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1xcblx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XFxuXHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcXG5cdHNraW5uZWQgID0gYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5vcm1hbF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2lubm9ybWFsX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblx0bWF0NCBza2luTWF0cml4ID0gbWF0NCggMC4wICk7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC56ICogYm9uZU1hdFo7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXO1xcblx0c2tpbk1hdHJpeCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4O1xcblx0b2JqZWN0Tm9ybWFsID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdE5vcm1hbCwgMC4wICkgKS54eXo7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zcGVjdWxhcm1hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NwZWN1bGFybWFwX2ZyYWdtZW50JyBdID0gXCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cdHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApO1xcblx0c3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcXG4jZWxzZVxcblx0c3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDtcXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2Ml9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1djJfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblx0YXR0cmlidXRlIHZlYzIgdXYyO1xcblx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3ZlcnRleCcgXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXHR2VXYyID0gdXYyO1xcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXZfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2X3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblx0dmFyeWluZyB2ZWMyIHZVdjtcXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAndXZfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblx0dmFyeWluZyB2ZWMyIHZVdjtcXG5cdHVuaWZvcm0gdmVjNCBvZmZzZXRSZXBlYXQ7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91dl92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1dl92ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblx0dlV2ID0gdXYgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHk7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay93b3JsZHBvc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICd3b3JsZHBvc192ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBTVEFOREFSRCApIHx8IGRlZmluZWQoIExBTUJFUlQgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApXFxuXHQjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogc2tpbm5lZDtcXG5cdCNlbHNlXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9Vbmlmb3Jtc1V0aWxzLmpzXHJcblxyXG4vKipcclxuICogVW5pZm9ybSBVdGlsaXRpZXNcclxuICovXHJcblxyXG5USFJFRS5Vbmlmb3Jtc1V0aWxzID0ge1xyXG5cclxuXHRtZXJnZTogZnVuY3Rpb24gKCB1bmlmb3JtcyApIHtcclxuXHJcblx0XHR2YXIgbWVyZ2VkID0ge307XHJcblxyXG5cdFx0Zm9yICggdmFyIHUgPSAwOyB1IDwgdW5pZm9ybXMubGVuZ3RoOyB1ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuY2xvbmUoIHVuaWZvcm1zWyB1IF0gKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBwIGluIHRtcCApIHtcclxuXHJcblx0XHRcdFx0bWVyZ2VkWyBwIF0gPSB0bXBbIHAgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1lcmdlZDtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICggdW5pZm9ybXNfc3JjICkge1xyXG5cclxuXHRcdHZhciB1bmlmb3Jtc19kc3QgPSB7fTtcclxuXHJcblx0XHRmb3IgKCB2YXIgdSBpbiB1bmlmb3Jtc19zcmMgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtc19kc3RbIHUgXSA9IHt9O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIHAgaW4gdW5pZm9ybXNfc3JjWyB1IF0gKSB7XHJcblxyXG5cdFx0XHRcdHZhciBwYXJhbWV0ZXJfc3JjID0gdW5pZm9ybXNfc3JjWyB1IF1bIHAgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgfHxcclxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiB8fFxyXG5cdFx0XHRcdFx0IHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzIHx8XHJcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjQgfHxcclxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4MyB8fFxyXG5cdFx0XHRcdFx0IHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXg0IHx8XHJcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggcGFyYW1ldGVyX3NyYyApICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLnNsaWNlKCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuaWZvcm1zX2RzdDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1VuaWZvcm1zTGliLmpzXHJcblxyXG4vKipcclxuICogVW5pZm9ybXMgbGlicmFyeSBmb3Igc2hhcmVkIHdlYmdsIHNoYWRlcnNcclxuICovXHJcblxyXG5USFJFRS5Vbmlmb3Jtc0xpYiA9IHtcclxuXHJcblx0Y29tbW9uOiB7XHJcblxyXG5cdFx0XCJkaWZmdXNlXCI6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZWVlZWVlICkgfSxcclxuXHRcdFwib3BhY2l0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblxyXG5cdFx0XCJtYXBcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFwib2Zmc2V0UmVwZWF0XCI6IHsgdHlwZTogXCJ2NFwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjQoIDAsIDAsIDEsIDEgKSB9LFxyXG5cclxuXHRcdFwic3BlY3VsYXJNYXBcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFwiYWxwaGFNYXBcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHJcblx0XHRcImVudk1hcFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJmbGlwRW52TWFwXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfSxcclxuXHRcdFwicmVmbGVjdGl2aXR5XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFwicmVmcmFjdGlvblJhdGlvXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjk4IH1cclxuXHJcblx0fSxcclxuXHJcblx0YW9tYXA6IHtcclxuXHJcblx0XHRcImFvTWFwXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcImFvTWFwSW50ZW5zaXR5XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH1cclxuXHJcblx0fSxcclxuXHJcblx0bGlnaHRtYXA6IHtcclxuXHJcblx0XHRcImxpZ2h0TWFwXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcImxpZ2h0TWFwSW50ZW5zaXR5XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH1cclxuXHJcblx0fSxcclxuXHJcblx0ZW1pc3NpdmVtYXA6IHtcclxuXHJcblx0XHRcImVtaXNzaXZlTWFwXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH1cclxuXHJcblx0fSxcclxuXHJcblx0YnVtcG1hcDoge1xyXG5cclxuXHRcdFwiYnVtcE1hcFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJidW1wU2NhbGVcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxtYXA6IHtcclxuXHJcblx0XHRcIm5vcm1hbE1hcFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJub3JtYWxTY2FsZVwiOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICkgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwbGFjZW1lbnRtYXA6IHtcclxuXHJcblx0XHRcImRpc3BsYWNlbWVudE1hcFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJkaXNwbGFjZW1lbnRTY2FsZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cdFx0XCJkaXNwbGFjZW1lbnRCaWFzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwIH1cclxuXHJcblx0fSxcclxuXHJcblx0cm91Z2huZXNzbWFwOiB7XHJcblxyXG5cdFx0XCJyb3VnaG5lc3NNYXBcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRtZXRhbG5lc3NtYXA6IHtcclxuXHJcblx0XHRcIm1ldGFsbmVzc01hcFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9XHJcblxyXG5cdH0sXHJcblxyXG5cdGZvZzoge1xyXG5cclxuXHRcdFwiZm9nRGVuc2l0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wMDAyNSB9LFxyXG5cdFx0XCJmb2dOZWFyXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcblx0XHRcImZvZ0ZhclwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMCB9LFxyXG5cdFx0XCJmb2dDb2xvclwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH1cclxuXHJcblx0fSxcclxuXHJcblx0YW1iaWVudDoge1xyXG5cclxuXHRcdFwiYW1iaWVudExpZ2h0Q29sb3JcIjogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9XHJcblxyXG5cdH0sXHJcblxyXG5cdGxpZ2h0czoge1xyXG5cclxuXHRcdFwiZGlyZWN0aW9uYWxMaWdodHNcIjogeyB0eXBlOiBcInNhXCIsIHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xyXG5cdFx0XHRcImRpcmVjdGlvblwiOiB7IHR5cGU6IFwidjNcIiB9LFxyXG5cdFx0XHRcImNvbG9yXCI6IHsgdHlwZTogXCJjXCIgfSxcclxuXHJcblx0XHRcdFwic2hhZG93XCI6IHsgdHlwZTogXCJpXCIgfSxcclxuXHRcdFx0XCJzaGFkb3dCaWFzXCI6IHsgdHlwZTogXCJmXCIgfSxcclxuXHRcdFx0XCJzaGFkb3dSYWRpdXNcIjogeyB0eXBlOiBcImZcIiB9LFxyXG5cdFx0XHRcInNoYWRvd01hcFNpemVcIjogeyB0eXBlOiBcInYyXCIgfVxyXG5cdFx0fSB9LFxyXG5cclxuXHRcdFwiZGlyZWN0aW9uYWxTaGFkb3dNYXBcIjogeyB0eXBlOiBcInR2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFwiOiB7IHR5cGU6IFwibTR2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFwic3BvdExpZ2h0c1wiOiB7IHR5cGU6IFwic2FcIiwgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XHJcblx0XHRcdFwiY29sb3JcIjogeyB0eXBlOiBcImNcIiB9LFxyXG5cdFx0XHRcInBvc2l0aW9uXCI6IHsgdHlwZTogXCJ2M1wiIH0sXHJcblx0XHRcdFwiZGlyZWN0aW9uXCI6IHsgdHlwZTogXCJ2M1wiIH0sXHJcblx0XHRcdFwiZGlzdGFuY2VcIjogeyB0eXBlOiBcImZcIiB9LFxyXG5cdFx0XHRcImFuZ2xlQ29zXCI6IHsgdHlwZTogXCJmXCIgfSxcclxuXHRcdFx0XCJleHBvbmVudFwiOiB7IHR5cGU6IFwiZlwiIH0sXHJcblx0XHRcdFwiZGVjYXlcIjogeyB0eXBlOiBcImZcIiB9LFxyXG5cclxuXHRcdFx0XCJzaGFkb3dcIjogeyB0eXBlOiBcImlcIiB9LFxyXG5cdFx0XHRcInNoYWRvd0JpYXNcIjogeyB0eXBlOiBcImZcIiB9LFxyXG5cdFx0XHRcInNoYWRvd1JhZGl1c1wiOiB7IHR5cGU6IFwiZlwiIH0sXHJcblx0XHRcdFwic2hhZG93TWFwU2l6ZVwiOiB7IHR5cGU6IFwidjJcIiB9XHJcblx0XHR9IH0sXHJcblxyXG5cdFx0XCJzcG90U2hhZG93TWFwXCI6IHsgdHlwZTogXCJ0dlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwic3BvdFNoYWRvd01hdHJpeFwiOiB7IHR5cGU6IFwibTR2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFwicG9pbnRMaWdodHNcIjogeyB0eXBlOiBcInNhXCIsIHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xyXG5cdFx0XHRcImNvbG9yXCI6IHsgdHlwZTogXCJjXCIgfSxcclxuXHRcdFx0XCJwb3NpdGlvblwiOiB7IHR5cGU6IFwidjNcIiB9LFxyXG5cdFx0XHRcImRlY2F5XCI6IHsgdHlwZTogXCJmXCIgfSxcclxuXHRcdFx0XCJkaXN0YW5jZVwiOiB7IHR5cGU6IFwiZlwiIH0sXHJcblxyXG5cdFx0XHRcInNoYWRvd1wiOiB7IHR5cGU6IFwiaVwiIH0sXHJcblx0XHRcdFwic2hhZG93Qmlhc1wiOiB7IHR5cGU6IFwiZlwiIH0sXHJcblx0XHRcdFwic2hhZG93UmFkaXVzXCI6IHsgdHlwZTogXCJmXCIgfSxcclxuXHRcdFx0XCJzaGFkb3dNYXBTaXplXCI6IHsgdHlwZTogXCJ2MlwiIH1cclxuXHRcdH0gfSxcclxuXHJcblx0XHRcInBvaW50U2hhZG93TWFwXCI6IHsgdHlwZTogXCJ0dlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwicG9pbnRTaGFkb3dNYXRyaXhcIjogeyB0eXBlOiBcIm00dlwiLCB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRcImhlbWlzcGhlcmVMaWdodHNcIjogeyB0eXBlOiBcInNhXCIsIHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xyXG5cdFx0XHRcImRpcmVjdGlvblwiOiB7IHR5cGU6IFwidjNcIiB9LFxyXG5cdFx0XHRcInNreUNvbG9yXCI6IHsgdHlwZTogXCJjXCIgfSxcclxuXHRcdFx0XCJncm91bmRDb2xvclwiOiB7IHR5cGU6IFwiY1wiIH1cclxuXHRcdH0gfVxyXG5cclxuXHR9LFxyXG5cclxuXHRwb2ludHM6IHtcclxuXHJcblx0XHRcImRpZmZ1c2VcIjogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKSB9LFxyXG5cdFx0XCJvcGFjaXR5XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFwic2l6ZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblx0XHRcInNjYWxlXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFwibWFwXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcIm9mZnNldFJlcGVhdFwiOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxICkgfVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyTGliLmpzXHJcblxyXG4vKipcclxuICogV2ViZ2wgU2hhZGVyIExpYnJhcnkgZm9yIHRocmVlLmpzXHJcbiAqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqL1xyXG5cclxuXHJcblRIUkVFLlNoYWRlckxpYiA9IHtcclxuXHJcblx0J2Jhc2ljJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhb21hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF1cclxuXHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwiXHQjaWZkZWYgVVNFX0VOVk1BUFwiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwiXHQjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxyXG5cclxuXHRcdFx0XCJcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQ7XCIsXHJcblx0XHRcdFwiXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlID0gdmVjMyggMC4wICk7XCIsXHJcblx0XHRcdFwiXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcIlx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlID0gZGlmZnVzZUNvbG9yLnJnYjtcIixcclxuXHRcdFx0XCJcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblx0J2xhbWJlcnQnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImFvbWFwXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJlbWlzc2l2ZW1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImFtYmllbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxyXG5cclxuXHRcdFx0e1xyXG5cdFx0XHRcdFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCIjZGVmaW5lIExBTUJFUlRcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcIlx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJic2Rmc1wiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19wYXJzXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX2xhbWJlcnRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcIlx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYnNkZnNcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbWJpZW50X3BhcnNcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGFyc1wiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcclxuXHRcdFx0XCJcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XCIsXHJcblx0XHRcdFwiXHR2ZWMzIHRvdGFsRW1pc3NpdmVMaWdodCA9IGVtaXNzaXZlO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0Ly8gYWNjdW11bGF0aW9uXHJcblx0XHRcdFwiXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBkaWZmdXNlQ29sb3IucmdiICk7XCIsXHJcblxyXG5cdFx0XHRcIlx0I2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XCJcdFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9ICggZ2xfRnJvbnRGYWNpbmcgKSA/IHZMaWdodEZyb250IDogdkxpZ2h0QmFjaztcIixcclxuXHJcblx0XHRcdFwiXHQjZWxzZVwiLFxyXG5cclxuXHRcdFx0XCJcdFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9IHZMaWdodEZyb250O1wiLFxyXG5cclxuXHRcdFx0XCJcdCNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKj0gQlJERl9EaWZmdXNlX0xhbWJlcnQoIGRpZmZ1c2VDb2xvci5yZ2IgKSAqIGdldFNoYWRvd01hc2soKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gbW9kdWxhdGlvblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgdG90YWxFbWlzc2l2ZUxpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApXHJcblxyXG5cdH0sXHJcblxyXG5cdCdwaG9uZyc6IHtcclxuXHJcblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiYW9tYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodG1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImVtaXNzaXZlbWFwXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiYnVtcG1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcIm5vcm1hbG1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImRpc3BsYWNlbWVudG1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImFtYmllbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxyXG5cclxuXHRcdFx0e1xyXG5cdFx0XHRcdFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfSxcclxuXHRcdFx0XHRcInNwZWN1bGFyXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApIH0sXHJcblx0XHRcdFx0XCJzaGluaW5lc3NcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDMwIH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwiI2RlZmluZSBQSE9OR1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxyXG5cclxuXHRcdFx0XCJcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLCAvLyBOb3JtYWwgY29tcHV0ZWQgd2l0aCBkZXJpdmF0aXZlcyB3aGVuIEZMQVRfU0hBREVEXHJcblxyXG5cdFx0XHRcIlx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGlzcGxhY2VtZW50bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCIjZGVmaW5lIFBIT05HXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BlY3VsYXI7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJic2Rmc1wiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFtYmllbnRfcGFyc1wiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19wYXJzXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJ1bXBtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXHJcblx0XHRcdFwiXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1wiLFxyXG5cdFx0XHRcIlx0dmVjMyB0b3RhbEVtaXNzaXZlTGlnaHQgPSBlbWlzc2l2ZTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJub3JtYWxfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0Ly8gYWNjdW11bGF0aW9uXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfdGVtcGxhdGVcIiBdLFxyXG5cclxuXHRcdFx0XHQvLyBtb2R1bGF0aW9uXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlTGlnaHQ7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9LFxyXG5cclxuXHQnc3RhbmRhcmQnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImFvbWFwXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJlbWlzc2l2ZW1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImJ1bXBtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJub3JtYWxtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJkaXNwbGFjZW1lbnRtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJyb3VnaG5lc3NtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJtZXRhbG5lc3NtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhbWJpZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcclxuXHJcblx0XHRcdHtcclxuXHRcdFx0XHRcImVtaXNzaXZlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApIH0sXHJcblx0XHRcdFx0XCJyb3VnaG5lc3NcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuNSB9LFxyXG5cdFx0XHRcdFwibWV0YWxuZXNzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwIH0sXHJcblx0XHRcdFx0XCJlbnZNYXBJbnRlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0gLy8gdGVtcG9yYXJ5XHJcblx0XHRcdH1cclxuXHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcIiNkZWZpbmUgU1RBTkRBUkRcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcIiNpZm5kZWYgRkxBVF9TSEFERURcIixcclxuXHJcblx0XHRcdFwiXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIiwgLy8gU1RBTkRBUkRcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCIjaWZuZGVmIEZMQVRfU0hBREVEXCIsIC8vIE5vcm1hbCBjb21wdXRlZCB3aXRoIGRlcml2YXRpdmVzIHdoZW4gRkxBVF9TSEFERURcclxuXHJcblx0XHRcdFwiXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkaXNwbGFjZW1lbnRtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcIiNkZWZpbmUgU1RBTkRBUkRcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgcm91Z2huZXNzO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgbWV0YWxuZXNzO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBlbnZNYXBJbnRlbnNpdHk7XCIsIC8vIHRlbXBvcmFyeVxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxyXG5cclxuXHRcdFx0XCJcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYnNkZnNcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbWJpZW50X3BhcnNcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGFyc1wiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19zdGFuZGFyZF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJidW1wbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJub3JtYWxtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxyXG5cdFx0XHRcIlx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcIixcclxuXHRcdFx0XCJcdHZlYzMgdG90YWxFbWlzc2l2ZUxpZ2h0ID0gZW1pc3NpdmU7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicm91Z2huZXNzbWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtZXRhbG5lc3NtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW1pc3NpdmVtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHQvLyBhY2N1bXVsYXRpb25cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfc3RhbmRhcmRfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c190ZW1wbGF0ZVwiIF0sXHJcblxyXG5cdFx0XHRcdC8vIG1vZHVsYXRpb25cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFwidmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVMaWdodDtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9LFxyXG5cclxuXHQncG9pbnRzJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJwb2ludHNcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdXHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNpemU7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cIixcclxuXHRcdFx0XCJcdFx0Z2xfUG9pbnRTaXplID0gc2l6ZSAqICggc2NhbGUgLyAtIG12UG9zaXRpb24ueiApO1wiLFxyXG5cdFx0XHRcIlx0I2Vsc2VcIixcclxuXHRcdFx0XCJcdFx0Z2xfUG9pbnRTaXplID0gc2l6ZTtcIixcclxuXHRcdFx0XCJcdCNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApXHJcblxyXG5cdH0sXHJcblxyXG5cdCdkYXNoZWQnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXHJcblxyXG5cdFx0XHR7XHJcblx0XHRcdFx0XCJzY2FsZVwiICAgIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcclxuXHRcdFx0XHRcImRhc2hTaXplXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cdFx0XHRcdFwidG90YWxTaXplXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyIH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcIixcclxuXHRcdFx0XCJhdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJcdHZMaW5lRGlzdGFuY2UgPSBzY2FsZSAqIGxpbmVEaXN0YW5jZTtcIixcclxuXHJcblx0XHRcdFwiXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCB0b3RhbFNpemU7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0XHRkaXNjYXJkO1wiLFxyXG5cclxuXHRcdFx0XCJcdH1cIixcclxuXHJcblx0XHRcdFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFx0XCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1wiLCAvLyBzaW1wbGUgc2hhZGVyXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblx0J2RlcHRoJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcIm1OZWFyXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFx0XCJtRmFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMC4wIH0sXHJcblx0XHRcdFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBtTmVhcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1GYXI7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXCIsXHJcblxyXG5cdFx0XHRcIlx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdEZXB0aEVYVCAvIGdsX0ZyYWdDb29yZC53O1wiLFxyXG5cclxuXHRcdFx0XCJcdCNlbHNlXCIsXHJcblxyXG5cdFx0XHRcIlx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXHJcblxyXG5cdFx0XHRcIlx0I2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIlx0ZmxvYXQgY29sb3IgPSAxLjAgLSBzbW9vdGhzdGVwKCBtTmVhciwgbUZhciwgZGVwdGggKTtcIixcclxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIGNvbG9yICksIG9wYWNpdHkgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblx0J25vcm1hbCc6IHtcclxuXHJcblx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjUgKiBub3JtYWxpemUoIHZOb3JtYWwgKSArIDAuNSwgb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApXHJcblxyXG5cdH0sXHJcblxyXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHQvL1x0Q3ViZSBtYXAgc2hhZGVyXHJcblx0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcblx0J2N1YmUnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHtcclxuXHRcdFx0XCJ0Q3ViZVwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRcInRGbGlwXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfVxyXG5cdFx0fSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1wiLFxyXG5cclxuXHRcdFx0XCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHRGbGlwO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdC8vXHRDdWJlIG1hcCBzaGFkZXJcclxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHQnZXF1aXJlY3QnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHtcclxuXHRcdFx0XCJ0RXF1aXJlY3RcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0XCJ0RmxpcFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLSAxIH1cclxuXHRcdH0sXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XCJcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcIixcclxuXHJcblx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHRGbGlwO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHQvLyBcIlx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1wiLFxyXG5cdFx0XHRcdFwidmVjMiBzYW1wbGVVVjtcIixcclxuXHRcdFx0XHRcInNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggdEZsaXAgKiBkaXJlY3Rpb24ueSAqIC0wLjUgKyAwLjUgKTtcIixcclxuXHRcdFx0XHRcInNhbXBsZVVWLnggPSBhdGFuKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1wiLFxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblx0LyogRGVwdGggZW5jb2RpbmcgaW50byBSR0JBIHRleHR1cmVcclxuXHQgKlxyXG5cdCAqIGJhc2VkIG9uIFNwaWRlckdMIHNoYWRvdyBtYXAgZXhhbXBsZVxyXG5cdCAqIGh0dHA6Ly9zcGlkZXJnbC5vcmcvZXhhbXBsZS5waHA/aWQ9NlxyXG5cdCAqXHJcblx0ICogb3JpZ2luYWxseSBmcm9tXHJcblx0ICogaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC90b3BpYy80NDIxMzgtcGFja2luZy1hLWZsb2F0LWludG8tYS1hOHI4ZzhiOC10ZXh0dXJlLXNoYWRlci9wYWdlX193aGljaHBhZ2VfXzElMjVFRiUyNUJGJTI1QkRcclxuXHQgKlxyXG5cdCAqIHNlZSBhbHNvXHJcblx0ICogaHR0cDovL2FyYXMtcC5pbmZvL2Jsb2cvMjAwOS8wNy8zMC9lbmNvZGluZy1mbG9hdHMtdG8tcmdiYS10aGUtZmluYWwvXHJcblx0ICovXHJcblxyXG5cdCdkZXB0aFJHQkEnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHt9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHBhY2tfZGVwdGgoIGNvbnN0IGluIGZsb2F0IGRlcHRoICkge1wiLFxyXG5cclxuXHRcdFx0XCJcdGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wLCAyNTYuMCwgMS4wICk7XCIsXHJcblx0XHRcdFwiXHRjb25zdCB2ZWM0IGJpdF9tYXNrID0gdmVjNCggMC4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wICk7XCIsXHJcblx0XHRcdFwiXHR2ZWM0IHJlcyA9IG1vZCggZGVwdGggKiBiaXRfc2hpZnQgKiB2ZWM0KCAyNTUgKSwgdmVjNCggMjU2ICkgKSAvIHZlYzQoIDI1NSApO1wiLFxyXG5cdFx0XHRcIlx0cmVzIC09IHJlcy54eHl6ICogYml0X21hc2s7XCIsXHJcblx0XHRcdFwiXHRyZXR1cm4gcmVzO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXCIsXHJcblxyXG5cdFx0XHRcIlx0XHRnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0RlcHRoRVhUICk7XCIsXHJcblxyXG5cdFx0XHRcIlx0I2Vsc2VcIixcclxuXHJcblx0XHRcdFwiXHRcdGdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiApO1wiLFxyXG5cclxuXHRcdFx0XCJcdCNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKTtcIixcclxuXHRcdFx0XHQvL1wiZmxvYXQgeiA9ICggKCBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53ICkgLSAzLjAgKSAvICggNDAwMC4wIC0gMy4wICk7XCIsXHJcblx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCB6ICk7XCIsXHJcblx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSB2ZWM0KCB6LCB6LCB6LCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblxyXG5cdCdkaXN0YW5jZVJHQkEnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFwibGlnaHRQb3NcIjogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApIH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRcInZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGxpZ2h0UG9zO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblxyXG5cdFx0XHRcInZlYzQgcGFjazFLICggZmxvYXQgZGVwdGggKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0ZGVwdGggLz0gMTAwMC4wO1wiLFxyXG5cdFx0XHRcIlx0Y29uc3QgdmVjNCBiaXRTaCA9IHZlYzQoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCwgMjU2LjAgKiAyNTYuMCwgMjU2LjAsIDEuMCApO1wiLFxyXG5cdFx0XHRcIlx0Y29uc3QgdmVjNCBiaXRNc2sgPSB2ZWM0KCAwLjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAgKTtcIixcclxuXHRcdFx0XCJcdHZlYzQgcmVzID0gbW9kKCBkZXB0aCAqIGJpdFNoICogdmVjNCggMjU1ICksIHZlYzQoIDI1NiApICkgLyB2ZWM0KCAyNTUgKTtcIixcclxuXHRcdFx0XCJcdHJlcyAtPSByZXMueHh5eiAqIGJpdE1zaztcIixcclxuXHRcdFx0XCJcdHJldHVybiByZXM7IFwiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcImZsb2F0IHVucGFjazFLICggdmVjNCBjb2xvciApIHtcIixcclxuXHJcblx0XHRcdFwiXHRjb25zdCB2ZWM0IGJpdFNoID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcIixcclxuXHRcdFx0XCJcdHJldHVybiBkb3QoIGNvbG9yLCBiaXRTaCApICogMTAwMC4wO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbiAoKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gcGFjazFLKCBsZW5ndGgoIHZXb3JsZFBvc2l0aW9uLnh5eiAtIGxpZ2h0UG9zLnh5eiApICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApXHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cclxuICovXHJcblxyXG5USFJFRS5XZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXInLCBUSFJFRS5SRVZJU0lPTiApO1xyXG5cclxuXHRwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcclxuXHJcblx0dmFyIF9jYW52YXMgPSBwYXJhbWV0ZXJzLmNhbnZhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jYW52YXMgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApLFxyXG5cdF9jb250ZXh0ID0gcGFyYW1ldGVycy5jb250ZXh0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNvbnRleHQgOiBudWxsLFxyXG5cclxuXHRfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2UsXHJcblx0X2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5kZXB0aCA6IHRydWUsXHJcblx0X3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXHJcblx0X2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxyXG5cdF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxyXG5cdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZTtcclxuXHJcblx0dmFyIGxpZ2h0cyA9IFtdO1xyXG5cclxuXHR2YXIgb3BhcXVlT2JqZWN0cyA9IFtdO1xyXG5cdHZhciBvcGFxdWVPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xyXG5cdHZhciB0cmFuc3BhcmVudE9iamVjdHMgPSBbXTtcclxuXHR2YXIgdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xyXG5cclxuXHR2YXIgbW9ycGhJbmZsdWVuY2VzID0gbmV3IEZsb2F0MzJBcnJheSggOCApO1xyXG5cclxuXHR2YXIgc3ByaXRlcyA9IFtdO1xyXG5cdHZhciBsZW5zRmxhcmVzID0gW107XHJcblxyXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXHJcblxyXG5cdHRoaXMuZG9tRWxlbWVudCA9IF9jYW52YXM7XHJcblx0dGhpcy5jb250ZXh0ID0gbnVsbDtcclxuXHJcblx0Ly8gY2xlYXJpbmdcclxuXHJcblx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xyXG5cdHRoaXMuYXV0b0NsZWFyQ29sb3IgPSB0cnVlO1xyXG5cdHRoaXMuYXV0b0NsZWFyRGVwdGggPSB0cnVlO1xyXG5cdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XHJcblxyXG5cdC8vIHNjZW5lIGdyYXBoXHJcblxyXG5cdHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xyXG5cclxuXHQvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcclxuXHJcblx0dGhpcy5nYW1tYUZhY3RvciA9IDIuMDtcdC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cdHRoaXMuZ2FtbWFJbnB1dCA9IGZhbHNlO1xyXG5cdHRoaXMuZ2FtbWFPdXRwdXQgPSBmYWxzZTtcclxuXHJcblx0Ly8gbW9ycGhzXHJcblxyXG5cdHRoaXMubWF4TW9ycGhUYXJnZXRzID0gODtcclxuXHR0aGlzLm1heE1vcnBoTm9ybWFscyA9IDQ7XHJcblxyXG5cdC8vIGZsYWdzXHJcblxyXG5cdHRoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgPSB0cnVlO1xyXG5cclxuXHQvLyBpbnRlcm5hbCBwcm9wZXJ0aWVzXHJcblxyXG5cdHZhciBfdGhpcyA9IHRoaXMsXHJcblxyXG5cdC8vIGludGVybmFsIHN0YXRlIGNhY2hlXHJcblxyXG5cdF9jdXJyZW50UHJvZ3JhbSA9IG51bGwsXHJcblx0X2N1cnJlbnRSZW5kZXJUYXJnZXQgPSBudWxsLFxyXG5cdF9jdXJyZW50RnJhbWVidWZmZXIgPSBudWxsLFxyXG5cdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMSxcclxuXHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnLFxyXG5cdF9jdXJyZW50Q2FtZXJhID0gbnVsbCxcclxuXHJcblx0X2N1cnJlbnRTY2lzc29yID0gbmV3IFRIUkVFLlZlY3RvcjQoKSxcclxuXHRfY3VycmVudFNjaXNzb3JUZXN0ID0gbnVsbCxcclxuXHJcblx0X2N1cnJlbnRWaWV3cG9ydCA9IG5ldyBUSFJFRS5WZWN0b3I0KCksXHJcblxyXG5cdC8vXHJcblxyXG5cdF91c2VkVGV4dHVyZVVuaXRzID0gMCxcclxuXHJcblx0Ly9cclxuXHJcblx0X2NsZWFyQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICksXHJcblx0X2NsZWFyQWxwaGEgPSAwLFxyXG5cclxuXHRfd2lkdGggPSBfY2FudmFzLndpZHRoLFxyXG5cdF9oZWlnaHQgPSBfY2FudmFzLmhlaWdodCxcclxuXHJcblx0X3BpeGVsUmF0aW8gPSAxLFxyXG5cclxuXHRfc2Npc3NvciA9IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCBfd2lkdGgsIF9oZWlnaHQgKSxcclxuXHRfc2Npc3NvclRlc3QgPSBmYWxzZSxcclxuXHJcblx0X3ZpZXdwb3J0ID0gbmV3IFRIUkVFLlZlY3RvcjQoIDAsIDAsIF93aWR0aCwgX2hlaWdodCApLFxyXG5cclxuXHQvLyBmcnVzdHVtXHJcblxyXG5cdF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcclxuXHJcblx0Ly8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXHJcblxyXG5cdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHJcblx0X3ZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuXHQvLyBsaWdodCBhcnJheXMgY2FjaGVcclxuXHJcblx0X2xpZ2h0cyA9IHtcclxuXHJcblx0XHRoYXNoOiAnJyxcclxuXHJcblx0XHRhbWJpZW50OiBbIDAsIDAsIDAgXSxcclxuXHRcdGRpcmVjdGlvbmFsOiBbXSxcclxuXHRcdGRpcmVjdGlvbmFsU2hhZG93TWFwOiBbXSxcclxuXHRcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiBbXSxcclxuXHRcdHNwb3Q6IFtdLFxyXG5cdFx0c3BvdFNoYWRvd01hcDogW10sXHJcblx0XHRzcG90U2hhZG93TWF0cml4OiBbXSxcclxuXHRcdHBvaW50OiBbXSxcclxuXHRcdHBvaW50U2hhZG93TWFwOiBbXSxcclxuXHRcdHBvaW50U2hhZG93TWF0cml4OiBbXSxcclxuXHRcdGhlbWk6IFtdLFxyXG5cclxuXHRcdHNoYWRvd3M6IFtdLFxyXG5cdFx0c2hhZG93c1BvaW50TGlnaHQ6IDBcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gaW5mb1xyXG5cclxuXHRfaW5mb01lbW9yeSA9IHtcclxuXHJcblx0XHRnZW9tZXRyaWVzOiAwLFxyXG5cdFx0dGV4dHVyZXM6IDBcclxuXHJcblx0fSxcclxuXHJcblx0X2luZm9SZW5kZXIgPSB7XHJcblxyXG5cdFx0Y2FsbHM6IDAsXHJcblx0XHR2ZXJ0aWNlczogMCxcclxuXHRcdGZhY2VzOiAwLFxyXG5cdFx0cG9pbnRzOiAwXHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuaW5mbyA9IHtcclxuXHJcblx0XHRyZW5kZXI6IF9pbmZvUmVuZGVyLFxyXG5cdFx0bWVtb3J5OiBfaW5mb01lbW9yeSxcclxuXHRcdHByb2dyYW1zOiBudWxsXHJcblxyXG5cdH07XHJcblxyXG5cclxuXHQvLyBpbml0aWFsaXplXHJcblxyXG5cdHZhciBfZ2w7XHJcblxyXG5cdHRyeSB7XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB7XHJcblx0XHRcdGFscGhhOiBfYWxwaGEsXHJcblx0XHRcdGRlcHRoOiBfZGVwdGgsXHJcblx0XHRcdHN0ZW5jaWw6IF9zdGVuY2lsLFxyXG5cdFx0XHRhbnRpYWxpYXM6IF9hbnRpYWxpYXMsXHJcblx0XHRcdHByZW11bHRpcGxpZWRBbHBoYTogX3ByZW11bHRpcGxpZWRBbHBoYSxcclxuXHRcdFx0cHJlc2VydmVEcmF3aW5nQnVmZmVyOiBfcHJlc2VydmVEcmF3aW5nQnVmZmVyXHJcblx0XHR9O1xyXG5cclxuXHRcdF9nbCA9IF9jb250ZXh0IHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJywgYXR0cmlidXRlcyApIHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMgKTtcclxuXHJcblx0XHRpZiAoIF9nbCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGlmICggX2NhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnICkgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRocm93ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLic7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcclxuXHJcblx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgZXJyb3IgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgZXh0ZW5zaW9ucyA9IG5ldyBUSFJFRS5XZWJHTEV4dGVuc2lvbnMoIF9nbCApO1xyXG5cclxuXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xyXG5cdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApO1xyXG5cdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcclxuXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyApO1xyXG5cdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xyXG5cdGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcclxuXHJcblx0aWYgKCBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XHJcblxyXG5cdFx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuTWF4SW5kZXggPSA0Mjk0OTY3Mjk2O1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBjYXBhYmlsaXRpZXMgPSBuZXcgVEhSRUUuV2ViR0xDYXBhYmlsaXRpZXMoIF9nbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApO1xyXG5cclxuXHR2YXIgc3RhdGUgPSBuZXcgVEhSRUUuV2ViR0xTdGF0ZSggX2dsLCBleHRlbnNpb25zLCBwYXJhbVRocmVlVG9HTCApO1xyXG5cdHZhciBwcm9wZXJ0aWVzID0gbmV3IFRIUkVFLldlYkdMUHJvcGVydGllcygpO1xyXG5cdHZhciBvYmplY3RzID0gbmV3IFRIUkVFLldlYkdMT2JqZWN0cyggX2dsLCBwcm9wZXJ0aWVzLCB0aGlzLmluZm8gKTtcclxuXHR2YXIgcHJvZ3JhbUNhY2hlID0gbmV3IFRIUkVFLldlYkdMUHJvZ3JhbXMoIHRoaXMsIGNhcGFiaWxpdGllcyApO1xyXG5cdHZhciBsaWdodENhY2hlID0gbmV3IFRIUkVFLldlYkdMTGlnaHRzKCk7XHJcblxyXG5cdHRoaXMuaW5mby5wcm9ncmFtcyA9IHByb2dyYW1DYWNoZS5wcm9ncmFtcztcclxuXHJcblx0dmFyIGJ1ZmZlclJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXIoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKTtcclxuXHR2YXIgaW5kZXhlZEJ1ZmZlclJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdGZ1bmN0aW9uIGdldFRhcmdldFBpeGVsUmF0aW8oKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsID8gX3BpeGVsUmF0aW8gOiAxO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdsQ2xlYXJDb2xvciggciwgZywgYiwgYSApIHtcclxuXHJcblx0XHRpZiAoIF9wcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRyICo9IGE7IGcgKj0gYTsgYiAqPSBhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0RGVmYXVsdEdMU3RhdGUoKSB7XHJcblxyXG5cdFx0c3RhdGUuaW5pdCgpO1xyXG5cclxuXHRcdHN0YXRlLnNjaXNzb3IoIF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApICk7XHJcblx0XHRzdGF0ZS52aWV3cG9ydCggX2N1cnJlbnRWaWV3cG9ydC5jb3B5KCBfdmlld3BvcnQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKSApO1xyXG5cclxuXHRcdGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZXNldEdMU3RhdGUoKSB7XHJcblxyXG5cdFx0X2N1cnJlbnRQcm9ncmFtID0gbnVsbDtcclxuXHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcclxuXHJcblx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xyXG5cdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxO1xyXG5cclxuXHRcdHN0YXRlLnJlc2V0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RGVmYXVsdEdMU3RhdGUoKTtcclxuXHJcblx0dGhpcy5jb250ZXh0ID0gX2dsO1xyXG5cdHRoaXMuY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzO1xyXG5cdHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XHJcblx0dGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuXHR0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG5cdC8vIHNoYWRvdyBtYXBcclxuXHJcblx0dmFyIHNoYWRvd01hcCA9IG5ldyBUSFJFRS5XZWJHTFNoYWRvd01hcCggdGhpcywgX2xpZ2h0cywgb2JqZWN0cyApO1xyXG5cclxuXHR0aGlzLnNoYWRvd01hcCA9IHNoYWRvd01hcDtcclxuXHJcblxyXG5cdC8vIFBsdWdpbnNcclxuXHJcblx0dmFyIHNwcml0ZVBsdWdpbiA9IG5ldyBUSFJFRS5TcHJpdGVQbHVnaW4oIHRoaXMsIHNwcml0ZXMgKTtcclxuXHR2YXIgbGVuc0ZsYXJlUGx1Z2luID0gbmV3IFRIUkVFLkxlbnNGbGFyZVBsdWdpbiggdGhpcywgbGVuc0ZsYXJlcyApO1xyXG5cclxuXHQvLyBBUElcclxuXHJcblx0dGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfZ2w7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0Q29udGV4dEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmZvcmNlQ29udGV4dExvc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0ZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICkubG9zZUNvbnRleHQoKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRNYXhBbmlzb3Ryb3B5ID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHZhbHVlO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xyXG5cclxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIHZhbHVlO1xyXG5cclxuXHRcdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xyXG5cclxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHZhbHVlID0gX2dsLmdldFBhcmFtZXRlciggZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dmFsdWUgPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0gKSgpO1xyXG5cclxuXHR0aGlzLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gY2FwYWJpbGl0aWVzLnByZWNpc2lvbjtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfcGl4ZWxSYXRpbztcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0X3BpeGVsUmF0aW8gPSB2YWx1ZTtcclxuXHJcblx0XHR0aGlzLnNldFNpemUoIF92aWV3cG9ydC56LCBfdmlld3BvcnQudywgZmFsc2UgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHdpZHRoOiBfd2lkdGgsXHJcblx0XHRcdGhlaWdodDogX2hlaWdodFxyXG5cdFx0fTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSApIHtcclxuXHJcblx0XHRfd2lkdGggPSB3aWR0aDtcclxuXHRcdF9oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdFx0X2NhbnZhcy53aWR0aCA9IHdpZHRoICogX3BpeGVsUmF0aW87XHJcblx0XHRfY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIF9waXhlbFJhdGlvO1xyXG5cclxuXHRcdGlmICggdXBkYXRlU3R5bGUgIT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0X2NhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcclxuXHRcdFx0X2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0c3RhdGUudmlld3BvcnQoIF92aWV3cG9ydC5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0c3RhdGUuc2Npc3NvciggX3NjaXNzb3Iuc2V0KCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggYm9vbGVhbiApIHtcclxuXHJcblx0XHRzdGF0ZS5zZXRTY2lzc29yVGVzdCggX3NjaXNzb3JUZXN0ID0gYm9vbGVhbiApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBDbGVhcmluZ1xyXG5cclxuXHR0aGlzLmdldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9jbGVhckNvbG9yO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcclxuXHJcblx0XHRfY2xlYXJDb2xvci5zZXQoIGNvbG9yICk7XHJcblxyXG5cdFx0X2NsZWFyQWxwaGEgPSBhbHBoYSAhPT0gdW5kZWZpbmVkID8gYWxwaGEgOiAxO1xyXG5cclxuXHRcdGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfY2xlYXJBbHBoYTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCBhbHBoYSApIHtcclxuXHJcblx0XHRfY2xlYXJBbHBoYSA9IGFscGhhO1xyXG5cclxuXHRcdGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICggY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xyXG5cclxuXHRcdHZhciBiaXRzID0gMDtcclxuXHJcblx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgfHwgY29sb3IgKSBiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xyXG5cdFx0aWYgKCBkZXB0aCA9PT0gdW5kZWZpbmVkIHx8IGRlcHRoICkgYml0cyB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcclxuXHRcdGlmICggc3RlbmNpbCA9PT0gdW5kZWZpbmVkIHx8IHN0ZW5jaWwgKSBiaXRzIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XHJcblxyXG5cdFx0X2dsLmNsZWFyKCBiaXRzICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuY2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNsZWFyKCB0cnVlLCBmYWxzZSwgZmFsc2UgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5jbGVhckRlcHRoID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY2xlYXIoIGZhbHNlLCB0cnVlLCBmYWxzZSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNsZWFyKCBmYWxzZSwgZmFsc2UsIHRydWUgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5jbGVhclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XHJcblxyXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xyXG5cdFx0dGhpcy5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFJlc2V0XHJcblxyXG5cdHRoaXMucmVzZXRHTFN0YXRlID0gcmVzZXRHTFN0YXRlO1xyXG5cclxuXHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRfY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gRXZlbnRzXHJcblxyXG5cdGZ1bmN0aW9uIG9uQ29udGV4dExvc3QoIGV2ZW50ICkge1xyXG5cclxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0cmVzZXRHTFN0YXRlKCk7XHJcblx0XHRzZXREZWZhdWx0R0xTdGF0ZSgpO1xyXG5cclxuXHRcdHByb3BlcnRpZXMuY2xlYXIoKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKCBldmVudCApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHR0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xyXG5cclxuXHRcdGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0X2luZm9NZW1vcnkudGV4dHVyZXMgLS07XHJcblxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcclxuXHJcblx0XHRkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyAtLTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbk1hdGVyaWFsRGlzcG9zZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdG1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcclxuXHJcblx0XHRkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gQnVmZmVyIGRlYWxsb2NhdGlvblxyXG5cclxuXHRmdW5jdGlvbiBkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xyXG5cclxuXHRcdFx0Ly8gY3ViZSB0ZXh0dXJlXHJcblxyXG5cdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyAyRCB0ZXh0dXJlXHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVtb3ZlIGFsbCB3ZWJnbCBwcm9wZXJ0aWVzXHJcblx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggdGV4dHVyZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggISByZW5kZXJUYXJnZXQgfHwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xyXG5cdFx0XHRcdF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcclxuXHRcdHByb3BlcnRpZXMuZGVsZXRlKCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0cHJvcGVydGllcy5kZWxldGUoIG1hdGVyaWFsICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtSW5mbyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApLnByb2dyYW07XHJcblxyXG5cdFx0bWF0ZXJpYWwucHJvZ3JhbSA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHRpZiAoIHByb2dyYW1JbmZvICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRwcm9ncmFtQ2FjaGUucmVsZWFzZVByb2dyYW0oIHByb2dyYW1JbmZvICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIEJ1ZmZlciByZW5kZXJpbmdcclxuXHJcblx0dGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHR2YXIgYnVmZmVycyA9IHByb3BlcnRpZXMuZ2V0KCBvYmplY3QgKTtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgJiYgISBidWZmZXJzLnBvc2l0aW9uICkgYnVmZmVycy5wb3NpdGlvbiA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgJiYgISBidWZmZXJzLm5vcm1hbCApIGJ1ZmZlcnMubm9ybWFsID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmICEgYnVmZmVycy51diApIGJ1ZmZlcnMudXYgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgISBidWZmZXJzLmNvbG9yICkgYnVmZmVycy5jb2xvciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnBvc2l0aW9uICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QucG9zaXRpb25BcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuXHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5ub3JtYWwgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwudHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyAmJiBtYXRlcmlhbC50eXBlICE9PSAnTWVzaFN0YW5kYXJkTWF0ZXJpYWwnICYmIG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLkZsYXRTaGFkaW5nICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3QuY291bnQgKiAzOyBpIDwgbDsgaSArPSA5ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBhcnJheSA9IG9iamVjdC5ub3JtYWxBcnJheTtcclxuXHJcblx0XHRcdFx0XHR2YXIgbnggPSAoIGFycmF5WyBpICsgMCBdICsgYXJyYXlbIGkgKyAzIF0gKyBhcnJheVsgaSArIDYgXSApIC8gMztcclxuXHRcdFx0XHRcdHZhciBueSA9ICggYXJyYXlbIGkgKyAxIF0gKyBhcnJheVsgaSArIDQgXSArIGFycmF5WyBpICsgNyBdICkgLyAzO1xyXG5cdFx0XHRcdFx0dmFyIG56ID0gKCBhcnJheVsgaSArIDIgXSArIGFycmF5WyBpICsgNSBdICsgYXJyYXlbIGkgKyA4IF0gKSAvIDM7XHJcblxyXG5cdFx0XHRcdFx0YXJyYXlbIGkgKyAwIF0gPSBueDtcclxuXHRcdFx0XHRcdGFycmF5WyBpICsgMSBdID0gbnk7XHJcblx0XHRcdFx0XHRhcnJheVsgaSArIDIgXSA9IG56O1xyXG5cclxuXHRcdFx0XHRcdGFycmF5WyBpICsgMyBdID0gbng7XHJcblx0XHRcdFx0XHRhcnJheVsgaSArIDQgXSA9IG55O1xyXG5cdFx0XHRcdFx0YXJyYXlbIGkgKyA1IF0gPSBuejtcclxuXHJcblx0XHRcdFx0XHRhcnJheVsgaSArIDYgXSA9IG54O1xyXG5cdFx0XHRcdFx0YXJyYXlbIGkgKyA3IF0gPSBueTtcclxuXHRcdFx0XHRcdGFycmF5WyBpICsgOCBdID0gbno7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3Qubm9ybWFsQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcclxuXHJcblx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5ub3JtYWwgKTtcclxuXHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC5oYXNVdnMgJiYgbWF0ZXJpYWwubWFwICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMudXYgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC51dkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblxyXG5cdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcclxuXHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMuY29sb3IgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5jb2xvckFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblxyXG5cdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuY29sb3IgKTtcclxuXHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLmNvbG9yLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdFx0X2dsLmRyYXdBcnJheXMoIF9nbC5UUklBTkdMRVMsIDAsIG9iamVjdC5jb3VudCApO1xyXG5cclxuXHRcdG9iamVjdC5jb3VudCA9IDA7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVuZGVyQnVmZmVyRGlyZWN0ID0gZnVuY3Rpb24gKCBjYW1lcmEsIGZvZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICkge1xyXG5cclxuXHRcdHNldE1hdGVyaWFsKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHJcblx0XHR2YXIgdXBkYXRlQnVmZmVycyA9IGZhbHNlO1xyXG5cdFx0dmFyIGdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5LmlkICsgJ18nICsgcHJvZ3JhbS5pZCArICdfJyArIG1hdGVyaWFsLndpcmVmcmFtZTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5UHJvZ3JhbSAhPT0gX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gKSB7XHJcblxyXG5cdFx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5UHJvZ3JhbTtcclxuXHRcdFx0dXBkYXRlQnVmZmVycyA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG1vcnBoIHRhcmdldHNcclxuXHJcblx0XHR2YXIgbW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcclxuXHJcblx0XHRpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIGFjdGl2ZUluZmx1ZW5jZXMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5mbHVlbmNlID0gbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XHJcblx0XHRcdFx0YWN0aXZlSW5mbHVlbmNlcy5wdXNoKCBbIGluZmx1ZW5jZSwgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhY3RpdmVJbmZsdWVuY2VzLnNvcnQoIGFic051bWVyaWNhbFNvcnQgKTtcclxuXHJcblx0XHRcdGlmICggYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGggPiA4ICkge1xyXG5cclxuXHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aCA9IDg7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5mbHVlbmNlID0gYWN0aXZlSW5mbHVlbmNlc1sgaSBdO1xyXG5cdFx0XHRcdG1vcnBoSW5mbHVlbmNlc1sgaSBdID0gaW5mbHVlbmNlWyAwIF07XHJcblxyXG5cdFx0XHRcdGlmICggaW5mbHVlbmNlWyAwIF0gIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gaW5mbHVlbmNlWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgJiYgbW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSwgbW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uWyBpbmRleCBdICk7XHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9PT0gdHJ1ZSAmJiBtb3JwaEF0dHJpYnV0ZXMubm9ybWFsICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSwgbW9ycGhBdHRyaWJ1dGVzLm5vcm1hbFsgaW5kZXggXSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSApO1xyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB1bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcclxuXHJcblx0XHRcdGlmICggdW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFmdiggdW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLCBtb3JwaEluZmx1ZW5jZXMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG5cdFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGluZGV4ID0gb2JqZWN0cy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByZW5kZXJlcjtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0cmVuZGVyZXIgPSBpbmRleGVkQnVmZmVyUmVuZGVyZXI7XHJcblx0XHRcdHJlbmRlcmVyLnNldEluZGV4KCBpbmRleCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZW5kZXJlciA9IGJ1ZmZlclJlbmRlcmVyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgb2JqZWN0cy5nZXRBdHRyaWJ1dGVCdWZmZXIoIGluZGV4ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgZGF0YVN0YXJ0ID0gMDtcclxuXHRcdHZhciBkYXRhQ291bnQgPSBJbmZpbml0eTtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0ZGF0YUNvdW50ID0gaW5kZXguY291bnQ7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGRhdGFDb3VudCA9IHBvc2l0aW9uLmNvdW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmFuZ2VTdGFydCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5zdGFydDtcclxuXHRcdHZhciByYW5nZUNvdW50ID0gZ2VvbWV0cnkuZHJhd1JhbmdlLmNvdW50O1xyXG5cclxuXHRcdHZhciBncm91cFN0YXJ0ID0gZ3JvdXAgIT09IG51bGwgPyBncm91cC5zdGFydCA6IDA7XHJcblx0XHR2YXIgZ3JvdXBDb3VudCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuY291bnQgOiBJbmZpbml0eTtcclxuXHJcblx0XHR2YXIgZHJhd1N0YXJ0ID0gTWF0aC5tYXgoIGRhdGFTdGFydCwgcmFuZ2VTdGFydCwgZ3JvdXBTdGFydCApO1xyXG5cdFx0dmFyIGRyYXdFbmQgPSBNYXRoLm1pbiggZGF0YVN0YXJ0ICsgZGF0YUNvdW50LCByYW5nZVN0YXJ0ICsgcmFuZ2VDb3VudCwgZ3JvdXBTdGFydCArIGdyb3VwQ291bnQgKSAtIDE7XHJcblxyXG5cdFx0dmFyIGRyYXdDb3VudCA9IE1hdGgubWF4KCAwLCBkcmF3RW5kIC0gZHJhd1N0YXJ0ICsgMSApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdHN0YXRlLnNldExpbmVXaWR0aCggbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoICogZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpICk7XHJcblx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVTICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCBvYmplY3QuZHJhd01vZGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5UcmlhbmdsZXNEcmF3TW9kZTpcclxuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFUyApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFRIUkVFLlRyaWFuZ2xlU3RyaXBEcmF3TW9kZTpcclxuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFX1NUUklQICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuVHJpYW5nbGVGYW5EcmF3TW9kZTpcclxuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFX0ZBTiApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xyXG5cclxuXHRcdFx0dmFyIGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcclxuXHJcblx0XHRcdGlmICggbGluZVdpZHRoID09PSB1bmRlZmluZWQgKSBsaW5lV2lkdGggPSAxOyAvLyBOb3QgdXNpbmcgTGluZSpNYXRlcmlhbFxyXG5cclxuXHRcdFx0c3RhdGUuc2V0TGluZVdpZHRoKCBsaW5lV2lkdGggKiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkgKTtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZVNlZ21lbnRzICkge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FX1NUUklQICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzICkge1xyXG5cclxuXHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlBPSU5UUyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgJiYgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPiAwICkge1xyXG5cclxuXHRcdFx0cmVuZGVyZXIucmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSwgZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBkcmF3U3RhcnQsIGRyYXdDb3VudCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKSB7XHJcblxyXG5cdFx0dmFyIGV4dGVuc2lvbjtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblxyXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCApIHN0YXJ0SW5kZXggPSAwO1xyXG5cclxuXHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0dmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIHByb2dyYW1BdHRyaWJ1dGUgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc2l6ZSA9IGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplO1xyXG5cdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IG9iamVjdHMuZ2V0QXR0cmlidXRlQnVmZmVyKCBnZW9tZXRyeUF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcclxuXHRcdFx0XHRcdFx0dmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xyXG5cdFx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gZ2VvbWV0cnlBdHRyaWJ1dGUub2Zmc2V0O1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhIGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUsIGRhdGEubWVzaFBlckF0dHJpYnV0ZSwgZXh0ZW5zaW9uICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGRhdGEubWVzaFBlckF0dHJpYnV0ZSAqIGRhdGEuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgc3RyaWRlICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgKCBzdGFydEluZGV4ICogc3RyaWRlICsgb2Zmc2V0ICkgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUsIGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUsIGV4dGVuc2lvbiApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICogZ2VvbWV0cnlBdHRyaWJ1dGUuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgc3RhcnRJbmRleCAqIHNpemUgKiA0ICk7IC8vIDQgYnl0ZXMgcGVyIEZsb2F0MzJcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHN3aXRjaCAoIHZhbHVlLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAyOlxyXG5cdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjJmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYXNlIDM6XHJcblx0XHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliM2Z2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhc2UgNDpcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWI0ZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIxZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gU29ydGluZ1xyXG5cclxuXHRmdW5jdGlvbiBhYnNOdW1lcmljYWxTb3J0KCBhLCBiICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggYlsgMCBdICkgLSBNYXRoLmFicyggYVsgMCBdICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xyXG5cclxuXHRcdGlmICggYS5vYmplY3QucmVuZGVyT3JkZXIgIT09IGIub2JqZWN0LnJlbmRlck9yZGVyICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGEub2JqZWN0LnJlbmRlck9yZGVyIC0gYi5vYmplY3QucmVuZGVyT3JkZXI7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYS5tYXRlcmlhbC5pZCAhPT0gYi5tYXRlcmlhbC5pZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBhLm1hdGVyaWFsLmlkIC0gYi5tYXRlcmlhbC5pZDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBhLnogLSBiLno7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBhLmlkIC0gYi5pZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcclxuXHJcblx0XHRpZiAoIGEub2JqZWN0LnJlbmRlck9yZGVyICE9PSBiLm9iamVjdC5yZW5kZXJPcmRlciApIHtcclxuXHJcblx0XHRcdHJldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciAtIGIub2JqZWN0LnJlbmRlck9yZGVyO1xyXG5cclxuXHRcdH0gaWYgKCBhLnogIT09IGIueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBiLnogLSBhLno7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBhLmlkIC0gYi5pZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gUmVuZGVyaW5nXHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQsIGZvcmNlQ2xlYXIgKSB7XHJcblxyXG5cdFx0aWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmEgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS4nICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZvZyA9IHNjZW5lLmZvZztcclxuXHJcblx0XHQvLyByZXNldCBjYWNoaW5nIGZvciB0aGlzIGZyYW1lXHJcblxyXG5cdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcclxuXHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTtcclxuXHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcclxuXHJcblx0XHQvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcclxuXHJcblx0XHRpZiAoIHNjZW5lLmF1dG9VcGRhdGUgPT09IHRydWUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cclxuXHJcblx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuXHRcdGxpZ2h0cy5sZW5ndGggPSAwO1xyXG5cclxuXHRcdG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggPSAtIDE7XHJcblx0XHR0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggPSAtIDE7XHJcblxyXG5cdFx0c3ByaXRlcy5sZW5ndGggPSAwO1xyXG5cdFx0bGVuc0ZsYXJlcy5sZW5ndGggPSAwO1xyXG5cclxuXHRcdHByb2plY3RPYmplY3QoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0XHRvcGFxdWVPYmplY3RzLmxlbmd0aCA9IG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggKyAxO1xyXG5cdFx0dHJhbnNwYXJlbnRPYmplY3RzLmxlbmd0aCA9IHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleCArIDE7XHJcblxyXG5cdFx0aWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdG9wYXF1ZU9iamVjdHMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcclxuXHRcdFx0dHJhbnNwYXJlbnRPYmplY3RzLnNvcnQoIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzZXR1cExpZ2h0cyggbGlnaHRzLCBjYW1lcmEgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHNoYWRvd01hcC5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdF9pbmZvUmVuZGVyLmNhbGxzID0gMDtcclxuXHRcdF9pbmZvUmVuZGVyLnZlcnRpY2VzID0gMDtcclxuXHRcdF9pbmZvUmVuZGVyLmZhY2VzID0gMDtcclxuXHRcdF9pbmZvUmVuZGVyLnBvaW50cyA9IDA7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJlbmRlclRhcmdldCA9IG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuYXV0b0NsZWFyIHx8IGZvcmNlQ2xlYXIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNsZWFyKCB0aGlzLmF1dG9DbGVhckNvbG9yLCB0aGlzLmF1dG9DbGVhckRlcHRoLCB0aGlzLmF1dG9DbGVhclN0ZW5jaWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHR2YXIgb3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRyZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBjYW1lcmEsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApO1xyXG5cdFx0XHRyZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgZm9nLCBvdmVycmlkZU1hdGVyaWFsICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIG9wYXF1ZSBwYXNzIChmcm9udC10by1iYWNrIG9yZGVyKVxyXG5cclxuXHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIFRIUkVFLk5vQmxlbmRpbmcgKTtcclxuXHRcdFx0cmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgY2FtZXJhLCBmb2cgKTtcclxuXHJcblx0XHRcdC8vIHRyYW5zcGFyZW50IHBhc3MgKGJhY2stdG8tZnJvbnQgb3JkZXIpXHJcblxyXG5cdFx0XHRyZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgZm9nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGN1c3RvbSByZW5kZXIgcGx1Z2lucyAocG9zdCBwYXNzKVxyXG5cclxuXHRcdHNwcml0ZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHRcdGxlbnNGbGFyZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50Vmlld3BvcnQgKTtcclxuXHJcblx0XHQvLyBHZW5lcmF0ZSBtaXBtYXAgaWYgd2UncmUgdXNpbmcgYW55IGtpbmQgb2YgbWlwbWFwIGZpbHRlcmluZ1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQgKSAmJlxyXG5cdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgJiZcclxuXHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XHJcblxyXG5cdFx0XHRcdHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEVuc3VyZSBkZXB0aCBidWZmZXIgd3JpdGluZyBpcyBlbmFibGVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkIG9uIG5leHQgcmVuZGVyXHJcblxyXG5cdFx0c3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XHJcblx0XHRzdGF0ZS5zZXREZXB0aFdyaXRlKCB0cnVlICk7XHJcblx0XHRzdGF0ZS5zZXRDb2xvcldyaXRlKCB0cnVlICk7XHJcblxyXG5cdFx0Ly8gX2dsLmZpbmlzaCgpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHosIGdyb3VwICkge1xyXG5cclxuXHRcdHZhciBhcnJheSwgaW5kZXg7XHJcblxyXG5cdFx0Ly8gYWxsb2NhdGUgdGhlIG5leHQgcG9zaXRpb24gaW4gdGhlIGFwcHJvcHJpYXRlIGFycmF5XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcclxuXHJcblx0XHRcdGFycmF5ID0gdHJhbnNwYXJlbnRPYmplY3RzO1xyXG5cdFx0XHRpbmRleCA9ICsrIHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0YXJyYXkgPSBvcGFxdWVPYmplY3RzO1xyXG5cdFx0XHRpbmRleCA9ICsrIG9wYXF1ZU9iamVjdHNMYXN0SW5kZXg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlY3ljbGUgZXhpc3RpbmcgcmVuZGVyIGl0ZW0gb3IgZ3JvdyB0aGUgYXJyYXlcclxuXHJcblx0XHR2YXIgcmVuZGVySXRlbSA9IGFycmF5WyBpbmRleCBdO1xyXG5cclxuXHRcdGlmICggcmVuZGVySXRlbSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmVuZGVySXRlbS5pZCA9IG9iamVjdC5pZDtcclxuXHRcdFx0cmVuZGVySXRlbS5vYmplY3QgPSBvYmplY3Q7XHJcblx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHRcdFx0cmVuZGVySXRlbS5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG5cdFx0XHRyZW5kZXJJdGVtLnogPSBfdmVjdG9yMy56O1xyXG5cdFx0XHRyZW5kZXJJdGVtLmdyb3VwID0gZ3JvdXA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJlbmRlckl0ZW0gPSB7XHJcblx0XHRcdFx0aWQ6IG9iamVjdC5pZCxcclxuXHRcdFx0XHRvYmplY3Q6IG9iamVjdCxcclxuXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnksXHJcblx0XHRcdFx0bWF0ZXJpYWw6IG1hdGVyaWFsLFxyXG5cdFx0XHRcdHo6IF92ZWN0b3IzLnosXHJcblx0XHRcdFx0Z3JvdXA6IGdyb3VwXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvLyBhc3NlcnQoIGluZGV4ID09PSBhcnJheS5sZW5ndGggKTtcclxuXHRcdFx0YXJyYXkucHVzaCggcmVuZGVySXRlbSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5sYXllcnMudGVzdCggY2FtZXJhLmxheWVycyApICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCApIHtcclxuXHJcblx0XHRcdFx0bGlnaHRzLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRzcHJpdGVzLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MZW5zRmxhcmUgKSB7XHJcblxyXG5cdFx0XHRcdGxlbnNGbGFyZXMucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBudWxsLCBvYmplY3QubWF0ZXJpYWwsIF92ZWN0b3IzLnosIG51bGwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0LnNrZWxldG9uLnVwZGF0ZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NdWx0aU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbHMgPSBtYXRlcmlhbC5tYXRlcmlhbHM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBncm91cE1hdGVyaWFsLCBfdmVjdG9yMy56LCBncm91cCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0cHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0cHJvamVjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgY2FtZXJhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbmRlck9iamVjdHMoIHJlbmRlckxpc3QsIGNhbWVyYSwgZm9nLCBvdmVycmlkZU1hdGVyaWFsICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciByZW5kZXJJdGVtID0gcmVuZGVyTGlzdFsgaSBdO1xyXG5cclxuXHRcdFx0dmFyIG9iamVjdCA9IHJlbmRlckl0ZW0ub2JqZWN0O1xyXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSByZW5kZXJJdGVtLmdlb21ldHJ5O1xyXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsID09PSB1bmRlZmluZWQgPyByZW5kZXJJdGVtLm1hdGVyaWFsIDogb3ZlcnJpZGVNYXRlcmlhbDtcclxuXHRcdFx0dmFyIGdyb3VwID0gcmVuZGVySXRlbS5ncm91cDtcclxuXHJcblx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdG9iamVjdC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubW9kZWxWaWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0c2V0TWF0ZXJpYWwoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcclxuXHJcblx0XHRcdFx0b2JqZWN0LnJlbmRlciggZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3RoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCggY2FtZXJhLCBmb2csIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmb2csIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0dmFyIHBhcmFtZXRlcnMgPSBwcm9ncmFtQ2FjaGUuZ2V0UGFyYW1ldGVycyggbWF0ZXJpYWwsIF9saWdodHMsIGZvZywgb2JqZWN0ICk7XHJcblx0XHR2YXIgY29kZSA9IHByb2dyYW1DYWNoZS5nZXRQcm9ncmFtQ29kZSggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtO1xyXG5cdFx0dmFyIHByb2dyYW1DaGFuZ2UgPSB0cnVlO1xyXG5cclxuXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ly8gbmV3IG1hdGVyaWFsXHJcblx0XHRcdG1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBwcm9ncmFtLmNvZGUgIT09IGNvZGUgKSB7XHJcblxyXG5cdFx0XHQvLyBjaGFuZ2VkIGdsc2wgb3IgcGFyYW1ldGVyc1xyXG5cdFx0XHRyZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdC8vIHNhbWUgZ2xzbCBhbmQgdW5pZm9ybSBsaXN0XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gb25seSByZWJ1aWxkIHVuaWZvcm0gbGlzdFxyXG5cdFx0XHRwcm9ncmFtQ2hhbmdlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcHJvZ3JhbUNoYW5nZSApIHtcclxuXHJcblx0XHRcdGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgcGFyYW1ldGVycy5zaGFkZXJJRCBdO1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlciA9IHtcclxuXHRcdFx0XHRcdG5hbWU6IG1hdGVyaWFsLnR5cGUsXHJcblx0XHRcdFx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICksXHJcblx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsXHJcblx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyID0ge1xyXG5cdFx0XHRcdFx0bmFtZTogbWF0ZXJpYWwudHlwZSxcclxuXHRcdFx0XHRcdHVuaWZvcm1zOiBtYXRlcmlhbC51bmlmb3JtcyxcclxuXHRcdFx0XHRcdHZlcnRleFNoYWRlcjogbWF0ZXJpYWwudmVydGV4U2hhZGVyLFxyXG5cdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlcjtcclxuXHJcblx0XHRcdHByb2dyYW0gPSBwcm9ncmFtQ2FjaGUuYWNxdWlyZVByb2dyYW0oIG1hdGVyaWFsLCBwYXJhbWV0ZXJzLCBjb2RlICk7XHJcblxyXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSA9IHByb2dyYW07XHJcblx0XHRcdG1hdGVyaWFsLnByb2dyYW0gPSBwcm9ncmFtO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoVGFyZ2V0czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhUYXJnZXQnICsgaSBdID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoTm9ybWFsczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgaSBdID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QgPSBbXTtcclxuXHJcblx0XHR2YXIgdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlci51bmlmb3JtcyxcclxuXHRcdFx0dW5pZm9ybUxvY2F0aW9ucyA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtLmdldFVuaWZvcm1zKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIHUgaW4gdW5pZm9ybXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgbG9jYXRpb24gPSB1bmlmb3JtTG9jYXRpb25zWyB1IF07XHJcblxyXG5cdFx0XHRpZiAoIGxvY2F0aW9uICkge1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LnB1c2goIFsgbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXNbIHUgXSwgbG9jYXRpb24gXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHRtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHRtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsIHx8XHJcblx0XHRcdFx0bWF0ZXJpYWwubGlnaHRzICkge1xyXG5cclxuXHRcdFx0Ly8gc3RvcmUgdGhlIGxpZ2h0IHNldHVwIGl0IHdhcyBjcmVhdGVkIGZvclxyXG5cclxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c0hhc2ggPSBfbGlnaHRzLmhhc2g7XHJcblxyXG5cdFx0XHQvLyB3aXJlIHVwIHRoZSBtYXRlcmlhbCB0byB0aGlzIHJlbmRlcmVyJ3MgbGlnaHRpbmcgc3RhdGVcclxuXHJcblx0XHRcdHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLnZhbHVlID0gX2xpZ2h0cy5hbWJpZW50O1xyXG5cdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0cy52YWx1ZSA9IF9saWdodHMuZGlyZWN0aW9uYWw7XHJcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodHMudmFsdWUgPSBfbGlnaHRzLnNwb3Q7XHJcblx0XHRcdHVuaWZvcm1zLnBvaW50TGlnaHRzLnZhbHVlID0gX2xpZ2h0cy5wb2ludDtcclxuXHRcdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0cy52YWx1ZSA9IF9saWdodHMuaGVtaTtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsU2hhZG93TWFwLnZhbHVlID0gX2xpZ2h0cy5kaXJlY3Rpb25hbFNoYWRvd01hcDtcclxuXHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXgudmFsdWUgPSBfbGlnaHRzLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4O1xyXG5cdFx0XHR1bmlmb3Jtcy5zcG90U2hhZG93TWFwLnZhbHVlID0gX2xpZ2h0cy5zcG90U2hhZG93TWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5zcG90U2hhZG93TWF0cml4LnZhbHVlID0gX2xpZ2h0cy5zcG90U2hhZG93TWF0cml4O1xyXG5cdFx0XHR1bmlmb3Jtcy5wb2ludFNoYWRvd01hcC52YWx1ZSA9IF9saWdodHMucG9pbnRTaGFkb3dNYXA7XHJcblx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gX2xpZ2h0cy5wb2ludFNoYWRvd01hdHJpeDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZGV0ZWN0IGR5bmFtaWMgdW5pZm9ybXNcclxuXHJcblx0XHRtYXRlcmlhbFByb3BlcnRpZXMuaGFzRHluYW1pY1VuaWZvcm1zID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdW5pZm9ybSA9IG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3RbIGogXVsgMCBdO1xyXG5cclxuXHRcdFx0aWYgKCB1bmlmb3JtLmR5bmFtaWMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5oYXNEeW5hbWljVW5pZm9ybXMgPSB0cnVlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0c2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSwgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSwgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggVEhSRUUuTm9CbGVuZGluZyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5zZXREZXB0aEZ1bmMoIG1hdGVyaWFsLmRlcHRoRnVuYyApO1xyXG5cdFx0c3RhdGUuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcclxuXHRcdHN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcclxuXHRcdHN0YXRlLnNldENvbG9yV3JpdGUoIG1hdGVyaWFsLmNvbG9yV3JpdGUgKTtcclxuXHRcdHN0YXRlLnNldFBvbHlnb25PZmZzZXQoIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldE1hdGVyaWFsRmFjZXMoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgPyBzdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKSA6IHN0YXRlLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHRcdHN0YXRlLnNldEZsaXBTaWRlZCggbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRQcm9ncmFtKCBjYW1lcmEsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcclxuXHJcblx0XHRfdXNlZFRleHR1cmVVbml0cyA9IDA7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzSGFzaCAhPT0gdW5kZWZpbmVkICYmXHJcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNIYXNoICE9PSBfbGlnaHRzLmhhc2ggKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmb2csIG9iamVjdCApO1xyXG5cdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVmcmVzaFByb2dyYW0gPSBmYWxzZTtcclxuXHRcdHZhciByZWZyZXNoTWF0ZXJpYWwgPSBmYWxzZTtcclxuXHRcdHZhciByZWZyZXNoTGlnaHRzID0gZmFsc2U7XHJcblxyXG5cdFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSxcclxuXHRcdFx0cF91bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcclxuXHRcdFx0bV91bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zO1xyXG5cclxuXHRcdGlmICggcHJvZ3JhbS5pZCAhPT0gX2N1cnJlbnRQcm9ncmFtICkge1xyXG5cclxuXHRcdFx0X2dsLnVzZVByb2dyYW0oIHByb2dyYW0ucHJvZ3JhbSApO1xyXG5cdFx0XHRfY3VycmVudFByb2dyYW0gPSBwcm9ncmFtLmlkO1xyXG5cclxuXHRcdFx0cmVmcmVzaFByb2dyYW0gPSB0cnVlO1xyXG5cdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xyXG5cdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5pZCAhPT0gX2N1cnJlbnRNYXRlcmlhbElkICkge1xyXG5cclxuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gbWF0ZXJpYWwuaWQ7XHJcblxyXG5cdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHJlZnJlc2hQcm9ncmFtIHx8IGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMgKTtcclxuXHJcblx0XHRcdGlmICggY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWYoIHBfdW5pZm9ybXMubG9nRGVwdGhCdWZGQywgMi4wIC8gKCBNYXRoLmxvZyggY2FtZXJhLmZhciArIDEuMCApIC8gTWF0aC5MTjIgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdGlmICggY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0X2N1cnJlbnRDYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdFx0XHRcdC8vIGxpZ2h0aW5nIHVuaWZvcm1zIGRlcGVuZCBvbiB0aGUgY2FtZXJhIHNvIGVuZm9yY2UgYW4gdXBkYXRlXHJcblx0XHRcdFx0Ly8gbm93LCBpbiBjYXNlIHRoaXMgbWF0ZXJpYWwgc3VwcG9ydHMgbGlnaHRzIC0gb3IgbGF0ZXIsIHdoZW5cclxuXHRcdFx0XHQvLyB0aGUgbmV4dCBtYXRlcmlhbCB0aGF0IGRvZXMgZ2V0cyBhY3RpdmF0ZWQ6XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XHRcdC8vIHNldCB0byB0cnVlIG9uIG1hdGVyaWFsIGNoYW5nZVxyXG5cdFx0XHRcdHJlZnJlc2hMaWdodHMgPSB0cnVlO1x0XHQvLyByZW1haW5zIHNldCB1bnRpbCB1cGRhdGUgZG9uZVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbG9hZCBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xyXG5cdFx0XHQvLyAoc2hhZGVyIG1hdGVyaWFsIGFsc28gZ2V0cyB0aGVtIGZvciB0aGUgc2FrZSBvZiBnZW5lcmljaXR5KVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbC5lbnZNYXAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5jYW1lcmFQb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uLCBfdmVjdG9yMy54LCBfdmVjdG9yMy55LCBfdmVjdG9yMy56ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy52aWV3TWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMudmlld01hdHJpeCwgZmFsc2UsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZWxlbWVudHMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBza2lubmluZyB1bmlmb3JtcyBtdXN0IGJlIHNldCBldmVuIGlmIG1hdGVyaWFsIGRpZG4ndCBjaGFuZ2VcclxuXHRcdC8vIGF1dG8tc2V0dGluZyBvZiB0ZXh0dXJlIHVuaXQgZm9yIGJvbmUgdGV4dHVyZSBtdXN0IGdvIGJlZm9yZSBvdGhlciB0ZXh0dXJlc1xyXG5cdFx0Ly8gbm90IHN1cmUgd2h5LCBidXQgb3RoZXJ3aXNlIHdlaXJkIHRoaW5ncyBoYXBwZW5cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnNraW5uaW5nICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuYmluZE1hdHJpeCAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMuYmluZE1hdHJpeCwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZSAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXhJbnZlcnNlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJpbmRNYXRyaXhJbnZlcnNlLCBmYWxzZSwgb2JqZWN0LmJpbmRNYXRyaXhJbnZlcnNlLmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHRleHR1cmVVbml0ID0gZ2V0VGV4dHVyZVVuaXQoKTtcclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggb2JqZWN0LnNrZWxldG9uLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoLCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVXaWR0aCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZUhlaWdodCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVIZWlnaHQsIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZUhlaWdodCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLmJvbmVNYXRyaWNlcyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcywgZmFsc2UsIG9iamVjdC5za2VsZXRvbi5ib25lTWF0cmljZXMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHJlZnJlc2hNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbC5saWdodHMgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHRoZSBjdXJyZW50IG1hdGVyaWFsIHJlcXVpcmVzIGxpZ2h0aW5nIGluZm9cclxuXHJcblx0XHRcdFx0Ly8gbm90ZTogYWxsIGxpZ2h0aW5nIHVuaWZvcm1zIGFyZSBhbHdheXMgc2V0IGNvcnJlY3RseVxyXG5cdFx0XHRcdC8vIHRoZXkgc2ltcGx5IHJlZmVyZW5jZSB0aGUgcmVuZGVyZXIncyBzdGF0ZSBmb3IgdGhlaXJcclxuXHRcdFx0XHQvLyB2YWx1ZXNcclxuXHRcdFx0XHQvL1xyXG5cdFx0XHRcdC8vIHVzZSB0aGUgY3VycmVudCBtYXRlcmlhbCdzIC5uZWVkc1VwZGF0ZSBmbGFncyB0byBzZXRcclxuXHRcdFx0XHQvLyB0aGUgR0wgc3RhdGUgd2hlbiByZXF1aXJlZFxyXG5cclxuXHRcdFx0XHRtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgcmVmcmVzaExpZ2h0cyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcmVmcmVzaCB1bmlmb3JtcyBjb21tb24gdG8gc2V2ZXJhbCBtYXRlcmlhbHNcclxuXHJcblx0XHRcdGlmICggZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRm9nKCBtX3VuaWZvcm1zLCBmb2cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyByZWZyZXNoIHNpbmdsZSBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xpbmUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1BvaW50cyggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGFtYmVydCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1Bob25nKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRtX3VuaWZvcm1zLm1OZWFyLnZhbHVlID0gY2FtZXJhLm5lYXI7XHJcblx0XHRcdFx0bV91bmlmb3Jtcy5tRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcclxuXHRcdFx0XHRtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdG1fdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBsb2FkIGNvbW1vbiB1bmlmb3Jtc1xyXG5cclxuXHRcdFx0bG9hZFVuaWZvcm1zR2VuZXJpYyggbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRsb2FkVW5pZm9ybXNNYXRyaWNlcyggcF91bmlmb3Jtcywgb2JqZWN0ICk7XHJcblxyXG5cdFx0aWYgKCBwX3VuaWZvcm1zLm1vZGVsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5tb2RlbE1hdHJpeCwgZmFsc2UsIG9iamVjdC5tYXRyaXhXb3JsZC5lbGVtZW50cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5oYXNEeW5hbWljVW5pZm9ybXMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR1cGRhdGVEeW5hbWljVW5pZm9ybXMoIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QsIG9iamVjdCwgY2FtZXJhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwcm9ncmFtO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZUR5bmFtaWNVbmlmb3JtcyAoIHVuaWZvcm1zLCBvYmplY3QsIGNhbWVyYSApIHtcclxuXHJcblx0XHR2YXIgZHluYW1pY1VuaWZvcm1zID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHVuaWZvcm1zLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHVuaWZvcm0gPSB1bmlmb3Jtc1sgaiBdWyAwIF07XHJcblx0XHRcdHZhciBvblVwZGF0ZUNhbGxiYWNrID0gdW5pZm9ybS5vblVwZGF0ZUNhbGxiYWNrO1xyXG5cclxuXHRcdFx0aWYgKCBvblVwZGF0ZUNhbGxiYWNrICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG9uVXBkYXRlQ2FsbGJhY2suYmluZCggdW5pZm9ybSApKCBvYmplY3QsIGNhbWVyYSApO1xyXG5cdFx0XHRcdGR5bmFtaWNVbmlmb3Jtcy5wdXNoKCB1bmlmb3Jtc1sgaiBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxvYWRVbmlmb3Jtc0dlbmVyaWMoIGR5bmFtaWNVbmlmb3JtcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFVuaWZvcm1zIChyZWZyZXNoIHVuaWZvcm1zIG9iamVjdHMpXHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZSApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmVtaXNzaXZlICkubXVsdGlwbHlTY2FsYXIoIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcclxuXHRcdHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XHJcblx0XHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuYW9NYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXNcclxuXHRcdC8vIDEuIGNvbG9yIG1hcFxyXG5cdFx0Ly8gMi4gc3BlY3VsYXIgbWFwXHJcblx0XHQvLyAzLiBub3JtYWwgbWFwXHJcblx0XHQvLyA0LiBidW1wIG1hcFxyXG5cdFx0Ly8gNS4gYWxwaGEgbWFwXHJcblx0XHQvLyA2LiBlbWlzc2l2ZSBtYXBcclxuXHJcblx0XHR2YXIgdXZTY2FsZU1hcDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcclxuXHJcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xyXG5cclxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYnVtcE1hcDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLm1ldGFsbmVzc01hcCApIHtcclxuXHJcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tZXRhbG5lc3NNYXA7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCB1dlNjYWxlTWFwIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRcdHV2U2NhbGVNYXAgPSB1dlNjYWxlTWFwLnRleHR1cmU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgb2Zmc2V0ID0gdXZTY2FsZU1hcC5vZmZzZXQ7XHJcblx0XHRcdHZhciByZXBlYXQgPSB1dlNjYWxlTWFwLnJlcGVhdDtcclxuXHJcblx0XHRcdHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDtcclxuXHRcdHVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSAoIG1hdGVyaWFsLmVudk1hcCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApID8gMSA6IC0gMTtcclxuXHJcblx0XHR1bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XHJcblx0XHR1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGluZSAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XHJcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEYXNoICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLmRhc2hTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemU7XHJcblx0XHR1bmlmb3Jtcy50b3RhbFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZSArIG1hdGVyaWFsLmdhcFNpemU7XHJcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IG1hdGVyaWFsLnNjYWxlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BvaW50cyAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XHJcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHRcdHVuaWZvcm1zLnNpemUudmFsdWUgPSBtYXRlcmlhbC5zaXplICogX3BpeGVsUmF0aW87XHJcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IF9jYW52YXMuY2xpZW50SGVpZ2h0IC8gMi4wOyAvLyBUT0RPOiBDYWNoZSB0aGlzLlxyXG5cclxuXHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHZhciBvZmZzZXQgPSBtYXRlcmlhbC5tYXAub2Zmc2V0O1xyXG5cdFx0XHR2YXIgcmVwZWF0ID0gbWF0ZXJpYWwubWFwLnJlcGVhdDtcclxuXHJcblx0XHRcdHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0ZvZyAoIHVuaWZvcm1zLCBmb2cgKSB7XHJcblxyXG5cdFx0dW5pZm9ybXMuZm9nQ29sb3IudmFsdWUgPSBmb2cuY29sb3I7XHJcblxyXG5cdFx0aWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2cgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5mb2dOZWFyLnZhbHVlID0gZm9nLm5lYXI7XHJcblx0XHRcdHVuaWZvcm1zLmZvZ0Zhci52YWx1ZSA9IGZvZy5mYXI7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMiApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmZvZ0RlbnNpdHkudmFsdWUgPSBmb2cuZGVuc2l0eTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGFtYmVydCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmxpZ2h0TWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcclxuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Bob25nICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXI7XHJcblx0XHR1bmlmb3Jtcy5zaGluaW5lc3MudmFsdWUgPSBNYXRoLm1heCggbWF0ZXJpYWwuc2hpbmluZXNzLCAxZS00ICk7IC8vIHRvIHByZXZlbnQgcG93KCAwLjAsIDAuMCApXHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5saWdodE1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwLnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXA7XHJcblx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcclxuXHRcdFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcclxuXHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XHJcblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5yb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XHJcblx0XHR1bmlmb3Jtcy5tZXRhbG5lc3MudmFsdWUgPSBtYXRlcmlhbC5tZXRhbG5lc3M7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5yb3VnaG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3NNYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubWV0YWxuZXNzTWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubWV0YWxuZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwubWV0YWxuZXNzTWFwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmxpZ2h0TWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcclxuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcclxuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuZW52TWFwICkge1xyXG5cclxuXHRcdFx0Ly91bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7IC8vIHBhcnQgb2YgdW5pZm9ybXMgY29tbW9uXHJcblx0XHRcdHVuaWZvcm1zLmVudk1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcEludGVuc2l0eTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gSWYgdW5pZm9ybXMgYXJlIG1hcmtlZCBhcyBjbGVhbiwgdGhleSBkb24ndCBuZWVkIHRvIGJlIGxvYWRlZCB0byB0aGUgR1BVLlxyXG5cclxuXHRmdW5jdGlvbiBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSAoIHVuaWZvcm1zLCB2YWx1ZSApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cclxuXHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFVuaWZvcm1zIChsb2FkIHRvIEdQVSlcclxuXHJcblx0ZnVuY3Rpb24gbG9hZFVuaWZvcm1zTWF0cmljZXMgKCB1bmlmb3Jtcywgb2JqZWN0ICkge1xyXG5cclxuXHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBvYmplY3QubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0aWYgKCB1bmlmb3Jtcy5ub3JtYWxNYXRyaXggKSB7XHJcblxyXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggdW5pZm9ybXMubm9ybWFsTWF0cml4LCBmYWxzZSwgb2JqZWN0Lm5vcm1hbE1hdHJpeC5lbGVtZW50cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRUZXh0dXJlVW5pdCgpIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZVVuaXQgPSBfdXNlZFRleHR1cmVVbml0cztcclxuXHJcblx0XHRpZiAoIHRleHR1cmVVbml0ID49IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRyeWluZyB0byB1c2UgJyArIHRleHR1cmVVbml0ICsgJyB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgJyArIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfdXNlZFRleHR1cmVVbml0cyArPSAxO1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlVW5pdDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBsb2FkVW5pZm9ybXNHZW5lcmljICggdW5pZm9ybXMgKSB7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUsIHRleHR1cmVVbml0O1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB1bmlmb3Jtcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdHZhciB1bmlmb3JtID0gdW5pZm9ybXNbIGogXVsgMCBdO1xyXG5cclxuXHRcdFx0Ly8gbmVlZHNVcGRhdGUgcHJvcGVydHkgaXMgbm90IGFkZGVkIHRvIGFsbCB1bmlmb3Jtcy5cclxuXHRcdFx0aWYgKCB1bmlmb3JtLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0dmFyIHR5cGUgPSB1bmlmb3JtLnR5cGU7XHJcblx0XHRcdHZhciB2YWx1ZSA9IHVuaWZvcm0udmFsdWU7XHJcblx0XHRcdHZhciBsb2NhdGlvbiA9IHVuaWZvcm1zWyBqIF1bIDEgXTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJzFpJzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJzFmJzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJzJmJzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMmYoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnM2YnOlxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0sIHZhbHVlWyAyIF0gKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICc0Zic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSwgdmFsdWVbIDIgXSwgdmFsdWVbIDMgXSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJzFpdic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnM2l2JzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2l2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICcxZnYnOlxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJzJmdic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTJmdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnM2Z2JzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICc0ZnYnOlxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ01hdHJpeDJmdic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDJmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ01hdHJpeDNmdic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ01hdHJpeDRmdic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdC8vXHJcblxyXG5cdFx0XHRcdGNhc2UgJ2knOlxyXG5cclxuXHRcdFx0XHRcdC8vIHNpbmdsZSBpbnRlZ2VyXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnZic6XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIGZsb2F0XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmKCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAndjInOlxyXG5cclxuXHRcdFx0XHRcdC8vIHNpbmdsZSBUSFJFRS5WZWN0b3IyXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTJmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd2Myc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLlZlY3RvcjNcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56ICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3Y0JzpcclxuXHJcblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVmVjdG9yNFxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm00ZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnosIHZhbHVlLncgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnYyc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLkNvbG9yXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUuciwgdmFsdWUuZywgdmFsdWUuYiApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHQvKlxyXG5cdFx0XHRcdGNhc2UgJ3MnOlxyXG5cclxuXHRcdFx0XHRcdC8vIFRPRE86IE9wdGltaXplIHRoaXMuXHJcblx0XHRcdFx0XHRmb3IoIHZhciBwcm9wZXJ0eU5hbWUgaW4gdW5pZm9ybS5wcm9wZXJ0aWVzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHByb3BlcnR5ID0gdW5pZm9ybS5wcm9wZXJ0aWVzWyBwcm9wZXJ0eU5hbWUgXTtcclxuXHRcdFx0XHRcdFx0dmFyIGxvY2F0aW9uUHJvcGVydHkgPSAgbG9jYXRpb25bIHByb3BlcnR5TmFtZSBdO1xyXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVQcm9wZXJ0eSA9IHZhbHVlWyBwcm9wZXJ0eU5hbWUgXTtcclxuXHJcblx0XHRcdFx0XHRcdHN3aXRjaCggcHJvcGVydHkudHlwZSApIHtcclxuXHRcdFx0XHRcdFx0XHRjYXNlICdpJzpcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2YnOlxyXG5cdFx0XHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0xZiggbG9jYXRpb25Qcm9wZXJ0eSwgdmFsdWVQcm9wZXJ0eSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAndjInOlxyXG5cdFx0XHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0yZiggbG9jYXRpb25Qcm9wZXJ0eSwgdmFsdWVQcm9wZXJ0eS54LCB2YWx1ZVByb3BlcnR5LnkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3YzJzpcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkueCwgdmFsdWVQcm9wZXJ0eS55LCB2YWx1ZVByb3BlcnR5LnogKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3Y0JzpcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtNGYoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkueCwgdmFsdWVQcm9wZXJ0eS55LCB2YWx1ZVByb3BlcnR5LnosIHZhbHVlUHJvcGVydHkudyApO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnYyc6XHJcblx0XHRcdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvblByb3BlcnR5LCB2YWx1ZVByb3BlcnR5LnIsIHZhbHVlUHJvcGVydHkuZywgdmFsdWVQcm9wZXJ0eS5iICk7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Ki9cclxuXHJcblx0XHRcdFx0Y2FzZSAnc2EnOlxyXG5cclxuXHRcdFx0XHRcdC8vIFRPRE86IE9wdGltaXplIHRoaXMuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgcHJvcGVydHlOYW1lIGluIHVuaWZvcm0ucHJvcGVydGllcyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHByb3BlcnR5ID0gdW5pZm9ybS5wcm9wZXJ0aWVzWyBwcm9wZXJ0eU5hbWUgXTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbG9jYXRpb25Qcm9wZXJ0eSA9ICBsb2NhdGlvblsgaSBdWyBwcm9wZXJ0eU5hbWUgXTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWVQcm9wZXJ0eSA9IHZhbHVlWyBpIF1bIHByb3BlcnR5TmFtZSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKCBwcm9wZXJ0eS50eXBlICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnaSc6XHJcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdmJzpcclxuXHRcdFx0XHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0xZiggbG9jYXRpb25Qcm9wZXJ0eSwgdmFsdWVQcm9wZXJ0eSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3YyJzpcclxuXHRcdFx0XHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0yZiggbG9jYXRpb25Qcm9wZXJ0eSwgdmFsdWVQcm9wZXJ0eS54LCB2YWx1ZVByb3BlcnR5LnkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd2Myc6XHJcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkueCwgdmFsdWVQcm9wZXJ0eS55LCB2YWx1ZVByb3BlcnR5LnogKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd2NCc6XHJcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtNGYoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkueCwgdmFsdWVQcm9wZXJ0eS55LCB2YWx1ZVByb3BlcnR5LnosIHZhbHVlUHJvcGVydHkudyApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2MnOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvblByb3BlcnR5LCB2YWx1ZVByb3BlcnR5LnIsIHZhbHVlUHJvcGVydHkuZywgdmFsdWVQcm9wZXJ0eS5iICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbTQnOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb25Qcm9wZXJ0eSwgZmFsc2UsIHZhbHVlUHJvcGVydHkuZWxlbWVudHMgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaXYxJzpcclxuXHJcblx0XHRcdFx0XHQvLyBmbGF0IGFycmF5IG9mIGludGVnZXJzIChKUyBvciB0eXBlZCBhcnJheSlcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaXYnOlxyXG5cclxuXHRcdFx0XHRcdC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2l2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnZnYxJzpcclxuXHJcblx0XHRcdFx0XHQvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2Z2JzpcclxuXHJcblx0XHRcdFx0XHQvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyB3aXRoIDMgeCBOIHNpemUgKEpTIG9yIHR5cGVkIGFycmF5KVxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd2MnYnOlxyXG5cclxuXHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjJcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDIgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpMiA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKyssIGkyICs9IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaTIgKyAwIF0gPSB2YWx1ZVsgaSBdLng7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpMiArIDEgXSA9IHZhbHVlWyBpIF0ueTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0yZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd2M3YnOlxyXG5cclxuXHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjNcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDMgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpMyA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKyssIGkzICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaTMgKyAwIF0gPSB2YWx1ZVsgaSBdLng7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpMyArIDEgXSA9IHZhbHVlWyBpIF0ueTtcclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGkzICsgMiBdID0gdmFsdWVbIGkgXS56O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3Y0dic6XHJcblxyXG5cdFx0XHRcdFx0Ly8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yNFxyXG5cclxuXHRcdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggNCAqIHZhbHVlLmxlbmd0aCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGk0ID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKywgaTQgKz0gNCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpNCArIDAgXSA9IHZhbHVlWyBpIF0ueDtcclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGk0ICsgMSBdID0gdmFsdWVbIGkgXS55O1xyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaTQgKyAyIF0gPSB2YWx1ZVsgaSBdLno7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpNCArIDMgXSA9IHZhbHVlWyBpIF0udztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdtMic6XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLk1hdHJpeDJcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4MmZ2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlLmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ20zJzpcclxuXHJcblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuTWF0cml4M1xyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUuZWxlbWVudHMgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnbTN2JzpcclxuXHJcblx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXgzXHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA5ICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhbHVlWyBpIF0uZmxhdHRlblRvQXJyYXlPZmZzZXQoIHVuaWZvcm0uX2FycmF5LCBpICogOSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdtNCc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLk1hdHJpeDRcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlLmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ200dic6XHJcblxyXG5cdFx0XHRcdFx0Ly8gYXJyYXkgb2YgVEhSRUUuTWF0cml4NFxyXG5cclxuXHRcdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiAxNiApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd0JzpcclxuXHJcblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVGV4dHVyZSAoMmQgb3IgY3ViZSlcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlID0gdmFsdWU7XHJcblx0XHRcdFx0XHR0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIHRleHR1cmUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5DdWJlVGV4dHVyZSB8fFxyXG5cdFx0XHRcdFx0XHQgKCBBcnJheS5pc0FycmF5KCB0ZXh0dXJlLmltYWdlICkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXHJcblxyXG5cdFx0XHRcdFx0XHRzZXRDdWJlVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c2V0Q3ViZVRleHR1cmVEeW5hbWljKCB0ZXh0dXJlLnRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZS50ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAndHYnOlxyXG5cclxuXHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLlRleHR1cmUgKDJkIG9yIGN1YmUpXHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBbXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaSBdID0gZ2V0VGV4dHVyZVVuaXQoKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB1bmlmb3JtLnZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGV4dHVyZSA9IHVuaWZvcm0udmFsdWVbIGkgXTtcclxuXHRcdFx0XHRcdFx0dGV4dHVyZVVuaXQgPSB1bmlmb3JtLl9hcnJheVsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCAhIHRleHR1cmUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkN1YmVUZXh0dXJlIHx8XHJcblx0XHRcdFx0XHRcdFx0ICggdGV4dHVyZS5pbWFnZSBpbnN0YW5jZW9mIEFycmF5ICYmIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXHJcblxyXG5cdFx0XHRcdFx0XHRcdHNldEN1YmVUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLnRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzZXRDdWJlVGV4dHVyZUR5bmFtaWMoIHRleHR1cmUudGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdF90aGlzLnNldFRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVua25vd24gdW5pZm9ybSB0eXBlOiAnICsgdHlwZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXR1cExpZ2h0cyAoIGxpZ2h0cywgY2FtZXJhICkge1xyXG5cclxuXHRcdHZhciBsLCBsbCwgbGlnaHQsXHJcblx0XHRyID0gMCwgZyA9IDAsIGIgPSAwLFxyXG5cdFx0Y29sb3IsXHJcblx0XHRpbnRlbnNpdHksXHJcblx0XHRkaXN0YW5jZSxcclxuXHJcblx0XHR2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSxcclxuXHJcblx0XHRkaXJlY3Rpb25hbExlbmd0aCA9IDAsXHJcblx0XHRwb2ludExlbmd0aCA9IDAsXHJcblx0XHRzcG90TGVuZ3RoID0gMCxcclxuXHRcdGhlbWlMZW5ndGggPSAwLFxyXG5cclxuXHRcdHNoYWRvd3NMZW5ndGggPSAwO1xyXG5cclxuXHRcdF9saWdodHMuc2hhZG93c1BvaW50TGlnaHQgPSAwO1xyXG5cclxuXHRcdGZvciAoIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcclxuXHJcblx0XHRcdGxpZ2h0ID0gbGlnaHRzWyBsIF07XHJcblxyXG5cdFx0XHRjb2xvciA9IGxpZ2h0LmNvbG9yO1xyXG5cdFx0XHRpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XHJcblx0XHRcdGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuQW1iaWVudExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRyICs9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XHJcblx0XHRcdFx0ZyArPSBjb2xvci5nICogaW50ZW5zaXR5O1xyXG5cdFx0XHRcdGIgKz0gY29sb3IuYiAqIGludGVuc2l0eTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHVuaWZvcm1zID0gbGlnaHRDYWNoZS5nZXQoIGxpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGxpZ2h0LmludGVuc2l0eSApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3cuYmlhcztcclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IGxpZ2h0LnNoYWRvdy5yYWRpdXM7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gbGlnaHQuc2hhZG93Lm1hcFNpemU7XHJcblxyXG5cdFx0XHRcdFx0X2xpZ2h0cy5zaGFkb3dzWyBzaGFkb3dzTGVuZ3RoICsrIF0gPSBsaWdodDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfbGlnaHRzLmRpcmVjdGlvbmFsU2hhZG93TWFwWyBkaXJlY3Rpb25hbExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hcDtcclxuXHRcdFx0XHRfbGlnaHRzLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBkaXJlY3Rpb25hbExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcclxuXHRcdFx0XHRfbGlnaHRzLmRpcmVjdGlvbmFsWyBkaXJlY3Rpb25hbExlbmd0aCArKyBdID0gdW5pZm9ybXM7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHVuaWZvcm1zID0gbGlnaHRDYWNoZS5nZXQoIGxpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weSggY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zdWIoIF92ZWN0b3IzICk7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5hbmdsZUNvcyA9IE1hdGguY29zKCBsaWdodC5hbmdsZSApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmV4cG9uZW50ID0gbGlnaHQuZXhwb25lbnQ7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3cuYmlhcztcclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IGxpZ2h0LnNoYWRvdy5yYWRpdXM7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gbGlnaHQuc2hhZG93Lm1hcFNpemU7XHJcblxyXG5cdFx0XHRcdFx0X2xpZ2h0cy5zaGFkb3dzWyBzaGFkb3dzTGVuZ3RoICsrIF0gPSBsaWdodDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfbGlnaHRzLnNwb3RTaGFkb3dNYXBbIHNwb3RMZW5ndGggXSA9IGxpZ2h0LnNoYWRvdy5tYXA7XHJcblx0XHRcdFx0X2xpZ2h0cy5zcG90U2hhZG93TWF0cml4WyBzcG90TGVuZ3RoIF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xyXG5cdFx0XHRcdF9saWdodHMuc3BvdFsgc3BvdExlbmd0aCArKyBdID0gdW5pZm9ybXM7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB1bmlmb3JtcyA9IGxpZ2h0Q2FjaGUuZ2V0KCBsaWdodCApO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGxpZ2h0LmludGVuc2l0eSApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3cuYmlhcztcclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IGxpZ2h0LnNoYWRvdy5yYWRpdXM7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gbGlnaHQuc2hhZG93Lm1hcFNpemU7XHJcblxyXG5cdFx0XHRcdFx0X2xpZ2h0cy5zaGFkb3dzWyBzaGFkb3dzTGVuZ3RoICsrIF0gPSBsaWdodDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfbGlnaHRzLnBvaW50U2hhZG93TWFwWyBwb2ludExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hcDtcclxuXHJcblx0XHRcdFx0aWYgKCBfbGlnaHRzLnBvaW50U2hhZG93TWF0cml4WyBwb2ludExlbmd0aCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2xpZ2h0cy5wb2ludFNoYWRvd01hdHJpeFsgcG9pbnRMZW5ndGggXSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZm9yIHBvaW50IGxpZ2h0cyB3ZSBzZXQgdGhlIHNoYWRvdyBtYXRyaXggdG8gYmUgYSB0cmFuc2xhdGlvbi1vbmx5IG1hdHJpeFxyXG5cdFx0XHRcdC8vIGVxdWFsIHRvIGludmVyc2Ugb2YgdGhlIGxpZ2h0J3MgcG9zaXRpb25cclxuXHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCk7XHJcblx0XHRcdFx0X2xpZ2h0cy5wb2ludFNoYWRvd01hdHJpeFsgcG9pbnRMZW5ndGggXS5pZGVudGl0eSgpLnNldFBvc2l0aW9uKCBfdmVjdG9yMyApO1xyXG5cclxuXHRcdFx0XHRfbGlnaHRzLnBvaW50WyBwb2ludExlbmd0aCArKyBdID0gdW5pZm9ybXM7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHVuaWZvcm1zID0gbGlnaHRDYWNoZS5nZXQoIGxpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuc2t5Q29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblx0XHRcdFx0dW5pZm9ybXMuZ3JvdW5kQ29sb3IuY29weSggbGlnaHQuZ3JvdW5kQ29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdF9saWdodHMuaGVtaVsgaGVtaUxlbmd0aCArKyBdID0gdW5pZm9ybXM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9saWdodHMuYW1iaWVudFsgMCBdID0gcjtcclxuXHRcdF9saWdodHMuYW1iaWVudFsgMSBdID0gZztcclxuXHRcdF9saWdodHMuYW1iaWVudFsgMiBdID0gYjtcclxuXHJcblx0XHRfbGlnaHRzLmRpcmVjdGlvbmFsLmxlbmd0aCA9IGRpcmVjdGlvbmFsTGVuZ3RoO1xyXG5cdFx0X2xpZ2h0cy5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XHJcblx0XHRfbGlnaHRzLnBvaW50Lmxlbmd0aCA9IHBvaW50TGVuZ3RoO1xyXG5cdFx0X2xpZ2h0cy5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XHJcblxyXG5cdFx0X2xpZ2h0cy5zaGFkb3dzLmxlbmd0aCA9IHNoYWRvd3NMZW5ndGg7XHJcblxyXG5cdFx0X2xpZ2h0cy5oYXNoID0gZGlyZWN0aW9uYWxMZW5ndGggKyAnLCcgKyBwb2ludExlbmd0aCArICcsJyArIHNwb3RMZW5ndGggKyAnLCcgKyBoZW1pTGVuZ3RoICsgJywnICsgc2hhZG93c0xlbmd0aDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBHTCBzdGF0ZSBzZXR0aW5nXHJcblxyXG5cdHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBmdW5jdGlvbiAoIGN1bGxGYWNlLCBmcm9udEZhY2VEaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0aWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VOb25lICkge1xyXG5cclxuXHRcdFx0c3RhdGUuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIGZyb250RmFjZURpcmVjdGlvbiA9PT0gVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DVyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VCYWNrICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkZST05UX0FORF9CQUNLICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFRleHR1cmVzXHJcblxyXG5cdGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzICggdGV4dHVyZVR5cGUsIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICkge1xyXG5cclxuXHRcdHZhciBleHRlbnNpb247XHJcblxyXG5cdFx0aWYgKCBpc1Bvd2VyT2ZUd29JbWFnZSApIHtcclxuXHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwUyApICk7XHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwVCApICk7XHJcblxyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUubWluRmlsdGVyICkgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLndyYXBTICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS53cmFwUyBhbmQgVGV4dHVyZS53cmFwVCBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcuJywgdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS5taW5GaWx0ZXIgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5OZWFyZXN0RmlsdGVyIG9yIFRIUkVFLkxpbmVhckZpbHRlci4nLCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xyXG5cclxuXHRcdGlmICggZXh0ZW5zaW9uICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IFRIUkVFLkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcclxuXHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IFRIUkVFLkhhbGZGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS5hbmlzb3Ryb3B5ID4gMSB8fCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJmKCB0ZXh0dXJlVHlwZSwgZXh0ZW5zaW9uLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbiggdGV4dHVyZS5hbmlzb3Ryb3B5LCBfdGhpcy5nZXRNYXhBbmlzb3Ryb3B5KCkgKSApO1xyXG5cdFx0XHRcdHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSA9IHRleHR1cmUuYW5pc290cm9weTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPSB0cnVlO1xyXG5cclxuXHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcclxuXHJcblx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcblx0XHRcdF9pbmZvTWVtb3J5LnRleHR1cmVzICsrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xyXG5cdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcclxuXHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XHJcblxyXG5cdFx0dmFyIGltYWdlID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2UsIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApICYmIGlzUG93ZXJPZlR3byggaW1hZ2UgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRpbWFnZSA9IG1ha2VQb3dlck9mVHdvKCBpbWFnZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaXNQb3dlck9mVHdvSW1hZ2UgPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXHJcblx0XHRnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxyXG5cdFx0Z2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xyXG5cclxuXHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgaXNQb3dlck9mVHdvSW1hZ2UgKTtcclxuXHJcblx0XHR2YXIgbWlwbWFwLCBtaXBtYXBzID0gdGV4dHVyZS5taXBtYXBzO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcclxuXHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXHJcblx0XHRcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xyXG5cclxuXHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcclxuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JGb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzdGF0ZS5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKVwiICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIHJlZ3VsYXIgVGV4dHVyZSAoaW1hZ2UsIHZpZGVvLCBjYW52YXMpXHJcblxyXG5cdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxyXG5cdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcclxuXHRcdFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXHJcblxyXG5cdFx0XHRpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc1Bvd2VyT2ZUd29JbWFnZSApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xyXG5cdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzUG93ZXJPZlR3b0ltYWdlICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xyXG5cclxuXHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5zZXRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzbG90ICkge1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xyXG5cclxuXHRcdFx0dmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZTtcclxuXHJcblx0XHRcdGlmICggaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgdW5kZWZpbmVkJywgdGV4dHVyZSApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyBpbmNvbXBsZXRlJywgdGV4dHVyZSApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICk7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY2xhbXBUb01heFNpemUgKCBpbWFnZSwgbWF4U2l6ZSApIHtcclxuXHJcblx0XHRpZiAoIGltYWdlLndpZHRoID4gbWF4U2l6ZSB8fCBpbWFnZS5oZWlnaHQgPiBtYXhTaXplICkge1xyXG5cclxuXHRcdFx0Ly8gV2FybmluZzogU2NhbGluZyB0aHJvdWdoIHRoZSBjYW52YXMgd2lsbCBvbmx5IHdvcmsgd2l0aCBpbWFnZXMgdGhhdCB1c2VcclxuXHRcdFx0Ly8gcHJlbXVsdGlwbGllZCBhbHBoYS5cclxuXHJcblx0XHRcdHZhciBzY2FsZSA9IG1heFNpemUgLyBNYXRoLm1heCggaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xyXG5cclxuXHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0XHRcdGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3IoIGltYWdlLndpZHRoICogc2NhbGUgKTtcclxuXHRcdFx0Y2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoIGltYWdlLmhlaWdodCAqIHNjYWxlICk7XHJcblxyXG5cdFx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XHJcblx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyB0b28gYmlnICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcclxuXHJcblx0XHRcdHJldHVybiBjYW52YXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbWFnZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpc1Bvd2VyT2ZUd28oIGltYWdlICkge1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSAmJiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApIHtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUud3JhcFMgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHJldHVybiB0cnVlO1xyXG5cdFx0aWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTGluZWFyRmlsdGVyICkgcmV0dXJuIHRydWU7XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG1ha2VQb3dlck9mVHdvKCBpbWFnZSApIHtcclxuXHJcblx0XHRpZiAoIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkge1xyXG5cclxuXHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0XHRcdGNhbnZhcy53aWR0aCA9IFRIUkVFLk1hdGgubmVhcmVzdFBvd2VyT2ZUd28oIGltYWdlLndpZHRoICk7XHJcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBUSFJFRS5NYXRoLm5lYXJlc3RQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKTtcclxuXHJcblx0XHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcclxuXHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIG5vdCBwb3dlciBvZiB0d28gKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNhbnZhcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGltYWdlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldEN1YmVUZXh0dXJlICggdGV4dHVyZSwgc2xvdCApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XHJcblxyXG5cdFx0XHRcdGlmICggISB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHRcdFx0X2luZm9NZW1vcnkudGV4dHVyZXMgKys7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xyXG5cclxuXHRcdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XHJcblxyXG5cdFx0XHRcdHZhciBpc0NvbXByZXNzZWQgPSB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XHJcblx0XHRcdFx0dmFyIGlzRGF0YVRleHR1cmUgPSB0ZXh0dXJlLmltYWdlWyAwIF0gaW5zdGFuY2VvZiBUSFJFRS5EYXRhVGV4dHVyZTtcclxuXHJcblx0XHRcdFx0dmFyIGN1YmVJbWFnZSA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggX3RoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgJiYgISBpc0NvbXByZXNzZWQgJiYgISBpc0RhdGFUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZVsgaSBdLCBjYXBhYmlsaXRpZXMubWF4Q3ViZW1hcFNpemUgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBpc0RhdGFUZXh0dXJlID8gdGV4dHVyZS5pbWFnZVsgaSBdLmltYWdlIDogdGV4dHVyZS5pbWFnZVsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcclxuXHRcdFx0XHRpc1Bvd2VyT2ZUd29JbWFnZSA9IGlzUG93ZXJPZlR3byggaW1hZ2UgKSxcclxuXHRcdFx0XHRnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxyXG5cdFx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcclxuXHJcblx0XHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCBpc1Bvd2VyT2ZUd29JbWFnZSApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggISBpc0NvbXByZXNzZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGlzRGF0YVRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgY3ViZUltYWdlWyBpIF0ud2lkdGgsIGN1YmVJbWFnZVsgaSBdLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0uZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgbWlwbWFwLCBtaXBtYXBzID0gY3ViZUltYWdlWyBpIF0ubWlwbWFwcztcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBtaXBtYXBzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBqIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkZvcm1hdCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAuc2V0Q3ViZVRleHR1cmUoKVwiICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZUR5bmFtaWMgKCB0ZXh0dXJlLCBzbG90ICkge1xyXG5cclxuXHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFJlbmRlciB0YXJnZXRzXHJcblxyXG5cdC8vIFNldHVwIHN0b3JhZ2UgZm9yIHRhcmdldCB0ZXh0dXJlIGFuZCBiaW5kIGl0IHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcclxuXHRmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSAoIGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIGF0dGFjaG1lbnQsIHRleHR1cmVUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHJlbmRlclRhcmdldC50ZXh0dXJlLmZvcm1hdCApO1xyXG5cdFx0dmFyIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlICk7XHJcblx0XHRzdGF0ZS50ZXhJbWFnZTJEKCB0ZXh0dXJlVGFyZ2V0LCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XHJcblx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcblx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCwgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICkuX193ZWJnbFRleHR1cmUsIDAgKTtcclxuXHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFNldHVwIHN0b3JhZ2UgZm9yIGludGVybmFsIGRlcHRoL3N0ZW5jaWwgYnVmZmVycyBhbmQgYmluZCB0byBjb3JyZWN0IGZyYW1lYnVmZmVyXHJcblx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlICggcmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICEgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX0NPTVBPTkVOVDE2LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUwsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xyXG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIEZJWE1FOiBXZSBkb24ndCBzdXBwb3J0ICFkZXB0aCAhc3RlbmNpbFxyXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBTZXR1cCBHTCByZXNvdXJjZXMgZm9yIGEgbm9uLXRleHR1cmUgZGVwdGggYnVmZmVyXHJcblx0ZnVuY3Rpb24gc2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApO1xyXG5cclxuXHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xyXG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcblx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xyXG5cdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuXHRcdFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFNldCB1cCBHTCByZXNvdXJjZXMgZm9yIHRoZSByZW5kZXIgdGFyZ2V0XHJcblx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xyXG5cclxuXHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcblx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyArKztcclxuXHJcblx0XHR2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKTtcclxuXHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0LndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHJcblx0XHQvLyBTZXR1cCBmcmFtZWJ1ZmZlclxyXG5cclxuXHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0dXAgY29sb3IgYnVmZmVyXHJcblxyXG5cdFx0aWYgKCBpc0N1YmUgKSB7XHJcblxyXG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XHJcblx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xyXG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xyXG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcclxuXHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfMkQgKTtcclxuXHJcblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcclxuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldHVwIGRlcHRoIGFuZCBzdGVuY2lsIGJ1ZmZlcnNcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdHNldHVwRGVwdGhSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnNldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0ICYmIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXIgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHNldHVwUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICk7XHJcblx0XHR2YXIgZnJhbWVidWZmZXI7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgXTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZyYW1lYnVmZmVyID0gcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfY3VycmVudFNjaXNzb3IuY29weSggcmVuZGVyVGFyZ2V0LnNjaXNzb3IgKTtcclxuXHRcdFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IHJlbmRlclRhcmdldC5zY2lzc29yVGVzdDtcclxuXHJcblx0XHRcdF9jdXJyZW50Vmlld3BvcnQuY29weSggcmVuZGVyVGFyZ2V0LnZpZXdwb3J0ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGZyYW1lYnVmZmVyID0gbnVsbDtcclxuXHJcblx0XHRcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApO1xyXG5cdFx0XHRfY3VycmVudFNjaXNzb3JUZXN0ID0gX3NjaXNzb3JUZXN0O1xyXG5cclxuXHRcdFx0X2N1cnJlbnRWaWV3cG9ydC5jb3B5KCBfdmlld3BvcnQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBfY3VycmVudEZyYW1lYnVmZmVyICE9PSBmcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcclxuXHRcdFx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5zY2lzc29yKCBfY3VycmVudFNjaXNzb3IgKTtcclxuXHRcdHN0YXRlLnNldFNjaXNzb3JUZXN0KCBfY3VycmVudFNjaXNzb3JUZXN0ICk7XHJcblxyXG5cdFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQgKTtcclxuXHJcblx0XHRpZiAoIGlzQ3ViZSApIHtcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xyXG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJ1ZmZlciApIHtcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuJyApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXI7XHJcblxyXG5cdFx0aWYgKCBmcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRcdHZhciByZXN0b3JlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRpZiAoIGZyYW1lYnVmZmVyICE9PSBfY3VycmVudEZyYW1lYnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdHJlc3RvcmUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dHJ5IHtcclxuXHJcblx0XHRcdFx0dmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdFxyXG5cdFx0XHRcdFx0JiYgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCApICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIGZvcm1hdC4nICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgIT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGVcclxuXHRcdFx0XHRcdCYmIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKSAhPT0gX2dsLmdldFBhcmFtZXRlciggX2dsLklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfVFlQRSApXHJcblx0XHRcdFx0XHQmJiAhICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5GbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnICkgKVxyXG5cdFx0XHRcdFx0JiYgISAoIHRleHR1cmUudHlwZSA9PT0gVEhSRUUuSGFsZkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcgKSApICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuJyApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggX2dsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoIF9nbC5GUkFNRUJVRkZFUiApID09PSBfZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnJlYWRQaXhlbHMoIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICksIGJ1ZmZlciApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlYWRQaXhlbHMgZnJvbSByZW5kZXJUYXJnZXQgZmFpbGVkLiBGcmFtZWJ1ZmZlciBub3QgY29tcGxldGUuJyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGZpbmFsbHkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlc3RvcmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfY3VycmVudEZyYW1lYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciB0YXJnZXQgPSByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgPyBfZ2wuVEVYVFVSRV9DVUJFX01BUCA6IF9nbC5URVhUVVJFXzJEO1xyXG5cdFx0dmFyIHRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZTtcclxuXHJcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCB0ZXh0dXJlICk7XHJcblx0XHRfZ2wuZ2VuZXJhdGVNaXBtYXAoIHRhcmdldCApO1xyXG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIHRhcmdldCwgbnVsbCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIEZhbGxiYWNrIGZpbHRlcnMgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXHJcblxyXG5cdGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrICggZiApIHtcclxuXHJcblx0XHRpZiAoIGYgPT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHtcclxuXHJcblx0XHRcdHJldHVybiBfZ2wuTkVBUkVTVDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIF9nbC5MSU5FQVI7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gTWFwIHRocmVlLmpzIGNvbnN0YW50cyB0byBXZWJHTCBjb25zdGFudHNcclxuXHJcblx0ZnVuY3Rpb24gcGFyYW1UaHJlZVRvR0wgKCBwICkge1xyXG5cclxuXHRcdHZhciBleHRlbnNpb247XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5SZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuUkVQRUFUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIF9nbC5DTEFNUF9UT19FREdFO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIF9nbC5NSVJST1JFRF9SRVBFQVQ7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5OZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVI7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX0JZVEU7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDU1NTFUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV82XzU7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5CeXRlVHlwZSApIHJldHVybiBfZ2wuQllURTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5TSE9SVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5JbnRUeXBlICkgcmV0dXJuIF9nbC5JTlQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkSW50VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfSU5UO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5GbG9hdFR5cGUgKSByZXR1cm4gX2dsLkZMT0FUO1xyXG5cclxuXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuSGFsZkZsb2F0VHlwZSApIHJldHVybiBleHRlbnNpb24uSEFMRl9GTE9BVF9PRVM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuQWxwaGFGb3JtYXQgKSByZXR1cm4gX2dsLkFMUEhBO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5SR0JGb3JtYXQgKSByZXR1cm4gX2dsLlJHQjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQUZvcm1hdCApIHJldHVybiBfZ2wuUkdCQTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0U7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0VfQUxQSEE7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5BZGRFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19BREQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfU1VCVFJBQ1Q7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1Q7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5aZXJvRmFjdG9yICkgcmV0dXJuIF9nbC5aRVJPO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVGYWN0b3IgKSByZXR1cm4gX2dsLk9ORTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19DT0xPUjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19DT0xPUjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLkRTVF9BTFBIQTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9BTFBIQTtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkRzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQ09MT1I7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19EU1RfQ09MT1I7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQV9TQVRVUkFURTtcclxuXHJcblx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xyXG5cclxuXHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcclxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO1xyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ7XHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XHJcblxyXG5cdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HO1xyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HO1xyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUc7XHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMScgKTtcclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCX0VUQzFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XHJcblxyXG5cdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLk1pbkVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NSU5fRVhUO1xyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLk1heEVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NQVhfRVhUO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gMDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9XZWJHTFJlbmRlclRhcmdldC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBNYXJpdXMgS2ludGVsIC8gaHR0cHM6Ly9naXRodWIuY29tL2tpbnRlbFxyXG4gKi9cclxuXHJcbi8qXHJcbiBJbiBvcHRpb25zLCB3ZSBjYW4gc3BlY2lmeTpcclxuICogVGV4dHVyZSBwYXJhbWV0ZXJzIGZvciBhbiBhdXRvLWdlbmVyYXRlZCB0YXJnZXQgdGV4dHVyZVxyXG4gKiBkZXB0aEJ1ZmZlci9zdGVuY2lsQnVmZmVyOiBCb29sZWFucyB0byBpbmRpY2F0ZSBpZiB3ZSBzaG91bGQgZ2VuZXJhdGUgdGhlc2UgYnVmZmVyc1xyXG4qL1xyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcclxuXHJcblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHR0aGlzLnNjaXNzb3IgPSBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cdHRoaXMuc2Npc3NvclRlc3QgPSBmYWxzZTtcclxuXHJcblx0dGhpcy52aWV3cG9ydCA9IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRpZiAoIG9wdGlvbnMubWluRmlsdGVyID09PSB1bmRlZmluZWQgKSBvcHRpb25zLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHJcblx0dGhpcy50ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zLndyYXBTLCBvcHRpb25zLndyYXBULCBvcHRpb25zLm1hZ0ZpbHRlciwgb3B0aW9ucy5taW5GaWx0ZXIsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIG9wdGlvbnMuYW5pc290cm9weSApO1xyXG5cclxuXHR0aGlzLmRlcHRoQnVmZmVyID0gb3B0aW9ucy5kZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aEJ1ZmZlciA6IHRydWU7XHJcblx0dGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiB0cnVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LFxyXG5cclxuXHRzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0ICkge1xyXG5cclxuXHRcdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHRcdHRoaXMuZGlzcG9zZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnZpZXdwb3J0LnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cdFx0dGhpcy5zY2lzc29yLnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcclxuXHRcdHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcclxuXHJcblx0XHR0aGlzLnZpZXdwb3J0LmNvcHkoIHNvdXJjZS52aWV3cG9ydCApO1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZSA9IHNvdXJjZS50ZXh0dXJlLmNsb25lKCk7XHJcblxyXG5cdFx0dGhpcy5kZXB0aEJ1ZmZlciA9IHNvdXJjZS5kZXB0aEJ1ZmZlcjtcclxuXHRcdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IHNvdXJjZS5zdGVuY2lsQnVmZmVyO1xyXG5cclxuXHRcdHRoaXMuc2hhcmVEZXB0aEZyb20gPSBzb3VyY2Uuc2hhcmVEZXB0aEZyb207XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb21cclxuICovXHJcblxyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XHJcblxyXG5cdFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LmNhbGwoIHRoaXMsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcclxuXHJcblx0dGhpcy5hY3RpdmVDdWJlRmFjZSA9IDA7IC8vIFBYIDAsIE5YIDEsIFBZIDIsIE5ZIDMsIFBaIDQsIE5aIDVcclxuXHJcbn07XHJcblxyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlICk7XHJcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmU7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xCdWZmZXJSZW5kZXJlci5qc1xyXG5cclxuLyoqXHJcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuKi9cclxuXHJcblRIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXIgPSBmdW5jdGlvbiAoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKSB7XHJcblxyXG5cdHZhciBtb2RlO1xyXG5cclxuXHRmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRtb2RlID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XHJcblxyXG5cdFx0X2dsLmRyYXdBcnJheXMoIG1vZGUsIHN0YXJ0LCBjb3VudCApO1xyXG5cclxuXHRcdF9pbmZvUmVuZGVyLmNhbGxzICsrO1xyXG5cdFx0X2luZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XHJcblx0XHRpZiAoIG1vZGUgPT09IF9nbC5UUklBTkdMRVMgKSBfaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xyXG5cclxuXHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdHZhciBjb3VudCA9IDA7XHJcblxyXG5cdFx0aWYgKCBwb3NpdGlvbiBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0Y291bnQgPSBwb3NpdGlvbi5kYXRhLmNvdW50O1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvdW50ID0gcG9zaXRpb24uY291bnQ7XHJcblxyXG5cdFx0XHRleHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCBtb2RlLCAwLCBjb3VudCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X2luZm9SZW5kZXIuY2FsbHMgKys7XHJcblx0XHRfaW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudCAqIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50O1xyXG5cdFx0aWYgKCBtb2RlID09PSBfZ2wuVFJJQU5HTEVTICkgX2luZm9SZW5kZXIuZmFjZXMgKz0gZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKiBjb3VudCAvIDM7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcclxuXHR0aGlzLnJlbmRlciA9IHJlbmRlcjtcclxuXHR0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIuanNcclxuXHJcbi8qKlxyXG4qIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiovXHJcblxyXG5USFJFRS5XZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IGZ1bmN0aW9uICggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApIHtcclxuXHJcblx0dmFyIG1vZGU7XHJcblxyXG5cdGZ1bmN0aW9uIHNldE1vZGUoIHZhbHVlICkge1xyXG5cclxuXHRcdG1vZGUgPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgdHlwZSwgc2l6ZTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0SW5kZXgoIGluZGV4ICkge1xyXG5cclxuXHRcdGlmICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSAmJiBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XHJcblxyXG5cdFx0XHR0eXBlID0gX2dsLlVOU0lHTkVEX0lOVDtcclxuXHRcdFx0c2l6ZSA9IDQ7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHR5cGUgPSBfZ2wuVU5TSUdORURfU0hPUlQ7XHJcblx0XHRcdHNpemUgPSAyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcclxuXHJcblx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQgKiBzaXplICk7XHJcblxyXG5cdFx0X2luZm9SZW5kZXIuY2FsbHMgKys7XHJcblx0XHRfaW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcclxuXHRcdGlmICggbW9kZSA9PT0gX2dsLlRSSUFOR0xFUyApIF9pbmZvUmVuZGVyLmZhY2VzICs9IGNvdW50IC8gMztcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5LCBzdGFydCwgY291bnQgKSB7XHJcblxyXG5cdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZXh0ZW5zaW9uLmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKCBtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQgKiBzaXplLCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xyXG5cclxuXHRcdF9pbmZvUmVuZGVyLmNhbGxzICsrO1xyXG5cdFx0X2luZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQgKiBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudDtcclxuXHRcdGlmICggbW9kZSA9PT0gX2dsLlRSSUFOR0xFUyApIF9pbmZvUmVuZGVyLmZhY2VzICs9IGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICogY291bnQgLyAzO1xyXG5cdH1cclxuXHJcblx0dGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcclxuXHR0aGlzLnNldEluZGV4ID0gc2V0SW5kZXg7XHJcblx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XHJcblx0dGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMRXh0ZW5zaW9ucy5qc1xyXG5cclxuLyoqXHJcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuKi9cclxuXHJcblRIUkVFLldlYkdMRXh0ZW5zaW9ucyA9IGZ1bmN0aW9uICggZ2wgKSB7XHJcblxyXG5cdHZhciBleHRlbnNpb25zID0ge307XHJcblxyXG5cdHRoaXMuZ2V0ID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRcdGlmICggZXh0ZW5zaW9uc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9uc1sgbmFtZSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZXh0ZW5zaW9uO1xyXG5cclxuXHRcdHN3aXRjaCAoIG5hbWUgKSB7XHJcblxyXG5cdFx0XHRjYXNlICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnOlxyXG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yyc6XHJcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yyc6XHJcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMSc6XHJcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggbmFtZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBuYW1lICsgJyBleHRlbnNpb24gbm90IHN1cHBvcnRlZC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGV4dGVuc2lvbnNbIG5hbWUgXSA9IGV4dGVuc2lvbjtcclxuXHJcblx0XHRyZXR1cm4gZXh0ZW5zaW9uO1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTENhcGFiaWxpdGllcy5qc1xyXG5cclxuVEhSRUUuV2ViR0xDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoIGdsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRmdW5jdGlvbiBnZXRNYXhQcmVjaXNpb24oIHByZWNpc2lvbiApIHtcclxuXHJcblx0XHRpZiAoIHByZWNpc2lvbiA9PT0gJ2hpZ2hwJyApIHtcclxuXHJcblx0XHRcdGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxyXG5cdFx0XHQgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuICdoaWdocCc7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwcmVjaXNpb24gPSAnbWVkaXVtcCc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcHJlY2lzaW9uID09PSAnbWVkaXVtcCcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxyXG5cdFx0XHQgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gJ21lZGl1bXAnO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gJ2xvd3AnO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuZ2V0TWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uO1xyXG5cclxuXHR0aGlzLnByZWNpc2lvbiA9IHBhcmFtZXRlcnMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZWNpc2lvbiA6ICdoaWdocCcsXHJcblx0dGhpcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgOiBmYWxzZTtcclxuXHJcblx0dGhpcy5tYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuXHR0aGlzLm1heFZlcnRleFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuXHR0aGlzLm1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9TSVpFICk7XHJcblx0dGhpcy5tYXhDdWJlbWFwU2l6ZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSApO1xyXG5cclxuXHR0aGlzLm1heEF0dHJpYnV0ZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfQVRUUklCUyApO1xyXG5cdHRoaXMubWF4VmVydGV4VW5pZm9ybXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTICk7XHJcblx0dGhpcy5tYXhWYXJ5aW5ncyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZBUllJTkdfVkVDVE9SUyApO1xyXG5cdHRoaXMubWF4RnJhZ21lbnRVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyApO1xyXG5cclxuXHR0aGlzLnZlcnRleFRleHR1cmVzID0gdGhpcy5tYXhWZXJ0ZXhUZXh0dXJlcyA+IDA7XHJcblx0dGhpcy5mbG9hdEZyYWdtZW50VGV4dHVyZXMgPSAhISBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xyXG5cdHRoaXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyA9IHRoaXMudmVydGV4VGV4dHVyZXMgJiYgdGhpcy5mbG9hdEZyYWdtZW50VGV4dHVyZXM7XHJcblxyXG5cdHZhciBfbWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uKCB0aGlzLnByZWNpc2lvbiApO1xyXG5cclxuXHRpZiAoIF9tYXhQcmVjaXNpb24gIT09IHRoaXMucHJlY2lzaW9uICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6JywgdGhpcy5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIF9tYXhQcmVjaXNpb24sICdpbnN0ZWFkLicgKTtcclxuXHRcdHRoaXMucHJlY2lzaW9uID0gX21heFByZWNpc2lvbjtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIHRoaXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcclxuXHJcblx0XHR0aGlzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSAhISBleHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMR2VvbWV0cmllcy5qc1xyXG5cclxuLyoqXHJcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuKi9cclxuXHJcblRIUkVFLldlYkdMR2VvbWV0cmllcyA9IGZ1bmN0aW9uICggZ2wsIHByb3BlcnRpZXMsIGluZm8gKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyaWVzID0ge307XHJcblxyXG5cdGZ1bmN0aW9uIGdldCggb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XHJcblxyXG5cdFx0dmFyIGJ1ZmZlcmdlb21ldHJ5O1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21PYmplY3QoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF0gPSBidWZmZXJnZW9tZXRyeTtcclxuXHJcblx0XHRpbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xyXG5cclxuXHRcdHJldHVybiBidWZmZXJnZW9tZXRyeTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbkdlb21ldHJ5RGlzcG9zZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gZXZlbnQudGFyZ2V0O1xyXG5cdFx0dmFyIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcclxuXHJcblx0XHRpZiAoIGJ1ZmZlcmdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0ZGVsZXRlQXR0cmlidXRlKCBidWZmZXJnZW9tZXRyeS5pbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGVBdHRyaWJ1dGVzKCBidWZmZXJnZW9tZXRyeS5hdHRyaWJ1dGVzICk7XHJcblxyXG5cdFx0Z2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xyXG5cclxuXHRcdGRlbGV0ZSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xyXG5cclxuXHRcdC8vIFRPRE9cclxuXHJcblx0XHR2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzLmdldCggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRpZiAoIHByb3BlcnR5LndpcmVmcmFtZSApIHtcclxuXHJcblx0XHRcdGRlbGV0ZUF0dHJpYnV0ZSggcHJvcGVydHkud2lyZWZyYW1lICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHByb3BlcnRpZXMuZGVsZXRlKCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdHZhciBidWZmZXJwcm9wZXJ0eSA9IHByb3BlcnRpZXMuZ2V0KCBidWZmZXJnZW9tZXRyeSApO1xyXG5cclxuXHRcdGlmICggYnVmZmVycHJvcGVydHkud2lyZWZyYW1lICkge1xyXG5cclxuXHRcdFx0ZGVsZXRlQXR0cmlidXRlKCBidWZmZXJwcm9wZXJ0eS53aXJlZnJhbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cHJvcGVydGllcy5kZWxldGUoIGJ1ZmZlcmdlb21ldHJ5ICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpbmZvLm1lbW9yeS5nZW9tZXRyaWVzIC0tO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUgKS5fX3dlYmdsQnVmZmVyO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRlbGV0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdHZhciBidWZmZXIgPSBnZXRBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdGlmICggYnVmZmVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRnbC5kZWxldGVCdWZmZXIoIGJ1ZmZlciApO1xyXG5cdFx0XHRyZW1vdmVBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkZWxldGVBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRkZWxldGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXNbIG5hbWUgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0cHJvcGVydGllcy5kZWxldGUoIGF0dHJpYnV0ZS5kYXRhICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHByb3BlcnRpZXMuZGVsZXRlKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5nZXQgPSBnZXQ7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMTGlnaHRzLmpzXHJcblxyXG4vKipcclxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4qL1xyXG5cclxuVEhSRUUuV2ViR0xMaWdodHMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBsaWdodHMgPSB7fTtcclxuXHJcblx0dGhpcy5nZXQgPSBmdW5jdGlvbiAoIGxpZ2h0ICkge1xyXG5cclxuXHRcdGlmICggbGlnaHRzWyBsaWdodC5pZCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbGlnaHRzWyBsaWdodC5pZCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdW5pZm9ybXM7XHJcblxyXG5cdFx0c3dpdGNoICggbGlnaHQudHlwZSApIHtcclxuXHJcblx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxyXG5cdFx0XHRcdHVuaWZvcm1zID0ge1xyXG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRcdFx0Y29sb3I6IG5ldyBUSFJFRS5Db2xvcigpLFxyXG5cclxuXHRcdFx0XHRcdHNoYWRvdzogZmFsc2UsXHJcblx0XHRcdFx0XHRzaGFkb3dCaWFzOiAwLFxyXG5cdFx0XHRcdFx0c2hhZG93UmFkaXVzOiAxLFxyXG5cdFx0XHRcdFx0c2hhZG93TWFwU2l6ZTogbmV3IFRIUkVFLlZlY3RvcjIoKVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdTcG90TGlnaHQnOlxyXG5cdFx0XHRcdHVuaWZvcm1zID0ge1xyXG5cdFx0XHRcdFx0cG9zaXRpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdFx0XHRjb2xvcjogbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0XHRcdFx0XHRkaXN0YW5jZTogMCxcclxuXHRcdFx0XHRcdGFuZ2xlQ29zOiAwLFxyXG5cdFx0XHRcdFx0ZXhwb25lbnQ6IDAsXHJcblx0XHRcdFx0XHRkZWNheTogMCxcclxuXHJcblx0XHRcdFx0XHRzaGFkb3c6IGZhbHNlLFxyXG5cdFx0XHRcdFx0c2hhZG93QmlhczogMCxcclxuXHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcclxuXHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBUSFJFRS5WZWN0b3IyKClcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XHJcblx0XHRcdFx0dW5pZm9ybXMgPSB7XHJcblx0XHRcdFx0XHRwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0XHRcdGNvbG9yOiBuZXcgVEhSRUUuQ29sb3IoKSxcclxuXHRcdFx0XHRcdGRpc3RhbmNlOiAwLFxyXG5cdFx0XHRcdFx0ZGVjYXk6IDAsXHJcblxyXG5cdFx0XHRcdFx0c2hhZG93OiBmYWxzZSxcclxuXHRcdFx0XHRcdHNoYWRvd0JpYXM6IDAsXHJcblx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXHJcblx0XHRcdFx0XHRzaGFkb3dNYXBTaXplOiBuZXcgVEhSRUUuVmVjdG9yMigpXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XHJcblx0XHRcdFx0dW5pZm9ybXMgPSB7XHJcblx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdFx0XHRza3lDb2xvcjogbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0XHRcdFx0XHRncm91bmRDb2xvcjogbmV3IFRIUkVFLkNvbG9yKClcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRsaWdodHNbIGxpZ2h0LmlkIF0gPSB1bmlmb3JtcztcclxuXHJcblx0XHRyZXR1cm4gdW5pZm9ybXM7XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMT2JqZWN0cy5qc1xyXG5cclxuLyoqXHJcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuKi9cclxuXHJcblRIUkVFLldlYkdMT2JqZWN0cyA9IGZ1bmN0aW9uICggZ2wsIHByb3BlcnRpZXMsIGluZm8gKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyaWVzID0gbmV3IFRIUkVFLldlYkdMR2VvbWV0cmllcyggZ2wsIHByb3BlcnRpZXMsIGluZm8gKTtcclxuXHJcblx0Ly9cclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0Ly8gVE9ETzogQXZvaWQgdXBkYXRpbmcgdHdpY2UgKHdoZW4gdXNpbmcgc2hhZG93TWFwKS4gTWF5YmUgYWRkIGZyYW1lIGNvdW50ZXIuXHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gZ2VvbWV0cmllcy5nZXQoIG9iamVjdCApO1xyXG5cclxuXHRcdGlmICggb2JqZWN0Lmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS51cGRhdGVGcm9tT2JqZWN0KCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHVwZGF0ZUF0dHJpYnV0ZSggaW5kZXgsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHR1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXNbIG5hbWUgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG1vcnBoIHRhcmdldHNcclxuXHJcblx0XHR2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dXBkYXRlQXR0cmlidXRlKCBhcnJheVsgaSBdLCBnbC5BUlJBWV9CVUZGRVIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBidWZmZXJUeXBlICkge1xyXG5cclxuXHRcdHZhciBkYXRhID0gKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApID8gYXR0cmlidXRlLmRhdGEgOiBhdHRyaWJ1dGU7XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggZGF0YSApO1xyXG5cclxuXHRcdGlmICggYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gIT09IGRhdGEudmVyc2lvbiApIHtcclxuXHJcblx0XHRcdHVwZGF0ZUJ1ZmZlciggYXR0cmlidXRlUHJvcGVydGllcywgZGF0YSwgYnVmZmVyVHlwZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XHJcblxyXG5cdFx0YXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgKTtcclxuXHJcblx0XHR2YXIgdXNhZ2UgPSBkYXRhLmR5bmFtaWMgPyBnbC5EWU5BTUlDX0RSQVcgOiBnbC5TVEFUSUNfRFJBVztcclxuXHJcblx0XHRnbC5idWZmZXJEYXRhKCBidWZmZXJUeXBlLCBkYXRhLmFycmF5LCB1c2FnZSApO1xyXG5cclxuXHRcdGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XHJcblxyXG5cdFx0Z2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyICk7XHJcblxyXG5cdFx0aWYgKCBkYXRhLmR5bmFtaWMgPT09IGZhbHNlIHx8IGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPT09IC0gMSApIHtcclxuXHJcblx0XHRcdC8vIE5vdCB1c2luZyB1cGRhdGUgcmFuZ2VzXHJcblxyXG5cdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCAwLCBkYXRhLmFycmF5ICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9PT0gMCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTE9iamVjdHMudXBkYXRlQnVmZmVyOiBkeW5hbWljIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSBtYXJrZWQgYXMgbmVlZHNVcGRhdGUgYnV0IHVwZGF0ZVJhbmdlLmNvdW50IGlzIDAsIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHNldCBtZXRob2RzIG9yIHVwZGF0aW5nIG1hbnVhbGx5LicgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Z2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG5cdFx0XHRcdFx0XHRcdCAgZGF0YS5hcnJheS5zdWJhcnJheSggZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQsIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0ICsgZGF0YS51cGRhdGVSYW5nZS5jb3VudCApICk7XHJcblxyXG5cdFx0XHRkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID0gMDsgLy8gcmVzZXQgcmFuZ2VcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0YXR0cmlidXRlUHJvcGVydGllcy52ZXJzaW9uID0gZGF0YS52ZXJzaW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUgKS5fX3dlYmdsQnVmZmVyO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIHByb3BlcnR5ID0gcHJvcGVydGllcy5nZXQoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0aWYgKCBwcm9wZXJ0eS53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBwcm9wZXJ0eS53aXJlZnJhbWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbmRpY2VzID0gW107XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblx0XHR2YXIgcG9zaXRpb24gPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdC8vIGNvbnNvbGUudGltZSggJ3dpcmVmcmFtZScgKTtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dmFyIGVkZ2VzID0ge307XHJcblx0XHRcdHZhciBhcnJheSA9IGluZGV4LmFycmF5O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IGFycmF5WyBpICsgMCBdO1xyXG5cdFx0XHRcdHZhciBiID0gYXJyYXlbIGkgKyAxIF07XHJcblx0XHRcdFx0dmFyIGMgPSBhcnJheVsgaSArIDIgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBjaGVja0VkZ2UoIGVkZ2VzLCBhLCBiICkgKSBpbmRpY2VzLnB1c2goIGEsIGIgKTtcclxuXHRcdFx0XHRpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGIsIGMgKSApIGluZGljZXMucHVzaCggYiwgYyApO1xyXG5cdFx0XHRcdGlmICggY2hlY2tFZGdlKCBlZGdlcywgYywgYSApICkgaW5kaWNlcy5wdXNoKCBjLCBhICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSAoIGFycmF5Lmxlbmd0aCAvIDMgKSAtIDE7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBhID0gaSArIDA7XHJcblx0XHRcdFx0dmFyIGIgPSBpICsgMTtcclxuXHRcdFx0XHR2YXIgYyA9IGkgKyAyO1xyXG5cclxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY29uc29sZS50aW1lRW5kKCAnd2lyZWZyYW1lJyApO1xyXG5cclxuXHRcdHZhciBUeXBlQXJyYXkgPSBwb3NpdGlvbi5jb3VudCA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcclxuXHRcdHZhciBhdHRyaWJ1dGUgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVHlwZUFycmF5KCBpbmRpY2VzICksIDEgKTtcclxuXHJcblx0XHR1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcclxuXHJcblx0XHRwcm9wZXJ0eS53aXJlZnJhbWUgPSBhdHRyaWJ1dGU7XHJcblxyXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjaGVja0VkZ2UoIGVkZ2VzLCBhLCBiICkge1xyXG5cclxuXHRcdGlmICggYSA+IGIgKSB7XHJcblxyXG5cdFx0XHR2YXIgdG1wID0gYTtcclxuXHRcdFx0YSA9IGI7XHJcblx0XHRcdGIgPSB0bXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaXN0ID0gZWRnZXNbIGEgXTtcclxuXHJcblx0XHRpZiAoIGxpc3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGVkZ2VzWyBhIF0gPSBbIGIgXTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbGlzdC5pbmRleE9mKCBiICkgPT09IC0xICkge1xyXG5cclxuXHRcdFx0bGlzdC5wdXNoKCBiICk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5nZXRBdHRyaWJ1dGVCdWZmZXIgPSBnZXRBdHRyaWJ1dGVCdWZmZXI7XHJcblx0dGhpcy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUgPSBnZXRXaXJlZnJhbWVBdHRyaWJ1dGU7XHJcblxyXG5cdHRoaXMudXBkYXRlID0gdXBkYXRlO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb2dyYW0uanNcclxuXHJcblRIUkVFLldlYkdMUHJvZ3JhbSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgcHJvZ3JhbUlkQ291bnQgPSAwO1xyXG5cclxuXHQvLyBUT0RPOiBDb21iaW5lIHRoZSByZWdleFxyXG5cdHZhciBzdHJ1Y3RSZSA9IC9eKFtcXHdcXGRfXSspXFwuKFtcXHdcXGRfXSspJC87XHJcblx0dmFyIGFycmF5U3RydWN0UmUgPSAvXihbXFx3XFxkX10rKVxcWyhcXGQrKVxcXVxcLihbXFx3XFxkX10rKSQvO1xyXG5cdHZhciBhcnJheVJlID0gL14oW1xcd1xcZF9dKylcXFswXFxdJC87XHJcblxyXG5cdGZ1bmN0aW9uIGdlbmVyYXRlRXh0ZW5zaW9ucyggZXh0ZW5zaW9ucywgcGFyYW1ldGVycywgcmVuZGVyZXJFeHRlbnNpb25zICkge1xyXG5cclxuXHRcdGV4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xyXG5cclxuXHRcdHZhciBjaHVua3MgPSBbXHJcblx0XHRcdCggZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcyB8fCBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy5ub3JtYWxNYXAgfHwgcGFyYW1ldGVycy5mbGF0U2hhZGluZyApID8gJyNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlJyA6ICcnLFxyXG5cdFx0XHQoIGV4dGVuc2lvbnMuZnJhZ0RlcHRoIHx8IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApICYmIHJlbmRlcmVyRXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlJyA6ICcnLFxyXG5cdFx0XHQoIGV4dGVuc2lvbnMuZHJhd0J1ZmZlcnMgKSAmJiByZW5kZXJlckV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfZHJhd19idWZmZXJzJyApID8gJyNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmUnIDogJycsXHJcblx0XHRcdCggZXh0ZW5zaW9ucy5zaGFkZXJUZXh0dXJlTE9EIHx8IHBhcmFtZXRlcnMuZW52TWFwICkgJiYgcmVuZGVyZXJFeHRlbnNpb25zLmdldCggJ0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnICkgPyAnI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kIDogZW5hYmxlJyA6ICcnLFxyXG5cdFx0XTtcclxuXHJcblx0XHRyZXR1cm4gY2h1bmtzLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKSB7XHJcblxyXG5cdFx0dmFyIGNodW5rcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGRlZmluZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmFsdWUgPSBkZWZpbmVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0Y2h1bmtzLnB1c2goICcjZGVmaW5lICcgKyBuYW1lICsgJyAnICsgdmFsdWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNodW5rcy5qb2luKCAnXFxuJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGZldGNoVW5pZm9ybUxvY2F0aW9ucyggZ2wsIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xyXG5cclxuXHRcdHZhciB1bmlmb3JtcyA9IHt9O1xyXG5cclxuXHRcdHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbjsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybSggcHJvZ3JhbSwgaSApO1xyXG5cdFx0XHR2YXIgbmFtZSA9IGluZm8ubmFtZTtcclxuXHRcdFx0dmFyIGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICk7XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiBBQ1RJVkUgVU5JRk9STTpcIiwgbmFtZSk7XHJcblxyXG5cdFx0XHR2YXIgbWF0Y2hlcyA9IHN0cnVjdFJlLmV4ZWMoIG5hbWUgKTtcclxuXHRcdFx0aWYgKCBtYXRjaGVzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgc3RydWN0TmFtZSA9IG1hdGNoZXNbIDEgXTtcclxuXHRcdFx0XHR2YXIgc3RydWN0UHJvcGVydHkgPSBtYXRjaGVzWyAyIF07XHJcblxyXG5cdFx0XHRcdHZhciB1bmlmb3Jtc1N0cnVjdCA9IHVuaWZvcm1zWyBzdHJ1Y3ROYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggISB1bmlmb3Jtc1N0cnVjdCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtc1N0cnVjdCA9IHVuaWZvcm1zWyBzdHJ1Y3ROYW1lIF0gPSB7fTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1N0cnVjdFsgc3RydWN0UHJvcGVydHkgXSA9IGxvY2F0aW9uO1xyXG5cclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1hdGNoZXMgPSBhcnJheVN0cnVjdFJlLmV4ZWMoIG5hbWUgKTtcclxuXHJcblx0XHRcdGlmICggbWF0Y2hlcyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGFycmF5TmFtZSA9IG1hdGNoZXNbIDEgXTtcclxuXHRcdFx0XHR2YXIgYXJyYXlJbmRleCA9IG1hdGNoZXNbIDIgXTtcclxuXHRcdFx0XHR2YXIgYXJyYXlQcm9wZXJ0eSA9IG1hdGNoZXNbIDMgXTtcclxuXHJcblx0XHRcdFx0dmFyIHVuaWZvcm1zQXJyYXkgPSB1bmlmb3Jtc1sgYXJyYXlOYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggISB1bmlmb3Jtc0FycmF5ICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zQXJyYXkgPSB1bmlmb3Jtc1sgYXJyYXlOYW1lIF0gPSBbXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgdW5pZm9ybXNBcnJheUluZGV4ID0gdW5pZm9ybXNBcnJheVsgYXJyYXlJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgdW5pZm9ybXNBcnJheUluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zQXJyYXlJbmRleCA9IHVuaWZvcm1zQXJyYXlbIGFycmF5SW5kZXggXSA9IHt9O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zQXJyYXlJbmRleFsgYXJyYXlQcm9wZXJ0eSBdID0gbG9jYXRpb247XHJcblxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bWF0Y2hlcyA9IGFycmF5UmUuZXhlYyggbmFtZSApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRjaGVzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYXJyYXlOYW1lID0gbWF0Y2hlc1sgMSBdO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgYXJyYXlOYW1lIF0gPSBsb2NhdGlvbjtcclxuXHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR1bmlmb3Jtc1sgbmFtZSBdID0gbG9jYXRpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmlmb3JtcztcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0ge307XHJcblxyXG5cdFx0dmFyIG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZUF0dHJpYiggcHJvZ3JhbSwgaSApO1xyXG5cdFx0XHR2YXIgbmFtZSA9IGluZm8ubmFtZTtcclxuXHJcblx0XHRcdC8vIGNvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiBBQ1RJVkUgVkVSVEVYIEFUVFJJQlVURTpcIiwgbmFtZSwgaSApO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlc1sgbmFtZSBdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sIG5hbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZmlsdGVyRW1wdHlMaW5lKCBzdHJpbmcgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHN0cmluZyAhPT0gJyc7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVwbGFjZUxpZ2h0TnVtcyggc3RyaW5nLCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHJldHVybiBzdHJpbmdcclxuXHRcdFx0LnJlcGxhY2UoIC9OVU1fRElSX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bURpckxpZ2h0cyApXHJcblx0XHRcdC5yZXBsYWNlKCAvTlVNX1NQT1RfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0cyApXHJcblx0XHRcdC5yZXBsYWNlKCAvTlVNX1BPSU5UX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVBvaW50TGlnaHRzIClcclxuXHRcdFx0LnJlcGxhY2UoIC9OVU1fSEVNSV9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1IZW1pTGlnaHRzICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdW5yb2xsTG9vcHMoIHN0cmluZyApIHtcclxuXHJcblx0XHR2YXIgcGF0dGVybiA9IC9mb3IgXFwoIGludCBpIFxcPSAoXFxkKylcXDsgaSA8IChcXGQrKVxcOyBpIFxcK1xcKyBcXCkgXFx7KFtcXHNcXFNdKz8pKD89XFx9KVxcfS9nO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHJlcGxhY2UoIG1hdGNoLCBzdGFydCwgZW5kLCBzbmlwcGV0ICkge1xyXG5cclxuXHRcdFx0dmFyIHVucm9sbCA9ICcnO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSBwYXJzZUludCggc3RhcnQgKTsgaSA8IHBhcnNlSW50KCBlbmQgKTsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dW5yb2xsICs9IHNuaXBwZXQucmVwbGFjZSggL1xcWyBpIFxcXS9nLCAnWyAnICsgaSArICcgXScgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB1bnJvbGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcGF0dGVybiwgcmVwbGFjZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiBXZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBjb2RlLCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xyXG5cclxuXHRcdHZhciBleHRlbnNpb25zID0gbWF0ZXJpYWwuZXh0ZW5zaW9ucztcclxuXHRcdHZhciBkZWZpbmVzID0gbWF0ZXJpYWwuZGVmaW5lcztcclxuXHJcblx0XHR2YXIgdmVydGV4U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci52ZXJ0ZXhTaGFkZXI7XHJcblx0XHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLmZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRcdHZhciBzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX0JBU0lDJztcclxuXHJcblx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gVEhSRUUuUENGU2hhZG93TWFwICkge1xyXG5cclxuXHRcdFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0YnO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gVEhSRUUuUENGU29mdFNoYWRvd01hcCApIHtcclxuXHJcblx0XHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcclxuXHRcdHZhciBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRkxFQ1RJT04nO1xyXG5cdFx0dmFyIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XHJcblxyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApIHtcclxuXHJcblx0XHRcdHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRjYXNlIFRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxyXG5cdFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9FUVVJUkVDJztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLlNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nOlxyXG5cdFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9TUEhFUkUnO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc6XHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRcdGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN3aXRjaCAoIG1hdGVyaWFsLmNvbWJpbmUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuTXVsdGlwbHlPcGVyYXRpb246XHJcblx0XHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuTWl4T3BlcmF0aW9uOlxyXG5cdFx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01JWCc7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5BZGRPcGVyYXRpb246XHJcblx0XHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfQUREJztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ2FtbWFGYWN0b3JEZWZpbmUgPSAoIHJlbmRlcmVyLmdhbW1hRmFjdG9yID4gMCApID8gcmVuZGVyZXIuZ2FtbWFGYWN0b3IgOiAxLjA7XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coICdidWlsZGluZyBuZXcgcHJvZ3JhbSAnICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgY3VzdG9tRXh0ZW5zaW9ucyA9IGdlbmVyYXRlRXh0ZW5zaW9ucyggZXh0ZW5zaW9ucywgcGFyYW1ldGVycywgcmVuZGVyZXIuZXh0ZW5zaW9ucyApO1xyXG5cclxuXHRcdHZhciBjdXN0b21EZWZpbmVzID0gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcblx0XHR2YXIgcHJlZml4VmVydGV4LCBwcmVmaXhGcmFnbWVudDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRwcmVmaXhWZXJ0ZXggPSAnJztcclxuXHRcdFx0cHJlZml4RnJhZ21lbnQgPSAnJztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cHJlZml4VmVydGV4ID0gW1xyXG5cclxuXHRcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcclxuXHRcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXHJcblxyXG5cdFx0XHRcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLm5hbWUsXHJcblxyXG5cdFx0XHRcdGN1c3RvbURlZmluZXMsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFZFUlRFWF9URVhUVVJFUycgOiAnJyxcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIuZ2FtbWFJbnB1dCA/ICcjZGVmaW5lIEdBTU1BX0lOUFVUJyA6ICcnLFxyXG5cdFx0XHRcdHJlbmRlcmVyLmdhbW1hT3V0cHV0ID8gJyNkZWZpbmUgR0FNTUFfT1VUUFVUJyA6ICcnLFxyXG5cdFx0XHRcdCcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXHJcblxyXG5cdFx0XHRcdCcjZGVmaW5lIE1BWF9CT05FUyAnICsgcGFyYW1ldGVycy5tYXhCb25lcyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwICYmIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5za2lubmluZyA/ICcjZGVmaW5lIFVTRV9TS0lOTklORycgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnVzZVZlcnRleFRleHR1cmUgPyAnI2RlZmluZSBCT05FX1RFWFRVUkUnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID8gJyNkZWZpbmUgVVNFX01PUlBIVEFSR0VUUycgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyAmJiBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID09PSBmYWxzZSA/ICcjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFMnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgJyArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnBvaW50TGlnaHRTaGFkb3dzID4gMCA/ICcjZGVmaW5lIFBPSU5UX0xJR0hUX1NIQURPV1MnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2l6ZUF0dGVudWF0aW9uID8gJyNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTicgOiAnJyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcclxuXHJcblxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7JyxcclxuXHRcdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4OycsXHJcblx0XHRcdFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxyXG5cclxuXHRcdFx0XHQnYXR0cmlidXRlIHZlYzMgcG9zaXRpb247JyxcclxuXHRcdFx0XHQnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycsXHJcblx0XHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXHJcblxyXG5cdFx0XHRcdCcjaWZkZWYgVVNFX0NPTE9SJyxcclxuXHJcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgY29sb3I7JyxcclxuXHJcblx0XHRcdFx0JyNlbmRpZicsXHJcblxyXG5cdFx0XHRcdCcjaWZkZWYgVVNFX01PUlBIVEFSR0VUUycsXHJcblxyXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MDsnLFxyXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTsnLFxyXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjsnLFxyXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MzsnLFxyXG5cclxuXHRcdFx0XHQnXHQjaWZkZWYgVVNFX01PUlBITk9STUFMUycsXHJcblxyXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwwOycsXHJcblx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDE7JyxcclxuXHRcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMjsnLFxyXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwzOycsXHJcblxyXG5cdFx0XHRcdCdcdCNlbHNlJyxcclxuXHJcblx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDQ7JyxcclxuXHRcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NTsnLFxyXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsXHJcblx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDc7JyxcclxuXHJcblx0XHRcdFx0J1x0I2VuZGlmJyxcclxuXHJcblx0XHRcdFx0JyNlbmRpZicsXHJcblxyXG5cdFx0XHRcdCcjaWZkZWYgVVNFX1NLSU5OSU5HJyxcclxuXHJcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OycsXHJcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsnLFxyXG5cclxuXHRcdFx0XHQnI2VuZGlmJyxcclxuXHJcblx0XHRcdFx0J1xcbidcclxuXHJcblx0XHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xyXG5cclxuXHJcblx0XHRcdHByZWZpeEZyYWdtZW50ID0gW1xyXG5cclxuXHRcdFx0XHRjdXN0b21FeHRlbnNpb25zLFxyXG5cclxuXHRcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcclxuXHRcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXHJcblxyXG5cdFx0XHRcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLm5hbWUsXHJcblxyXG5cdFx0XHRcdGN1c3RvbURlZmluZXMsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgQUxQSEFURVNUICcgKyBwYXJhbWV0ZXJzLmFscGhhVGVzdCA6ICcnLFxyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5nYW1tYUlucHV0ID8gJyNkZWZpbmUgR0FNTUFfSU5QVVQnIDogJycsXHJcblx0XHRcdFx0cmVuZGVyZXIuZ2FtbWFPdXRwdXQgPyAnI2RlZmluZSBHQU1NQV9PVVRQVVQnIDogJycsXHJcblx0XHRcdFx0JyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcclxuXHJcblx0XHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcclxuXHRcdFx0XHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwICkgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBUeXBlRGVmaW5lIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcEJsZW5kaW5nRGVmaW5lIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5yb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5wb2ludExpZ2h0U2hhZG93cyA+IDAgPyAnI2RlZmluZSBQT0lOVF9MSUdIVF9TSEFET1dTJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnICkgPyAnI2RlZmluZSBURVhUVVJFX0xPRF9FWFQnIDogJycsXHJcblxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcclxuXHJcblx0XHRcdFx0J1xcbidcclxuXHJcblx0XHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKCB2ZXJ0ZXhTaGFkZXIsIHBhcmFtZXRlcnMgKTtcclxuXHRcdGZyYWdtZW50U2hhZGVyID0gcmVwbGFjZUxpZ2h0TnVtcyggZnJhZ21lbnRTaGFkZXIsIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0dmVydGV4U2hhZGVyID0gdW5yb2xsTG9vcHMoIHZlcnRleFNoYWRlciApO1xyXG5cdFx0XHRmcmFnbWVudFNoYWRlciA9IHVucm9sbExvb3BzKCBmcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdmVydGV4R2xzbCA9IHByZWZpeFZlcnRleCArIHZlcnRleFNoYWRlcjtcclxuXHRcdHZhciBmcmFnbWVudEdsc2wgPSBwcmVmaXhGcmFnbWVudCArIGZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnKlZFUlRFWConLCB2ZXJ0ZXhHbHNsICk7XHJcblx0XHQvLyBjb25zb2xlLmxvZyggJypGUkFHTUVOVConLCBmcmFnbWVudEdsc2wgKTtcclxuXHJcblx0XHR2YXIgZ2xWZXJ0ZXhTaGFkZXIgPSBUSFJFRS5XZWJHTFNoYWRlciggZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleEdsc2wgKTtcclxuXHRcdHZhciBnbEZyYWdtZW50U2hhZGVyID0gVEhSRUUuV2ViR0xTaGFkZXIoIGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50R2xzbCApO1xyXG5cclxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIgKTtcclxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdC8vIEZvcmNlIGEgcGFydGljdWxhciBhdHRyaWJ1dGUgdG8gaW5kZXggMC5cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Ly8gcHJvZ3JhbXMgd2l0aCBtb3JwaFRhcmdldHMgZGlzcGxhY2UgcG9zaXRpb24gb3V0IG9mIGF0dHJpYnV0ZSAwXHJcblx0XHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgJ3Bvc2l0aW9uJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuXHRcdHZhciBwcm9ncmFtTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW0gKTtcclxuXHRcdHZhciB2ZXJ0ZXhMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbFZlcnRleFNoYWRlciApO1xyXG5cdFx0dmFyIGZyYWdtZW50TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xGcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdHZhciBydW5uYWJsZSA9IHRydWU7XHJcblx0XHR2YXIgaGF2ZURpYWdub3N0aWNzID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBjb25zb2xlLmxvZyggJyoqVkVSVEVYKionLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIGdsVmVydGV4U2hhZGVyICkgKTtcclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnKipGUkFHTUVOVCoqJywgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBnbEZyYWdtZW50U2hhZGVyICkgKTtcclxuXHJcblx0XHRpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkxJTktfU1RBVFVTICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0cnVubmFibGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFByb2dyYW06IHNoYWRlciBlcnJvcjogJywgZ2wuZ2V0RXJyb3IoKSwgJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyApLCAnZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cnLCBwcm9ncmFtTG9nLCB2ZXJ0ZXhMb2csIGZyYWdtZW50TG9nICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggcHJvZ3JhbUxvZyAhPT0gJycgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IGdsLmdldFByb2dyYW1JbmZvTG9nKCknLCBwcm9ncmFtTG9nICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycgKSB7XHJcblxyXG5cdFx0XHRoYXZlRGlhZ25vc3RpY3MgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBoYXZlRGlhZ25vc3RpY3MgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpYWdub3N0aWNzID0ge1xyXG5cclxuXHRcdFx0XHRydW5uYWJsZTogcnVubmFibGUsXHJcblx0XHRcdFx0bWF0ZXJpYWw6IG1hdGVyaWFsLFxyXG5cclxuXHRcdFx0XHRwcm9ncmFtTG9nOiBwcm9ncmFtTG9nLFxyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHtcclxuXHJcblx0XHRcdFx0XHRsb2c6IHZlcnRleExvZyxcclxuXHRcdFx0XHRcdHByZWZpeDogcHJlZml4VmVydGV4XHJcblxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdGZyYWdtZW50U2hhZGVyOiB7XHJcblxyXG5cdFx0XHRcdFx0bG9nOiBmcmFnbWVudExvZyxcclxuXHRcdFx0XHRcdHByZWZpeDogcHJlZml4RnJhZ21lbnRcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2xlYW4gdXBcclxuXHJcblx0XHRnbC5kZWxldGVTaGFkZXIoIGdsVmVydGV4U2hhZGVyICk7XHJcblx0XHRnbC5kZWxldGVTaGFkZXIoIGdsRnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcblx0XHQvLyBzZXQgdXAgY2FjaGluZyBmb3IgdW5pZm9ybSBsb2NhdGlvbnNcclxuXHJcblx0XHR2YXIgY2FjaGVkVW5pZm9ybXM7XHJcblxyXG5cdFx0dGhpcy5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0aWYgKCBjYWNoZWRVbmlmb3JtcyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjYWNoZWRVbmlmb3JtcyA9IGZldGNoVW5pZm9ybUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjYWNoZWRVbmlmb3JtcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIHNldCB1cCBjYWNoaW5nIGZvciBhdHRyaWJ1dGUgbG9jYXRpb25zXHJcblxyXG5cdFx0dmFyIGNhY2hlZEF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0dGhpcy5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRpZiAoIGNhY2hlZEF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y2FjaGVkQXR0cmlidXRlcyA9IGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNhY2hlZEF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBmcmVlIHJlc291cmNlXHJcblxyXG5cdFx0dGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRnbC5kZWxldGVQcm9ncmFtKCBwcm9ncmFtICk7XHJcblx0XHRcdHRoaXMucHJvZ3JhbSA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIERFUFJFQ0FURURcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLnVuaWZvcm1zIGlzIG5vdyAuZ2V0VW5pZm9ybXMoKS4nICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRVbmlmb3JtcygpO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRhdHRyaWJ1dGVzOiB7XHJcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC5hdHRyaWJ1dGVzIGlzIG5vdyAuZ2V0QXR0cmlidXRlcygpLicgKTtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHRoaXMuaWQgPSBwcm9ncmFtSWRDb3VudCArKztcclxuXHRcdHRoaXMuY29kZSA9IGNvZGU7XHJcblx0XHR0aGlzLnVzZWRUaW1lcyA9IDE7XHJcblx0XHR0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG5cdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBnbFZlcnRleFNoYWRlcjtcclxuXHRcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBnbEZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9ncmFtcy5qc1xyXG5cclxuVEhSRUUuV2ViR0xQcm9ncmFtcyA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIGNhcGFiaWxpdGllcyApIHtcclxuXHJcblx0dmFyIHByb2dyYW1zID0gW107XHJcblxyXG5cdHZhciBzaGFkZXJJRHMgPSB7XHJcblx0XHRNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcclxuXHRcdE1lc2hOb3JtYWxNYXRlcmlhbDogJ25vcm1hbCcsXHJcblx0XHRNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcclxuXHRcdE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ICdsYW1iZXJ0JyxcclxuXHRcdE1lc2hQaG9uZ01hdGVyaWFsOiAncGhvbmcnLFxyXG5cdFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWw6ICdzdGFuZGFyZCcsXHJcblx0XHRMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcclxuXHRcdExpbmVEYXNoZWRNYXRlcmlhbDogJ2Rhc2hlZCcsXHJcblx0XHRQb2ludHNNYXRlcmlhbDogJ3BvaW50cydcclxuXHR9O1xyXG5cclxuXHR2YXIgcGFyYW1ldGVyTmFtZXMgPSBbXHJcblx0XHRcInByZWNpc2lvblwiLCBcInN1cHBvcnRzVmVydGV4VGV4dHVyZXNcIiwgXCJtYXBcIiwgXCJlbnZNYXBcIiwgXCJlbnZNYXBNb2RlXCIsXHJcblx0XHRcImxpZ2h0TWFwXCIsIFwiYW9NYXBcIiwgXCJlbWlzc2l2ZU1hcFwiLCBcImJ1bXBNYXBcIiwgXCJub3JtYWxNYXBcIiwgXCJkaXNwbGFjZW1lbnRNYXBcIiwgXCJzcGVjdWxhck1hcFwiLFxyXG5cdFx0XCJyb3VnaG5lc3NNYXBcIiwgXCJtZXRhbG5lc3NNYXBcIixcclxuXHRcdFwiYWxwaGFNYXBcIiwgXCJjb21iaW5lXCIsIFwidmVydGV4Q29sb3JzXCIsIFwiZm9nXCIsIFwidXNlRm9nXCIsIFwiZm9nRXhwXCIsXHJcblx0XHRcImZsYXRTaGFkaW5nXCIsIFwic2l6ZUF0dGVudWF0aW9uXCIsIFwibG9nYXJpdGhtaWNEZXB0aEJ1ZmZlclwiLCBcInNraW5uaW5nXCIsXHJcblx0XHRcIm1heEJvbmVzXCIsIFwidXNlVmVydGV4VGV4dHVyZVwiLCBcIm1vcnBoVGFyZ2V0c1wiLCBcIm1vcnBoTm9ybWFsc1wiLFxyXG5cdFx0XCJtYXhNb3JwaFRhcmdldHNcIiwgXCJtYXhNb3JwaE5vcm1hbHNcIixcclxuXHRcdFwibnVtRGlyTGlnaHRzXCIsIFwibnVtUG9pbnRMaWdodHNcIiwgXCJudW1TcG90TGlnaHRzXCIsIFwibnVtSGVtaUxpZ2h0c1wiLFxyXG5cdFx0XCJzaGFkb3dNYXBFbmFibGVkXCIsIFwicG9pbnRMaWdodFNoYWRvd3NcIixcclxuXHRcdFwic2hhZG93TWFwVHlwZVwiLFxyXG5cdFx0XCJhbHBoYVRlc3RcIiwgXCJkb3VibGVTaWRlZFwiLCBcImZsaXBTaWRlZFwiXHJcblx0XTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIGFsbG9jYXRlQm9uZXMgKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIDEwMjQ7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGRlZmF1bHQgZm9yIHdoZW4gb2JqZWN0IGlzIG5vdCBzcGVjaWZpZWRcclxuXHRcdFx0Ly8gKCBmb3IgZXhhbXBsZSB3aGVuIHByZWJ1aWxkaW5nIHNoYWRlciB0byBiZSB1c2VkIHdpdGggbXVsdGlwbGUgb2JqZWN0cyApXHJcblx0XHRcdC8vXHJcblx0XHRcdC8vICAtIGxlYXZlIHNvbWUgZXh0cmEgc3BhY2UgZm9yIG90aGVyIHVuaWZvcm1zXHJcblx0XHRcdC8vICAtIGxpbWl0IGhlcmUgaXMgQU5HTEUncyAyNTQgbWF4IHVuaWZvcm0gdmVjdG9yc1xyXG5cdFx0XHQvLyAgICAodXAgdG8gNTQgc2hvdWxkIGJlIHNhZmUpXHJcblxyXG5cdFx0XHR2YXIgblZlcnRleFVuaWZvcm1zID0gY2FwYWJpbGl0aWVzLm1heFZlcnRleFVuaWZvcm1zO1xyXG5cdFx0XHR2YXIgblZlcnRleE1hdHJpY2VzID0gTWF0aC5mbG9vciggKCBuVmVydGV4VW5pZm9ybXMgLSAyMCApIC8gNCApO1xyXG5cclxuXHRcdFx0dmFyIG1heEJvbmVzID0gblZlcnRleE1hdHJpY2VzO1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCApIHtcclxuXHJcblx0XHRcdFx0bWF4Qm9uZXMgPSBNYXRoLm1pbiggb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCwgbWF4Qm9uZXMgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXhCb25lcyA8IG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnV2ViR0xSZW5kZXJlcjogdG9vIG1hbnkgYm9uZXMgLSAnICsgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCArICcsIHRoaXMgR1BVIHN1cHBvcnRzIGp1c3QgJyArIG1heEJvbmVzICsgJyAodHJ5IE9wZW5HTCBpbnN0ZWFkIG9mIEFOR0xFKScgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG1heEJvbmVzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBzaGFkZXJJRCA9IHNoYWRlcklEc1sgbWF0ZXJpYWwudHlwZSBdO1xyXG5cdFx0Ly8gaGV1cmlzdGljcyB0byBjcmVhdGUgc2hhZGVyIHBhcmFtZXRlcnMgYWNjb3JkaW5nIHRvIGxpZ2h0cyBpbiB0aGUgc2NlbmVcclxuXHRcdC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXHJcblxyXG5cdFx0dmFyIG1heEJvbmVzID0gYWxsb2NhdGVCb25lcyggb2JqZWN0ICk7XHJcblx0XHR2YXIgcHJlY2lzaW9uID0gcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCk7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5wcmVjaXNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMuZ2V0TWF4UHJlY2lzaW9uKCBtYXRlcmlhbC5wcmVjaXNpb24gKTtcclxuXHJcblx0XHRcdGlmICggcHJlY2lzaW9uICE9PSBtYXRlcmlhbC5wcmVjaXNpb24gKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbS5nZXRQYXJhbWV0ZXJzOicsIG1hdGVyaWFsLnByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgcHJlY2lzaW9uLCAnaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwYXJhbWV0ZXJzID0ge1xyXG5cclxuXHRcdFx0c2hhZGVySUQ6IHNoYWRlcklELFxyXG5cclxuXHRcdFx0cHJlY2lzaW9uOiBwcmVjaXNpb24sXHJcblx0XHRcdHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IGNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcyxcclxuXHJcblx0XHRcdG1hcDogISEgbWF0ZXJpYWwubWFwLFxyXG5cdFx0XHRlbnZNYXA6ICEhIG1hdGVyaWFsLmVudk1hcCxcclxuXHRcdFx0ZW52TWFwTW9kZTogbWF0ZXJpYWwuZW52TWFwICYmIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nLFxyXG5cdFx0XHRsaWdodE1hcDogISEgbWF0ZXJpYWwubGlnaHRNYXAsXHJcblx0XHRcdGFvTWFwOiAhISBtYXRlcmlhbC5hb01hcCxcclxuXHRcdFx0ZW1pc3NpdmVNYXA6ICEhIG1hdGVyaWFsLmVtaXNzaXZlTWFwLFxyXG5cdFx0XHRidW1wTWFwOiAhISBtYXRlcmlhbC5idW1wTWFwLFxyXG5cdFx0XHRub3JtYWxNYXA6ICEhIG1hdGVyaWFsLm5vcm1hbE1hcCxcclxuXHRcdFx0ZGlzcGxhY2VtZW50TWFwOiAhISBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAsXHJcblx0XHRcdHJvdWdobmVzc01hcDogISEgbWF0ZXJpYWwucm91Z2huZXNzTWFwLFxyXG5cdFx0XHRtZXRhbG5lc3NNYXA6ICEhIG1hdGVyaWFsLm1ldGFsbmVzc01hcCxcclxuXHRcdFx0c3BlY3VsYXJNYXA6ICEhIG1hdGVyaWFsLnNwZWN1bGFyTWFwLFxyXG5cdFx0XHRhbHBoYU1hcDogISEgbWF0ZXJpYWwuYWxwaGFNYXAsXHJcblxyXG5cdFx0XHRjb21iaW5lOiBtYXRlcmlhbC5jb21iaW5lLFxyXG5cclxuXHRcdFx0dmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXHJcblxyXG5cdFx0XHRmb2c6IGZvZyxcclxuXHRcdFx0dXNlRm9nOiBtYXRlcmlhbC5mb2csXHJcblx0XHRcdGZvZ0V4cDogZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMixcclxuXHJcblx0XHRcdGZsYXRTaGFkaW5nOiBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyxcclxuXHJcblx0XHRcdHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uLFxyXG5cdFx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcclxuXHJcblx0XHRcdHNraW5uaW5nOiBtYXRlcmlhbC5za2lubmluZyxcclxuXHRcdFx0bWF4Qm9uZXM6IG1heEJvbmVzLFxyXG5cdFx0XHR1c2VWZXJ0ZXhUZXh0dXJlOiBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlLFxyXG5cclxuXHRcdFx0bW9ycGhUYXJnZXRzOiBtYXRlcmlhbC5tb3JwaFRhcmdldHMsXHJcblx0XHRcdG1vcnBoTm9ybWFsczogbWF0ZXJpYWwubW9ycGhOb3JtYWxzLFxyXG5cdFx0XHRtYXhNb3JwaFRhcmdldHM6IHJlbmRlcmVyLm1heE1vcnBoVGFyZ2V0cyxcclxuXHRcdFx0bWF4TW9ycGhOb3JtYWxzOiByZW5kZXJlci5tYXhNb3JwaE5vcm1hbHMsXHJcblxyXG5cdFx0XHRudW1EaXJMaWdodHM6IGxpZ2h0cy5kaXJlY3Rpb25hbC5sZW5ndGgsXHJcblx0XHRcdG51bVBvaW50TGlnaHRzOiBsaWdodHMucG9pbnQubGVuZ3RoLFxyXG5cdFx0XHRudW1TcG90TGlnaHRzOiBsaWdodHMuc3BvdC5sZW5ndGgsXHJcblx0XHRcdG51bUhlbWlMaWdodHM6IGxpZ2h0cy5oZW1pLmxlbmd0aCxcclxuXHJcblx0XHRcdHBvaW50TGlnaHRTaGFkb3dzOiBsaWdodHMuc2hhZG93c1BvaW50TGlnaHQsXHJcblxyXG5cdFx0XHRzaGFkb3dNYXBFbmFibGVkOiByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBsaWdodHMuc2hhZG93cy5sZW5ndGggPiAwLFxyXG5cdFx0XHRzaGFkb3dNYXBUeXBlOiByZW5kZXJlci5zaGFkb3dNYXAudHlwZSxcclxuXHJcblx0XHRcdGFscGhhVGVzdDogbWF0ZXJpYWwuYWxwaGFUZXN0LFxyXG5cdFx0XHRkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZSxcclxuXHRcdFx0ZmxpcFNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZVxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIHBhcmFtZXRlcnM7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0UHJvZ3JhbUNvZGUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHZhciBjaHVua3MgPSBbXTtcclxuXHJcblx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XHJcblxyXG5cdFx0XHRjaHVua3MucHVzaCggcGFyYW1ldGVycy5zaGFkZXJJRCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjaHVua3MucHVzaCggbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdFx0Y2h1bmtzLnB1c2goIG1hdGVyaWFsLnZlcnRleFNoYWRlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmRlZmluZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmRlZmluZXMgKSB7XHJcblxyXG5cdFx0XHRcdGNodW5rcy5wdXNoKCBuYW1lICk7XHJcblx0XHRcdFx0Y2h1bmtzLnB1c2goIG1hdGVyaWFsLmRlZmluZXNbIG5hbWUgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJOYW1lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcGFyYW1ldGVyTmFtZSA9IHBhcmFtZXRlck5hbWVzWyBpIF07XHJcblx0XHRcdGNodW5rcy5wdXNoKCBwYXJhbWV0ZXJOYW1lICk7XHJcblx0XHRcdGNodW5rcy5wdXNoKCBwYXJhbWV0ZXJzWyBwYXJhbWV0ZXJOYW1lIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNodW5rcy5qb2luKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuYWNxdWlyZVByb2dyYW0gPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzLCBjb2RlICkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtO1xyXG5cclxuXHRcdC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxyXG5cdFx0Zm9yICggdmFyIHAgPSAwLCBwbCA9IHByb2dyYW1zLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHByb2dyYW1JbmZvID0gcHJvZ3JhbXNbIHAgXTtcclxuXHJcblx0XHRcdGlmICggcHJvZ3JhbUluZm8uY29kZSA9PT0gY29kZSApIHtcclxuXHJcblx0XHRcdFx0cHJvZ3JhbSA9IHByb2dyYW1JbmZvO1xyXG5cdFx0XHRcdCsrIHByb2dyYW0udXNlZFRpbWVzO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRwcm9ncmFtID0gbmV3IFRIUkVFLldlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XHJcblx0XHRcdHByb2dyYW1zLnB1c2goIHByb2dyYW0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb2dyYW07XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVsZWFzZVByb2dyYW0gPSBmdW5jdGlvbiggcHJvZ3JhbSApIHtcclxuXHJcblx0XHRpZiAoIC0tIHByb2dyYW0udXNlZFRpbWVzID09PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gUmVtb3ZlIGZyb20gdW5vcmRlcmVkIHNldFxyXG5cdFx0XHR2YXIgaSA9IHByb2dyYW1zLmluZGV4T2YoIHByb2dyYW0gKTtcclxuXHRcdFx0cHJvZ3JhbXNbIGkgXSA9IHByb2dyYW1zWyBwcm9ncmFtcy5sZW5ndGggLSAxIF07XHJcblx0XHRcdHByb2dyYW1zLnBvcCgpO1xyXG5cclxuXHRcdFx0Ly8gRnJlZSBXZWJHTCByZXNvdXJjZXNcclxuXHRcdFx0cHJvZ3JhbS5kZXN0cm95KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBFeHBvc2VkIGZvciByZXNvdXJjZSBtb25pdG9yaW5nICYgZXJyb3IgZmVlZGJhY2sgdmlhIHJlbmRlcmVyLmluZm86XHJcblx0dGhpcy5wcm9ncmFtcyA9IHByb2dyYW1zO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb3BlcnRpZXMuanNcclxuXHJcbi8qKlxyXG4qIEBhdXRob3IgZm9yZGFjaW91cyAvIGZvcmRhY2lvdXMuZ2l0aHViLmlvXHJcbiovXHJcblxyXG5USFJFRS5XZWJHTFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBwcm9wZXJ0aWVzID0ge307XHJcblxyXG5cdHRoaXMuZ2V0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIHV1aWQgPSBvYmplY3QudXVpZDtcclxuXHRcdHZhciBtYXAgPSBwcm9wZXJ0aWVzWyB1dWlkIF07XHJcblxyXG5cdFx0aWYgKCBtYXAgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1hcCA9IHt9O1xyXG5cdFx0XHRwcm9wZXJ0aWVzWyB1dWlkIF0gPSBtYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtYXA7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZGVsZXRlID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0ZGVsZXRlIHByb3BlcnRpZXNbIG9iamVjdC51dWlkIF07XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cHJvcGVydGllcyA9IHt9O1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFNoYWRlci5qc1xyXG5cclxuVEhSRUUuV2ViR0xTaGFkZXIgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0ZnVuY3Rpb24gYWRkTGluZU51bWJlcnMoIHN0cmluZyApIHtcclxuXHJcblx0XHR2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXG4nICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0bGluZXNbIGkgXSA9ICggaSArIDEgKSArICc6ICcgKyBsaW5lc1sgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGluZXMuam9pbiggJ1xcbicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gV2ViR0xTaGFkZXIoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XHJcblxyXG5cdFx0dmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggdHlwZSApO1xyXG5cclxuXHRcdGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzdHJpbmcgKTtcclxuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIHNoYWRlciApO1xyXG5cclxuXHRcdGlmICggZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU2hhZGVyOiBTaGFkZXIgY291bGRuXFwndCBjb21waWxlLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSAhPT0gJycgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRlcjogZ2wuZ2V0U2hhZGVySW5mb0xvZygpJywgdHlwZSA9PT0gZ2wuVkVSVEVYX1NIQURFUiA/ICd2ZXJ0ZXgnIDogJ2ZyYWdtZW50JywgZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICksIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxyXG5cdFx0Ly8gY29uc29sZS5sb2coIHR5cGUsIGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlYnVnX3NoYWRlcnMnICkuZ2V0VHJhbnNsYXRlZFNoYWRlclNvdXJjZSggc2hhZGVyICkgKTtcclxuXHJcblx0XHRyZXR1cm4gc2hhZGVyO1xyXG5cclxuXHR9O1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTaGFkb3dNYXAuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldlYkdMU2hhZG93TWFwID0gZnVuY3Rpb24gKCBfcmVuZGVyZXIsIF9saWdodHMsIF9vYmplY3RzICkge1xyXG5cclxuXHR2YXIgX2dsID0gX3JlbmRlcmVyLmNvbnRleHQsXHJcblx0X3N0YXRlID0gX3JlbmRlcmVyLnN0YXRlLFxyXG5cdF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcclxuXHRfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXHJcblxyXG5cdF9sb29rVGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRfbGlnaHRQb3NpdGlvbldvcmxkID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHJcblx0X3JlbmRlckxpc3QgPSBbXSxcclxuXHJcblx0X01vcnBoaW5nRmxhZyA9IDEsXHJcblx0X1NraW5uaW5nRmxhZyA9IDIsXHJcblxyXG5cdF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgPSAoIF9Nb3JwaGluZ0ZsYWcgfCBfU2tpbm5pbmdGbGFnICkgKyAxLFxyXG5cclxuXHRfZGVwdGhNYXRlcmlhbHMgPSBuZXcgQXJyYXkoIF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgKSxcclxuXHRfZGlzdGFuY2VNYXRlcmlhbHMgPSBuZXcgQXJyYXkoIF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgKTtcclxuXHJcblx0dmFyIGN1YmVEaXJlY3Rpb25zID0gW1xyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIC0gMSwgMCwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwIClcclxuXHRdO1xyXG5cclxuXHR2YXIgY3ViZVVwcyA9IFtcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApLFx0bmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApXHJcblx0XTtcclxuXHJcblx0dmFyIGN1YmUyRFZpZXdQb3J0cyA9IFtcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3I0KCksIG5ldyBUSFJFRS5WZWN0b3I0KCksIG5ldyBUSFJFRS5WZWN0b3I0KCksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yNCgpLCBuZXcgVEhSRUUuVmVjdG9yNCgpLCBuZXcgVEhSRUUuVmVjdG9yNCgpXHJcblx0XTtcclxuXHJcblx0Ly8gaW5pdFxyXG5cclxuXHR2YXIgZGVwdGhTaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIFwiZGVwdGhSR0JBXCIgXTtcclxuXHR2YXIgZGVwdGhVbmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRlcHRoU2hhZGVyLnVuaWZvcm1zICk7XHJcblxyXG5cdHZhciBkaXN0YW5jZVNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgXCJkaXN0YW5jZVJHQkFcIiBdO1xyXG5cdHZhciBkaXN0YW5jZVVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggZGlzdGFuY2VTaGFkZXIudW5pZm9ybXMgKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzOyArKyBpICkge1xyXG5cclxuXHRcdHZhciB1c2VNb3JwaGluZyA9ICggaSAmIF9Nb3JwaGluZ0ZsYWcgKSAhPT0gMDtcclxuXHRcdHZhciB1c2VTa2lubmluZyA9ICggaSAmIF9Ta2lubmluZ0ZsYWcgKSAhPT0gMDtcclxuXHJcblx0XHR2YXIgZGVwdGhNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xyXG5cdFx0XHR1bmlmb3JtczogZGVwdGhVbmlmb3JtcyxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlcixcclxuXHRcdFx0bW9ycGhUYXJnZXRzOiB1c2VNb3JwaGluZyxcclxuXHRcdFx0c2tpbm5pbmc6IHVzZVNraW5uaW5nXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0ZGVwdGhNYXRlcmlhbC5fc2hhZG93UGFzcyA9IHRydWU7XHJcblxyXG5cdFx0X2RlcHRoTWF0ZXJpYWxzWyBpIF0gPSBkZXB0aE1hdGVyaWFsO1xyXG5cclxuXHRcdHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XHJcblx0XHRcdHVuaWZvcm1zOiBkaXN0YW5jZVVuaWZvcm1zLFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IGRpc3RhbmNlU2hhZGVyLnZlcnRleFNoYWRlcixcclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGRpc3RhbmNlU2hhZGVyLmZyYWdtZW50U2hhZGVyLFxyXG5cdFx0XHRtb3JwaFRhcmdldHM6IHVzZU1vcnBoaW5nLFxyXG5cdFx0XHRza2lubmluZzogdXNlU2tpbm5pbmdcclxuXHRcdH0gKTtcclxuXHJcblx0XHRkaXN0YW5jZU1hdGVyaWFsLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHJcblx0XHRfZGlzdGFuY2VNYXRlcmlhbHNbIGkgXSA9IGRpc3RhbmNlTWF0ZXJpYWw7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0dGhpcy5lbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XHJcblx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnR5cGUgPSBUSFJFRS5QQ0ZTaGFkb3dNYXA7XHJcblx0dGhpcy5jdWxsRmFjZSA9IFRIUkVFLkN1bGxGYWNlRnJvbnQ7XHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdHZhciBmYWNlQ291bnQsIGlzUG9pbnRMaWdodDtcclxuXHJcblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cdFx0aWYgKCBzY29wZS5hdXRvVXBkYXRlID09PSBmYWxzZSAmJiBzY29wZS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0Ly8gU2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXAuXHJcblx0XHRfc3RhdGUuY2xlYXJDb2xvciggMSwgMSwgMSwgMSApO1xyXG5cdFx0X3N0YXRlLmRpc2FibGUoIF9nbC5CTEVORCApO1xyXG5cdFx0X3N0YXRlLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cdFx0X2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xyXG5cdFx0X2dsLmN1bGxGYWNlKCBzY29wZS5jdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCA/IF9nbC5GUk9OVCA6IF9nbC5CQUNLICk7XHJcblx0XHRfc3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XHJcblx0XHRfc3RhdGUuc2V0U2Npc3NvclRlc3QoIGZhbHNlICk7XHJcblxyXG5cdFx0Ly8gcmVuZGVyIGRlcHRoIG1hcFxyXG5cclxuXHRcdHZhciBzaGFkb3dzID0gX2xpZ2h0cy5zaGFkb3dzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzaGFkb3dzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGxpZ2h0ID0gc2hhZG93c1sgaSBdO1xyXG5cclxuXHRcdFx0dmFyIHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcclxuXHRcdFx0dmFyIHNoYWRvd0NhbWVyYSA9IHNoYWRvdy5jYW1lcmE7XHJcblx0XHRcdHZhciBzaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZUNvdW50ID0gNjtcclxuXHRcdFx0XHRpc1BvaW50TGlnaHQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR2YXIgdnBXaWR0aCA9IHNoYWRvd01hcFNpemUueCAvIDQuMDtcclxuXHRcdFx0XHR2YXIgdnBIZWlnaHQgPSBzaGFkb3dNYXBTaXplLnkgLyAyLjA7XHJcblxyXG5cdFx0XHRcdC8vIFRoZXNlIHZpZXdwb3J0cyBtYXAgYSBjdWJlLW1hcCBvbnRvIGEgMkQgdGV4dHVyZSB3aXRoIHRoZVxyXG5cdFx0XHRcdC8vIGZvbGxvd2luZyBvcmllbnRhdGlvbjpcclxuXHRcdFx0XHQvL1xyXG5cdFx0XHRcdC8vICB4elhaXHJcblx0XHRcdFx0Ly8gICB5IFlcclxuXHRcdFx0XHQvL1xyXG5cdFx0XHRcdC8vIFggLSBQb3NpdGl2ZSB4IGRpcmVjdGlvblxyXG5cdFx0XHRcdC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxyXG5cdFx0XHRcdC8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxyXG5cdFx0XHRcdC8vIHkgLSBOZWdhdGl2ZSB5IGRpcmVjdGlvblxyXG5cdFx0XHRcdC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxyXG5cdFx0XHRcdC8vIHogLSBOZWdhdGl2ZSB6IGRpcmVjdGlvblxyXG5cclxuXHRcdFx0XHQvLyBwb3NpdGl2ZSBYXHJcblx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAwIF0uc2V0KCB2cFdpZHRoICogMiwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcblx0XHRcdFx0Ly8gbmVnYXRpdmUgWFxyXG5cdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgMSBdLnNldCggMCwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcblx0XHRcdFx0Ly8gcG9zaXRpdmUgWlxyXG5cdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgMiBdLnNldCggdnBXaWR0aCAqIDMsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xyXG5cdFx0XHRcdC8vIG5lZ2F0aXZlIFpcclxuXHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDMgXS5zZXQoIHZwV2lkdGgsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xyXG5cdFx0XHRcdC8vIHBvc2l0aXZlIFlcclxuXHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDQgXS5zZXQoIHZwV2lkdGggKiAzLCAwLCB2cFdpZHRoLCB2cEhlaWdodCApO1xyXG5cdFx0XHRcdC8vIG5lZ2F0aXZlIFlcclxuXHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDUgXS5zZXQoIHZwV2lkdGgsIDAsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmYWNlQ291bnQgPSAxO1xyXG5cdFx0XHRcdGlzUG9pbnRMaWdodCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBzaGFkb3cubWFwID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcGFycyA9IHsgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLCBmb3JtYXQ6IFRIUkVFLlJHQkFGb3JtYXQgfTtcclxuXHJcblx0XHRcdFx0c2hhZG93Lm1hcCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCggc2hhZG93TWFwU2l6ZS54LCBzaGFkb3dNYXBTaXplLnksIHBhcnMgKTtcclxuXHJcblx0XHRcdFx0Ly9cclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHRzaGFkb3dDYW1lcmEuYXNwZWN0ID0gc2hhZG93TWFwU2l6ZS54IC8gc2hhZG93TWFwU2l6ZS55O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNoYWRvd0NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgc2hhZG93TWFwID0gc2hhZG93Lm1hcDtcclxuXHRcdFx0dmFyIHNoYWRvd01hdHJpeCA9IHNoYWRvdy5tYXRyaXg7XHJcblxyXG5cdFx0XHRfbGlnaHRQb3NpdGlvbldvcmxkLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0c2hhZG93Q2FtZXJhLnBvc2l0aW9uLmNvcHkoIF9saWdodFBvc2l0aW9uV29ybGQgKTtcclxuXHJcblx0XHRcdF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHNoYWRvd01hcCApO1xyXG5cdFx0XHRfcmVuZGVyZXIuY2xlYXIoKTtcclxuXHJcblx0XHRcdC8vIHJlbmRlciBzaGFkb3cgbWFwIGZvciBlYWNoIGN1YmUgZmFjZSAoaWYgb21uaS1kaXJlY3Rpb25hbCkgb3JcclxuXHRcdFx0Ly8gcnVuIGEgc2luZ2xlIHBhc3MgaWYgbm90XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgZmFjZSA9IDA7IGZhY2UgPCBmYWNlQ291bnQ7IGZhY2UgKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggaXNQb2ludExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdF9sb29rVGFyZ2V0LmNvcHkoIHNoYWRvd0NhbWVyYS5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0X2xvb2tUYXJnZXQuYWRkKCBjdWJlRGlyZWN0aW9uc1sgZmFjZSBdICk7XHJcblx0XHRcdFx0XHRzaGFkb3dDYW1lcmEudXAuY29weSggY3ViZVVwc1sgZmFjZSBdICk7XHJcblx0XHRcdFx0XHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xyXG5cclxuXHRcdFx0XHRcdHZhciB2cERpbWVuc2lvbnMgPSBjdWJlMkRWaWV3UG9ydHNbIGZhY2UgXTtcclxuXHRcdFx0XHRcdF9zdGF0ZS52aWV3cG9ydCggdnBEaW1lbnNpb25zICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0X2xvb2tUYXJnZXQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdHNoYWRvd0NhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblx0XHRcdFx0c2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0Ly8gY29tcHV0ZSBzaGFkb3cgbWF0cml4XHJcblxyXG5cdFx0XHRcdHNoYWRvd01hdHJpeC5zZXQoXHJcblx0XHRcdFx0XHQwLjUsIDAuMCwgMC4wLCAwLjUsXHJcblx0XHRcdFx0XHQwLjAsIDAuNSwgMC4wLCAwLjUsXHJcblx0XHRcdFx0XHQwLjAsIDAuMCwgMC41LCAwLjUsXHJcblx0XHRcdFx0XHQwLjAsIDAuMCwgMC4wLCAxLjBcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblx0XHRcdFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG5cdFx0XHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cclxuXHJcblx0XHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHRcdFx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHQvLyBzZXQgb2JqZWN0IG1hdHJpY2VzICYgZnJ1c3R1bSBjdWxsaW5nXHJcblxyXG5cdFx0XHRcdF9yZW5kZXJMaXN0Lmxlbmd0aCA9IDA7XHJcblxyXG5cdFx0XHRcdHByb2plY3RPYmplY3QoIHNjZW5lLCBjYW1lcmEsIHNoYWRvd0NhbWVyYSApO1xyXG5cclxuXHRcdFx0XHQvLyByZW5kZXIgc2hhZG93IG1hcFxyXG5cdFx0XHRcdC8vIHJlbmRlciByZWd1bGFyIG9iamVjdHNcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IF9yZW5kZXJMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBvYmplY3QgPSBfcmVuZGVyTGlzdFsgaiBdO1xyXG5cdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcclxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTXVsdGlNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbHMgPSBtYXRlcmlhbC5tYXRlcmlhbHM7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgayA9IDAsIGtsID0gZ3JvdXBzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGsgXTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsc1sgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgZGVwdGhNYXRlcmlhbCA9IGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgZ3JvdXBNYXRlcmlhbCwgaXNQb2ludExpZ2h0LCBfbGlnaHRQb3NpdGlvbldvcmxkICk7XHJcblx0XHRcdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIF9saWdodFBvc2l0aW9uV29ybGQgKTtcclxuXHRcdFx0XHRcdFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBudWxsLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgb2JqZWN0LCBudWxsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBXZSBtdXN0IGNhbGwgX3JlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpIGF0IHRoZSBlbmQgb2YgZWFjaCBpdGVyYXRpb24gb2ZcclxuXHRcdFx0Ly8gdGhlIGxpZ2h0IGxvb3AgaW4gb3JkZXIgdG8gZm9yY2UgbWF0ZXJpYWwgdXBkYXRlcyBmb3IgZWFjaCBsaWdodC5cclxuXHRcdFx0X3JlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZXN0b3JlIEdMIHN0YXRlLlxyXG5cdFx0dmFyIGNsZWFyQ29sb3IgPSBfcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcigpLFxyXG5cdFx0Y2xlYXJBbHBoYSA9IF9yZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XHJcblx0XHRfcmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApO1xyXG5cclxuXHRcdF9zdGF0ZS5lbmFibGUoIF9nbC5CTEVORCApO1xyXG5cclxuXHRcdGlmICggc2NvcGUuY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XHJcblxyXG5cdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9yZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcclxuXHJcblx0XHRzY29wZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIGxpZ2h0UG9zaXRpb25Xb3JsZCApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdFx0dmFyIG5ld01hdGVyaWFsID0gbnVsbDtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWxWYXJpYW50cyA9IF9kZXB0aE1hdGVyaWFscztcclxuXHRcdHZhciBjdXN0b21NYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsO1xyXG5cclxuXHRcdGlmICggaXNQb2ludExpZ2h0ICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWxWYXJpYW50cyA9IF9kaXN0YW5jZU1hdGVyaWFscztcclxuXHRcdFx0Y3VzdG9tTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGlzdGFuY2VNYXRlcmlhbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAhIGN1c3RvbU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0dmFyIHVzZU1vcnBoaW5nID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiZcclxuXHRcdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICYmIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cztcclxuXHJcblx0XHRcdHZhciB1c2VTa2lubmluZyA9IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICYmIG1hdGVyaWFsLnNraW5uaW5nO1xyXG5cclxuXHRcdFx0dmFyIHZhcmlhbnRJbmRleCA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIHVzZU1vcnBoaW5nICkgdmFyaWFudEluZGV4IHw9IF9Nb3JwaGluZ0ZsYWc7XHJcblx0XHRcdGlmICggdXNlU2tpbm5pbmcgKSB2YXJpYW50SW5kZXggfD0gX1NraW5uaW5nRmxhZztcclxuXHJcblx0XHRcdG5ld01hdGVyaWFsID0gbWF0ZXJpYWxWYXJpYW50c1sgdmFyaWFudEluZGV4IF07XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdG5ld01hdGVyaWFsID0gY3VzdG9tTWF0ZXJpYWw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG5ld01hdGVyaWFsLnZpc2libGUgPSBtYXRlcmlhbC52aXNpYmxlO1xyXG5cdFx0bmV3TWF0ZXJpYWwud2lyZWZyYW1lID0gbWF0ZXJpYWwud2lyZWZyYW1lO1xyXG5cdFx0bmV3TWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cclxuXHRcdGlmICggaXNQb2ludExpZ2h0ICYmIG5ld01hdGVyaWFsLnVuaWZvcm1zLmxpZ2h0UG9zICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRuZXdNYXRlcmlhbC51bmlmb3Jtcy5saWdodFBvcy52YWx1ZS5jb3B5KCBsaWdodFBvc2l0aW9uV29ybGQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ld01hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEgKSB7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0aWYgKCBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKSAmJiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgKSApIHtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LmNhc3RTaGFkb3cgJiYgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgPT09IHRydWUgKSApIHtcclxuXHJcblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdF9yZW5kZXJMaXN0LnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0cHJvamVjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgY2FtZXJhLCBzaGFkb3dDYW1lcmEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTdGF0ZS5qc1xyXG5cclxuLyoqXHJcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuKi9cclxuXHJcblRIUkVFLldlYkdMU3RhdGUgPSBmdW5jdGlvbiAoIGdsLCBleHRlbnNpb25zLCBwYXJhbVRocmVlVG9HTCApIHtcclxuXHJcblx0dmFyIF90aGlzID0gdGhpcztcclxuXHJcblx0dmFyIGNvbG9yID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcblx0dmFyIG5ld0F0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggMTYgKTtcclxuXHR2YXIgZW5hYmxlZEF0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggMTYgKTtcclxuXHR2YXIgYXR0cmlidXRlRGl2aXNvcnMgPSBuZXcgVWludDhBcnJheSggMTYgKTtcclxuXHJcblx0dmFyIGNhcGFiaWxpdGllcyA9IHt9O1xyXG5cclxuXHR2YXIgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gbnVsbDtcclxuXHJcblx0dmFyIGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XHJcblx0dmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcclxuXHR2YXIgY3VycmVudEJsZW5kU3JjID0gbnVsbDtcclxuXHR2YXIgY3VycmVudEJsZW5kRHN0ID0gbnVsbDtcclxuXHR2YXIgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XHJcblx0dmFyIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcclxuXHR2YXIgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xyXG5cclxuXHR2YXIgY3VycmVudERlcHRoRnVuYyA9IG51bGw7XHJcblx0dmFyIGN1cnJlbnREZXB0aFdyaXRlID0gbnVsbDtcclxuXHJcblx0dmFyIGN1cnJlbnRDb2xvcldyaXRlID0gbnVsbDtcclxuXHJcblx0dmFyIGN1cnJlbnRTdGVuY2lsV3JpdGUgPSBudWxsO1xyXG5cdHZhciBjdXJyZW50U3RlbmNpbEZ1bmMgPSBudWxsO1xyXG5cdHZhciBjdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XHJcblx0dmFyIGN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XHJcblx0dmFyIGN1cnJlbnRTdGVuY2lsRmFpbCAgPSBudWxsO1xyXG5cdHZhciBjdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcclxuXHR2YXIgY3VycmVudFN0ZW5jaWxaUGFzcyA9IG51bGw7XHJcblxyXG5cdHZhciBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcclxuXHJcblx0dmFyIGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xyXG5cclxuXHR2YXIgY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsO1xyXG5cdHZhciBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gbnVsbDtcclxuXHJcblx0dmFyIGN1cnJlbnRTY2lzc29yVGVzdCA9IG51bGw7XHJcblxyXG5cdHZhciBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuXHJcblx0dmFyIGN1cnJlbnRUZXh0dXJlU2xvdCA9IHVuZGVmaW5lZDtcclxuXHR2YXIgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcclxuXHJcblx0dmFyIGN1cnJlbnRDbGVhckNvbG9yID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHR2YXIgY3VycmVudENsZWFyRGVwdGggPSBudWxsO1xyXG5cdHZhciBjdXJyZW50Q2xlYXJTdGVuY2lsID0gbnVsbDtcclxuXHJcblx0dmFyIGN1cnJlbnRTY2lzc29yID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHR2YXIgY3VycmVudFZpZXdwb3J0ID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcblx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY2xlYXJDb2xvciggMCwgMCwgMCwgMSApO1xyXG5cdFx0dGhpcy5jbGVhckRlcHRoKCAxICk7XHJcblx0XHR0aGlzLmNsZWFyU3RlbmNpbCggMCApO1xyXG5cclxuXHRcdHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xyXG5cclxuXHRcdGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XHJcblx0XHRnbC5jdWxsRmFjZSggZ2wuQkFDSyApO1xyXG5cdFx0dGhpcy5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xyXG5cclxuXHRcdHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcclxuXHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuaW5pdEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbmV3QXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0bmV3QXR0cmlidXRlc1sgaSBdID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZW5hYmxlQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xyXG5cclxuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xyXG5cdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gMCApIHtcclxuXHJcblx0XHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblxyXG5cdFx0XHRleHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBhdHRyaWJ1dGUsIDAgKTtcclxuXHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciA9IGZ1bmN0aW9uICggYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlLCBleHRlbnNpb24gKSB7XHJcblxyXG5cdFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xyXG5cclxuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xyXG5cdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gbWVzaFBlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSApO1xyXG5cdFx0XHRhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gPSBtZXNoUGVyQXR0cmlidXRlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5kaXNhYmxlVW51c2VkQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBuZXdBdHRyaWJ1dGVzWyBpIF0gKSB7XHJcblxyXG5cdFx0XHRcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xyXG5cdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5lbmFibGUgPSBmdW5jdGlvbiAoIGlkICkge1xyXG5cclxuXHRcdGlmICggY2FwYWJpbGl0aWVzWyBpZCBdICE9PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Z2wuZW5hYmxlKCBpZCApO1xyXG5cdFx0XHRjYXBhYmlsaXRpZXNbIGlkIF0gPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5kaXNhYmxlID0gZnVuY3Rpb24gKCBpZCApIHtcclxuXHJcblx0XHRpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRnbC5kaXNhYmxlKCBpZCApO1xyXG5cdFx0XHRjYXBhYmlsaXRpZXNbIGlkIF0gPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICggY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gW107XHJcblxyXG5cdFx0XHRpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8XHJcblx0XHRcdCAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fFxyXG5cdFx0XHQgICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnICkpIHtcclxuXHJcblx0XHRcdFx0dmFyIGZvcm1hdHMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZvcm1hdHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5wdXNoKCBmb3JtYXRzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldEJsZW5kaW5nID0gZnVuY3Rpb24gKCBibGVuZGluZywgYmxlbmRFcXVhdGlvbiwgYmxlbmRTcmMsIGJsZW5kRHN0LCBibGVuZEVxdWF0aW9uQWxwaGEsIGJsZW5kU3JjQWxwaGEsIGJsZW5kRHN0QWxwaGEgKSB7XHJcblxyXG5cdFx0aWYgKCBibGVuZGluZyA9PT0gVEhSRUUuTm9CbGVuZGluZyApIHtcclxuXHJcblx0XHRcdHRoaXMuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggYmxlbmRpbmcgIT09IGN1cnJlbnRCbGVuZGluZyApIHtcclxuXHJcblx0XHRcdGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XHJcblx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxyXG5cclxuXHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk11bHRpcGx5QmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxyXG5cclxuXHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkN1c3RvbUJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0YmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhIHx8IGJsZW5kRXF1YXRpb247XHJcblx0XHRcdGJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhIHx8IGJsZW5kU3JjO1xyXG5cdFx0XHRibGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYSB8fCBibGVuZERzdDtcclxuXHJcblx0XHRcdGlmICggYmxlbmRFcXVhdGlvbiAhPT0gY3VycmVudEJsZW5kRXF1YXRpb24gfHwgYmxlbmRFcXVhdGlvbkFscGhhICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhICkge1xyXG5cclxuXHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIHBhcmFtVGhyZWVUb0dMKCBibGVuZEVxdWF0aW9uICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZEVxdWF0aW9uQWxwaGEgKSApO1xyXG5cclxuXHRcdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IGJsZW5kRXF1YXRpb247XHJcblx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggYmxlbmRTcmMgIT09IGN1cnJlbnRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gY3VycmVudEJsZW5kRHN0IHx8IGJsZW5kU3JjQWxwaGEgIT09IGN1cnJlbnRCbGVuZFNyY0FscGhhIHx8IGJsZW5kRHN0QWxwaGEgIT09IGN1cnJlbnRCbGVuZERzdEFscGhhICkge1xyXG5cclxuXHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZERzdCApLCBwYXJhbVRocmVlVG9HTCggYmxlbmRTcmNBbHBoYSApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3RBbHBoYSApICk7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRCbGVuZFNyYyA9IGJsZW5kU3JjO1xyXG5cdFx0XHRcdGN1cnJlbnRCbGVuZERzdCA9IGJsZW5kRHN0O1xyXG5cdFx0XHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcclxuXHRcdFx0XHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcclxuXHRcdFx0Y3VycmVudEJsZW5kU3JjID0gbnVsbDtcclxuXHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gbnVsbDtcclxuXHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XHJcblx0XHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcclxuXHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXREZXB0aEZ1bmMgPSBmdW5jdGlvbiAoIGRlcHRoRnVuYyApIHtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnREZXB0aEZ1bmMgIT09IGRlcHRoRnVuYyApIHtcclxuXHJcblx0XHRcdGlmICggZGVwdGhGdW5jICkge1xyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCBkZXB0aEZ1bmMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5OZXZlckRlcHRoOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5ORVZFUiApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFRIUkVFLkFsd2F5c0RlcHRoOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5BTFdBWVMgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5MZXNzRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFU1MgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5MZXNzRXF1YWxEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuRXF1YWxEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuRVFVQUwgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5HcmVhdGVyRXF1YWxEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuR0VRVUFMICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuR3JlYXRlckRlcHRoOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5HUkVBVEVSICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuTm90RXF1YWxEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTk9URVFVQUwgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjdXJyZW50RGVwdGhGdW5jID0gZGVwdGhGdW5jO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXREZXB0aFRlc3QgPSBmdW5jdGlvbiAoIGRlcHRoVGVzdCApIHtcclxuXHJcblx0XHRpZiAoIGRlcHRoVGVzdCApIHtcclxuXHJcblx0XHRcdHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXREZXB0aFdyaXRlID0gZnVuY3Rpb24gKCBkZXB0aFdyaXRlICkge1xyXG5cclxuXHRcdC8vIFRPRE86IFJlbmFtZSB0byBzZXREZXB0aE1hc2tcclxuXHJcblx0XHRpZiAoIGN1cnJlbnREZXB0aFdyaXRlICE9PSBkZXB0aFdyaXRlICkge1xyXG5cclxuXHRcdFx0Z2wuZGVwdGhNYXNrKCBkZXB0aFdyaXRlICk7XHJcblx0XHRcdGN1cnJlbnREZXB0aFdyaXRlID0gZGVwdGhXcml0ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0Q29sb3JXcml0ZSA9IGZ1bmN0aW9uICggY29sb3JXcml0ZSApIHtcclxuXHJcblx0XHQvLyBUT0RPOiBSZW5hbWUgdG8gc2V0Q29sb3JNYXNrXHJcblxyXG5cdFx0aWYgKCBjdXJyZW50Q29sb3JXcml0ZSAhPT0gY29sb3JXcml0ZSApIHtcclxuXHJcblx0XHRcdGdsLmNvbG9yTWFzayggY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSApO1xyXG5cdFx0XHRjdXJyZW50Q29sb3JXcml0ZSA9IGNvbG9yV3JpdGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldFN0ZW5jaWxGdW5jID0gZnVuY3Rpb24gKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50U3RlbmNpbEZ1bmMgIT09IHN0ZW5jaWxGdW5jIHx8XHJcblx0XHRcdFx0IGN1cnJlbnRTdGVuY2lsUmVmIFx0IT09IHN0ZW5jaWxSZWYgXHR8fFxyXG5cdFx0XHRcdCBjdXJyZW50U3RlbmNpbE1hc2sgIT09IHN0ZW5jaWxNYXNrICkge1xyXG5cclxuXHRcdFx0Z2wuc3RlbmNpbEZ1bmMoIHN0ZW5jaWxGdW5jLCAgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKTtcclxuXHJcblx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IHN0ZW5jaWxGdW5jO1xyXG5cdFx0XHRjdXJyZW50U3RlbmNpbFJlZiAgPSBzdGVuY2lsUmVmO1xyXG5cdFx0XHRjdXJyZW50U3RlbmNpbE1hc2sgPSBzdGVuY2lsTWFzaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0U3RlbmNpbE9wID0gZnVuY3Rpb24gKCBzdGVuY2lsRmFpbCwgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50U3RlbmNpbEZhaWxcdCAhPT0gc3RlbmNpbEZhaWwgXHR8fFxyXG5cdFx0XHRcdCBjdXJyZW50U3RlbmNpbFpGYWlsICE9PSBzdGVuY2lsWkZhaWwgfHxcclxuXHRcdFx0XHQgY3VycmVudFN0ZW5jaWxaUGFzcyAhPT0gc3RlbmNpbFpQYXNzICkge1xyXG5cclxuXHRcdFx0Z2wuc3RlbmNpbE9wKCBzdGVuY2lsRmFpbCwgIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICk7XHJcblxyXG5cdFx0XHRjdXJyZW50U3RlbmNpbEZhaWwgID0gc3RlbmNpbEZhaWw7XHJcblx0XHRcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBzdGVuY2lsWkZhaWw7XHJcblx0XHRcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBzdGVuY2lsWlBhc3M7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldFN0ZW5jaWxUZXN0ID0gZnVuY3Rpb24gKCBzdGVuY2lsVGVzdCApIHtcclxuXHJcblx0XHRpZiAoIHN0ZW5jaWxUZXN0ICkge1xyXG5cclxuXHRcdFx0dGhpcy5lbmFibGUoIGdsLlNURU5DSUxfVEVTVCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpc2FibGUoIGdsLlNURU5DSUxfVEVTVCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRTdGVuY2lsV3JpdGUgPSBmdW5jdGlvbiAoIHN0ZW5jaWxXcml0ZSApIHtcclxuXHJcblx0XHQvLyBUT0RPOiBSZW5hbWUgdG8gc2V0U3RlbmNpbE1hc2tcclxuXHJcblx0XHRpZiAoIGN1cnJlbnRTdGVuY2lsV3JpdGUgIT09IHN0ZW5jaWxXcml0ZSApIHtcclxuXHJcblx0XHRcdGdsLnN0ZW5jaWxNYXNrKCBzdGVuY2lsV3JpdGUgKTtcclxuXHRcdFx0Y3VycmVudFN0ZW5jaWxXcml0ZSA9IHN0ZW5jaWxXcml0ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0RmxpcFNpZGVkID0gZnVuY3Rpb24gKCBmbGlwU2lkZWQgKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGZsaXBTaWRlZCApIHtcclxuXHJcblx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DVyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGN1cnJlbnRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldExpbmVXaWR0aCA9IGZ1bmN0aW9uICggd2lkdGggKSB7XHJcblxyXG5cdFx0aWYgKCB3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCApIHtcclxuXHJcblx0XHRcdGdsLmxpbmVXaWR0aCggd2lkdGggKTtcclxuXHJcblx0XHRcdGN1cnJlbnRMaW5lV2lkdGggPSB3aWR0aDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0UG9seWdvbk9mZnNldCA9IGZ1bmN0aW9uICggcG9seWdvbk9mZnNldCwgZmFjdG9yLCB1bml0cyApIHtcclxuXHJcblx0XHRpZiAoIHBvbHlnb25PZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmVuYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpc2FibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwb2x5Z29uT2Zmc2V0ICYmICggY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgIT09IGZhY3RvciB8fCBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzICE9PSB1bml0cyApICkge1xyXG5cclxuXHRcdFx0Z2wucG9seWdvbk9mZnNldCggZmFjdG9yLCB1bml0cyApO1xyXG5cclxuXHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XHJcblx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIGN1cnJlbnRTY2lzc29yVGVzdDtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggc2Npc3NvclRlc3QgKSB7XHJcblxyXG5cdFx0Y3VycmVudFNjaXNzb3JUZXN0ID0gc2Npc3NvclRlc3Q7XHJcblxyXG5cdFx0aWYgKCBzY2lzc29yVGVzdCApIHtcclxuXHJcblx0XHRcdHRoaXMuZW5hYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5kaXNhYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIHRleHR1cmVcclxuXHJcblx0dGhpcy5hY3RpdmVUZXh0dXJlID0gZnVuY3Rpb24gKCB3ZWJnbFNsb3QgKSB7XHJcblxyXG5cdFx0aWYgKCB3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCApIHdlYmdsU2xvdCA9IGdsLlRFWFRVUkUwICsgbWF4VGV4dHVyZXMgLSAxO1xyXG5cclxuXHRcdGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XHJcblxyXG5cdFx0XHRnbC5hY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKTtcclxuXHRcdFx0Y3VycmVudFRleHR1cmVTbG90ID0gd2ViZ2xTbG90O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5iaW5kVGV4dHVyZSA9IGZ1bmN0aW9uICggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdF90aGlzLmFjdGl2ZVRleHR1cmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXTtcclxuXHJcblx0XHRpZiAoIGJvdW5kVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ym91bmRUZXh0dXJlID0geyB0eXBlOiB1bmRlZmluZWQsIHRleHR1cmU6IHVuZGVmaW5lZCB9O1xyXG5cdFx0XHRjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF0gPSBib3VuZFRleHR1cmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggYm91bmRUZXh0dXJlLnR5cGUgIT09IHdlYmdsVHlwZSB8fCBib3VuZFRleHR1cmUudGV4dHVyZSAhPT0gd2ViZ2xUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0Z2wuYmluZFRleHR1cmUoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0XHRib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcclxuXHRcdFx0Ym91bmRUZXh0dXJlLnRleHR1cmUgPSB3ZWJnbFRleHR1cmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNvbXByZXNzZWRUZXhJbWFnZTJEID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRyeSB7XHJcblxyXG5cdFx0XHRnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xyXG5cclxuXHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnRleEltYWdlMkQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHJcblx0XHRcdGdsLnRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcclxuXHJcblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBlcnJvciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gY2xlYXIgdmFsdWVzXHJcblxyXG5cdHRoaXMuY2xlYXJDb2xvciA9IGZ1bmN0aW9uICggciwgZywgYiwgYSApIHtcclxuXHJcblx0XHRjb2xvci5zZXQoIHIsIGcsIGIsIGEgKTtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnRDbGVhckNvbG9yLmVxdWFscyggY29sb3IgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRnbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XHJcblx0XHRcdGN1cnJlbnRDbGVhckNvbG9yLmNvcHkoIGNvbG9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNsZWFyRGVwdGggPSBmdW5jdGlvbiAoIGRlcHRoICkge1xyXG5cclxuXHRcdGlmICggY3VycmVudENsZWFyRGVwdGggIT09IGRlcHRoICkge1xyXG5cclxuXHRcdFx0Z2wuY2xlYXJEZXB0aCggZGVwdGggKTtcclxuXHRcdFx0Y3VycmVudENsZWFyRGVwdGggPSBkZXB0aDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24gKCBzdGVuY2lsICkge1xyXG5cclxuXHRcdGlmICggY3VycmVudENsZWFyU3RlbmNpbCAhPT0gc3RlbmNpbCApIHtcclxuXHJcblx0XHRcdGdsLmNsZWFyU3RlbmNpbCggc3RlbmNpbCApO1xyXG5cdFx0XHRjdXJyZW50Q2xlYXJTdGVuY2lsID0gc3RlbmNpbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMuc2Npc3NvciA9IGZ1bmN0aW9uICggc2Npc3NvciApIHtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnRTY2lzc29yLmVxdWFscyggc2Npc3NvciApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGdsLnNjaXNzb3IoIHNjaXNzb3IueCwgc2Npc3Nvci55LCBzY2lzc29yLnosIHNjaXNzb3IudyApO1xyXG5cdFx0XHRjdXJyZW50U2Npc3Nvci5jb3B5KCBzY2lzc29yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnZpZXdwb3J0ID0gZnVuY3Rpb24gKCB2aWV3cG9ydCApIHtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnRWaWV3cG9ydC5lcXVhbHMoIHZpZXdwb3J0ICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Z2wudmlld3BvcnQoIHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LnosIHZpZXdwb3J0LncgKTtcclxuXHRcdFx0Y3VycmVudFZpZXdwb3J0LmNvcHkoIHZpZXdwb3J0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0Z2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XHJcblx0XHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNhcGFiaWxpdGllcyA9IHt9O1xyXG5cclxuXHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XHJcblxyXG5cdFx0Y3VycmVudEJsZW5kaW5nID0gbnVsbDtcclxuXHJcblx0XHRjdXJyZW50Q29sb3JXcml0ZSA9IG51bGw7XHJcblx0XHRjdXJyZW50RGVwdGhXcml0ZSA9IG51bGw7XHJcblx0XHRjdXJyZW50U3RlbmNpbFdyaXRlID0gbnVsbDtcclxuXHJcblx0XHRjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvcGx1Z2lucy9MZW5zRmxhcmVQbHVnaW4uanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxlbnNGbGFyZVBsdWdpbiA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIGZsYXJlcyApIHtcclxuXHJcblx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcclxuXHR2YXIgc3RhdGUgPSByZW5kZXJlci5zdGF0ZTtcclxuXHJcblx0dmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcclxuXHR2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XHJcblx0dmFyIGhhc1ZlcnRleFRleHR1cmU7XHJcblxyXG5cdHZhciB0ZW1wVGV4dHVyZSwgb2NjbHVzaW9uVGV4dHVyZTtcclxuXHJcblx0ZnVuY3Rpb24gaW5pdCgpIHtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXHJcblx0XHRcdC0gMSwgLSAxLCAgMCwgMCxcclxuXHRcdFx0IDEsIC0gMSwgIDEsIDAsXHJcblx0XHRcdCAxLCAgMSwgIDEsIDEsXHJcblx0XHRcdC0gMSwgIDEsICAwLCAxXHJcblx0XHRdICk7XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXHJcblx0XHRcdDAsIDEsIDIsXHJcblx0XHRcdDAsIDIsIDNcclxuXHRcdF0gKTtcclxuXHJcblx0XHQvLyBidWZmZXJzXHJcblxyXG5cdFx0dmVydGV4QnVmZmVyICAgICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0ZWxlbWVudEJ1ZmZlciAgICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XHJcblx0XHRnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XHJcblx0XHRnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XHJcblxyXG5cdFx0Ly8gdGV4dHVyZXNcclxuXHJcblx0XHR0ZW1wVGV4dHVyZSAgICAgID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cdFx0b2NjbHVzaW9uVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcclxuXHRcdGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgMTYsIDE2LCAwLCBnbC5SR0IsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcclxuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcclxuXHJcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xyXG5cdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMTYsIDE2LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcclxuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xyXG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XHJcblxyXG5cdFx0aGFzVmVydGV4VGV4dHVyZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICkgPiAwO1xyXG5cclxuXHRcdHZhciBzaGFkZXI7XHJcblxyXG5cdFx0aWYgKCBoYXNWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0c2hhZGVyID0ge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcclxuXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcIixcclxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuXHRcdFx0XHRcdFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcclxuXHJcblx0XHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidlVWID0gdXY7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImlmICggcmVuZGVyVHlwZSA9PSAyICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInZlYzQgdmlzaWJpbGl0eSA9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuMSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuMSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuOSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuOSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuNSApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgPSAgICAgICAgdmlzaWJpbGl0eS5yIC8gOS4wO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5nIC8gOS4wO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gICAgICAgdmlzaWJpbGl0eS5iIC8gOS4wO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5hIC8gOS4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwifVwiXHJcblxyXG5cdFx0XHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdFx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcclxuXHJcblx0XHRcdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXHJcblx0XHRcdFx0XHRcInZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBwaW5rIHNxdWFyZVxyXG5cclxuXHRcdFx0XHRcdFx0XCJpZiAoIHJlbmRlclR5cGUgPT0gMCApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMS4wLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJlc3RvcmVcclxuXHJcblx0XHRcdFx0XHRcdFwifSBlbHNlIGlmICggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIGZsYXJlXHJcblxyXG5cdFx0XHRcdFx0XHRcIn0gZWxzZSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwidmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2VmlzaWJpbGl0eTtcIixcclxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ9XCJcclxuXHJcblx0XHRcdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHNoYWRlciA9IHtcclxuXHJcblx0XHRcdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247XCIsXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMiBzY2FsZTtcIixcclxuXHRcdFx0XHRcdFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcclxuXHJcblx0XHRcdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZVViA9IHV2O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMyIHBvcyA9IHBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJpZiAoIHJlbmRlclR5cGUgPT0gMiApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJwb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHZlYzQoICggcG9zICogc2NhbGUgKyBzY3JlZW5Qb3NpdGlvbi54eSApLnh5LCBzY3JlZW5Qb3NpdGlvbi56LCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIn1cIlxyXG5cclxuXHRcdFx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFx0XHRcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuXHJcblx0XHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIHBpbmsgc3F1YXJlXHJcblxyXG5cdFx0XHRcdFx0XHRcImlmICggcmVuZGVyVHlwZSA9PSAwICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIHRleHR1cmUyRCggbWFwLCB2VVYgKS5yZ2IsIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcmVzdG9yZVxyXG5cclxuXHRcdFx0XHRcdFx0XCJ9IGVsc2UgaWYgKCByZW5kZXJUeXBlID09IDEgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gZmxhcmVcclxuXHJcblx0XHRcdFx0XHRcdFwifSBlbHNlIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKS5hO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApLmE7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICkuYTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKS5hO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSA9ICggMS4wIC0gdmlzaWJpbGl0eSAvIDQuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInRleHR1cmUuYSAqPSBvcGFjaXR5ICogdmlzaWJpbGl0eTtcIixcclxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ9XCJcclxuXHJcblx0XHRcdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCBzaGFkZXIgKTtcclxuXHJcblx0XHRhdHRyaWJ1dGVzID0ge1xyXG5cdFx0XHR2ZXJ0ZXg6IGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgXCJwb3NpdGlvblwiICksXHJcblx0XHRcdHV2OiAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCBcInV2XCIgKVxyXG5cdFx0fTtcclxuXHJcblx0XHR1bmlmb3JtcyA9IHtcclxuXHRcdFx0cmVuZGVyVHlwZTogICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyZW5kZXJUeXBlXCIgKSxcclxuXHRcdFx0bWFwOiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJtYXBcIiApLFxyXG5cdFx0XHRvY2NsdXNpb25NYXA6ICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm9jY2x1c2lvbk1hcFwiICksXHJcblx0XHRcdG9wYWNpdHk6ICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib3BhY2l0eVwiICksXHJcblx0XHRcdGNvbG9yOiAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwiY29sb3JcIiApLFxyXG5cdFx0XHRzY2FsZTogICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjYWxlXCIgKSxcclxuXHRcdFx0cm90YXRpb246ICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyb3RhdGlvblwiICksXHJcblx0XHRcdHNjcmVlblBvc2l0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NyZWVuUG9zaXRpb25cIiApXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qXHJcblx0ICogUmVuZGVyIGxlbnMgZmxhcmVzXHJcblx0ICogTWV0aG9kOiByZW5kZXJzIDE2eDE2IDB4ZmYwMGZmLWNvbG9yZWQgcG9pbnRzIHNjYXR0ZXJlZCBvdmVyIHRoZSBsaWdodCBzb3VyY2UgYXJlYSxcclxuXHQgKiAgICAgICAgIHJlYWRzIHRoZXNlIGJhY2sgYW5kIGNhbGN1bGF0ZXMgb2NjbHVzaW9uLlxyXG5cdCAqL1xyXG5cclxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgdmlld3BvcnQgKSB7XHJcblxyXG5cdFx0aWYgKCBmbGFyZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xyXG5cclxuXHRcdHZhciB0ZW1wUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHZhciBpbnZBc3BlY3QgPSB2aWV3cG9ydC53IC8gdmlld3BvcnQueixcclxuXHRcdFx0aGFsZlZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydC56ICogMC41LFxyXG5cdFx0XHRoYWxmVmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydC53ICogMC41O1xyXG5cclxuXHRcdHZhciBzaXplID0gMTYgLyB2aWV3cG9ydC53LFxyXG5cdFx0XHRzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XHJcblxyXG5cdFx0dmFyIHNjcmVlblBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDAgKSxcclxuXHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aW5pdCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcclxuXHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy52ZXJ0ZXggKTtcclxuXHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xyXG5cdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHQvLyBsb29wIHRocm91Z2ggYWxsIGxlbnMgZmxhcmVzIHRvIHVwZGF0ZSB0aGVpciBvY2NsdXNpb24gYW5kIHBvc2l0aW9uc1xyXG5cdFx0Ly8gc2V0dXAgZ2wgYW5kIGNvbW1vbiB1c2VkIGF0dHJpYnMvdW5pZm9ybXNcclxuXHJcblx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm9jY2x1c2lvbk1hcCwgMCApO1xyXG5cdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDEgKTtcclxuXHJcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xyXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy52ZXJ0ZXgsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcclxuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcclxuXHJcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xyXG5cclxuXHRcdHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xyXG5cdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggZmFsc2UgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmbGFyZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHNpemUgPSAxNiAvIHZpZXdwb3J0Lnc7XHJcblx0XHRcdHNjYWxlLnNldCggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xyXG5cclxuXHRcdFx0Ly8gY2FsYyBvYmplY3Qgc2NyZWVuIHBvc2l0aW9uXHJcblxyXG5cdFx0XHR2YXIgZmxhcmUgPSBmbGFyZXNbIGkgXTtcclxuXHJcblx0XHRcdHRlbXBQb3NpdGlvbi5zZXQoIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMiBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTMgXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDE0IF0gKTtcclxuXHJcblx0XHRcdHRlbXBQb3NpdGlvbi5hcHBseU1hdHJpeDQoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHRcdFx0dGVtcFBvc2l0aW9uLmFwcGx5UHJvamVjdGlvbiggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRcdC8vIHNldHVwIGFycmF5cyBmb3IgZ2wgcHJvZ3JhbXNcclxuXHJcblx0XHRcdHNjcmVlblBvc2l0aW9uLmNvcHkoIHRlbXBQb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA9IHNjcmVlblBvc2l0aW9uLnggKiBoYWxmVmlld3BvcnRXaWR0aCArIGhhbGZWaWV3cG9ydFdpZHRoO1xyXG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy55ID0gc2NyZWVuUG9zaXRpb24ueSAqIGhhbGZWaWV3cG9ydEhlaWdodCArIGhhbGZWaWV3cG9ydEhlaWdodDtcclxuXHJcblx0XHRcdC8vIHNjcmVlbiBjdWxsXHJcblxyXG5cdFx0XHRpZiAoIGhhc1ZlcnRleFRleHR1cmUgfHwgKFxyXG5cdFx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPiAwICYmXHJcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA8IHZpZXdwb3J0LnogJiZcclxuXHRcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy55ID4gMCAmJlxyXG5cdFx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPCB2aWV3cG9ydC53ICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHNhdmUgY3VycmVudCBSR0IgdG8gdGVtcCB0ZXh0dXJlXHJcblxyXG5cdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XHJcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcclxuXHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xyXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xyXG5cdFx0XHRcdGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIHZpZXdwb3J0LnggKyBzY3JlZW5Qb3NpdGlvblBpeGVscy54IC0gOCwgdmlld3BvcnQueSArIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcclxuXHJcblxyXG5cdFx0XHRcdC8vIHJlbmRlciBwaW5rIHF1YWRcclxuXHJcblx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAwICk7XHJcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xyXG5cdFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcclxuXHJcblx0XHRcdFx0c3RhdGUuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHRcdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHJcblx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG5cclxuXHRcdFx0XHQvLyBjb3B5IHJlc3VsdCB0byBvY2NsdXNpb25NYXBcclxuXHJcblx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcclxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xyXG5cdFx0XHRcdGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB2aWV3cG9ydC54ICsgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHZpZXdwb3J0LnkgKyBzY3JlZW5Qb3NpdGlvblBpeGVscy55IC0gOCwgMTYsIDE2LCAwICk7XHJcblxyXG5cclxuXHRcdFx0XHQvLyByZXN0b3JlIGdyYXBoaWNzXHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMSApO1xyXG5cdFx0XHRcdHN0YXRlLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHJcblx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTEgKTtcclxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcclxuXHRcdFx0XHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcblxyXG5cdFx0XHRcdC8vIHVwZGF0ZSBvYmplY3QgcG9zaXRpb25zXHJcblxyXG5cdFx0XHRcdGZsYXJlLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNjcmVlblBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRcdGlmICggZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2soIGZsYXJlICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0ZmxhcmUudXBkYXRlTGVuc0ZsYXJlcygpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHJlbmRlciBmbGFyZXNcclxuXHJcblx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAyICk7XHJcblx0XHRcdFx0c3RhdGUuZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmxhcmUubGVuc0ZsYXJlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc3ByaXRlID0gZmxhcmUubGVuc0ZsYXJlc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggc3ByaXRlLm9wYWNpdHkgPiAwLjAwMSAmJiBzcHJpdGUuc2NhbGUgPiAwLjAwMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnggPSBzcHJpdGUueDtcclxuXHRcdFx0XHRcdFx0c2NyZWVuUG9zaXRpb24ueSA9IHNwcml0ZS55O1xyXG5cdFx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi56ID0gc3ByaXRlLno7XHJcblxyXG5cdFx0XHRcdFx0XHRzaXplID0gc3ByaXRlLnNpemUgKiBzcHJpdGUuc2NhbGUgLyB2aWV3cG9ydC53O1xyXG5cclxuXHRcdFx0XHRcdFx0c2NhbGUueCA9IHNpemUgKiBpbnZBc3BlY3Q7XHJcblx0XHRcdFx0XHRcdHNjYWxlLnkgPSBzaXplO1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xyXG5cdFx0XHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZS54LCBzY2FsZS55ICk7XHJcblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIHNwcml0ZS5yb3RhdGlvbiApO1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBzcHJpdGUub3BhY2l0eSApO1xyXG5cdFx0XHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBzcHJpdGUuY29sb3Iuciwgc3ByaXRlLmNvbG9yLmcsIHNwcml0ZS5jb2xvci5iICk7XHJcblxyXG5cdFx0XHRcdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggc3ByaXRlLmJsZW5kaW5nLCBzcHJpdGUuYmxlbmRFcXVhdGlvbiwgc3ByaXRlLmJsZW5kU3JjLCBzcHJpdGUuYmxlbmREc3QgKTtcclxuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggc3ByaXRlLnRleHR1cmUsIDEgKTtcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXN0b3JlIGdsXHJcblxyXG5cdFx0c3RhdGUuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuXHRcdHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggdHJ1ZSApO1xyXG5cclxuXHRcdHJlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVQcm9ncmFtICggc2hhZGVyICkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRcdHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XHJcblx0XHR2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XHJcblxyXG5cdFx0dmFyIHByZWZpeCA9IFwicHJlY2lzaW9uIFwiICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyBcIiBmbG9hdDtcXG5cIjtcclxuXHJcblx0XHRnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdGdsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIudmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xyXG5cclxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcblx0XHRyZXR1cm4gcHJvZ3JhbTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9wbHVnaW5zL1Nwcml0ZVBsdWdpbi5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlUGx1Z2luID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc3ByaXRlcyApIHtcclxuXHJcblx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcclxuXHR2YXIgc3RhdGUgPSByZW5kZXJlci5zdGF0ZTtcclxuXHJcblx0dmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcclxuXHR2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XHJcblxyXG5cdHZhciB0ZXh0dXJlO1xyXG5cclxuXHQvLyBkZWNvbXBvc2UgbWF0cml4V29ybGRcclxuXHJcblx0dmFyIHNwcml0ZVBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgc3ByaXRlUm90YXRpb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cdHZhciBzcHJpdGVTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdGZ1bmN0aW9uIGluaXQoKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xyXG5cdFx0XHQtIDAuNSwgLSAwLjUsICAwLCAwLFxyXG5cdFx0XHQgIDAuNSwgLSAwLjUsICAxLCAwLFxyXG5cdFx0XHQgIDAuNSwgICAwLjUsICAxLCAxLFxyXG5cdFx0XHQtIDAuNSwgICAwLjUsICAwLCAxXHJcblx0XHRdICk7XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXHJcblx0XHRcdDAsIDEsIDIsXHJcblx0XHRcdDAsIDIsIDNcclxuXHRcdF0gKTtcclxuXHJcblx0XHR2ZXJ0ZXhCdWZmZXIgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRlbGVtZW50QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XHJcblxyXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcclxuXHJcblx0XHRwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRcdGF0dHJpYnV0ZXMgPSB7XHJcblx0XHRcdHBvc2l0aW9uOlx0XHRcdGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgJ3Bvc2l0aW9uJyApLFxyXG5cdFx0XHR1djpcdFx0XHRcdFx0Z2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCAndXYnIClcclxuXHRcdH07XHJcblxyXG5cdFx0dW5pZm9ybXMgPSB7XHJcblx0XHRcdHV2T2Zmc2V0Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2T2Zmc2V0JyApLFxyXG5cdFx0XHR1dlNjYWxlOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2U2NhbGUnICksXHJcblxyXG5cdFx0XHRyb3RhdGlvbjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdyb3RhdGlvbicgKSxcclxuXHRcdFx0c2NhbGU6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdzY2FsZScgKSxcclxuXHJcblx0XHRcdGNvbG9yOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnY29sb3InICksXHJcblx0XHRcdG1hcDpcdFx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21hcCcgKSxcclxuXHRcdFx0b3BhY2l0eTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvcGFjaXR5JyApLFxyXG5cclxuXHRcdFx0bW9kZWxWaWV3TWF0cml4OiBcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21vZGVsVmlld01hdHJpeCcgKSxcclxuXHRcdFx0cHJvamVjdGlvbk1hdHJpeDpcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3Byb2plY3Rpb25NYXRyaXgnICksXHJcblxyXG5cdFx0XHRmb2dUeXBlOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ1R5cGUnICksXHJcblx0XHRcdGZvZ0RlbnNpdHk6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRGVuc2l0eScgKSxcclxuXHRcdFx0Zm9nTmVhcjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dOZWFyJyApLFxyXG5cdFx0XHRmb2dGYXI6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dGYXInICksXHJcblx0XHRcdGZvZ0NvbG9yOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0NvbG9yJyApLFxyXG5cclxuXHRcdFx0YWxwaGFUZXN0Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2FscGhhVGVzdCcgKVxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcclxuXHRcdGNhbnZhcy53aWR0aCA9IDg7XHJcblx0XHRjYW52YXMuaGVpZ2h0ID0gODtcclxuXHJcblx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XHJcblx0XHRjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XHJcblx0XHRjb250ZXh0LmZpbGxSZWN0KCAwLCAwLCA4LCA4ICk7XHJcblxyXG5cdFx0dGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCBjYW52YXMgKTtcclxuXHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdGlmICggc3ByaXRlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XHJcblxyXG5cdFx0Ly8gc2V0dXAgZ2xcclxuXHJcblx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGluaXQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2wudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuXHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XHJcblx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcclxuXHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xyXG5cdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHRzdGF0ZS5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuXHRcdHN0YXRlLmVuYWJsZSggZ2wuQkxFTkQgKTtcclxuXHJcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xyXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xyXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XHJcblxyXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcclxuXHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAwICk7XHJcblxyXG5cdFx0dmFyIG9sZEZvZ1R5cGUgPSAwO1xyXG5cdFx0dmFyIHNjZW5lRm9nVHlwZSA9IDA7XHJcblx0XHR2YXIgZm9nID0gc2NlbmUuZm9nO1xyXG5cclxuXHRcdGlmICggZm9nICkge1xyXG5cclxuXHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5mb2dDb2xvciwgZm9nLmNvbG9yLnIsIGZvZy5jb2xvci5nLCBmb2cuY29sb3IuYiApO1xyXG5cclxuXHRcdFx0aWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2cgKSB7XHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nTmVhciwgZm9nLm5lYXIgKTtcclxuXHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0ZhciwgZm9nLmZhciApO1xyXG5cclxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDEgKTtcclxuXHRcdFx0XHRvbGRGb2dUeXBlID0gMTtcclxuXHRcdFx0XHRzY2VuZUZvZ1R5cGUgPSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMiApIHtcclxuXHJcblx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDIgKTtcclxuXHRcdFx0XHRvbGRGb2dUeXBlID0gMjtcclxuXHRcdFx0XHRzY2VuZUZvZ1R5cGUgPSAyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDAgKTtcclxuXHRcdFx0b2xkRm9nVHlwZSA9IDA7XHJcblx0XHRcdHNjZW5lRm9nVHlwZSA9IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyB1cGRhdGUgcG9zaXRpb25zIGFuZCBzb3J0XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcclxuXHJcblx0XHRcdHNwcml0ZS5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgc3ByaXRlLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdHNwcml0ZS56ID0gLSBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzWyAxNCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzcHJpdGVzLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XHJcblxyXG5cdFx0Ly8gcmVuZGVyIGFsbCBzcHJpdGVzXHJcblxyXG5cdFx0dmFyIHNjYWxlID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcclxuXHRcdFx0dmFyIG1hdGVyaWFsID0gc3ByaXRlLm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5hbHBoYVRlc3QsIG1hdGVyaWFsLmFscGhhVGVzdCApO1xyXG5cdFx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHRzcHJpdGUubWF0cml4V29ybGQuZGVjb21wb3NlKCBzcHJpdGVQb3NpdGlvbiwgc3ByaXRlUm90YXRpb24sIHNwcml0ZVNjYWxlICk7XHJcblxyXG5cdFx0XHRzY2FsZVsgMCBdID0gc3ByaXRlU2NhbGUueDtcclxuXHRcdFx0c2NhbGVbIDEgXSA9IHNwcml0ZVNjYWxlLnk7XHJcblxyXG5cdFx0XHR2YXIgZm9nVHlwZSA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIHNjZW5lLmZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XHJcblxyXG5cdFx0XHRcdGZvZ1R5cGUgPSBzY2VuZUZvZ1R5cGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9sZEZvZ1R5cGUgIT09IGZvZ1R5cGUgKSB7XHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgZm9nVHlwZSApO1xyXG5cdFx0XHRcdG9sZEZvZ1R5cGUgPSBmb2dUeXBlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZPZmZzZXQsIG1hdGVyaWFsLm1hcC5vZmZzZXQueCwgbWF0ZXJpYWwubWFwLm9mZnNldC55ICk7XHJcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCBtYXRlcmlhbC5tYXAucmVwZWF0LngsIG1hdGVyaWFsLm1hcC5yZXBlYXQueSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgMCwgMCApO1xyXG5cdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZTY2FsZSwgMSwgMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBtYXRlcmlhbC5vcGFjaXR5ICk7XHJcblx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIG1hdGVyaWFsLmNvbG9yLnIsIG1hdGVyaWFsLmNvbG9yLmcsIG1hdGVyaWFsLmNvbG9yLmIgKTtcclxuXHJcblx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIG1hdGVyaWFsLnJvdGF0aW9uICk7XHJcblx0XHRcdGdsLnVuaWZvcm0yZnYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZSApO1xyXG5cclxuXHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcclxuXHRcdFx0c3RhdGUuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcclxuXHRcdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgJiYgbWF0ZXJpYWwubWFwLmltYWdlICYmIG1hdGVyaWFsLm1hcC5pbWFnZS53aWR0aCApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggbWF0ZXJpYWwubWFwLCAwICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5zZXRUZXh0dXJlKCB0ZXh0dXJlLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVzdG9yZSBnbFxyXG5cclxuXHRcdHN0YXRlLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0gKCkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcclxuXHRcdHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XHJcblxyXG5cdFx0Z2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIFtcclxuXHJcblx0XHRcdCdwcmVjaXNpb24gJyArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgJyBmbG9hdDsnLFxyXG5cclxuXHRcdFx0J3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcclxuXHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXHJcblx0XHRcdCd1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOycsXHJcblx0XHRcdCd1bmlmb3JtIHZlYzIgc2NhbGU7JyxcclxuXHRcdFx0J3VuaWZvcm0gdmVjMiB1dk9mZnNldDsnLFxyXG5cdFx0XHQndW5pZm9ybSB2ZWMyIHV2U2NhbGU7JyxcclxuXHJcblx0XHRcdCdhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjsnLFxyXG5cdFx0XHQnYXR0cmlidXRlIHZlYzIgdXY7JyxcclxuXHJcblx0XHRcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXHJcblxyXG5cdFx0XHQndm9pZCBtYWluKCkgeycsXHJcblxyXG5cdFx0XHRcdCd2VVYgPSB1dk9mZnNldCArIHV2ICogdXZTY2FsZTsnLFxyXG5cclxuXHRcdFx0XHQndmVjMiBhbGlnbmVkUG9zaXRpb24gPSBwb3NpdGlvbiAqIHNjYWxlOycsXHJcblxyXG5cdFx0XHRcdCd2ZWMyIHJvdGF0ZWRQb3NpdGlvbjsnLFxyXG5cdFx0XHRcdCdyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcclxuXHRcdFx0XHQncm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXHJcblxyXG5cdFx0XHRcdCd2ZWM0IGZpbmFsUG9zaXRpb247JyxcclxuXHJcblx0XHRcdFx0J2ZpbmFsUG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsnLFxyXG5cdFx0XHRcdCdmaW5hbFBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjsnLFxyXG5cdFx0XHRcdCdmaW5hbFBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIGZpbmFsUG9zaXRpb247JyxcclxuXHJcblx0XHRcdFx0J2dsX1Bvc2l0aW9uID0gZmluYWxQb3NpdGlvbjsnLFxyXG5cclxuXHRcdFx0J30nXHJcblxyXG5cdFx0XS5qb2luKCAnXFxuJyApICk7XHJcblxyXG5cdFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgW1xyXG5cclxuXHRcdFx0J3ByZWNpc2lvbiAnICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyAnIGZsb2F0OycsXHJcblxyXG5cdFx0XHQndW5pZm9ybSB2ZWMzIGNvbG9yOycsXHJcblx0XHRcdCd1bmlmb3JtIHNhbXBsZXIyRCBtYXA7JyxcclxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgb3BhY2l0eTsnLFxyXG5cclxuXHRcdFx0J3VuaWZvcm0gaW50IGZvZ1R5cGU7JyxcclxuXHRcdFx0J3VuaWZvcm0gdmVjMyBmb2dDb2xvcjsnLFxyXG5cdFx0XHQndW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5OycsXHJcblx0XHRcdCd1bmlmb3JtIGZsb2F0IGZvZ05lYXI7JyxcclxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nRmFyOycsXHJcblx0XHRcdCd1bmlmb3JtIGZsb2F0IGFscGhhVGVzdDsnLFxyXG5cclxuXHRcdFx0J3ZhcnlpbmcgdmVjMiB2VVY7JyxcclxuXHJcblx0XHRcdCd2b2lkIG1haW4oKSB7JyxcclxuXHJcblx0XHRcdFx0J3ZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTsnLFxyXG5cclxuXHRcdFx0XHQnaWYgKCB0ZXh0dXJlLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkOycsXHJcblxyXG5cdFx0XHRcdCdnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciAqIHRleHR1cmUueHl6LCB0ZXh0dXJlLmEgKiBvcGFjaXR5ICk7JyxcclxuXHJcblx0XHRcdFx0J2lmICggZm9nVHlwZSA+IDAgKSB7JyxcclxuXHJcblx0XHRcdFx0XHQnZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53OycsXHJcblx0XHRcdFx0XHQnZmxvYXQgZm9nRmFjdG9yID0gMC4wOycsXHJcblxyXG5cdFx0XHRcdFx0J2lmICggZm9nVHlwZSA9PSAxICkgeycsXHJcblxyXG5cdFx0XHRcdFx0XHQnZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApOycsXHJcblxyXG5cdFx0XHRcdFx0J30gZWxzZSB7JyxcclxuXHJcblx0XHRcdFx0XHRcdCdjb25zdCBmbG9hdCBMT0cyID0gMS40NDI2OTU7JyxcclxuXHRcdFx0XHRcdFx0J2ZvZ0ZhY3RvciA9IGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApOycsXHJcblx0XHRcdFx0XHRcdCdmb2dGYWN0b3IgPSAxLjAgLSBjbGFtcCggZm9nRmFjdG9yLCAwLjAsIDEuMCApOycsXHJcblxyXG5cdFx0XHRcdFx0J30nLFxyXG5cclxuXHRcdFx0XHRcdCdnbF9GcmFnQ29sb3IgPSBtaXgoIGdsX0ZyYWdDb2xvciwgdmVjNCggZm9nQ29sb3IsIGdsX0ZyYWdDb2xvci53ICksIGZvZ0ZhY3RvciApOycsXHJcblxyXG5cdFx0XHRcdCd9JyxcclxuXHJcblx0XHRcdCd9J1xyXG5cclxuXHRcdF0uam9pbiggJ1xcbicgKSApO1xyXG5cclxuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xyXG5cdFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xyXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0cmV0dXJuIHByb2dyYW07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xyXG5cdFx0XHJcblx0XHRpZiAoIGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYi56IC0gYS56O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYi5pZCAtIGEuaWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvVGhyZWUuTGVnYWN5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuQm94Mi5wcm90b3R5cGUsIHtcclxuXHRlbXB0eToge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLmVtcHR5KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaXNFbXB0eSgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0aXNJbnRlcnNlY3Rpb25Cb3g6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveCggYm94ICk7XHJcblx0XHR9XHJcblx0fVxyXG59ICk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuQm94My5wcm90b3R5cGUsIHtcclxuXHRlbXB0eToge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmVtcHR5KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaXNFbXB0eSgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0aXNJbnRlcnNlY3Rpb25Cb3g6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveCggYm94ICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRpc0ludGVyc2VjdGlvblNwaGVyZToge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuaXNJbnRlcnNlY3Rpb25TcGhlcmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzU3BoZXJlKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5NYXRyaXgzLnByb3RvdHlwZSwge1xyXG5cdG11bHRpcGx5VmVjdG9yMzoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDMoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4MyggdGhpcyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGEgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xyXG5cdFx0fVxyXG5cdH1cclxufSApO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLk1hdHJpeDQucHJvdG90eXBlLCB7XHJcblx0ZXh0cmFjdFBvc2l0aW9uOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBtICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jb3B5UG9zaXRpb24oIG0gKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHEgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRtdWx0aXBseVZlY3RvcjM6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBvciB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIHRoaXMgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdG11bHRpcGx5VmVjdG9yNDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3I0KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGEgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0cm90YXRlQXhpczoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggdiApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0XHR2LnRyYW5zZm9ybURpcmVjdGlvbiggdGhpcyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0Y3Jvc3NWZWN0b3I6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0dHJhbnNsYXRlOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0cm90YXRlWDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0cm90YXRlWToge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0cm90YXRlWjoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0cm90YXRlQnlBeGlzOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVCeUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5QbGFuZS5wcm90b3R5cGUsIHtcclxuXHRpc0ludGVyc2VjdGlvbkxpbmU6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGxpbmUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBsYW5lOiAuaXNJbnRlcnNlY3Rpb25MaW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0xpbmUoKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNMaW5lKCBsaW5lICk7XHJcblx0XHR9XHJcblx0fVxyXG59ICk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuUXVhdGVybmlvbi5wcm90b3R5cGUsIHtcclxuXHRtdWx0aXBseVZlY3RvcjM6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBpcyBub3cgdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcyApO1xyXG5cdFx0fVxyXG5cdH1cclxufSApO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLlJheS5wcm90b3R5cGUsIHtcclxuXHRpc0ludGVyc2VjdGlvbkJveDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXk6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNCb3goIGJveCApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0aXNJbnRlcnNlY3Rpb25QbGFuZToge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uUGxhbmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzUGxhbmUoKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNQbGFuZSggcGxhbmUgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGlzSW50ZXJzZWN0aW9uU3BoZXJlOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uU3BoZXJlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1NwaGVyZSgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XHJcblx0XHR9XHJcblx0fVxyXG59ICk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuVmVjdG9yMy5wcm90b3R5cGUsIHtcclxuXHRzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLicgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNldEV1bGVyRnJvbVF1YXRlcm5pb246IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUXVhdGVybmlvbigpIGluc3RlYWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0Z2V0UG9zaXRpb25Gcm9tTWF0cml4OiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBtICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG0gKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGdldFNjYWxlRnJvbU1hdHJpeDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggbSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFNjYWxlRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhTY2FsZSgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFNjYWxlKCBtICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRnZXRDb2x1bW5Gcm9tTWF0cml4OiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBpbmRleCwgbWF0cml4ICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0Q29sdW1uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhDb2x1bW4oKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIGluZGV4LCBtYXRyaXggKTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbi8vXHJcblxyXG5USFJFRS5GYWNlNCA9IGZ1bmN0aW9uICggYSwgYiwgYywgZCwgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmFjZTQgaGFzIGJlZW4gcmVtb3ZlZC4gQSBUSFJFRS5GYWNlMyB3aWxsIGJlIGNyZWF0ZWQgaW5zdGVhZC4nICk7XHJcblx0cmV0dXJuIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApO1xyXG5cclxufTtcclxuXHJcbi8vXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLCB7XHJcblx0ZXVsZXJPcmRlcjoge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBpcyBub3cgLnJvdGF0aW9uLm9yZGVyLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRpb24ub3JkZXI7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nICk7XHJcblx0XHRcdHRoaXMucm90YXRpb24ub3JkZXIgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGdldENoaWxkQnlOYW1lOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmdldENoaWxkQnlOYW1lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0T2JqZWN0QnlOYW1lKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeU5hbWUoIG5hbWUgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHJlbmRlckRlcHRoOiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAucmVuZGVyRGVwdGggaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5yZW5kZXJPcmRlciwgaW5zdGVhZC4nICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHR0cmFuc2xhdGU6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGRpc3RhbmNlLCBheGlzICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHR1c2VRdWF0ZXJuaW9uOiB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xyXG5cdFx0fSxcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xyXG5cdFx0fVxyXG5cdH1cclxufSApO1xyXG5cclxuLy9cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRSwge1xyXG5cdFBvaW50Q2xvdWQ6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy4nICk7XHJcblx0XHRcdHJldHVybiBuZXcgVEhSRUUuUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdFBhcnRpY2xlU3lzdGVtOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlU3lzdGVtIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicgKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5Qb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cdFx0fVxyXG5cdH1cclxufSApO1xyXG5cclxuLy9cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5MaWdodC5wcm90b3R5cGUsIHtcclxuXHRvbmx5U2hhZG93OiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAub25seVNoYWRvdyBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd0NhbWVyYUZvdjoge1xyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUZvdiBpcyBub3cgLnNoYWRvdy5jYW1lcmEuZm92LicgKTtcclxuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmZvdiA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93Q2FtZXJhTGVmdDoge1xyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUxlZnQgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmxlZnQuJyApO1xyXG5cdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEubGVmdCA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93Q2FtZXJhUmlnaHQ6IHtcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFSaWdodCBpcyBub3cgLnNoYWRvdy5jYW1lcmEucmlnaHQuJyApO1xyXG5cdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEucmlnaHQgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd0NhbWVyYVRvcDoge1xyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVRvcCBpcyBub3cgLnNoYWRvdy5jYW1lcmEudG9wLicgKTtcclxuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLnRvcCA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93Q2FtZXJhQm90dG9tOiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhQm90dG9tIGlzIG5vdyAuc2hhZG93LmNhbWVyYS5ib3R0b20uJyApO1xyXG5cdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuYm90dG9tID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzaGFkb3dDYW1lcmFOZWFyOiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhTmVhciBpcyBub3cgLnNoYWRvdy5jYW1lcmEubmVhci4nICk7XHJcblx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5uZWFyID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzaGFkb3dDYW1lcmFGYXI6IHtcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFGYXIgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmZhci4nICk7XHJcblx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5mYXIgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd0NhbWVyYVZpc2libGU6IHtcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFWaXNpYmxlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBsaWdodC5zaGFkb3cuY2FtZXJhICkgaW5zdGVhZC4nICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzaGFkb3dCaWFzOiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93QmlhcyBpcyBub3cgLnNoYWRvdy5iaWFzLicgKTtcclxuXHRcdFx0dGhpcy5zaGFkb3cuYmlhcyA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93RGFya25lc3M6IHtcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dEYXJrbmVzcyBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd01hcFdpZHRoOiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93TWFwV2lkdGggaXMgbm93IC5zaGFkb3cubWFwU2l6ZS53aWR0aC4nICk7XHJcblx0XHRcdHRoaXMuc2hhZG93Lm1hcFNpemUud2lkdGggPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd01hcEhlaWdodDoge1xyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd01hcEhlaWdodCBpcyBub3cgLnNoYWRvdy5tYXBTaXplLmhlaWdodC4nICk7XHJcblx0XHRcdHRoaXMuc2hhZG93Lm1hcFNpemUuaGVpZ2h0ID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fVxyXG59ICk7XHJcblxyXG4vL1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcclxuXHRsZW5ndGg6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAuY291bnQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XHJcblx0XHR9XHJcblx0fVxyXG59ICk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLCB7XHJcblx0ZHJhd2NhbGxzOiB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuZHJhd2NhbGxzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdyb3Vwcy4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmdyb3VwcztcclxuXHRcdH1cclxuXHR9LFxyXG5cdG9mZnNldHM6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLm9mZnNldHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBzO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0YWRkSW5kZXg6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEluZGV4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0SW5kZXgoKS4nICk7XHJcblx0XHRcdHRoaXMuc2V0SW5kZXgoIGluZGV4ICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRhZGREcmF3Q2FsbDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbmRleE9mZnNldCApIHtcclxuXHRcdFx0aWYgKCBpbmRleE9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBubyBsb25nZXIgc3VwcG9ydHMgaW5kZXhPZmZzZXQuJyApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBpcyBub3cgLmFkZEdyb3VwKCkuJyApO1xyXG5cdFx0XHR0aGlzLmFkZEdyb3VwKCBzdGFydCwgY291bnQgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGNsZWFyRHJhd0NhbGxzOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNsZWFyRHJhd0NhbGxzKCkgaXMgbm93IC5jbGVhckdyb3VwcygpLicgKTtcclxuXHRcdFx0dGhpcy5jbGVhckdyb3VwcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0Y29tcHV0ZVRhbmdlbnRzOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0Y29tcHV0ZU9mZnNldHM6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZU9mZnNldHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbi8vXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLCB7XHJcblx0d3JhcEFyb3VuZDoge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH0sXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHdyYXBSR0I6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBSR0IgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblx0XHRcdHJldHVybiBuZXcgVEhSRUUuQ29sb3IoKTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRSwge1xyXG5cdFBvaW50Q2xvdWRNYXRlcmlhbDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRQYXJ0aWNsZUJhc2ljTWF0ZXJpYWw6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0UGFydGljbGVTeXN0ZW1NYXRlcmlhbDp7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XHJcblx0XHR9XHJcblx0fVxyXG59ICk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLCB7XHJcblx0bWV0YWw6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDogLm1ldGFsIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fSxcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw6IC5tZXRhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgaW5zdGVhZCcgKTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUsIHtcclxuXHRkZXJpdmF0aXZlczoge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYWRlck1hdGVyaWFsOiAuZGVyaXZhdGl2ZXMgaGFzIGJlZW4gbW92ZWQgdG8gLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmRlcml2YXRpdmVzO1xyXG5cdFx0fSxcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuIFNoYWRlck1hdGVyaWFsOiAuZGVyaXZhdGl2ZXMgaGFzIGJlZW4gbW92ZWQgdG8gLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMuJyApO1xyXG5cdFx0XHR0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbi8vXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUsIHtcclxuXHRzdXBwb3J0c0Zsb2F0VGV4dHVyZXM6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0Zsb2F0VGV4dHVyZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfdGV4dHVyZV9mbG9hdFxcJyApLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXM6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3RleHR1cmVfaGFsZl9mbG9hdFxcJyApLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFwnICkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xcJyApLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQzoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xcJyApLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzdXBwb3J0c0JsZW5kTWluTWF4OiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNCbGVuZE1pbk1heCgpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ0VYVF9ibGVuZF9taW5tYXhcXCcgKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcztcclxuXHRcdH1cclxuXHR9LFxyXG5cdHN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXFwnICkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRlbmFibGVTY2lzc29yVGVzdDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggYm9vbGVhbiApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmVuYWJsZVNjaXNzb3JUZXN0KCkgaXMgbm93IC5zZXRTY2lzc29yVGVzdCgpLicgKTtcclxuXHRcdFx0dGhpcy5zZXRTY2lzc29yVGVzdCggYm9vbGVhbiApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0aW5pdE1hdGVyaWFsOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRhZGRQcmVQbHVnaW46IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQcmVQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGFkZFBvc3RQbHVnaW46IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQb3N0UGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHR1cGRhdGVTaGFkb3dNYXA6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC51cGRhdGVTaGFkb3dNYXAoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd01hcEVuYWJsZWQ6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zaGFkb3dNYXAuZW5hYmxlZDtcclxuXHRcdH0sXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBFbmFibGVkIGlzIG5vdyAuc2hhZG93TWFwLmVuYWJsZWQuJyApO1xyXG5cdFx0XHR0aGlzLnNoYWRvd01hcC5lbmFibGVkID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzaGFkb3dNYXBUeXBlOiB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2hhZG93TWFwLnR5cGU7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwVHlwZSBpcyBub3cgLnNoYWRvd01hcC50eXBlLicgKTtcclxuXHRcdFx0dGhpcy5zaGFkb3dNYXAudHlwZSA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93TWFwQ3VsbEZhY2U6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zaGFkb3dNYXAuY3VsbEZhY2U7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwQ3VsbEZhY2UgaXMgbm93IC5zaGFkb3dNYXAuY3VsbEZhY2UuJyApO1xyXG5cdFx0XHR0aGlzLnNoYWRvd01hcC5jdWxsRmFjZSA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH1cclxufSApO1xyXG5cclxuLy9cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUsIHtcclxuXHR3cmFwUzoge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS53cmFwUztcclxuXHRcdH0sXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcclxuXHRcdFx0dGhpcy50ZXh0dXJlLndyYXBTID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHR3cmFwVDoge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS53cmFwVDtcclxuXHRcdH0sXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcclxuXHRcdFx0dGhpcy50ZXh0dXJlLndyYXBUID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRtYWdGaWx0ZXI6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5tYWdGaWx0ZXI7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcclxuXHRcdFx0dGhpcy50ZXh0dXJlLm1hZ0ZpbHRlciA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0bWluRmlsdGVyOiB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUubWluRmlsdGVyO1xyXG5cdFx0fSxcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci4nICk7XHJcblx0XHRcdHRoaXMudGV4dHVyZS5taW5GaWx0ZXIgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGFuaXNvdHJvcHk6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmFuaXNvdHJvcHk7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuJyApO1xyXG5cdFx0XHR0aGlzLnRleHR1cmUuYW5pc290cm9weSA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0b2Zmc2V0OiB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUub2Zmc2V0O1xyXG5cdFx0fSxcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XHJcblx0XHRcdHRoaXMudGV4dHVyZS5vZmZzZXQgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHJlcGVhdDoge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLnJlcGVhdDtcclxuXHRcdH0sXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyApO1xyXG5cdFx0XHR0aGlzLnRleHR1cmUucmVwZWF0ID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRmb3JtYXQ6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5mb3JtYXQ7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcclxuXHRcdFx0dGhpcy50ZXh0dXJlLmZvcm1hdCA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0dHlwZToge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUudHlwZTtcclxuXHRcdH0sXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XHJcblx0XHRcdHRoaXMudGV4dHVyZS50eXBlID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRnZW5lcmF0ZU1pcG1hcHM6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcclxuXHRcdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH1cclxufSApO1xyXG5cclxuLy9cclxuXHJcblRIUkVFLkdlb21ldHJ5VXRpbHMgPSB7XHJcblxyXG5cdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5MSwgZ2VvbWV0cnkyLCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5tZXJnZSgpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0dmFyIG1hdHJpeDtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5MiBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeTIubWF0cml4QXV0b1VwZGF0ZSAmJiBnZW9tZXRyeTIudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0XHRtYXRyaXggPSBnZW9tZXRyeTIubWF0cml4O1xyXG5cdFx0XHRnZW9tZXRyeTIgPSBnZW9tZXRyeTIuZ2VvbWV0cnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJ5MS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2VudGVyOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5jZW50ZXIoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5LmNlbnRlcigpIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIGdlb21ldHJ5LmNlbnRlcigpO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW1hZ2VVdGlscyA9IHtcclxuXHJcblx0Y3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcclxuXHJcblx0bG9hZFRleHR1cmU6IGZ1bmN0aW9uICggdXJsLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xyXG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJsLCBvbkxvYWQsIHVuZGVmaW5lZCwgb25FcnJvciApO1xyXG5cclxuXHRcdGlmICggbWFwcGluZyApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvYWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCB1cmxzLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZUN1YmUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyKCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpO1xyXG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJscywgb25Mb2FkLCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcclxuXHJcblx0XHRpZiAoIG1hcHBpbmcgKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsb2FkQ29tcHJlc3NlZFRleHR1cmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vXHJcblxyXG5USFJFRS5Qcm9qZWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3IgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3JlbmRlcmVycy9Qcm9qZWN0b3IuanMuJyApO1xyXG5cclxuXHR0aGlzLnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnByb2plY3QoKS4nICk7XHJcblx0XHR2ZWN0b3IucHJvamVjdCggY2FtZXJhICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMudW5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9qZWN0b3I6IC51bnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnVucHJvamVjdCgpLicgKTtcclxuXHRcdHZlY3Rvci51bnByb2plY3QoIGNhbWVyYSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnBpY2tpbmdSYXkgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3I6IC5waWNraW5nUmF5KCkgaXMgbm93IHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCkuJyApO1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcbi8vXHJcblxyXG5USFJFRS5DYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkNhbnZhc1JlbmRlcmVyIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvQ2FudmFzUmVuZGVyZXIuanMnICk7XHJcblxyXG5cdHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge307XHJcblx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge307XHJcblx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCkge307XHJcblxyXG59O1xyXG5cclxuLy9cclxuXHJcblRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgPSBUSFJFRS5NdWx0aU1hdGVyaWFsO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL0N1cnZlVXRpbHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3VydmVVdGlscyA9IHtcclxuXHJcblx0dGFuZ2VudFF1YWRyYXRpY0JlemllcjogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyICkge1xyXG5cclxuXHRcdHJldHVybiAyICogKCAxIC0gdCApICogKCBwMSAtIHAwICkgKyAyICogdCAqICggcDIgLSBwMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBQdWF5IEJpbmcsIHRoYW5rcyBmb3IgaGVscGluZyB3aXRoIHRoaXMgZGVyaXZhdGl2ZSFcclxuXHJcblx0dGFuZ2VudEN1YmljQmV6aWVyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xyXG5cclxuXHRcdHJldHVybiAtIDMgKiBwMCAqICggMSAtIHQgKSAqICggMSAtIHQgKSAgK1xyXG5cdFx0XHQzICogcDEgKiAoIDEgLSB0ICkgKiAoIDEgLSB0ICkgLSA2ICogdCAqIHAxICogKCAxIC0gdCApICtcclxuXHRcdFx0NiAqIHQgKiAgcDIgKiAoIDEgLSB0ICkgLSAzICogdCAqIHQgKiBwMiArXHJcblx0XHRcdDMgKiB0ICogdCAqIHAzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0YW5nZW50U3BsaW5lOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xyXG5cclxuXHRcdC8vIFRvIGNoZWNrIGlmIG15IGZvcm11bGFzIGFyZSBjb3JyZWN0XHJcblxyXG5cdFx0dmFyIGgwMCA9IDYgKiB0ICogdCAtIDYgKiB0OyBcdC8vIGRlcml2ZWQgZnJvbSAydF4zIOKIkiAzdF4yICsgMVxyXG5cdFx0dmFyIGgxMCA9IDMgKiB0ICogdCAtIDQgKiB0ICsgMTsgLy8gdF4zIOKIkiAydF4yICsgdFxyXG5cdFx0dmFyIGgwMSA9IC0gNiAqIHQgKiB0ICsgNiAqIHQ7IFx0Ly8g4oiSIDJ0MyArIDN0MlxyXG5cdFx0dmFyIGgxMSA9IDMgKiB0ICogdCAtIDIgKiB0O1x0Ly8gdDMg4oiSIHQyXHJcblxyXG5cdFx0cmV0dXJuIGgwMCArIGgxMCArIGgwMSArIGgxMTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gQ2F0bXVsbC1Sb21cclxuXHJcblx0aW50ZXJwb2xhdGU6IGZ1bmN0aW9uKCBwMCwgcDEsIHAyLCBwMywgdCApIHtcclxuXHJcblx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcclxuXHRcdHZhciB2MSA9ICggcDMgLSBwMSApICogMC41O1xyXG5cdFx0dmFyIHQyID0gdCAqIHQ7XHJcblx0XHR2YXIgdDMgPSB0ICogdDI7XHJcblx0XHRyZXR1cm4gKCAyICogcDEgLSAyICogcDIgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogcDEgKyAzICogcDIgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9TY2VuZVV0aWxzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TY2VuZVV0aWxzID0ge1xyXG5cclxuXHRjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0dmFyIGdyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRncm91cC5hZGQoIG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWxzWyBpIF0gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ3JvdXA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRldGFjaDogZnVuY3Rpb24gKCBjaGlsZCwgcGFyZW50LCBzY2VuZSApIHtcclxuXHJcblx0XHRjaGlsZC5hcHBseU1hdHJpeCggcGFyZW50Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRwYXJlbnQucmVtb3ZlKCBjaGlsZCApO1xyXG5cdFx0c2NlbmUuYWRkKCBjaGlsZCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhdHRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHNjZW5lLCBwYXJlbnQgKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0XHRtYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggcGFyZW50Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRjaGlsZC5hcHBseU1hdHJpeCggbWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG5cdFx0c2NlbmUucmVtb3ZlKCBjaGlsZCApO1xyXG5cdFx0cGFyZW50LmFkZCggY2hpbGQgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9TaGFwZVV0aWxzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKi9cclxuXHJcblRIUkVFLlNoYXBlVXRpbHMgPSB7XHJcblxyXG5cdC8vIGNhbGN1bGF0ZSBhcmVhIG9mIHRoZSBjb250b3VyIHBvbHlnb25cclxuXHJcblx0YXJlYTogZnVuY3Rpb24gKCBjb250b3VyICkge1xyXG5cclxuXHRcdHZhciBuID0gY29udG91ci5sZW5ndGg7XHJcblx0XHR2YXIgYSA9IDAuMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xyXG5cclxuXHRcdFx0YSArPSBjb250b3VyWyBwIF0ueCAqIGNvbnRvdXJbIHEgXS55IC0gY29udG91clsgcSBdLnggKiBjb250b3VyWyBwIF0ueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGEgKiAwLjU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyaWFuZ3VsYXRlOiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgY29kZSBpcyBhIHF1aWNrIHBvcnQgb2YgY29kZSB3cml0dGVuIGluIEMrKyB3aGljaCB3YXMgc3VibWl0dGVkIHRvXHJcblx0XHQgKiBmbGlwY29kZS5jb20gYnkgSm9obiBXLiBSYXRjbGlmZiAgLy8gSnVseSAyMiwgMjAwMFxyXG5cdFx0ICogU2VlIG9yaWdpbmFsIGNvZGUgYW5kIG1vcmUgaW5mb3JtYXRpb24gaGVyZTpcclxuXHRcdCAqIGh0dHA6Ly93d3cuZmxpcGNvZGUuY29tL2FyY2hpdmVzL0VmZmljaWVudF9Qb2x5Z29uX1RyaWFuZ3VsYXRpb24uc2h0bWxcclxuXHRcdCAqXHJcblx0XHQgKiBwb3J0ZWQgdG8gYWN0aW9uc2NyaXB0IGJ5IFpldmFuIFJvc3NlclxyXG5cdFx0ICogd3d3LmFjdGlvbnNuaXBwZXQuY29tXHJcblx0XHQgKlxyXG5cdFx0ICogcG9ydGVkIHRvIGphdmFzY3JpcHQgYnkgSm9zaHVhIEtvb1xyXG5cdFx0ICogaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG5cdFx0ICpcclxuXHRcdCAqL1xyXG5cclxuXHRcdGZ1bmN0aW9uIHNuaXAoIGNvbnRvdXIsIHUsIHYsIHcsIG4sIHZlcnRzICkge1xyXG5cclxuXHRcdFx0dmFyIHA7XHJcblx0XHRcdHZhciBheCwgYXksIGJ4LCBieTtcclxuXHRcdFx0dmFyIGN4LCBjeSwgcHgsIHB5O1xyXG5cclxuXHRcdFx0YXggPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueDtcclxuXHRcdFx0YXkgPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueTtcclxuXHJcblx0XHRcdGJ4ID0gY29udG91clsgdmVydHNbIHYgXSBdLng7XHJcblx0XHRcdGJ5ID0gY29udG91clsgdmVydHNbIHYgXSBdLnk7XHJcblxyXG5cdFx0XHRjeCA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS54O1xyXG5cdFx0XHRjeSA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS55O1xyXG5cclxuXHRcdFx0aWYgKCBOdW1iZXIuRVBTSUxPTiA+ICggKCAoIGJ4IC0gYXggKSAqICggY3kgLSBheSApICkgLSAoICggYnkgLSBheSApICogKCBjeCAtIGF4ICkgKSApICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0dmFyIGFYLCBhWSwgYlgsIGJZLCBjWCwgY1k7XHJcblx0XHRcdHZhciBhcHgsIGFweSwgYnB4LCBicHksIGNweCwgY3B5O1xyXG5cdFx0XHR2YXIgY0NST1NTYXAsIGJDUk9TU2NwLCBhQ1JPU1NicDtcclxuXHJcblx0XHRcdGFYID0gY3ggLSBieDsgIGFZID0gY3kgLSBieTtcclxuXHRcdFx0YlggPSBheCAtIGN4OyAgYlkgPSBheSAtIGN5O1xyXG5cdFx0XHRjWCA9IGJ4IC0gYXg7ICBjWSA9IGJ5IC0gYXk7XHJcblxyXG5cdFx0XHRmb3IgKCBwID0gMDsgcCA8IG47IHAgKysgKSB7XHJcblxyXG5cdFx0XHRcdHB4ID0gY29udG91clsgdmVydHNbIHAgXSBdLng7XHJcblx0XHRcdFx0cHkgPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueTtcclxuXHJcblx0XHRcdFx0aWYgKCAoICggcHggPT09IGF4ICkgJiYgKCBweSA9PT0gYXkgKSApIHx8XHJcblx0XHRcdFx0XHQgKCAoIHB4ID09PSBieCApICYmICggcHkgPT09IGJ5ICkgKSB8fFxyXG5cdFx0XHRcdFx0ICggKCBweCA9PT0gY3ggKSAmJiAoIHB5ID09PSBjeSApICkgKVx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdGFweCA9IHB4IC0gYXg7ICBhcHkgPSBweSAtIGF5O1xyXG5cdFx0XHRcdGJweCA9IHB4IC0gYng7ICBicHkgPSBweSAtIGJ5O1xyXG5cdFx0XHRcdGNweCA9IHB4IC0gY3g7ICBjcHkgPSBweSAtIGN5O1xyXG5cclxuXHRcdFx0XHQvLyBzZWUgaWYgcCBpcyBpbnNpZGUgdHJpYW5nbGUgYWJjXHJcblxyXG5cdFx0XHRcdGFDUk9TU2JwID0gYVggKiBicHkgLSBhWSAqIGJweDtcclxuXHRcdFx0XHRjQ1JPU1NhcCA9IGNYICogYXB5IC0gY1kgKiBhcHg7XHJcblx0XHRcdFx0YkNST1NTY3AgPSBiWCAqIGNweSAtIGJZICogY3B4O1xyXG5cclxuXHRcdFx0XHRpZiAoICggYUNST1NTYnAgPj0gLSBOdW1iZXIuRVBTSUxPTiApICYmICggYkNST1NTY3AgPj0gLSBOdW1iZXIuRVBTSUxPTiApICYmICggY0NST1NTYXAgPj0gLSBOdW1iZXIuRVBTSUxPTiApICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRha2VzIGluIGFuIGNvbnRvdXIgYXJyYXkgYW5kIHJldHVybnNcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjb250b3VyLCBpbmRpY2VzICkge1xyXG5cclxuXHRcdFx0dmFyIG4gPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblx0XHRcdGlmICggbiA8IDMgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBbXSxcclxuXHRcdFx0XHR2ZXJ0cyA9IFtdLFxyXG5cdFx0XHRcdHZlcnRJbmRpY2VzID0gW107XHJcblxyXG5cdFx0XHQvKiB3ZSB3YW50IGEgY291bnRlci1jbG9ja3dpc2UgcG9seWdvbiBpbiB2ZXJ0cyAqL1xyXG5cclxuXHRcdFx0dmFyIHUsIHYsIHc7XHJcblxyXG5cdFx0XHRpZiAoIFRIUkVFLlNoYXBlVXRpbHMuYXJlYSggY29udG91ciApID4gMC4wICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2ID0gMDsgdiA8IG47IHYgKysgKSB2ZXJ0c1sgdiBdID0gdjtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHYgPSAwOyB2IDwgbjsgdiArKyApIHZlcnRzWyB2IF0gPSAoIG4gLSAxICkgLSB2O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIG52ID0gbjtcclxuXHJcblx0XHRcdC8qICByZW1vdmUgbnYgLSAyIHZlcnRpY2VzLCBjcmVhdGluZyAxIHRyaWFuZ2xlIGV2ZXJ5IHRpbWUgKi9cclxuXHJcblx0XHRcdHZhciBjb3VudCA9IDIgKiBudjsgICAvKiBlcnJvciBkZXRlY3Rpb24gKi9cclxuXHJcblx0XHRcdGZvciAoIHYgPSBudiAtIDE7IG52ID4gMjsgKSB7XHJcblxyXG5cdFx0XHRcdC8qIGlmIHdlIGxvb3AsIGl0IGlzIHByb2JhYmx5IGEgbm9uLXNpbXBsZSBwb2x5Z29uICovXHJcblxyXG5cdFx0XHRcdGlmICggKCBjb3VudCAtLSApIDw9IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8qKiBUcmlhbmd1bGF0ZTogRVJST1IgLSBwcm9iYWJsZSBiYWQgcG9seWdvbiFcclxuXHJcblx0XHRcdFx0XHQvL3Rocm93ICggXCJXYXJuaW5nLCB1bmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiFcIiApO1xyXG5cdFx0XHRcdFx0Ly9yZXR1cm4gbnVsbDtcclxuXHRcdFx0XHRcdC8vIFNvbWV0aW1lcyB3YXJuaW5nIGlzIGZpbmUsIGVzcGVjaWFsbHkgcG9seWdvbnMgYXJlIHRyaWFuZ3VsYXRlZCBpbiByZXZlcnNlLlxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2hhcGVVdGlsczogVW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hIGluIHRyaWFuZ3VsYXRlKCknICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvKiB0aHJlZSBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBpbiBjdXJyZW50IHBvbHlnb24sIDx1LHYsdz4gKi9cclxuXHJcblx0XHRcdFx0dSA9IHY7IFx0IFx0aWYgKCBudiA8PSB1ICkgdSA9IDA7ICAgICAvKiBwcmV2aW91cyAqL1xyXG5cdFx0XHRcdHYgPSB1ICsgMTsgIGlmICggbnYgPD0gdiApIHYgPSAwOyAgICAgLyogbmV3IHYgICAgKi9cclxuXHRcdFx0XHR3ID0gdiArIDE7ICBpZiAoIG52IDw9IHcgKSB3ID0gMDsgICAgIC8qIG5leHQgICAgICovXHJcblxyXG5cdFx0XHRcdGlmICggc25pcCggY29udG91ciwgdSwgdiwgdywgbnYsIHZlcnRzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGEsIGIsIGMsIHMsIHQ7XHJcblxyXG5cdFx0XHRcdFx0LyogdHJ1ZSBuYW1lcyBvZiB0aGUgdmVydGljZXMgKi9cclxuXHJcblx0XHRcdFx0XHRhID0gdmVydHNbIHUgXTtcclxuXHRcdFx0XHRcdGIgPSB2ZXJ0c1sgdiBdO1xyXG5cdFx0XHRcdFx0YyA9IHZlcnRzWyB3IF07XHJcblxyXG5cdFx0XHRcdFx0Lyogb3V0cHV0IFRyaWFuZ2xlICovXHJcblxyXG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goIFsgY29udG91clsgYSBdLFxyXG5cdFx0XHRcdFx0XHRjb250b3VyWyBiIF0sXHJcblx0XHRcdFx0XHRcdGNvbnRvdXJbIGMgXSBdICk7XHJcblxyXG5cclxuXHRcdFx0XHRcdHZlcnRJbmRpY2VzLnB1c2goIFsgdmVydHNbIHUgXSwgdmVydHNbIHYgXSwgdmVydHNbIHcgXSBdICk7XHJcblxyXG5cdFx0XHRcdFx0LyogcmVtb3ZlIHYgZnJvbSB0aGUgcmVtYWluaW5nIHBvbHlnb24gKi9cclxuXHJcblx0XHRcdFx0XHRmb3IgKCBzID0gdiwgdCA9IHYgKyAxOyB0IDwgbnY7IHMgKyssIHQgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2ZXJ0c1sgcyBdID0gdmVydHNbIHQgXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bnYgLS07XHJcblxyXG5cdFx0XHRcdFx0LyogcmVzZXQgZXJyb3IgZGV0ZWN0aW9uIGNvdW50ZXIgKi9cclxuXHJcblx0XHRcdFx0XHRjb3VudCA9IDIgKiBudjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApKCksXHJcblxyXG5cdHRyaWFuZ3VsYXRlU2hhcGU6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWdQdDEsIGluU2VnUHQyLCBpbk90aGVyUHQgKSB7XHJcblxyXG5cdFx0XHQvLyBpbk90aGVyUHQgbmVlZHMgdG8gYmUgY29sbGluZWFyIHRvIHRoZSBpblNlZ21lbnRcclxuXHRcdFx0aWYgKCBpblNlZ1B0MS54ICE9PSBpblNlZ1B0Mi54ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGluU2VnUHQxLnggPCBpblNlZ1B0Mi54ICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQxLnggPD0gaW5PdGhlclB0LnggKSAmJiAoIGluT3RoZXJQdC54IDw9IGluU2VnUHQyLnggKSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQyLnggPD0gaW5PdGhlclB0LnggKSAmJiAoIGluT3RoZXJQdC54IDw9IGluU2VnUHQxLnggKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIGluU2VnUHQxLnkgPCBpblNlZ1B0Mi55ICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQxLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQyLnkgKSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQyLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQxLnkgKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2VnMWR4ID0gaW5TZWcxUHQyLnggLSBpblNlZzFQdDEueCwgICBzZWcxZHkgPSBpblNlZzFQdDIueSAtIGluU2VnMVB0MS55O1xyXG5cdFx0XHR2YXIgc2VnMmR4ID0gaW5TZWcyUHQyLnggLSBpblNlZzJQdDEueCwgICBzZWcyZHkgPSBpblNlZzJQdDIueSAtIGluU2VnMlB0MS55O1xyXG5cclxuXHRcdFx0dmFyIHNlZzFzZWcyZHggPSBpblNlZzFQdDEueCAtIGluU2VnMlB0MS54O1xyXG5cdFx0XHR2YXIgc2VnMXNlZzJkeSA9IGluU2VnMVB0MS55IC0gaW5TZWcyUHQxLnk7XHJcblxyXG5cdFx0XHR2YXIgbGltaXRcdFx0PSBzZWcxZHkgKiBzZWcyZHggLSBzZWcxZHggKiBzZWcyZHk7XHJcblx0XHRcdHZhciBwZXJwU2VnMVx0PSBzZWcxZHkgKiBzZWcxc2VnMmR4IC0gc2VnMWR4ICogc2VnMXNlZzJkeTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIGxpbWl0ICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0Ly8gbm90IHBhcmFsbGVsXHJcblxyXG5cdFx0XHRcdHZhciBwZXJwU2VnMjtcclxuXHRcdFx0XHRpZiAoIGxpbWl0ID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICggcGVycFNlZzEgPCAwICkgfHwgKCBwZXJwU2VnMSA+IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xyXG5cdFx0XHRcdFx0cGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcclxuXHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMiA8IDAgKSB8fCAoIHBlcnBTZWcyID4gbGltaXQgKSApIFx0XHRyZXR1cm4gW107XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcxID4gMCApIHx8ICggcGVycFNlZzEgPCBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdHBlcnBTZWcyID0gc2VnMmR5ICogc2VnMXNlZzJkeCAtIHNlZzJkeCAqIHNlZzFzZWcyZHk7XHJcblx0XHRcdFx0XHRpZiAoICggcGVycFNlZzIgPiAwICkgfHwgKCBwZXJwU2VnMiA8IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGkuZS4gdG8gcmVkdWNlIHJvdW5kaW5nIGVycm9yc1xyXG5cdFx0XHRcdC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzE/XHJcblx0XHRcdFx0aWYgKCBwZXJwU2VnMiA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgJiZcclxuXHRcdFx0XHRcdFx0ICggKCBwZXJwU2VnMSA9PT0gMCApIHx8ICggcGVycFNlZzEgPT09IGxpbWl0ICkgKSApXHRcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdHJldHVybiBbIGluU2VnMVB0MSBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCBwZXJwU2VnMiA9PT0gbGltaXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXHJcblx0XHRcdFx0XHRcdCAoICggcGVycFNlZzEgPT09IDAgKSB8fCAoIHBlcnBTZWcxID09PSBsaW1pdCApICkgKVx0XHRyZXR1cm4gW107XHJcblx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDIgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzI/XHJcblx0XHRcdFx0aWYgKCBwZXJwU2VnMSA9PT0gMCApXHRcdHJldHVybiBbIGluU2VnMlB0MSBdO1xyXG5cdFx0XHRcdGlmICggcGVycFNlZzEgPT09IGxpbWl0IClcdHJldHVybiBbIGluU2VnMlB0MiBdO1xyXG5cclxuXHRcdFx0XHQvLyByZXR1cm4gcmVhbCBpbnRlcnNlY3Rpb24gcG9pbnRcclxuXHRcdFx0XHR2YXIgZmFjdG9yU2VnMSA9IHBlcnBTZWcyIC8gbGltaXQ7XHJcblx0XHRcdFx0cmV0dXJuXHRbIHsgeDogaW5TZWcxUHQxLnggKyBmYWN0b3JTZWcxICogc2VnMWR4LFxyXG5cdFx0XHRcdFx0XHRcdHk6IGluU2VnMVB0MS55ICsgZmFjdG9yU2VnMSAqIHNlZzFkeSB9IF07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcclxuXHRcdFx0XHRpZiAoICggcGVycFNlZzEgIT09IDAgKSB8fFxyXG5cdFx0XHRcdFx0ICggc2VnMmR5ICogc2VnMXNlZzJkeCAhPT0gc2VnMmR4ICogc2VnMXNlZzJkeSApICkgXHRcdFx0cmV0dXJuIFtdO1xyXG5cclxuXHRcdFx0XHQvLyB0aGV5IGFyZSBjb2xsaW5lYXIgb3IgZGVnZW5lcmF0ZVxyXG5cdFx0XHRcdHZhciBzZWcxUHQgPSAoICggc2VnMWR4ID09PSAwICkgJiYgKCBzZWcxZHkgPT09IDAgKSApO1x0Ly8gc2VnbWVudDEgaXMganVzdCBhIHBvaW50P1xyXG5cdFx0XHRcdHZhciBzZWcyUHQgPSAoICggc2VnMmR4ID09PSAwICkgJiYgKCBzZWcyZHkgPT09IDAgKSApO1x0Ly8gc2VnbWVudDIgaXMganVzdCBhIHBvaW50P1xyXG5cdFx0XHRcdC8vIGJvdGggc2VnbWVudHMgYXJlIHBvaW50c1xyXG5cdFx0XHRcdGlmICggc2VnMVB0ICYmIHNlZzJQdCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICggaW5TZWcxUHQxLnggIT09IGluU2VnMlB0MS54ICkgfHxcclxuXHRcdFx0XHRcdFx0ICggaW5TZWcxUHQxLnkgIT09IGluU2VnMlB0MS55ICkgKVx0XHRyZXR1cm4gW107XHQvLyB0aGV5IGFyZSBkaXN0aW5jdCAgcG9pbnRzXHJcblx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDEgXTsgICAgICAgICAgICAgICAgIFx0XHRcdFx0XHRcdC8vIHRoZXkgYXJlIHRoZSBzYW1lIHBvaW50XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBzZWdtZW50IzEgIGlzIGEgc2luZ2xlIHBvaW50XHJcblx0XHRcdFx0aWYgKCBzZWcxUHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpblNlZzFQdDEgKSApXHRcdHJldHVybiBbXTtcdFx0Ly8gYnV0IG5vdCBpbiBzZWdtZW50IzJcclxuXHRcdFx0XHRcdHJldHVybiBbIGluU2VnMVB0MSBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gc2VnbWVudCMyICBpcyBhIHNpbmdsZSBwb2ludFxyXG5cdFx0XHRcdGlmICggc2VnMlB0ICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggISBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZzFQdDEsIGluU2VnMVB0MiwgaW5TZWcyUHQxICkgKVx0XHRyZXR1cm4gW107XHRcdC8vIGJ1dCBub3QgaW4gc2VnbWVudCMxXHJcblx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzJQdDEgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyB0aGV5IGFyZSBjb2xsaW5lYXIgc2VnbWVudHMsIHdoaWNoIG1pZ2h0IG92ZXJsYXBcclxuXHRcdFx0XHR2YXIgc2VnMW1pbiwgc2VnMW1heCwgc2VnMW1pblZhbCwgc2VnMW1heFZhbDtcclxuXHRcdFx0XHR2YXIgc2VnMm1pbiwgc2VnMm1heCwgc2VnMm1pblZhbCwgc2VnMm1heFZhbDtcclxuXHRcdFx0XHRpZiAoIHNlZzFkeCAhPT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyB0aGUgc2VnbWVudHMgYXJlIE5PVCBvbiBhIHZlcnRpY2FsIGxpbmVcclxuXHRcdFx0XHRcdGlmICggaW5TZWcxUHQxLnggPCBpblNlZzFQdDIueCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDE7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueDtcclxuXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0Mjsgc2VnMW1heFZhbCA9IGluU2VnMVB0Mi54O1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzZWcxbWluID0gaW5TZWcxUHQyOyBzZWcxbWluVmFsID0gaW5TZWcxUHQyLng7XHJcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDE7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDEueDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoIGluU2VnMlB0MS54IDwgaW5TZWcyUHQyLnggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLng7XHJcblx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDI7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDIueDtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0c2VnMm1pbiA9IGluU2VnMlB0Mjsgc2VnMm1pblZhbCA9IGluU2VnMlB0Mi54O1xyXG5cdFx0XHRcdFx0XHRzZWcybWF4ID0gaW5TZWcyUHQxOyBzZWcybWF4VmFsID0gaW5TZWcyUHQxLng7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIHRoZSBzZWdtZW50cyBhcmUgb24gYSB2ZXJ0aWNhbCBsaW5lXHJcblx0XHRcdFx0XHRpZiAoIGluU2VnMVB0MS55IDwgaW5TZWcxUHQyLnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzZWcxbWluID0gaW5TZWcxUHQxOyBzZWcxbWluVmFsID0gaW5TZWcxUHQxLnk7XHJcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi55O1xyXG5cdFx0XHRcdFx0XHRzZWcxbWF4ID0gaW5TZWcxUHQxOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQxLnk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCBpblNlZzJQdDEueSA8IGluU2VnMlB0Mi55ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c2VnMm1pbiA9IGluU2VnMlB0MTsgc2VnMm1pblZhbCA9IGluU2VnMlB0MS55O1xyXG5cdFx0XHRcdFx0XHRzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLnk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueTtcclxuXHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0MTsgc2VnMm1heFZhbCA9IGluU2VnMlB0MS55O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICggc2VnMW1pblZhbCA8PSBzZWcybWluVmFsICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA8ICBzZWcybWluVmFsIClcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA9PT0gc2VnMm1pblZhbCApXHR7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGluRXhjbHVkZUFkamFjZW50U2VncyApXHRcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIFsgc2VnMm1pbiBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsIClcdHJldHVybiBbIHNlZzJtaW4sIHNlZzFtYXggXTtcclxuXHRcdFx0XHRcdHJldHVyblx0WyBzZWcybWluLCBzZWcybWF4IF07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzZWcxbWluVmFsID4gIHNlZzJtYXhWYWwgKVx0cmV0dXJuIFtdO1xyXG5cdFx0XHRcdFx0aWYgKCBzZWcxbWluVmFsID09PSBzZWcybWF4VmFsIClcdHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzIClcdFx0cmV0dXJuIFtdO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBzZWcxbWluIF07XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCBzZWcxbWF4VmFsIDw9IHNlZzJtYXhWYWwgKVx0cmV0dXJuIFsgc2VnMW1pbiwgc2VnMW1heCBdO1xyXG5cdFx0XHRcdFx0cmV0dXJuXHRbIHNlZzFtaW4sIHNlZzJtYXggXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBpc1BvaW50SW5zaWRlQW5nbGUoIGluVmVydGV4LCBpbkxlZ0Zyb21QdCwgaW5MZWdUb1B0LCBpbk90aGVyUHQgKSB7XHJcblxyXG5cdFx0XHQvLyBUaGUgb3JkZXIgb2YgbGVncyBpcyBpbXBvcnRhbnRcclxuXHJcblx0XHRcdC8vIHRyYW5zbGF0aW9uIG9mIGFsbCBwb2ludHMsIHNvIHRoYXQgVmVydGV4IGlzIGF0ICgwLDApXHJcblx0XHRcdHZhciBsZWdGcm9tUHRYXHQ9IGluTGVnRnJvbVB0LnggLSBpblZlcnRleC54LCAgbGVnRnJvbVB0WVx0PSBpbkxlZ0Zyb21QdC55IC0gaW5WZXJ0ZXgueTtcclxuXHRcdFx0dmFyIGxlZ1RvUHRYXHQ9IGluTGVnVG9QdC54XHQtIGluVmVydGV4LngsICBsZWdUb1B0WVx0XHQ9IGluTGVnVG9QdC55XHQtIGluVmVydGV4Lnk7XHJcblx0XHRcdHZhciBvdGhlclB0WFx0PSBpbk90aGVyUHQueFx0LSBpblZlcnRleC54LCAgb3RoZXJQdFlcdFx0PSBpbk90aGVyUHQueVx0LSBpblZlcnRleC55O1xyXG5cclxuXHRcdFx0Ly8gbWFpbiBhbmdsZSA+MDogPCAxODAgZGVnLjsgMDogMTgwIGRlZy47IDwwOiA+IDE4MCBkZWcuXHJcblx0XHRcdHZhciBmcm9tMnRvQW5nbGVcdD0gbGVnRnJvbVB0WCAqIGxlZ1RvUHRZIC0gbGVnRnJvbVB0WSAqIGxlZ1RvUHRYO1xyXG5cdFx0XHR2YXIgZnJvbTJvdGhlckFuZ2xlXHQ9IGxlZ0Zyb21QdFggKiBvdGhlclB0WSAtIGxlZ0Zyb21QdFkgKiBvdGhlclB0WDtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIGZyb20ydG9BbmdsZSApID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdC8vIGFuZ2xlICE9IDE4MCBkZWcuXHJcblxyXG5cdFx0XHRcdHZhciBvdGhlcjJ0b0FuZ2xlXHRcdD0gb3RoZXJQdFggKiBsZWdUb1B0WSAtIG90aGVyUHRZICogbGVnVG9QdFg7XHJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogXCIgKyBmcm9tMnRvQW5nbGUgKyBcIiwgZnJvbTJvdGhlcjogXCIgKyBmcm9tMm90aGVyQW5nbGUgKyBcIiwgb3RoZXIydG86IFwiICsgb3RoZXIydG9BbmdsZSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGZyb20ydG9BbmdsZSA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbWFpbiBhbmdsZSA8IDE4MCBkZWcuXHJcblx0XHRcdFx0XHRyZXR1cm5cdCggKCBmcm9tMm90aGVyQW5nbGUgPj0gMCApICYmICggb3RoZXIydG9BbmdsZSA+PSAwICkgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyBtYWluIGFuZ2xlID4gMTgwIGRlZy5cclxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgfHwgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBhbmdsZSA9PSAxODAgZGVnLlxyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IDE4MCBkZWcuLCBmcm9tMm90aGVyOiBcIiArIGZyb20yb3RoZXJBbmdsZSAgKTtcclxuXHRcdFx0XHRyZXR1cm5cdCggZnJvbTJvdGhlckFuZ2xlID4gMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICkge1xyXG5cclxuXHRcdFx0dmFyIHNoYXBlID0gY29udG91ci5jb25jYXQoKTsgLy8gd29yayBvbiB0aGlzIHNoYXBlXHJcblx0XHRcdHZhciBob2xlO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBpblNoYXBlSWR4LCBpbkhvbGVJZHggKSB7XHJcblxyXG5cdFx0XHRcdC8vIENoZWNrIGlmIGhvbGUgcG9pbnQgbGllcyB3aXRoaW4gYW5nbGUgYXJvdW5kIHNoYXBlIHBvaW50XHJcblx0XHRcdFx0dmFyIGxhc3RTaGFwZUlkeCA9IHNoYXBlLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHRcdHZhciBwcmV2U2hhcGVJZHggPSBpblNoYXBlSWR4IC0gMTtcclxuXHRcdFx0XHRpZiAoIHByZXZTaGFwZUlkeCA8IDAgKVx0XHRcdHByZXZTaGFwZUlkeCA9IGxhc3RTaGFwZUlkeDtcclxuXHJcblx0XHRcdFx0dmFyIG5leHRTaGFwZUlkeCA9IGluU2hhcGVJZHggKyAxO1xyXG5cdFx0XHRcdGlmICggbmV4dFNoYXBlSWR4ID4gbGFzdFNoYXBlSWR4IClcdG5leHRTaGFwZUlkeCA9IDA7XHJcblxyXG5cdFx0XHRcdHZhciBpbnNpZGVBbmdsZSA9IGlzUG9pbnRJbnNpZGVBbmdsZSggc2hhcGVbIGluU2hhcGVJZHggXSwgc2hhcGVbIHByZXZTaGFwZUlkeCBdLCBzaGFwZVsgbmV4dFNoYXBlSWR4IF0sIGhvbGVbIGluSG9sZUlkeCBdICk7XHJcblx0XHRcdFx0aWYgKCAhIGluc2lkZUFuZ2xlICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBcIlZlcnRleCAoU2hhcGUpOiBcIiArIGluU2hhcGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgaG9sZVtpbkhvbGVJZHhdLnggKyBcIi9cIiArIGhvbGVbaW5Ib2xlSWR4XS55ICk7XHJcblx0XHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIENoZWNrIGlmIHNoYXBlIHBvaW50IGxpZXMgd2l0aGluIGFuZ2xlIGFyb3VuZCBob2xlIHBvaW50XHJcblx0XHRcdFx0dmFyIGxhc3RIb2xlSWR4ID0gaG9sZS5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0XHR2YXIgcHJldkhvbGVJZHggPSBpbkhvbGVJZHggLSAxO1xyXG5cdFx0XHRcdGlmICggcHJldkhvbGVJZHggPCAwIClcdFx0XHRwcmV2SG9sZUlkeCA9IGxhc3RIb2xlSWR4O1xyXG5cclxuXHRcdFx0XHR2YXIgbmV4dEhvbGVJZHggPSBpbkhvbGVJZHggKyAxO1xyXG5cdFx0XHRcdGlmICggbmV4dEhvbGVJZHggPiBsYXN0SG9sZUlkeCApXHRuZXh0SG9sZUlkeCA9IDA7XHJcblxyXG5cdFx0XHRcdGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBob2xlWyBpbkhvbGVJZHggXSwgaG9sZVsgcHJldkhvbGVJZHggXSwgaG9sZVsgbmV4dEhvbGVJZHggXSwgc2hhcGVbIGluU2hhcGVJZHggXSApO1xyXG5cdFx0XHRcdGlmICggISBpbnNpZGVBbmdsZSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyggXCJWZXJ0ZXggKEhvbGUpOiBcIiArIGluSG9sZUlkeCArIFwiLCBQb2ludDogXCIgKyBzaGFwZVtpblNoYXBlSWR4XS54ICsgXCIvXCIgKyBzaGFwZVtpblNoYXBlSWR4XS55ICk7XHJcblx0XHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVyblx0dHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGludGVyc2VjdHNTaGFwZUVkZ2UoIGluU2hhcGVQdCwgaW5Ib2xlUHQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIHNoYXBlIGVkZ2VzXHJcblx0XHRcdFx0dmFyIHNJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcclxuXHRcdFx0XHRmb3IgKCBzSWR4ID0gMDsgc0lkeCA8IHNoYXBlLmxlbmd0aDsgc0lkeCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRuZXh0SWR4ID0gc0lkeCArIDE7IG5leHRJZHggJT0gc2hhcGUubGVuZ3RoO1xyXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNoYXBlUHQsIGluSG9sZVB0LCBzaGFwZVsgc0lkeCBdLCBzaGFwZVsgbmV4dElkeCBdLCB0cnVlICk7XHJcblx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbi5sZW5ndGggPiAwIClcdFx0cmV0dXJuXHR0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVyblx0ZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgaW5kZXBIb2xlcyA9IFtdO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gaW50ZXJzZWN0c0hvbGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xyXG5cclxuXHRcdFx0XHQvLyBjaGVja3MgZm9yIGludGVyc2VjdGlvbnMgd2l0aCBob2xlIGVkZ2VzXHJcblx0XHRcdFx0dmFyIGloSWR4LCBjaGtIb2xlLFxyXG5cdFx0XHRcdFx0aElkeCwgbmV4dElkeCwgaW50ZXJzZWN0aW9uO1xyXG5cdFx0XHRcdGZvciAoIGloSWR4ID0gMDsgaWhJZHggPCBpbmRlcEhvbGVzLmxlbmd0aDsgaWhJZHggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2hrSG9sZSA9IGhvbGVzWyBpbmRlcEhvbGVzWyBpaElkeCBdXTtcclxuXHRcdFx0XHRcdGZvciAoIGhJZHggPSAwOyBoSWR4IDwgY2hrSG9sZS5sZW5ndGg7IGhJZHggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRuZXh0SWR4ID0gaElkeCArIDE7IG5leHRJZHggJT0gY2hrSG9sZS5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgY2hrSG9sZVsgaElkeCBdLCBjaGtIb2xlWyBuZXh0SWR4IF0sIHRydWUgKTtcclxuXHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApXHRcdHJldHVyblx0dHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGhvbGVJbmRleCwgc2hhcGVJbmRleCxcclxuXHRcdFx0XHRzaGFwZVB0LCBob2xlUHQsXHJcblx0XHRcdFx0aG9sZUlkeCwgY3V0S2V5LCBmYWlsZWRDdXRzID0gW10sXHJcblx0XHRcdFx0dG1wU2hhcGUxLCB0bXBTaGFwZTIsXHJcblx0XHRcdFx0dG1wSG9sZTEsIHRtcEhvbGUyO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0XHRpbmRlcEhvbGVzLnB1c2goIGggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBtaW5TaGFwZUluZGV4ID0gMDtcclxuXHRcdFx0dmFyIGNvdW50ZXIgPSBpbmRlcEhvbGVzLmxlbmd0aCAqIDI7XHJcblx0XHRcdHdoaWxlICggaW5kZXBIb2xlcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRjb3VudGVyIC0tO1xyXG5cdFx0XHRcdGlmICggY291bnRlciA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coIFwiSW5maW5pdGUgTG9vcCEgSG9sZXMgbGVmdDpcIiArIGluZGVwSG9sZXMubGVuZ3RoICsgXCIsIFByb2JhYmx5IEhvbGUgb3V0c2lkZSBTaGFwZSFcIiApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gc2VhcmNoIGZvciBzaGFwZS12ZXJ0ZXggYW5kIGhvbGUtdmVydGV4LFxyXG5cdFx0XHRcdC8vIHdoaWNoIGNhbiBiZSBjb25uZWN0ZWQgd2l0aG91dCBpbnRlcnNlY3Rpb25zXHJcblx0XHRcdFx0Zm9yICggc2hhcGVJbmRleCA9IG1pblNoYXBlSW5kZXg7IHNoYXBlSW5kZXggPCBzaGFwZS5sZW5ndGg7IHNoYXBlSW5kZXggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2hhcGVQdCA9IHNoYXBlWyBzaGFwZUluZGV4IF07XHJcblx0XHRcdFx0XHRob2xlSW5kZXhcdD0gLSAxO1xyXG5cclxuXHRcdFx0XHRcdC8vIHNlYXJjaCBmb3IgaG9sZSB3aGljaCBjYW4gYmUgcmVhY2hlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcclxuXHRcdFx0XHRcdGZvciAoIHZhciBoID0gMDsgaCA8IGluZGVwSG9sZXMubGVuZ3RoOyBoICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aG9sZUlkeCA9IGluZGVwSG9sZXNbIGggXTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHByZXZlbnQgbXVsdGlwbGUgY2hlY2tzXHJcblx0XHRcdFx0XHRcdGN1dEtleSA9IHNoYXBlUHQueCArIFwiOlwiICsgc2hhcGVQdC55ICsgXCI6XCIgKyBob2xlSWR4O1xyXG5cdFx0XHRcdFx0XHRpZiAoIGZhaWxlZEN1dHNbIGN1dEtleSBdICE9PSB1bmRlZmluZWQgKVx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0aG9sZSA9IGhvbGVzWyBob2xlSWR4IF07XHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBoMiA9IDA7IGgyIDwgaG9sZS5sZW5ndGg7IGgyICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRob2xlUHQgPSBob2xlWyBoMiBdO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggISBpc0N1dExpbmVJbnNpZGVBbmdsZXMoIHNoYXBlSW5kZXgsIGgyICkgKVx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdHNTaGFwZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApIClcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzSG9sZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApIClcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGhvbGVJbmRleCA9IGgyO1xyXG5cdFx0XHRcdFx0XHRcdGluZGVwSG9sZXMuc3BsaWNlKCBoLCAxICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHRtcFNoYXBlMSA9IHNoYXBlLnNsaWNlKCAwLCBzaGFwZUluZGV4ICsgMSApO1xyXG5cdFx0XHRcdFx0XHRcdHRtcFNoYXBlMiA9IHNoYXBlLnNsaWNlKCBzaGFwZUluZGV4ICk7XHJcblx0XHRcdFx0XHRcdFx0dG1wSG9sZTEgPSBob2xlLnNsaWNlKCBob2xlSW5kZXggKTtcclxuXHRcdFx0XHRcdFx0XHR0bXBIb2xlMiA9IGhvbGUuc2xpY2UoIDAsIGhvbGVJbmRleCArIDEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0c2hhcGUgPSB0bXBTaGFwZTEuY29uY2F0KCB0bXBIb2xlMSApLmNvbmNhdCggdG1wSG9sZTIgKS5jb25jYXQoIHRtcFNoYXBlMiApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRtaW5TaGFwZUluZGV4ID0gc2hhcGVJbmRleDtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gRGVidWcgb25seSwgdG8gc2hvdyB0aGUgc2VsZWN0ZWQgY3V0c1xyXG5cdFx0XHRcdFx0XHRcdC8vIGdsb2JfQ3V0TGluZXMucHVzaCggWyBzaGFwZVB0LCBob2xlUHQgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYgKCBob2xlSW5kZXggPj0gMCApXHRicmVhaztcdFx0Ly8gaG9sZS12ZXJ0ZXggZm91bmRcclxuXHJcblx0XHRcdFx0XHRcdGZhaWxlZEN1dHNbIGN1dEtleSBdID0gdHJ1ZTtcdFx0XHQvLyByZW1lbWJlciBmYWlsdXJlXHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCBob2xlSW5kZXggPj0gMCApXHRicmVhaztcdFx0Ly8gaG9sZS12ZXJ0ZXggZm91bmRcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHNoYXBlOyBcdFx0XHQvKiBzaGFwZSB3aXRoIG5vIGhvbGVzICovXHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHR2YXIgaSwgaWwsIGYsIGZhY2UsXHJcblx0XHRcdGtleSwgaW5kZXgsXHJcblx0XHRcdGFsbFBvaW50c01hcCA9IHt9O1xyXG5cclxuXHRcdC8vIFRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvbGQgc2hhcGUsIG9uZSBtdXN0IG1hdGNoIGNvb3JkaW5hdGVzLCBvciBvZmZzZXQgdGhlIGluZGljZXMgZnJvbSBvcmlnaW5hbCBhcnJheXMuIEl0J3MgcHJvYmFibHkgZWFzaWVyIHRvIGRvIHRoZSBmaXJzdC5cclxuXHJcblx0XHR2YXIgYWxscG9pbnRzID0gY29udG91ci5jb25jYXQoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggYWxscG9pbnRzLCBob2xlc1sgaCBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vY29uc29sZS5sb2coIFwiYWxscG9pbnRzXCIsYWxscG9pbnRzLCBhbGxwb2ludHMubGVuZ3RoICk7XHJcblxyXG5cdFx0Ly8gcHJlcGFyZSBhbGwgcG9pbnRzIG1hcFxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGFsbHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGtleSA9IGFsbHBvaW50c1sgaSBdLnggKyBcIjpcIiArIGFsbHBvaW50c1sgaSBdLnk7XHJcblxyXG5cdFx0XHRpZiAoIGFsbFBvaW50c01hcFsga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLlNoYXBlOiBEdXBsaWNhdGUgcG9pbnRcIiwga2V5ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhbGxQb2ludHNNYXBbIGtleSBdID0gaTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVtb3ZlIGhvbGVzIGJ5IGN1dHRpbmcgcGF0aHMgdG8gaG9sZXMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZSBzaGFwZVxyXG5cdFx0dmFyIHNoYXBlV2l0aG91dEhvbGVzID0gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICk7XHJcblxyXG5cdFx0dmFyIHRyaWFuZ2xlcyA9IFRIUkVFLlNoYXBlVXRpbHMudHJpYW5ndWxhdGUoIHNoYXBlV2l0aG91dEhvbGVzLCBmYWxzZSApOyAvLyBUcnVlIHJldHVybnMgaW5kaWNlcyBmb3IgcG9pbnRzIG9mIHNwb29sZWQgc2hhcGVcclxuXHRcdC8vY29uc29sZS5sb2coIFwidHJpYW5nbGVzXCIsdHJpYW5nbGVzLCB0cmlhbmdsZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0Ly8gY2hlY2sgYWxsIGZhY2UgdmVydGljZXMgYWdhaW5zdCBhbGwgcG9pbnRzIG1hcFxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0cmlhbmdsZXNbIGkgXTtcclxuXHJcblx0XHRcdGZvciAoIGYgPSAwOyBmIDwgMzsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0a2V5ID0gZmFjZVsgZiBdLnggKyBcIjpcIiArIGZhY2VbIGYgXS55O1xyXG5cclxuXHRcdFx0XHRpbmRleCA9IGFsbFBvaW50c01hcFsga2V5IF07XHJcblxyXG5cdFx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlWyBmIF0gPSBpbmRleDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJpYW5nbGVzLmNvbmNhdCgpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0Nsb2NrV2lzZTogZnVuY3Rpb24gKCBwdHMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFRIUkVFLlNoYXBlVXRpbHMuYXJlYSggcHRzICkgPCAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cclxuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXHJcblxyXG5cdC8vIFF1YWQgQmV6aWVyIEZ1bmN0aW9uc1xyXG5cclxuXHRiMjogKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gYjJwMCggdCwgcCApIHtcclxuXHJcblx0XHRcdHZhciBrID0gMSAtIHQ7XHJcblx0XHRcdHJldHVybiBrICogayAqIHA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGIycDEoIHQsIHAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gMiAqICggMSAtIHQgKSAqIHQgKiBwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBiMnAyKCB0LCBwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHQgKiB0ICogcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiApIHtcclxuXHJcblx0XHRcdHJldHVybiBiMnAwKCB0LCBwMCApICsgYjJwMSggdCwgcDEgKSArIGIycDIoIHQsIHAyICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCksXHJcblxyXG5cdC8vIEN1YmljIEJlemllciBGdW5jdGlvbnNcclxuXHJcblx0YjM6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIGIzcDAoIHQsIHAgKSB7XHJcblxyXG5cdFx0XHR2YXIgayA9IDEgLSB0O1xyXG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrICogcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYjNwMSggdCwgcCApIHtcclxuXHJcblx0XHRcdHZhciBrID0gMSAtIHQ7XHJcblx0XHRcdHJldHVybiAzICogayAqIGsgKiB0ICogcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYjNwMiggdCwgcCApIHtcclxuXHJcblx0XHRcdHZhciBrID0gMSAtIHQ7XHJcblx0XHRcdHJldHVybiAzICogayAqIHQgKiB0ICogcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYjNwMyggdCwgcCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0ICogdCAqIHQgKiBwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcclxuXHJcblx0XHRcdHJldHVybiBiM3AwKCB0LCBwMCApICsgYjNwMSggdCwgcDEgKSArIGIzcDIoIHQsIHAyICkgKyBiM3AzKCB0LCBwMyApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0gKSgpXHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvQ3VydmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0XHJcbiAqXHJcbiAqIFNvbWUgY29tbW9uIG9mIEN1cnZlIG1ldGhvZHNcclxuICogLmdldFBvaW50KHQpLCBnZXRUYW5nZW50KHQpXHJcbiAqIC5nZXRQb2ludEF0KHUpLCBnZXRUYWdlbnRBdCh1KVxyXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxyXG4gKiAuZ2V0TGVuZ3RoKClcclxuICogLnVwZGF0ZUFyY0xlbmd0aHMoKVxyXG4gKlxyXG4gKiBUaGlzIGZvbGxvd2luZyBjbGFzc2VzIHN1YmNsYXNzZXMgVEhSRUUuQ3VydmU6XHJcbiAqXHJcbiAqIC0tIDJkIGNsYXNzZXMgLS1cclxuICogVEhSRUUuTGluZUN1cnZlXHJcbiAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlXHJcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmVcclxuICogVEhSRUUuU3BsaW5lQ3VydmVcclxuICogVEhSRUUuQXJjQ3VydmVcclxuICogVEhSRUUuRWxsaXBzZUN1cnZlXHJcbiAqXHJcbiAqIC0tIDNkIGNsYXNzZXMgLS1cclxuICogVEhSRUUuTGluZUN1cnZlM1xyXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTNcclxuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTNcclxuICogVEhSRUUuU3BsaW5lQ3VydmUzXHJcbiAqIFRIUkVFLkNsb3NlZFNwbGluZUN1cnZlM1xyXG4gKlxyXG4gKiBBIHNlcmllcyBvZiBjdXJ2ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgVEhSRUUuQ3VydmVQYXRoXHJcbiAqXHJcbiAqKi9cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0QWJzdHJhY3QgQ3VydmUgYmFzZSBjbGFzc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5DdXJ2ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5DdXJ2ZSxcclxuXHJcblx0Ly8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXHJcblx0Ly9cdC0gdCBbMCAuLiAxXVxyXG5cclxuXHRnZXRQb2ludDogZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5DdXJ2ZTogV2FybmluZywgZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQhXCIgKTtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgcG9pbnQgYXQgcmVsYXRpdmUgcG9zaXRpb24gaW4gY3VydmUgYWNjb3JkaW5nIHRvIGFyYyBsZW5ndGhcclxuXHQvLyAtIHUgWzAgLi4gMV1cclxuXHJcblx0Z2V0UG9pbnRBdDogZnVuY3Rpb24gKCB1ICkge1xyXG5cclxuXHRcdHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXHJcblxyXG5cdGdldFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0aWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XHJcblxyXG5cdFx0dmFyIGQsIHB0cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcclxuXHJcblx0XHRcdHB0cy5wdXNoKCB0aGlzLmdldFBvaW50KCBkIC8gZGl2aXNpb25zICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHB0cztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludEF0KCB1IClcclxuXHJcblx0Z2V0U3BhY2VkUG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0XHRpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNTtcclxuXHJcblx0XHR2YXIgZCwgcHRzID0gW107XHJcblxyXG5cdFx0Zm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xyXG5cclxuXHRcdFx0cHRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwdHM7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXHJcblxyXG5cdGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XHJcblx0XHRyZXR1cm4gbGVuZ3Roc1sgbGVuZ3Rocy5sZW5ndGggLSAxIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXHJcblxyXG5cdGdldExlbmd0aHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRcdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSAoIHRoaXMuX19hcmNMZW5ndGhEaXZpc2lvbnMgKSA/ICggdGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyApIDogMjAwO1xyXG5cclxuXHRcdGlmICggdGhpcy5jYWNoZUFyY0xlbmd0aHNcclxuXHRcdFx0JiYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKVxyXG5cdFx0XHQmJiAhIHRoaXMubmVlZHNVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCBcImNhY2hlZFwiLCB0aGlzLmNhY2hlQXJjTGVuZ3RocyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jYWNoZUFyY0xlbmd0aHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR2YXIgY2FjaGUgPSBbXTtcclxuXHRcdHZhciBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xyXG5cdFx0dmFyIHAsIHN1bSA9IDA7XHJcblxyXG5cdFx0Y2FjaGUucHVzaCggMCApO1xyXG5cclxuXHRcdGZvciAoIHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcclxuXHJcblx0XHRcdGN1cnJlbnQgPSB0aGlzLmdldFBvaW50ICggcCAvIGRpdmlzaW9ucyApO1xyXG5cdFx0XHRzdW0gKz0gY3VycmVudC5kaXN0YW5jZVRvKCBsYXN0ICk7XHJcblx0XHRcdGNhY2hlLnB1c2goIHN1bSApO1xyXG5cdFx0XHRsYXN0ID0gY3VycmVudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcclxuXHJcblx0XHRyZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTpzdW0gfTsgU3VtIGlzIGluIHRoZSBsYXN0IGVsZW1lbnQuXHJcblxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFyY0xlbmd0aHM6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5nZXRMZW5ndGhzKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aWRpc3RhbnRcclxuXHJcblx0Z2V0VXRvVG1hcHBpbmc6IGZ1bmN0aW9uICggdSwgZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0dmFyIGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcclxuXHJcblx0XHR2YXIgaSA9IDAsIGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XHJcblxyXG5cdFx0dmFyIHRhcmdldEFyY0xlbmd0aDsgLy8gVGhlIHRhcmdldGVkIHUgZGlzdGFuY2UgdmFsdWUgdG8gZ2V0XHJcblxyXG5cdFx0aWYgKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuXHRcdC8vIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHRhcmdldCB1IGRpc3RhbmNlXHJcblxyXG5cdFx0dmFyIGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XHJcblxyXG5cdFx0d2hpbGUgKCBsb3cgPD0gaGlnaCApIHtcclxuXHJcblx0XHRcdGkgPSBNYXRoLmZsb29yKCBsb3cgKyAoIGhpZ2ggLSBsb3cgKSAvIDIgKTsgLy8gbGVzcyBsaWtlbHkgdG8gb3ZlcmZsb3csIHRob3VnaCBwcm9iYWJseSBub3QgaXNzdWUgaGVyZSwgSlMgZG9lc24ndCByZWFsbHkgaGF2ZSBpbnRlZ2VycywgYWxsIG51bWJlcnMgYXJlIGZsb2F0c1xyXG5cclxuXHRcdFx0Y29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcclxuXHJcblx0XHRcdGlmICggY29tcGFyaXNvbiA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdGxvdyA9IGkgKyAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggY29tcGFyaXNvbiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGhpZ2ggPSBpIC0gMTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGhpZ2ggPSBpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHQvLyBET05FXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGkgPSBoaWdoO1xyXG5cclxuXHRcdC8vY29uc29sZS5sb2coJ2InICwgaSwgbG93LCBoaWdoLCBEYXRlLm5vdygpLSB0aW1lKTtcclxuXHJcblx0XHRpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dmFyIHQgPSBpIC8gKCBpbCAtIDEgKTtcclxuXHRcdFx0cmV0dXJuIHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHdlIGNvdWxkIGdldCBmaW5lciBncmFpbiBhdCBsZW5ndGhzLCBvciB1c2Ugc2ltcGxlIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXHJcblxyXG5cdFx0dmFyIGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcclxuXHRcdHZhciBsZW5ndGhBZnRlciA9IGFyY0xlbmd0aHNbIGkgKyAxIF07XHJcblxyXG5cdFx0dmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhBZnRlciAtIGxlbmd0aEJlZm9yZTtcclxuXHJcblx0XHQvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xyXG5cclxuXHRcdHZhciBzZWdtZW50RnJhY3Rpb24gPSAoIHRhcmdldEFyY0xlbmd0aCAtIGxlbmd0aEJlZm9yZSApIC8gc2VnbWVudExlbmd0aDtcclxuXHJcblx0XHQvLyBhZGQgdGhhdCBmcmFjdGlvbmFsIGFtb3VudCB0byB0XHJcblxyXG5cdFx0dmFyIHQgPSAoIGkgKyBzZWdtZW50RnJhY3Rpb24gKSAvICggaWwgLSAxICk7XHJcblxyXG5cdFx0cmV0dXJuIHQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcclxuXHQvLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXHJcblx0Ly8gMiBwb2ludHMgYSBzbWFsbCBkZWx0YSBhcGFydCB3aWxsIGJlIHVzZWQgdG8gZmluZCBpdHMgZ3JhZGllbnRcclxuXHQvLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXHJcblxyXG5cdGdldFRhbmdlbnQ6IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHRcdHZhciBkZWx0YSA9IDAuMDAwMTtcclxuXHRcdHZhciB0MSA9IHQgLSBkZWx0YTtcclxuXHRcdHZhciB0MiA9IHQgKyBkZWx0YTtcclxuXHJcblx0XHQvLyBDYXBwaW5nIGluIGNhc2Ugb2YgZGFuZ2VyXHJcblxyXG5cdFx0aWYgKCB0MSA8IDAgKSB0MSA9IDA7XHJcblx0XHRpZiAoIHQyID4gMSApIHQyID0gMTtcclxuXHJcblx0XHR2YXIgcHQxID0gdGhpcy5nZXRQb2ludCggdDEgKTtcclxuXHRcdHZhciBwdDIgPSB0aGlzLmdldFBvaW50KCB0MiApO1xyXG5cclxuXHRcdHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIoIHB0MSApO1xyXG5cdFx0cmV0dXJuIHZlYy5ub3JtYWxpemUoKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0VGFuZ2VudEF0OiBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdFx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB0ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBUT0RPOiBUcmFuc2Zvcm1hdGlvbiBmb3IgQ3VydmVzP1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHQzRCBDdXJ2ZXNcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLy8gQSBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgbmV3IGN1cnZlIHN1YmNsYXNzZXNcclxuXHJcblRIUkVFLkN1cnZlLmNyZWF0ZSA9IGZ1bmN0aW9uICggY29uc3RydWN0b3IsIGdldFBvaW50RnVuYyApIHtcclxuXHJcblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblx0Y29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XHJcblx0Y29uc3RydWN0b3IucHJvdG90eXBlLmdldFBvaW50ID0gZ2V0UG9pbnRGdW5jO1xyXG5cclxuXHRyZXR1cm4gY29uc3RydWN0b3I7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvQ3VydmVQYXRoLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKlxyXG4gKiovXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEN1cnZlZCBQYXRoIC0gYSBjdXJ2ZSBwYXRoIGlzIHNpbXBseSBhIGFycmF5IG9mIGNvbm5lY3RlZFxyXG4gKiAgY3VydmVzLCBidXQgcmV0YWlucyB0aGUgYXBpIG9mIGEgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmN1cnZlcyA9IFtdO1xyXG5cclxuXHR0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxyXG5cclxufTtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1cnZlUGF0aDtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCBjdXJ2ZSApIHtcclxuXHJcblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcbn07XHJcblxyXG4vKlxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNoZWNrQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdC8vIFRPRE9cclxuXHQvLyBJZiB0aGUgZW5kaW5nIG9mIGN1cnZlIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHN0YXJ0aW5nXHJcblx0Ly8gb3IgdGhlIG5leHQgY3VydmUsIHRoZW4sIHRoaXMgaXMgbm90IGEgcmVhbCBwYXRoXHJcbn07XHJcbiovXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHQvLyBUT0RPIFRlc3RcclxuXHQvLyBhbmQgdmVyaWZ5IGZvciB2ZWN0b3IzIChuZWVkcyB0byBpbXBsZW1lbnQgZXF1YWxzKVxyXG5cdC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxyXG5cdHZhciBzdGFydFBvaW50ID0gdGhpcy5jdXJ2ZXNbIDAgXS5nZXRQb2ludCggMCApO1xyXG5cdHZhciBlbmRQb2ludCA9IHRoaXMuY3VydmVzWyB0aGlzLmN1cnZlcy5sZW5ndGggLSAxIF0uZ2V0UG9pbnQoIDEgKTtcclxuXHJcblx0aWYgKCAhIHN0YXJ0UG9pbnQuZXF1YWxzKCBlbmRQb2ludCApICkge1xyXG5cclxuXHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBUSFJFRS5MaW5lQ3VydmUoIGVuZFBvaW50LCBzdGFydFBvaW50ICkgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xyXG4vLyBlbnRpcmUgcGF0aCBkaXN0YW5jZSBhdCB0aW1lIHQsXHJcbi8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcclxuXHJcbi8vIDEuIExlbmd0aCBvZiBlYWNoIHN1YiBwYXRoIGhhdmUgdG8gYmUga25vd25cclxuLy8gMi4gTG9jYXRlIGFuZCBpZGVudGlmeSB0eXBlIG9mIGN1cnZlXHJcbi8vIDMuIEdldCB0IGZvciB0aGUgY3VydmVcclxuLy8gNC4gUmV0dXJuIGN1cnZlLmdldFBvaW50QXQodCcpXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblx0dmFyIGN1cnZlTGVuZ3RocyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XHJcblx0dmFyIGkgPSAwO1xyXG5cclxuXHQvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cclxuXHJcblx0d2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcclxuXHJcblx0XHRpZiAoIGN1cnZlTGVuZ3Roc1sgaSBdID49IGQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcclxuXHRcdFx0dmFyIGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcclxuXHJcblx0XHRcdHZhciB1ID0gMSAtIGRpZmYgLyBjdXJ2ZS5nZXRMZW5ndGgoKTtcclxuXHJcblx0XHRcdHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KCB1ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGkgKys7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG51bGw7XHJcblxyXG5cdC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxyXG5cclxufTtcclxuXHJcbi8qXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG59O1xyXG4qL1xyXG5cclxuLy8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxyXG4vLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcclxuLy8gZ2V0UG9pbnQoKSBkZXBlbmRzIG9uIGdldExlbmd0aFxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xyXG5cdHJldHVybiBsZW5zWyBsZW5zLmxlbmd0aCAtIDEgXTtcclxuXHJcbn07XHJcblxyXG4vLyBDb21wdXRlIGxlbmd0aHMgYW5kIGNhY2hlIHRoZW1cclxuLy8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0Q3VydmVMZW5ndGhzID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcclxuXHJcblx0aWYgKCB0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT09IHRoaXMuY3VydmVzLmxlbmd0aCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gR2V0IGxlbmd0aCBvZiBzdWItY3VydmVcclxuXHQvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcclxuXHJcblx0dmFyIGxlbmd0aHMgPSBbXSwgc3VtcyA9IDA7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0c3VtcyArPSB0aGlzLmN1cnZlc1sgaSBdLmdldExlbmd0aCgpO1xyXG5cdFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xyXG5cclxuXHRyZXR1cm4gbGVuZ3RocztcclxuXHJcbn07XHJcblxyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0Q3JlYXRlIEdlb21ldHJpZXMgSGVscGVyc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBwYXRoIHBvaW50cyAoZm9yIExpbmUgb3IgUG9pbnRzIG9iamVjdHMpXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVBvaW50c0dlb21ldHJ5ID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcclxuXHJcblx0dmFyIHB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKTtcclxuXHRyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XHJcblxyXG59O1xyXG5cclxuLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBlcXVpZGlzdGFudCBzYW1wbGluZyBhbG9uZyB0aGUgcGF0aFxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVTcGFjZWRQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdHZhciBwdHMgPSB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zICk7XHJcblx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlR2VvbWV0cnkgPSBmdW5jdGlvbiggcG9pbnRzICkge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50ID0gcG9pbnRzWyBpIF07XHJcblx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiB8fCAwICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvRm9udC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Gb250ID0gZnVuY3Rpb24gKCBkYXRhICkge1xyXG5cclxuXHR0aGlzLmRhdGEgPSBkYXRhO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZvbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRm9udCxcclxuXHJcblx0Z2VuZXJhdGVTaGFwZXM6IGZ1bmN0aW9uICggdGV4dCwgc2l6ZSwgZGl2aXNpb25zICkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVBhdGhzKCB0ZXh0ICkge1xyXG5cclxuXHRcdFx0dmFyIGNoYXJzID0gU3RyaW5nKCB0ZXh0ICkuc3BsaXQoICcnICk7XHJcblx0XHRcdHZhciBzY2FsZSA9IHNpemUgLyBkYXRhLnJlc29sdXRpb247XHJcblx0XHRcdHZhciBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdFx0dmFyIHBhdGhzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciByZXQgPSBjcmVhdGVQYXRoKCBjaGFyc1sgaSBdLCBzY2FsZSwgb2Zmc2V0ICk7XHJcblx0XHRcdFx0b2Zmc2V0ICs9IHJldC5vZmZzZXQ7XHJcblxyXG5cdFx0XHRcdHBhdGhzLnB1c2goIHJldC5wYXRoICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcGF0aHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVBhdGgoIGMsIHNjYWxlLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZ2x5cGggPSBkYXRhLmdseXBoc1sgYyBdIHx8IGRhdGEuZ2x5cGhzWyAnPycgXTtcclxuXHJcblx0XHRcdGlmICggISBnbHlwaCApIHJldHVybjtcclxuXHJcblx0XHRcdHZhciBwYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcclxuXHJcblx0XHRcdHZhciBwdHMgPSBbXSwgYjIgPSBUSFJFRS5TaGFwZVV0aWxzLmIyLCBiMyA9IFRIUkVFLlNoYXBlVXRpbHMuYjM7XHJcblx0XHRcdHZhciB4LCB5LCBjcHgsIGNweSwgY3B4MCwgY3B5MCwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgbGFzdGU7XHJcblxyXG5cdFx0XHRpZiAoIGdseXBoLm8gKSB7XHJcblxyXG5cdFx0XHRcdHZhciBvdXRsaW5lID0gZ2x5cGguX2NhY2hlZE91dGxpbmUgfHwgKCBnbHlwaC5fY2FjaGVkT3V0bGluZSA9IGdseXBoLm8uc3BsaXQoICcgJyApICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG91dGxpbmUubGVuZ3RoOyBpIDwgbDsgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGFjdGlvbiA9IG91dGxpbmVbIGkgKysgXTtcclxuXHJcblx0XHRcdFx0XHRzd2l0Y2ggKCBhY3Rpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdtJzogLy8gbW92ZVRvXHJcblxyXG5cdFx0XHRcdFx0XHRcdHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldDtcclxuXHRcdFx0XHRcdFx0XHR5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHBhdGgubW92ZVRvKCB4LCB5ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSAnbCc6IC8vIGxpbmVUb1xyXG5cclxuXHRcdFx0XHRcdFx0XHR4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXQ7XHJcblx0XHRcdFx0XHRcdFx0eSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggeCwgeSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvXHJcblxyXG5cdFx0XHRcdFx0XHRcdGNweCAgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldDtcclxuXHRcdFx0XHRcdFx0XHRjcHkgID0gb3V0bGluZVsgaSArKyBdICogc2NhbGU7XHJcblx0XHRcdFx0XHRcdFx0Y3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0O1xyXG5cdFx0XHRcdFx0XHRcdGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgsIGNweSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBsYXN0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjcHgwID0gbGFzdGUueDtcclxuXHRcdFx0XHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpMiA9IDE7IGkyIDw9IGRpdmlzaW9uczsgaTIgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgdCA9IGkyIC8gZGl2aXNpb25zO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRiMiggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGIyKCB0LCBjcHkwLCBjcHkxLCBjcHkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdiJzogLy8gYmV6aWVyQ3VydmVUb1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjcHggID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXQ7XHJcblx0XHRcdFx0XHRcdFx0Y3B5ICA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlO1xyXG5cdFx0XHRcdFx0XHRcdGNweDEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldDtcclxuXHRcdFx0XHRcdFx0XHRjcHkxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGU7XHJcblx0XHRcdFx0XHRcdFx0Y3B4MiA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0O1xyXG5cdFx0XHRcdFx0XHRcdGNweTIgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBjcHgsIGNweSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBsYXN0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjcHgwID0gbGFzdGUueDtcclxuXHRcdFx0XHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpMiA9IDE7IGkyIDw9IGRpdmlzaW9uczsgaTIgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgdCA9IGkyIC8gZGl2aXNpb25zO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRiMyggdCwgY3B4MCwgY3B4MSwgY3B4MiwgY3B4ICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGIzKCB0LCBjcHkwLCBjcHkxLCBjcHkyLCBjcHkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4geyBvZmZzZXQ6IGdseXBoLmhhICogc2NhbGUsIHBhdGg6IHBhdGggfTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAxMDA7XHJcblx0XHRpZiAoIGRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkICkgZGl2aXNpb25zID0gNDtcclxuXHJcblx0XHR2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHJcblx0XHR2YXIgcGF0aHMgPSBjcmVhdGVQYXRocyggdGV4dCApO1xyXG5cdFx0dmFyIHNoYXBlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBwID0gMCwgcGwgPSBwYXRocy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcclxuXHJcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBzaGFwZXMsIHBhdGhzWyBwIF0udG9TaGFwZXMoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2hhcGVzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvUGF0aC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogQ3JlYXRlcyBmcmVlIGZvcm0gMmQgcGF0aCB1c2luZyBzZXJpZXMgb2YgcG9pbnRzLCBsaW5lcyBvciBjdXJ2ZXMuXHJcbiAqXHJcbiAqKi9cclxuXHJcblRIUkVFLlBhdGggPSBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0VEhSRUUuQ3VydmVQYXRoLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5hY3Rpb25zID0gW107XHJcblxyXG5cdGlmICggcG9pbnRzICkge1xyXG5cclxuXHRcdHRoaXMuZnJvbVBvaW50cyggcG9pbnRzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgKTtcclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QYXRoO1xyXG5cclxuLy8gVE9ETyBDbGVhbiB1cCBQQVRIIEFQSVxyXG5cclxuLy8gQ3JlYXRlIHBhdGggdXNpbmcgc3RyYWlnaHQgbGluZXMgdG8gY29ubmVjdCBhbGwgcG9pbnRzXHJcbi8vIC0gdmVjdG9yczogYXJyYXkgb2YgVmVjdG9yMlxyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZnJvbVBvaW50cyA9IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcclxuXHJcblx0dGhpcy5tb3ZlVG8oIHZlY3RvcnNbIDAgXS54LCB2ZWN0b3JzWyAwIF0ueSApO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dGhpcy5saW5lVG8oIHZlY3RvcnNbIGkgXS54LCB2ZWN0b3JzWyBpIF0ueSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gc3RhcnRQYXRoKCkgZW5kUGF0aCgpP1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdtb3ZlVG8nLCBhcmdzOiBbIHgsIHkgXSB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuXHJcblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuTGluZUN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksIG5ldyBUSFJFRS5WZWN0b3IyKCB4LCB5ICkgKTtcclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdsaW5lVG8nLCBhcmdzOiBbIHgsIHkgXSB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XHJcblxyXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG5cclxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZShcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1B4LCBhQ1B5ICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYVgsIGFZIClcclxuXHQpO1xyXG5cclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdxdWFkcmF0aWNDdXJ2ZVRvJywgYXJnczogWyBhQ1B4LCBhQ1B5LCBhWCwgYVkgXSB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICkge1xyXG5cclxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuXHJcblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZShcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1AxeCwgYUNQMXkgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1AyeCwgYUNQMnkgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhWCwgYVkgKVxyXG5cdCk7XHJcblxyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogJ2JlemllckN1cnZlVG8nLCBhcmdzOiBbIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgXSB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuc3BsaW5lVGhydSA9IGZ1bmN0aW9uKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcclxuXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XHJcblxyXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG5cclxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG5cdHZhciBucHRzID0gWyBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICkgXTtcclxuXHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggbnB0cywgcHRzICk7XHJcblxyXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggbnB0cyApO1xyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogJ3NwbGluZVRocnUnLCBhcmdzOiBhcmdzIH0gKTtcclxuXHJcbn07XHJcblxyXG4vLyBGVVRVUkU6IENoYW5nZSB0aGUgQVBJIG9yIGZvbGxvdyBjYW52YXMgQVBJP1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYXJjID0gZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0dGhpcy5hYnNhcmMoIGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsXHJcblx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XHJcblxyXG4gfTtcclxuXHJcbiBUSFJFRS5QYXRoLnByb3RvdHlwZS5hYnNhcmMgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0dGhpcy5hYnNlbGxpcHNlKCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcclxuXHJcbiB9O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZWxsaXBzZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XHJcblxyXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0dGhpcy5hYnNlbGxpcHNlKCBhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcclxuXHJcbiB9O1xyXG5cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmFic2VsbGlwc2UgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xyXG5cclxuXHR2YXIgYXJncyA9IFtcclxuXHRcdGFYLCBhWSxcclxuXHRcdHhSYWRpdXMsIHlSYWRpdXMsXHJcblx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLFxyXG5cdFx0YUNsb2Nrd2lzZSxcclxuXHRcdGFSb3RhdGlvbiB8fCAwIC8vIGFSb3RhdGlvbiBpcyBvcHRpb25hbC5cclxuXHRdO1xyXG5cclxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuRWxsaXBzZUN1cnZlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdHZhciBsYXN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCggMSApO1xyXG5cdGFyZ3MucHVzaCggbGFzdFBvaW50LnggKTtcclxuXHRhcmdzLnB1c2goIGxhc3RQb2ludC55ICk7XHJcblxyXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogJ2VsbGlwc2UnLCBhcmdzOiBhcmdzIH0gKTtcclxuXHJcbiB9O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA0MDtcclxuXHJcblx0dmFyIHBvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBkaXZpc2lvbnM7IGkgKysgKSB7XHJcblxyXG5cdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApO1xyXG5cclxuXHRcdC8vaWYgKCAhdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICkgdGhyb3cgXCJESUVcIjtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIHRoaXMuYXV0b0Nsb3NlICkge1xyXG5cclxuXHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcblxyXG59O1xyXG5cclxuLyogUmV0dXJuIGFuIGFycmF5IG9mIHZlY3RvcnMgYmFzZWQgb24gY29udG91ciBvZiB0aGUgcGF0aCAqL1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcclxuXHJcblx0ZGl2aXNpb25zID0gZGl2aXNpb25zIHx8IDEyO1xyXG5cclxuXHR2YXIgYjIgPSBUSFJFRS5TaGFwZVV0aWxzLmIyO1xyXG5cdHZhciBiMyA9IFRIUkVFLlNoYXBlVXRpbHMuYjM7XHJcblxyXG5cdHZhciBwb2ludHMgPSBbXTtcclxuXHJcblx0dmFyIGNweCwgY3B5LCBjcHgyLCBjcHkyLCBjcHgxLCBjcHkxLCBjcHgwLCBjcHkwLFxyXG5cdFx0bGFzdGUsIHR4LCB0eTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5hY3Rpb25zLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGl0ZW0gPSB0aGlzLmFjdGlvbnNbIGkgXTtcclxuXHJcblx0XHR2YXIgYWN0aW9uID0gaXRlbS5hY3Rpb247XHJcblx0XHR2YXIgYXJncyA9IGl0ZW0uYXJncztcclxuXHJcblx0XHRzd2l0Y2ggKCBhY3Rpb24gKSB7XHJcblxyXG5cdFx0Y2FzZSAnbW92ZVRvJzpcclxuXHJcblx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMCBdLCBhcmdzWyAxIF0gKSApO1xyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSAnbGluZVRvJzpcclxuXHJcblx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMCBdLCBhcmdzWyAxIF0gKSApO1xyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSAncXVhZHJhdGljQ3VydmVUbyc6XHJcblxyXG5cdFx0XHRjcHggID0gYXJnc1sgMiBdO1xyXG5cdFx0XHRjcHkgID0gYXJnc1sgMyBdO1xyXG5cclxuXHRcdFx0Y3B4MSA9IGFyZ3NbIDAgXTtcclxuXHRcdFx0Y3B5MSA9IGFyZ3NbIDEgXTtcclxuXHJcblx0XHRcdGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGxhc3RlID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0XHRjcHgwID0gbGFzdGUueDtcclxuXHRcdFx0XHRjcHkwID0gbGFzdGUueTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XHJcblxyXG5cdFx0XHRcdGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xyXG5cdFx0XHRcdGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAxOyBqIDw9IGRpdmlzaW9uczsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHQgPSBqIC8gZGl2aXNpb25zO1xyXG5cclxuXHRcdFx0XHR0eCA9IGIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcclxuXHRcdFx0XHR0eSA9IGIyKCB0LCBjcHkwLCBjcHkxLCBjcHkgKTtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSAnYmV6aWVyQ3VydmVUbyc6XHJcblxyXG5cdFx0XHRjcHggID0gYXJnc1sgNCBdO1xyXG5cdFx0XHRjcHkgID0gYXJnc1sgNSBdO1xyXG5cclxuXHRcdFx0Y3B4MSA9IGFyZ3NbIDAgXTtcclxuXHRcdFx0Y3B5MSA9IGFyZ3NbIDEgXTtcclxuXHJcblx0XHRcdGNweDIgPSBhcmdzWyAyIF07XHJcblx0XHRcdGNweTIgPSBhcmdzWyAzIF07XHJcblxyXG5cdFx0XHRpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRsYXN0ZSA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdFx0Y3B4MCA9IGxhc3RlLng7XHJcblx0XHRcdFx0Y3B5MCA9IGxhc3RlLnk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xyXG5cclxuXHRcdFx0XHRjcHgwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXTtcclxuXHRcdFx0XHRjcHkwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDE7IGogPD0gZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdCA9IGogLyBkaXZpc2lvbnM7XHJcblxyXG5cdFx0XHRcdHR4ID0gYjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xyXG5cdFx0XHRcdHR5ID0gYjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xyXG5cclxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlICdzcGxpbmVUaHJ1JzpcclxuXHJcblx0XHRcdGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XHJcblxyXG5cdFx0XHR2YXIgbGFzdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdLCBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdICk7XHJcblx0XHRcdHZhciBzcHRzID0gWyBsYXN0IF07XHJcblxyXG5cdFx0XHR2YXIgbiA9IGRpdmlzaW9ucyAqIGFyZ3NbIDAgXS5sZW5ndGg7XHJcblxyXG5cdFx0XHRzcHRzID0gc3B0cy5jb25jYXQoIGFyZ3NbIDAgXSApO1xyXG5cclxuXHRcdFx0dmFyIHNwbGluZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggc3B0cyApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAxOyBqIDw9IG47IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBzcGxpbmUuZ2V0UG9pbnRBdCggaiAvIG4gKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSAnYXJjJzpcclxuXHJcblx0XHRcdHZhciBhWCA9IGFyZ3NbIDAgXSwgYVkgPSBhcmdzWyAxIF0sXHJcblx0XHRcdFx0YVJhZGl1cyA9IGFyZ3NbIDIgXSxcclxuXHRcdFx0XHRhU3RhcnRBbmdsZSA9IGFyZ3NbIDMgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNCBdLFxyXG5cdFx0XHRcdGFDbG9ja3dpc2UgPSAhISBhcmdzWyA1IF07XHJcblxyXG5cdFx0XHR2YXIgZGVsdGFBbmdsZSA9IGFFbmRBbmdsZSAtIGFTdGFydEFuZ2xlO1xyXG5cdFx0XHR2YXIgYW5nbGU7XHJcblx0XHRcdHZhciB0ZGl2aXNpb25zID0gZGl2aXNpb25zICogMjtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdCA9IGogLyB0ZGl2aXNpb25zO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ID0gMSAtIHQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YW5nbGUgPSBhU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xyXG5cclxuXHRcdFx0XHR0eCA9IGFYICsgYVJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0XHRcdHR5ID0gYVkgKyBhUmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3QnLCB0LCAnYW5nbGUnLCBhbmdsZSwgJ3R4JywgdHgsICd0eScsIHR5KTtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9jb25zb2xlLmxvZyhwb2ludHMpO1xyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSAnZWxsaXBzZSc6XHJcblxyXG5cdFx0XHR2YXIgYVggPSBhcmdzWyAwIF0sIGFZID0gYXJnc1sgMSBdLFxyXG5cdFx0XHRcdHhSYWRpdXMgPSBhcmdzWyAyIF0sXHJcblx0XHRcdFx0eVJhZGl1cyA9IGFyZ3NbIDMgXSxcclxuXHRcdFx0XHRhU3RhcnRBbmdsZSA9IGFyZ3NbIDQgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNSBdLFxyXG5cdFx0XHRcdGFDbG9ja3dpc2UgPSAhISBhcmdzWyA2IF0sXHJcblx0XHRcdFx0YVJvdGF0aW9uID0gYXJnc1sgNyBdO1xyXG5cclxuXHJcblx0XHRcdHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XHJcblx0XHRcdHZhciBhbmdsZTtcclxuXHRcdFx0dmFyIHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgKiAyO1xyXG5cclxuXHRcdFx0dmFyIGNvcywgc2luO1xyXG5cdFx0XHRpZiAoIGFSb3RhdGlvbiAhPT0gMCApIHtcclxuXHJcblx0XHRcdFx0Y29zID0gTWF0aC5jb3MoIGFSb3RhdGlvbiApO1xyXG5cdFx0XHRcdHNpbiA9IE1hdGguc2luKCBhUm90YXRpb24gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdCA9IGogLyB0ZGl2aXNpb25zO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ID0gMSAtIHQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YW5nbGUgPSBhU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xyXG5cclxuXHRcdFx0XHR0eCA9IGFYICsgeFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0XHRcdHR5ID0gYVkgKyB5UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdFx0XHRcdGlmICggYVJvdGF0aW9uICE9PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB4ID0gdHgsIHkgPSB0eTtcclxuXHJcblx0XHRcdFx0XHQvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXHJcblx0XHRcdFx0XHR0eCA9ICggeCAtIGFYICkgKiBjb3MgLSAoIHkgLSBhWSApICogc2luICsgYVg7XHJcblx0XHRcdFx0XHR0eSA9ICggeCAtIGFYICkgKiBzaW4gKyAoIHkgLSBhWSApICogY29zICsgYVk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xyXG5cclxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKHBvaW50cyk7XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHR9IC8vIGVuZCBzd2l0Y2hcclxuXHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIE5vcm1hbGl6ZSB0byByZW1vdmUgdGhlIGNsb3NpbmcgcG9pbnQgYnkgZGVmYXVsdC5cclxuXHR2YXIgbGFzdFBvaW50ID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xyXG5cdGlmICggTWF0aC5hYnMoIGxhc3RQb2ludC54IC0gcG9pbnRzWyAwIF0ueCApIDwgTnVtYmVyLkVQU0lMT04gJiZcclxuXHRcdFx0IE1hdGguYWJzKCBsYXN0UG9pbnQueSAtIHBvaW50c1sgMCBdLnkgKSA8IE51bWJlci5FUFNJTE9OIClcclxuXHRcdHBvaW50cy5zcGxpY2UoIHBvaW50cy5sZW5ndGggLSAxLCAxICk7XHJcblxyXG5cdGlmICggdGhpcy5hdXRvQ2xvc2UgKSB7XHJcblxyXG5cdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxuXHJcbn07XHJcblxyXG4vL1xyXG4vLyBCcmVha3MgcGF0aCBpbnRvIHNoYXBlc1xyXG4vL1xyXG4vL1x0QXNzdW1wdGlvbnMgKGlmIHBhcmFtZXRlciBpc0NDVz09dHJ1ZSB0aGUgb3Bwb3NpdGUgaG9sZHMpOlxyXG4vL1x0LSBzb2xpZCBzaGFwZXMgYXJlIGRlZmluZWQgY2xvY2t3aXNlIChDVylcclxuLy9cdC0gaG9sZXMgYXJlIGRlZmluZWQgY291bnRlcmNsb2Nrd2lzZSAoQ0NXKVxyXG4vL1xyXG4vL1x0SWYgcGFyYW1ldGVyIG5vSG9sZXM9PXRydWU6XHJcbi8vICAtIGFsbCBzdWJQYXRocyBhcmUgcmVnYXJkZWQgYXMgc29saWQgc2hhcGVzXHJcbi8vICAtIGRlZmluaXRpb24gb3JkZXIgQ1cvQ0NXIGhhcyBubyByZWxldmFuY2VcclxuLy9cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLnRvU2hhcGVzID0gZnVuY3Rpb24oIGlzQ0NXLCBub0hvbGVzICkge1xyXG5cclxuXHRmdW5jdGlvbiBleHRyYWN0U3VicGF0aHMoIGluQWN0aW9ucyApIHtcclxuXHJcblx0XHR2YXIgc3ViUGF0aHMgPSBbXSwgbGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluQWN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGl0ZW0gPSBpbkFjdGlvbnNbIGkgXTtcclxuXHJcblx0XHRcdHZhciBhcmdzID0gaXRlbS5hcmdzO1xyXG5cdFx0XHR2YXIgYWN0aW9uID0gaXRlbS5hY3Rpb247XHJcblxyXG5cdFx0XHRpZiAoIGFjdGlvbiA9PT0gJ21vdmVUbycgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbGFzdFBhdGguYWN0aW9ucy5sZW5ndGggIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0c3ViUGF0aHMucHVzaCggbGFzdFBhdGggKTtcclxuXHRcdFx0XHRcdGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGFzdFBhdGhbIGFjdGlvbiBdLmFwcGx5KCBsYXN0UGF0aCwgYXJncyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9PSAwICkge1xyXG5cclxuXHRcdFx0c3ViUGF0aHMucHVzaCggbGFzdFBhdGggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coc3ViUGF0aHMpO1xyXG5cclxuXHRcdHJldHVyblx0c3ViUGF0aHM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKCBpblN1YnBhdGhzICkge1xyXG5cclxuXHRcdHZhciBzaGFwZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpblN1YnBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdG1wUGF0aCA9IGluU3VicGF0aHNbIGkgXTtcclxuXHJcblx0XHRcdHZhciB0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xyXG5cdFx0XHR0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xyXG5cdFx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcclxuXHJcblx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcclxuXHJcblx0XHRyZXR1cm4gc2hhcGVzO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBpblB0LCBpblBvbHlnb24gKSB7XHJcblxyXG5cdFx0dmFyIHBvbHlMZW4gPSBpblBvbHlnb24ubGVuZ3RoO1xyXG5cclxuXHRcdC8vIGluUHQgb24gcG9seWdvbiBjb250b3VyID0+IGltbWVkaWF0ZSBzdWNjZXNzICAgIG9yXHJcblx0XHQvLyB0b2dnbGluZyBvZiBpbnNpZGUvb3V0c2lkZSBhdCBldmVyeSBzaW5nbGUhIGludGVyc2VjdGlvbiBwb2ludCBvZiBhbiBlZGdlXHJcblx0XHQvLyAgd2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lIHRocm91Z2ggaW5QdCwgbGVmdCBvZiBpblB0XHJcblx0XHQvLyAgbm90IGNvdW50aW5nIGxvd2VyWSBlbmRwb2ludHMgb2YgZWRnZXMgYW5kIHdob2xlIGVkZ2VzIG9uIHRoYXQgbGluZVxyXG5cdFx0dmFyIGluc2lkZSA9IGZhbHNlO1xyXG5cdFx0Zm9yICggdmFyIHAgPSBwb2x5TGVuIC0gMSwgcSA9IDA7IHEgPCBwb2x5TGVuOyBwID0gcSArKyApIHtcclxuXHJcblx0XHRcdHZhciBlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBwIF07XHJcblx0XHRcdHZhciBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBxIF07XHJcblxyXG5cdFx0XHR2YXIgZWRnZUR4ID0gZWRnZUhpZ2hQdC54IC0gZWRnZUxvd1B0Lng7XHJcblx0XHRcdHZhciBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIGVkZ2VEeSApID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vdCBwYXJhbGxlbFxyXG5cdFx0XHRcdGlmICggZWRnZUR5IDwgMCApIHtcclxuXHJcblx0XHRcdFx0XHRlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBxIF07IGVkZ2VEeCA9IC0gZWRnZUR4O1xyXG5cdFx0XHRcdFx0ZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdOyBlZGdlRHkgPSAtIGVkZ2VEeTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICggKCBpblB0LnkgPCBlZGdlTG93UHQueSApIHx8ICggaW5QdC55ID4gZWRnZUhpZ2hQdC55ICkgKSBcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdGlmICggaW5QdC55ID09PSBlZGdlTG93UHQueSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGluUHQueCA9PT0gZWRnZUxvd1B0LnggKVx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XHJcblx0XHRcdFx0XHQvLyBjb250aW51ZTtcdFx0XHRcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgcGVycEVkZ2UgPSBlZGdlRHkgKiAoIGluUHQueCAtIGVkZ2VMb3dQdC54ICkgLSBlZGdlRHggKiAoIGluUHQueSAtIGVkZ2VMb3dQdC55ICk7XHJcblx0XHRcdFx0XHRpZiAoIHBlcnBFZGdlID09PSAwIClcdFx0XHRcdHJldHVyblx0dHJ1ZTtcdFx0Ly8gaW5QdCBpcyBvbiBjb250b3VyID9cclxuXHRcdFx0XHRcdGlmICggcGVycEVkZ2UgPCAwICkgXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdGluc2lkZSA9ICEgaW5zaWRlO1x0XHQvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gcGFyYWxsZWwgb3IgY29sbGluZWFyXHJcblx0XHRcdFx0aWYgKCBpblB0LnkgIT09IGVkZ2VMb3dQdC55ICkgXHRcdGNvbnRpbnVlO1x0XHRcdC8vIHBhcmFsbGVsXHJcblx0XHRcdFx0Ly8gZWRnZSBsaWVzIG9uIHRoZSBzYW1lIGhvcml6b250YWwgbGluZSBhcyBpblB0XHJcblx0XHRcdFx0aWYgKCAoICggZWRnZUhpZ2hQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VMb3dQdC54ICkgKSB8fFxyXG5cdFx0XHRcdFx0ICggKCBlZGdlTG93UHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlSGlnaFB0LnggKSApIClcdFx0cmV0dXJuXHR0cnVlO1x0Ly8gaW5QdDogUG9pbnQgb24gY29udG91ciAhXHJcblx0XHRcdFx0Ly8gY29udGludWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVyblx0aW5zaWRlO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBpc0Nsb2NrV2lzZSA9IFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2U7XHJcblxyXG5cdHZhciBzdWJQYXRocyA9IGV4dHJhY3RTdWJwYXRocyggdGhpcy5hY3Rpb25zICk7XHJcblx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XHJcblxyXG5cdGlmICggbm9Ib2xlcyA9PT0gdHJ1ZSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcclxuXHJcblxyXG5cdHZhciBzb2xpZCwgdG1wUGF0aCwgdG1wU2hhcGUsIHNoYXBlcyA9IFtdO1xyXG5cclxuXHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMSApIHtcclxuXHJcblx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIDAgXTtcclxuXHRcdHRtcFNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XHJcblx0XHR0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xyXG5cdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XHJcblx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcclxuXHRcdHJldHVybiBzaGFwZXM7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGhvbGVzRmlyc3QgPSAhIGlzQ2xvY2tXaXNlKCBzdWJQYXRoc1sgMCBdLmdldFBvaW50cygpICk7XHJcblx0aG9sZXNGaXJzdCA9IGlzQ0NXID8gISBob2xlc0ZpcnN0IDogaG9sZXNGaXJzdDtcclxuXHJcblx0Ly8gY29uc29sZS5sb2coXCJIb2xlcyBmaXJzdFwiLCBob2xlc0ZpcnN0KTtcclxuXHJcblx0dmFyIGJldHRlclNoYXBlSG9sZXMgPSBbXTtcclxuXHR2YXIgbmV3U2hhcGVzID0gW107XHJcblx0dmFyIG5ld1NoYXBlSG9sZXMgPSBbXTtcclxuXHR2YXIgbWFpbklkeCA9IDA7XHJcblx0dmFyIHRtcFBvaW50cztcclxuXHJcblx0bmV3U2hhcGVzWyBtYWluSWR4IF0gPSB1bmRlZmluZWQ7XHJcblx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyBpIF07XHJcblx0XHR0bXBQb2ludHMgPSB0bXBQYXRoLmdldFBvaW50cygpO1xyXG5cdFx0c29saWQgPSBpc0Nsb2NrV2lzZSggdG1wUG9pbnRzICk7XHJcblx0XHRzb2xpZCA9IGlzQ0NXID8gISBzb2xpZCA6IHNvbGlkO1xyXG5cclxuXHRcdGlmICggc29saWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoICggISBob2xlc0ZpcnN0ICkgJiYgKCBuZXdTaGFwZXNbIG1haW5JZHggXSApIClcdG1haW5JZHggKys7XHJcblxyXG5cdFx0XHRuZXdTaGFwZXNbIG1haW5JZHggXSA9IHsgczogbmV3IFRIUkVFLlNoYXBlKCksIHA6IHRtcFBvaW50cyB9O1xyXG5cdFx0XHRuZXdTaGFwZXNbIG1haW5JZHggXS5zLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XHJcblx0XHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdLnMuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XHJcblxyXG5cdFx0XHRpZiAoIGhvbGVzRmlyc3QgKVx0bWFpbklkeCArKztcclxuXHRcdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdjdycsIGkpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0ucHVzaCggeyBoOiB0bXBQYXRoLCBwOiB0bXBQb2ludHNbIDAgXSB9ICk7XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdjY3cnLCBpKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gb25seSBIb2xlcz8gLT4gcHJvYmFibHkgYWxsIFNoYXBlcyB3aXRoIHdyb25nIG9yaWVudGF0aW9uXHJcblx0aWYgKCAhIG5ld1NoYXBlc1sgMCBdIClcdHJldHVyblx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xyXG5cclxuXHJcblx0aWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHR2YXIgYW1iaWd1b3VzID0gZmFsc2U7XHJcblx0XHR2YXIgdG9DaGFuZ2UgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcclxuXHJcblx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHNJZHggXSA9IFtdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcclxuXHJcblx0XHRcdHZhciBzaG8gPSBuZXdTaGFwZUhvbGVzWyBzSWR4IF07XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaElkeCA9IDA7IGhJZHggPCBzaG8ubGVuZ3RoOyBoSWR4ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaG8gPSBzaG9bIGhJZHggXTtcclxuXHRcdFx0XHR2YXIgaG9sZV91bmFzc2lnbmVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBoby5wLCBuZXdTaGFwZXNbIHMySWR4IF0ucCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBzSWR4ICE9PSBzMklkeCApXHR0b0NoYW5nZS5wdXNoKCB7IGZyb21zOiBzSWR4LCB0b3M6IHMySWR4LCBob2xlOiBoSWR4IH0gKTtcclxuXHRcdFx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHMySWR4IF0ucHVzaCggaG8gKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGFtYmlndW91cyA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdLnB1c2goIGhvICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblx0XHQvLyBjb25zb2xlLmxvZyhcImFtYmlndW91czogXCIsIGFtYmlndW91cyk7XHJcblx0XHRpZiAoIHRvQ2hhbmdlLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcInRvIGNoYW5nZTogXCIsIHRvQ2hhbmdlKTtcclxuXHRcdFx0aWYgKCAhIGFtYmlndW91cyApXHRuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIHRtcEhvbGVzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbmV3U2hhcGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdHRtcFNoYXBlID0gbmV3U2hhcGVzWyBpIF0ucztcclxuXHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG5cdFx0dG1wSG9sZXMgPSBuZXdTaGFwZUhvbGVzWyBpIF07XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHRtcEhvbGVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCggdG1wSG9sZXNbIGogXS5oICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xyXG5cclxuXHRyZXR1cm4gc2hhcGVzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL1NoYXBlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXHJcbiAqKi9cclxuXHJcbi8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxyXG4vLyBTVEVQIDIgVHVybiBwYXRoIGludG8gc2hhcGUuXHJcbi8vIFNURVAgMyBFeHRydWRlR2VvbWV0cnkgdGFrZXMgaW4gU2hhcGUvU2hhcGVzXHJcbi8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcclxuLy8gU1RFUCAzYiAtIFRyaWFuZ3VsYXRlIGVhY2ggc2hhcGUsIGFkZCBmYWNlcy5cclxuXHJcblRIUkVFLlNoYXBlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5QYXRoLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuXHJcblx0dGhpcy5ob2xlcyA9IFtdO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBhdGgucHJvdG90eXBlICk7XHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNoYXBlO1xyXG5cclxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBFeHRydWRlR2VvbWV0cnlcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRydWRlID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xyXG5cclxufTtcclxuXHJcbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gU2hhcGVHZW9tZXRyeVxyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLm1ha2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5TaGFwZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHBvaW50cyBvZiBob2xlc1xyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFBvaW50c0hvbGVzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdHZhciBob2xlc1B0cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0aG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRQb2ludHMoIGRpdmlzaW9ucyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBob2xlc1B0cztcclxuXHJcbn07XHJcblxyXG5cclxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKGtleXBvaW50cyBiYXNlZCBvbiBzZWdtZW50cyBwYXJhbWV0ZXIpXHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdHNoYXBlOiB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zICksXHJcblx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5leHRyYWN0QWxsUG9pbnRzKCBkaXZpc2lvbnMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRMaW5lXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkxpbmVDdXJ2ZSA9IGZ1bmN0aW9uICggdjEsIHYyICkge1xyXG5cclxuXHR0aGlzLnYxID0gdjE7XHJcblx0dGhpcy52MiA9IHYyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVDdXJ2ZTtcclxuXHJcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdHZhciBwb2ludCA9IHRoaXMudjIuY2xvbmUoKS5zdWIoIHRoaXMudjEgKTtcclxuXHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xyXG5cclxuXHRyZXR1cm4gcG9pbnQ7XHJcblxyXG59O1xyXG5cclxuLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XHJcblxyXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLmdldFBvaW50KCB1ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciB0YW5nZW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1YiggdGhpcy52MSApO1xyXG5cclxuXHRyZXR1cm4gdGFuZ2VudC5ub3JtYWxpemUoKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlLmpzXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdFF1YWRyYXRpYyBCZXppZXIgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlID0gZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xyXG5cclxuXHR0aGlzLnYwID0gdjA7XHJcblx0dGhpcy52MSA9IHYxO1xyXG5cdHRoaXMudjIgPSB2MjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmU7XHJcblxyXG5cclxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHR2YXIgYjIgPSBUSFJFRS5TaGFwZVV0aWxzLmIyO1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoXHJcblx0XHRiMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApLFxyXG5cdFx0YjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKVxyXG5cdCk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciB0YW5nZW50UXVhZHJhdGljQmV6aWVyID0gVEhSRUUuQ3VydmVVdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyO1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoXHJcblx0XHR0YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICksXHJcblx0XHR0YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55IClcclxuXHQpLm5vcm1hbGl6ZSgpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDdWJpYyBCZXppZXIgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uICggdjAsIHYxLCB2MiwgdjMgKSB7XHJcblxyXG5cdHRoaXMudjAgPSB2MDtcclxuXHR0aGlzLnYxID0gdjE7XHJcblx0dGhpcy52MiA9IHYyO1xyXG5cdHRoaXMudjMgPSB2MztcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmljQmV6aWVyQ3VydmU7XHJcblxyXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0dmFyIGIzID0gVEhSRUUuU2hhcGVVdGlscy5iMztcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCBcclxuXHRcdGIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKSxcclxuXHRcdGIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKVxyXG5cdCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHR2YXIgdGFuZ2VudEN1YmljQmV6aWVyID0gVEhSRUUuQ3VydmVVdGlscy50YW5nZW50Q3ViaWNCZXppZXI7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggXHJcblx0XHR0YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApLFxyXG5cdFx0dGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKVxyXG5cdCkubm9ybWFsaXplKCk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRTcGxpbmUgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUgPSBmdW5jdGlvbiAoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IyICovICkge1xyXG5cclxuXHR0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwbGluZUN1cnZlO1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XHJcblx0dmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcclxuXHJcblx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuXHR2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcblx0dmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xyXG5cdHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF07XHJcblx0dmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XHJcblx0dmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XHJcblxyXG5cdHZhciBpbnRlcnBvbGF0ZSA9IFRIUkVFLkN1cnZlVXRpbHMuaW50ZXJwb2xhdGU7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMihcclxuXHRcdGludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICksXHJcblx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApXHJcblx0KTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0VsbGlwc2VDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRFbGxpcHNlIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkVsbGlwc2VDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XHJcblxyXG5cdHRoaXMuYVggPSBhWDtcclxuXHR0aGlzLmFZID0gYVk7XHJcblxyXG5cdHRoaXMueFJhZGl1cyA9IHhSYWRpdXM7XHJcblx0dGhpcy55UmFkaXVzID0geVJhZGl1cztcclxuXHJcblx0dGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlO1xyXG5cdHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlO1xyXG5cclxuXHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xyXG5cdFxyXG5cdHRoaXMuYVJvdGF0aW9uID0gYVJvdGF0aW9uIHx8IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWxsaXBzZUN1cnZlO1xyXG5cclxuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0dmFyIGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XHJcblxyXG5cdGlmICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IE1hdGguUEkgKiAyO1xyXG5cdGlmICggZGVsdGFBbmdsZSA+IE1hdGguUEkgKiAyICkgZGVsdGFBbmdsZSAtPSBNYXRoLlBJICogMjtcclxuXHJcblx0dmFyIGFuZ2xlO1xyXG5cclxuXHRpZiAoIHRoaXMuYUNsb2Nrd2lzZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRhbmdsZSA9IHRoaXMuYUVuZEFuZ2xlICsgKCAxIC0gdCApICogKCBNYXRoLlBJICogMiAtIGRlbHRhQW5nbGUgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcclxuXHJcblx0fVxyXG5cdFxyXG5cdHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG5cdHZhciB5ID0gdGhpcy5hWSArIHRoaXMueVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xyXG5cclxuXHRpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xyXG5cclxuXHRcdHZhciBjb3MgPSBNYXRoLmNvcyggdGhpcy5hUm90YXRpb24gKTtcclxuXHRcdHZhciBzaW4gPSBNYXRoLnNpbiggdGhpcy5hUm90YXRpb24gKTtcclxuXHJcblx0XHR2YXIgdHggPSB4LCB0eSA9IHk7XHJcblxyXG5cdFx0Ly8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxyXG5cdFx0eCA9ICggdHggLSB0aGlzLmFYICkgKiBjb3MgLSAoIHR5IC0gdGhpcy5hWSApICogc2luICsgdGhpcy5hWDtcclxuXHRcdHkgPSAoIHR4IC0gdGhpcy5hWCApICogc2luICsgKCB0eSAtIHRoaXMuYVkgKSAqIGNvcyArIHRoaXMuYVk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB4LCB5ICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9BcmNDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRBcmMgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQXJjQ3VydmUgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0VEhSRUUuRWxsaXBzZUN1cnZlLmNhbGwoIHRoaXMsIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFyY0N1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQXJjQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJjQ3VydmU7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZTMuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0TGluZTNEXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG5cdGZ1bmN0aW9uICggdjEsIHYyICkge1xyXG5cclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHJcblx0fSxcclxuXHJcblx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHZlY3Rvci5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICk7IC8vIGRpZmZcclxuXHRcdHZlY3Rvci5tdWx0aXBseVNjYWxhciggdCApO1xyXG5cdFx0dmVjdG9yLmFkZCggdGhpcy52MSApO1xyXG5cclxuXHRcdHJldHVybiB2ZWN0b3I7XHJcblxyXG5cdH1cclxuXHJcbik7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlMy5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRRdWFkcmF0aWMgQmV6aWVyIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcclxuXHJcblx0ZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xyXG5cclxuXHRcdHRoaXMudjAgPSB2MDtcclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHJcblx0fSxcclxuXHJcblx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciBiMiA9IFRIUkVFLlNoYXBlVXRpbHMuYjI7XHRcdFxyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcclxuXHRcdFx0YjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKSxcclxuXHRcdFx0YjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKSxcclxuXHRcdFx0YjIoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnogKVxyXG5cdFx0KTtcclxuXHJcblx0fVxyXG5cclxuKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZTMuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0Q3ViaWMgQmV6aWVyIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuXHRmdW5jdGlvbiAoIHYwLCB2MSwgdjIsIHYzICkge1xyXG5cclxuXHRcdHRoaXMudjAgPSB2MDtcclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHRcdHRoaXMudjMgPSB2MztcclxuXHJcblx0fSxcclxuXHJcblx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciBiMyA9IFRIUkVFLlNoYXBlVXRpbHMuYjM7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG5cdFx0XHRiMyggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICksXHJcblx0XHRcdGIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKSxcclxuXHRcdFx0YjMoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnosIHRoaXMudjMueiApXHJcblx0XHQpO1xyXG5cclxuXHR9XHJcblxyXG4pO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZTMuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0U3BsaW5lIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG5USFJFRS5TcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG5cdGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU3BsaW5lQ3VydmUzIHdpbGwgYmUgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzJyApO1xyXG5cdFx0dGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG5cdFx0dmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcclxuXHJcblx0XHR2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG5cdFx0dmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XHJcblxyXG5cdFx0dmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XHJcblx0XHR2YXIgcG9pbnQxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xyXG5cdFx0dmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XHJcblx0XHR2YXIgcG9pbnQzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcclxuXHJcblx0XHR2YXIgaW50ZXJwb2xhdGUgPSBUSFJFRS5DdXJ2ZVV0aWxzLmludGVycG9sYXRlO1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcclxuXHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKSxcclxuXHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKSxcclxuXHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC56LCBwb2ludDEueiwgcG9pbnQyLnosIHBvaW50My56LCB3ZWlnaHQgKVxyXG5cdFx0KTtcclxuXHJcblx0fVxyXG5cclxuKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ2F0bXVsbFJvbUN1cnZlMy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKlxyXG4gKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xyXG4gKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cclxuICogaHR0cDovL3d3dy5jZW15dWtzZWwuY29tL3Jlc2VhcmNoL2NhdG11bGxyb21fcGFyYW0vY2F0bXVsbHJvbS5wZGZcclxuICpcclxuICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXHJcbiAqIGN1cnZlLnRlbnNpb24gaXMgdXNlZCBmb3IgY2F0bXVsbHJvbSB3aGljaCBkZWZhdWx0cyB0byAwLjVcclxuICovXHJcblxyXG5USFJFRS5DYXRtdWxsUm9tQ3VydmUzID0gKCBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyXHJcblx0XHR0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0cHggPSBuZXcgQ3ViaWNQb2x5KCksXHJcblx0XHRweSA9IG5ldyBDdWJpY1BvbHkoKSxcclxuXHRcdHB6ID0gbmV3IEN1YmljUG9seSgpO1xyXG5cclxuXHQvKlxyXG5cdEJhc2VkIG9uIGFuIG9wdGltaXplZCBjKysgc29sdXRpb24gaW5cclxuXHQgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xyXG5cdCAtIGh0dHA6Ly9pZGVvbmUuY29tL05vRWJWTVxyXG5cclxuXHRUaGlzIEN1YmljUG9seSBjbGFzcyBjb3VsZCBiZSB1c2VkIGZvciByZXVzaW5nIHNvbWUgdmFyaWFibGVzIGFuZCBjYWxjdWxhdGlvbnMsXHJcblx0YnV0IGZvciB0aHJlZS5qcyBjdXJ2ZSB1c2UsIGl0IGNvdWxkIGJlIHBvc3NpYmxlIGlubGluZWQgYW5kIGZsYXR0ZW4gaW50byBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsXHJcblx0d2hpY2ggY2FuIGJlIHBsYWNlZCBpbiBDdXJ2ZVV0aWxzLlxyXG5cdCovXHJcblxyXG5cdGZ1bmN0aW9uIEN1YmljUG9seSgpIHtcclxuXHJcblx0fVxyXG5cclxuXHQvKlxyXG5cdCAqIENvbXB1dGUgY29lZmZpY2llbnRzIGZvciBhIGN1YmljIHBvbHlub21pYWxcclxuXHQgKiAgIHAocykgPSBjMCArIGMxKnMgKyBjMipzXjIgKyBjMypzXjNcclxuXHQgKiBzdWNoIHRoYXRcclxuXHQgKiAgIHAoMCkgPSB4MCwgcCgxKSA9IHgxXHJcblx0ICogIGFuZFxyXG5cdCAqICAgcCcoMCkgPSB0MCwgcCcoMSkgPSB0MS5cclxuXHQgKi9cclxuXHRDdWJpY1BvbHkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiggeDAsIHgxLCB0MCwgdDEgKSB7XHJcblxyXG5cdFx0dGhpcy5jMCA9IHgwO1xyXG5cdFx0dGhpcy5jMSA9IHQwO1xyXG5cdFx0dGhpcy5jMiA9IC0gMyAqIHgwICsgMyAqIHgxIC0gMiAqIHQwIC0gdDE7XHJcblx0XHR0aGlzLmMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcclxuXHJcblx0fTtcclxuXHJcblx0Q3ViaWNQb2x5LnByb3RvdHlwZS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIGR0MCwgZHQxLCBkdDIgKSB7XHJcblxyXG5cdFx0Ly8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxyXG5cdFx0dmFyIHQxID0gKCB4MSAtIHgwICkgLyBkdDAgLSAoIHgyIC0geDAgKSAvICggZHQwICsgZHQxICkgKyAoIHgyIC0geDEgKSAvIGR0MTtcclxuXHRcdHZhciB0MiA9ICggeDIgLSB4MSApIC8gZHQxIC0gKCB4MyAtIHgxICkgLyAoIGR0MSArIGR0MiApICsgKCB4MyAtIHgyICkgLyBkdDI7XHJcblxyXG5cdFx0Ly8gcmVzY2FsZSB0YW5nZW50cyBmb3IgcGFyYW1ldHJpemF0aW9uIGluIFswLDFdXHJcblx0XHR0MSAqPSBkdDE7XHJcblx0XHR0MiAqPSBkdDE7XHJcblxyXG5cdFx0Ly8gaW5pdEN1YmljUG9seVxyXG5cdFx0dGhpcy5pbml0KCB4MSwgeDIsIHQxLCB0MiApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBzdGFuZGFyZCBDYXRtdWxsLVJvbSBzcGxpbmU6IGludGVycG9sYXRlIGJldHdlZW4geDEgYW5kIHgyIHdpdGggcHJldmlvdXMvZm9sbG93aW5nIHBvaW50cyB4MS94NFxyXG5cdEN1YmljUG9seS5wcm90b3R5cGUuaW5pdENhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5pbml0KCB4MSwgeDIsIHRlbnNpb24gKiAoIHgyIC0geDAgKSwgdGVuc2lvbiAqICggeDMgLSB4MSApICk7XHJcblxyXG5cdH07XHJcblxyXG5cdEN1YmljUG9seS5wcm90b3R5cGUuY2FsYyA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHRcdHZhciB0MiA9IHQgKiB0O1xyXG5cdFx0dmFyIHQzID0gdDIgKiB0O1xyXG5cdFx0cmV0dXJuIHRoaXMuYzAgKyB0aGlzLmMxICogdCArIHRoaXMuYzIgKiB0MiArIHRoaXMuYzMgKiB0MztcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gU3ViY2xhc3MgVGhyZWUuanMgY3VydmVcclxuXHRyZXR1cm4gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuXHRcdGZ1bmN0aW9uICggcCAvKiBhcnJheSBvZiBWZWN0b3IzICovICkge1xyXG5cclxuXHRcdFx0dGhpcy5wb2ludHMgPSBwIHx8IFtdO1xyXG5cdFx0XHR0aGlzLmNsb3NlZCA9IGZhbHNlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxyXG5cdFx0XHRcdHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0LCBsO1xyXG5cclxuXHRcdFx0bCA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIGwgPCAyICkgY29uc29sZS5sb2coICdkdWgsIHlvdSBuZWVkIGF0IGxlYXN0IDIgcG9pbnRzJyApO1xyXG5cclxuXHRcdFx0cG9pbnQgPSAoIGwgLSAoIHRoaXMuY2xvc2VkID8gMCA6IDEgKSApICogdDtcclxuXHRcdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG5cdFx0XHR3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmNsb3NlZCApIHtcclxuXHJcblx0XHRcdFx0aW50UG9pbnQgKz0gaW50UG9pbnQgPiAwID8gMCA6ICggTWF0aC5mbG9vciggTWF0aC5hYnMoIGludFBvaW50ICkgLyBwb2ludHMubGVuZ3RoICkgKyAxICkgKiBwb2ludHMubGVuZ3RoO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggd2VpZ2h0ID09PSAwICYmIGludFBvaW50ID09PSBsIC0gMSApIHtcclxuXHJcblx0XHRcdFx0aW50UG9pbnQgPSBsIC0gMjtcclxuXHRcdFx0XHR3ZWlnaHQgPSAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHAwLCBwMSwgcDIsIHAzOyAvLyA0IHBvaW50c1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHAwID0gcG9pbnRzWyAoIGludFBvaW50IC0gMSApICUgbCBdO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gZXh0cmFwb2xhdGUgZmlyc3QgcG9pbnRcclxuXHRcdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xyXG5cdFx0XHRcdHAwID0gdG1wO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cDEgPSBwb2ludHNbIGludFBvaW50ICUgbCBdO1xyXG5cdFx0XHRwMiA9IHBvaW50c1sgKCBpbnRQb2ludCArIDEgKSAlIGwgXTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgKyAyIDwgbCApIHtcclxuXHJcblx0XHRcdFx0cDMgPSBwb2ludHNbICggaW50UG9pbnQgKyAyICkgJSBsIF07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBleHRyYXBvbGF0ZSBsYXN0IHBvaW50XHJcblx0XHRcdFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgbCAtIDEgXSwgcG9pbnRzWyBsIC0gMiBdICkuYWRkKCBwb2ludHNbIGwgLSAxIF0gKTtcclxuXHRcdFx0XHRwMyA9IHRtcDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdGhpcy50eXBlID09PSB1bmRlZmluZWQgfHwgdGhpcy50eXBlID09PSAnY2VudHJpcGV0YWwnIHx8IHRoaXMudHlwZSA9PT0gJ2Nob3JkYWwnICkge1xyXG5cclxuXHRcdFx0XHQvLyBpbml0IENlbnRyaXBldGFsIC8gQ2hvcmRhbCBDYXRtdWxsLVJvbVxyXG5cdFx0XHRcdHZhciBwb3cgPSB0aGlzLnR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XHJcblx0XHRcdFx0dmFyIGR0MCA9IE1hdGgucG93KCBwMC5kaXN0YW5jZVRvU3F1YXJlZCggcDEgKSwgcG93ICk7XHJcblx0XHRcdFx0dmFyIGR0MSA9IE1hdGgucG93KCBwMS5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSwgcG93ICk7XHJcblx0XHRcdFx0dmFyIGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XHJcblxyXG5cdFx0XHRcdC8vIHNhZmV0eSBjaGVjayBmb3IgcmVwZWF0ZWQgcG9pbnRzXHJcblx0XHRcdFx0aWYgKCBkdDEgPCAxZS00ICkgZHQxID0gMS4wO1xyXG5cdFx0XHRcdGlmICggZHQwIDwgMWUtNCApIGR0MCA9IGR0MTtcclxuXHRcdFx0XHRpZiAoIGR0MiA8IDFlLTQgKSBkdDIgPSBkdDE7XHJcblxyXG5cdFx0XHRcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xyXG5cdFx0XHRcdHB5LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgZHQwLCBkdDEsIGR0MiApO1xyXG5cdFx0XHRcdHB6LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgZHQwLCBkdDEsIGR0MiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy50eXBlID09PSAnY2F0bXVsbHJvbScgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ZW5zaW9uID0gdGhpcy50ZW5zaW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLnRlbnNpb24gOiAwLjU7XHJcblx0XHRcdFx0cHguaW5pdENhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIHRlbnNpb24gKTtcclxuXHRcdFx0XHRweS5pbml0Q2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgdGVuc2lvbiApO1xyXG5cdFx0XHRcdHB6LmluaXRDYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCB0ZW5zaW9uICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG5cdFx0XHRcdHB4LmNhbGMoIHdlaWdodCApLFxyXG5cdFx0XHRcdHB5LmNhbGMoIHdlaWdodCApLFxyXG5cdFx0XHRcdHB6LmNhbGMoIHdlaWdodCApXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdjtcclxuXHJcblx0XHR9XHJcblxyXG5cdCk7XHJcblxyXG59ICkoKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ2xvc2VkU3BsaW5lQ3VydmUzLmpzXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdENsb3NlZCBTcGxpbmUgM0QgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcblRIUkVFLkNsb3NlZFNwbGluZUN1cnZlMyA9IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzLicgKTtcclxuXHJcblx0VEhSRUUuQ2F0bXVsbFJvbUN1cnZlMy5jYWxsKCB0aGlzLCBwb2ludHMgKTtcclxuXHR0aGlzLnR5cGUgPSAnY2F0bXVsbHJvbSc7XHJcblx0dGhpcy5jbG9zZWQgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNsb3NlZFNwbGluZUN1cnZlMy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZSApO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQm94R2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvQ3ViZS5hc1xyXG4gKi9cclxuXHJcblRIUkVFLkJveEdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0JveEdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXHJcblx0XHRkZXB0aDogZGVwdGgsXHJcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG5cdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxyXG5cdFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xyXG5cdH07XHJcblxyXG5cdHRoaXMud2lkdGhTZWdtZW50cyA9IHdpZHRoU2VnbWVudHMgfHwgMTtcclxuXHR0aGlzLmhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcclxuXHR0aGlzLmRlcHRoU2VnbWVudHMgPSBkZXB0aFNlZ21lbnRzIHx8IDE7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xyXG5cdHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XHJcblx0dmFyIGRlcHRoX2hhbGYgPSBkZXB0aCAvIDI7XHJcblxyXG5cdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAtIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgd2lkdGhfaGFsZiwgMCApOyAvLyBweFxyXG5cdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAgIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgLSB3aWR0aF9oYWxmLCAxICk7IC8vIG54XHJcblx0YnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgICAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodF9oYWxmLCAyICk7IC8vIHB5XHJcblx0YnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgLSAxLCB3aWR0aCwgZGVwdGgsIC0gaGVpZ2h0X2hhbGYsIDMgKTsgLy8gbnlcclxuXHRidWlsZFBsYW5lKCAneCcsICd5JywgICAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoX2hhbGYsIDQgKTsgLy8gcHpcclxuXHRidWlsZFBsYW5lKCAneCcsICd5JywgLSAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIC0gZGVwdGhfaGFsZiwgNSApOyAvLyBuelxyXG5cclxuXHRmdW5jdGlvbiBidWlsZFBsYW5lKCB1LCB2LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0XHR2YXIgdywgaXgsIGl5LFxyXG5cdFx0Z3JpZFggPSBzY29wZS53aWR0aFNlZ21lbnRzLFxyXG5cdFx0Z3JpZFkgPSBzY29wZS5oZWlnaHRTZWdtZW50cyxcclxuXHRcdHdpZHRoX2hhbGYgPSB3aWR0aCAvIDIsXHJcblx0XHRoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDIsXHJcblx0XHRvZmZzZXQgPSBzY29wZS52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKCAoIHUgPT09ICd4JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneCcgKSApIHtcclxuXHJcblx0XHRcdHcgPSAneic7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3onICkgfHwgKCB1ID09PSAneicgJiYgdiA9PT0gJ3gnICkgKSB7XHJcblxyXG5cdFx0XHR3ID0gJ3knO1xyXG5cdFx0XHRncmlkWSA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggKCB1ID09PSAneicgJiYgdiA9PT0gJ3knICkgfHwgKCB1ID09PSAneScgJiYgdiA9PT0gJ3onICkgKSB7XHJcblxyXG5cdFx0XHR3ID0gJ3gnO1xyXG5cdFx0XHRncmlkWCA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBncmlkWDEgPSBncmlkWCArIDEsXHJcblx0XHRncmlkWTEgPSBncmlkWSArIDEsXHJcblx0XHRzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWCxcclxuXHRcdHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFksXHJcblx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdG5vcm1hbFsgdyBdID0gZGVwdGggPiAwID8gMSA6IC0gMTtcclxuXHJcblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0XHR2ZWN0b3JbIHUgXSA9ICggaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZiApICogdWRpcjtcclxuXHRcdFx0XHR2ZWN0b3JbIHYgXSA9ICggaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmICkgKiB2ZGlyO1xyXG5cdFx0XHRcdHZlY3RvclsgdyBdID0gZGVwdGg7XHJcblxyXG5cdFx0XHRcdHNjb3BlLnZlcnRpY2VzLnB1c2goIHZlY3RvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xyXG5cdFx0XHRcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xyXG5cdFx0XHRcdHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XHJcblx0XHRcdFx0dmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XHJcblxyXG5cdFx0XHRcdHZhciB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtIGl5IC8gZ3JpZFkgKTtcclxuXHRcdFx0XHR2YXIgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoIGl4IC8gZ3JpZFgsIDEgLSAoIGl5ICsgMSApIC8gZ3JpZFkgKTtcclxuXHRcdFx0XHR2YXIgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMSAtICggaXkgKyAxICkgLyBncmlkWSApO1xyXG5cdFx0XHRcdHZhciB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApO1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSArIG9mZnNldCwgYiArIG9mZnNldCwgZCArIG9mZnNldCApO1xyXG5cdFx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xyXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XHJcblx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdFx0c2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuXHRcdFx0XHRmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBiICsgb2Zmc2V0LCBjICsgb2Zmc2V0LCBkICsgb2Zmc2V0ICk7XHJcblx0XHRcdFx0ZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkgKTtcclxuXHRcdFx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdFx0XHRzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQm94R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm94R2VvbWV0cnk7XHJcblxyXG5USFJFRS5DdWJlR2VvbWV0cnkgPSBUSFJFRS5Cb3hHZW9tZXRyeTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBodWdoZXNcclxuICovXHJcblxyXG5USFJFRS5DaXJjbGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0NpcmNsZUdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRzZWdtZW50czogc2VnbWVudHMsXHJcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG5cdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcblx0fTtcclxuXHJcblx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5DaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DaXJjbGVHZW9tZXRyeTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUJ1ZmZlckdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuXHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxyXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG5cdH07XHJcblxyXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcclxuXHRzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XHJcblxyXG5cdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBzZWdtZW50cyArIDI7XHJcblxyXG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcclxuXHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMyApO1xyXG5cdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDIgKTtcclxuXHJcblx0Ly8gY2VudGVyIGRhdGEgaXMgYWxyZWFkeSB6ZXJvLCBidXQgbmVlZCB0byBzZXQgYSBmZXcgZXh0cmFzXHJcblx0bm9ybWFsc1sgMiBdID0gMS4wO1xyXG5cdHV2c1sgMCBdID0gMC41O1xyXG5cdHV2c1sgMSBdID0gMC41O1xyXG5cclxuXHRmb3IgKCB2YXIgcyA9IDAsIGkgPSAzLCBpaSA9IDIgOyBzIDw9IHNlZ21lbnRzOyBzICsrLCBpICs9IDMsIGlpICs9IDIgKSB7XHJcblxyXG5cdFx0dmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgcyAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7XHJcblxyXG5cdFx0cG9zaXRpb25zWyBpIF0gPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xyXG5cdFx0cG9zaXRpb25zWyBpICsgMSBdID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcclxuXHJcblx0XHRub3JtYWxzWyBpICsgMiBdID0gMTsgLy8gbm9ybWFsIHpcclxuXHJcblx0XHR1dnNbIGlpIF0gPSAoIHBvc2l0aW9uc1sgaSBdIC8gcmFkaXVzICsgMSApIC8gMjtcclxuXHRcdHV2c1sgaWkgKyAxIF0gPSAoIHBvc2l0aW9uc1sgaSArIDEgXSAvIHJhZGl1cyArIDEgKSAvIDI7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGluZGljZXMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdGluZGljZXMucHVzaCggaSwgaSArIDEsIDAgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGluZGljZXMgKSwgMSApICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0N5bGluZGVyR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkN5bGluZGVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnQ3lsaW5kZXJHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1c1RvcDogcmFkaXVzVG9wLFxyXG5cdFx0cmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXHJcblx0XHRoZWlnaHQ6IGhlaWdodCxcclxuXHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcclxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcclxuXHRcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxyXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG5cdH07XHJcblxyXG5cdHJhZGl1c1RvcCA9IHJhZGl1c1RvcCAhPT0gdW5kZWZpbmVkID8gcmFkaXVzVG9wIDogMjA7XHJcblx0cmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tICE9PSB1bmRlZmluZWQgPyByYWRpdXNCb3R0b20gOiAyMDtcclxuXHRoZWlnaHQgPSBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IGhlaWdodCA6IDEwMDtcclxuXHJcblx0cmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xyXG5cdGhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcclxuXHJcblx0b3BlbkVuZGVkID0gb3BlbkVuZGVkICE9PSB1bmRlZmluZWQgPyBvcGVuRW5kZWQgOiBmYWxzZTtcclxuXHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XHJcblx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiAyICogTWF0aC5QSTtcclxuXHJcblx0dmFyIGhlaWdodEhhbGYgPSBoZWlnaHQgLyAyO1xyXG5cclxuXHR2YXIgeCwgeSwgdmVydGljZXMgPSBbXSwgdXZzID0gW107XHJcblxyXG5cdGZvciAoIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xyXG5cdFx0dmFyIHV2c1JvdyA9IFtdO1xyXG5cclxuXHRcdHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xyXG5cdFx0dmFyIHJhZGl1cyA9IHYgKiAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApICsgcmFkaXVzVG9wO1xyXG5cclxuXHRcdGZvciAoIHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLnNpbiggdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydCApO1xyXG5cdFx0XHR2ZXJ0ZXgueSA9IC0gdiAqIGhlaWdodCArIGhlaWdodEhhbGY7XHJcblx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQgKTtcclxuXHJcblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlc1Jvdy5wdXNoKCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcclxuXHRcdFx0dXZzUm93LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XHJcblx0XHR1dnMucHVzaCggdXZzUm93ICk7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIHRhblRoZXRhID0gKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSAvIGhlaWdodDtcclxuXHR2YXIgbmEsIG5iO1xyXG5cclxuXHRmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdGlmICggcmFkaXVzVG9wICE9PSAwICkge1xyXG5cclxuXHRcdFx0bmEgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMCBdWyB4IF0gXS5jbG9uZSgpO1xyXG5cdFx0XHRuYiA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggKyAxIF0gXS5jbG9uZSgpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAxIF1bIHggXSBdLmNsb25lKCk7XHJcblx0XHRcdG5iID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDEgXVsgeCArIDEgXSBdLmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG5hLnNldFkoIE1hdGguc3FydCggbmEueCAqIG5hLnggKyBuYS56ICogbmEueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcclxuXHRcdG5iLnNldFkoIE1hdGguc3FydCggbmIueCAqIG5iLnggKyBuYi56ICogbmIueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjMgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcclxuXHRcdFx0dmFyIHY0ID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcclxuXHJcblx0XHRcdHZhciBuMSA9IG5hLmNsb25lKCk7XHJcblx0XHRcdHZhciBuMiA9IG5hLmNsb25lKCk7XHJcblx0XHRcdHZhciBuMyA9IG5iLmNsb25lKCk7XHJcblx0XHRcdHZhciBuNCA9IG5iLmNsb25lKCk7XHJcblxyXG5cdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYyID0gdXZzWyB5ICsgMSBdWyB4IF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2MyA9IHV2c1sgeSArIDEgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXY0ID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHY0LCBbIG4xLCBuMiwgbjQgXSApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2NCBdICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjIsIHYzLCB2NCwgWyBuMi5jbG9uZSgpLCBuMywgbjQuY2xvbmUoKSBdICkgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djIuY2xvbmUoKSwgdXYzLCB1djQuY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIHRvcCBjYXBcclxuXHJcblx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICYmIHJhZGl1c1RvcCA+IDAgKSB7XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgaGVpZ2h0SGFsZiwgMCApICk7XHJcblxyXG5cdFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyAwIF1bIHggXTtcclxuXHRcdFx0dmFyIHYyID0gdmVydGljZXNbIDAgXVsgeCArIDEgXTtcclxuXHRcdFx0dmFyIHYzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0dmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHRcdFx0dmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHRcdFx0dmFyIG4zID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHJcblx0XHRcdHZhciB1djEgPSB1dnNbIDAgXVsgeCBdLmNsb25lKCk7XHJcblx0XHRcdHZhciB1djIgPSB1dnNbIDAgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAwICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0sIHVuZGVmaW5lZCwgMSApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIGJvdHRvbSBjYXBcclxuXHJcblx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICYmIHJhZGl1c0JvdHRvbSA+IDAgKSB7XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSBoZWlnaHRIYWxmLCAwICkgKTtcclxuXHJcblx0XHRmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIGhlaWdodFNlZ21lbnRzIF1bIHggKyAxIF07XHJcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyBoZWlnaHRTZWdtZW50cyBdWyB4IF07XHJcblx0XHRcdHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdHZhciBuMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcclxuXHRcdFx0dmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xyXG5cdFx0XHR2YXIgbjMgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XHJcblxyXG5cdFx0XHR2YXIgdXYxID0gdXZzWyBoZWlnaHRTZWdtZW50cyBdWyB4ICsgMSBdLmNsb25lKCk7XHJcblx0XHRcdHZhciB1djIgPSB1dnNbIGhlaWdodFNlZ21lbnRzIF1bIHggXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAxICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0sIHVuZGVmaW5lZCwgMiApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DeWxpbmRlckdlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRWRnZXNHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLkVkZ2VzR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCB0aHJlc2hvbGRBbmdsZSApIHtcclxuXHJcblx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aHJlc2hvbGRBbmdsZSA9ICggdGhyZXNob2xkQW5nbGUgIT09IHVuZGVmaW5lZCApID8gdGhyZXNob2xkQW5nbGUgOiAxO1xyXG5cclxuXHR2YXIgdGhyZXNob2xkRG90ID0gTWF0aC5jb3MoIFRIUkVFLk1hdGguZGVnVG9SYWQoIHRocmVzaG9sZEFuZ2xlICkgKTtcclxuXHJcblx0dmFyIGVkZ2UgPSBbIDAsIDAgXSwgaGFzaCA9IHt9O1xyXG5cclxuXHRmdW5jdGlvbiBzb3J0RnVuY3Rpb24oIGEsIGIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGEgLSBiO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XHJcblxyXG5cdHZhciBnZW9tZXRyeTI7XHJcblxyXG5cdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRnZW9tZXRyeTIgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHRcdGdlb21ldHJ5Mi5mcm9tQnVmZmVyR2VvbWV0cnkoIGdlb21ldHJ5ICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Z2VvbWV0cnkyID0gZ2VvbWV0cnkuY2xvbmUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW9tZXRyeTIubWVyZ2VWZXJ0aWNlcygpO1xyXG5cdGdlb21ldHJ5Mi5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkyLnZlcnRpY2VzO1xyXG5cdHZhciBmYWNlcyA9IGdlb21ldHJ5Mi5mYWNlcztcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcblx0XHRcdGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xyXG5cdFx0XHRlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcclxuXHRcdFx0ZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcclxuXHJcblx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGhhc2hbIGtleSBdID0geyB2ZXJ0MTogZWRnZVsgMCBdLCB2ZXJ0MjogZWRnZVsgMSBdLCBmYWNlMTogaSwgZmFjZTI6IHVuZGVmaW5lZCB9O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aGFzaFsga2V5IF0uZmFjZTIgPSBpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBrZXkgaW4gaGFzaCApIHtcclxuXHJcblx0XHR2YXIgaCA9IGhhc2hbIGtleSBdO1xyXG5cclxuXHRcdGlmICggaC5mYWNlMiA9PT0gdW5kZWZpbmVkIHx8IGZhY2VzWyBoLmZhY2UxIF0ubm9ybWFsLmRvdCggZmFjZXNbIGguZmFjZTIgXS5ub3JtYWwgKSA8PSB0aHJlc2hvbGREb3QgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXNbIGgudmVydDEgXTtcclxuXHRcdFx0Y29vcmRzLnB1c2goIHZlcnRleC54ICk7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueSApO1xyXG5cdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnogKTtcclxuXHJcblx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQyIF07XHJcblx0XHRcdGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueCApO1xyXG5cdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnkgKTtcclxuXHRcdFx0Y29vcmRzLnB1c2goIHZlcnRleC56ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBjb29yZHMgKSwgMyApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRWRnZXNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuRWRnZXNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FZGdlc0dlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRXh0cnVkZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKlxyXG4gKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKlxyXG4gKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xyXG4gKiAgc3RlcHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIGZvciB6LXNpZGUgZXh0cnVzaW9ucyAvIHVzZWQgZm9yIHN1YmRpdmlkaW5nIHNlZ21lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xyXG4gKiAgYW1vdW50OiA8aW50PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcclxuICpcclxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXHJcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xyXG4gKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSBpcyBiZXZlbFxyXG4gKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcclxuICpcclxuICogIGV4dHJ1ZGVQYXRoOiA8VEhSRUUuQ3VydmVQYXRoPiAvLyAzZCBzcGxpbmUgcGF0aCB0byBleHRydWRlIHNoYXBlIGFsb25nLiAoY3JlYXRlcyBGcmFtZXMgaWYgLmZyYW1lcyBhcmVuJ3QgZGVmaW5lZClcclxuICogIGZyYW1lczogPFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXM+IC8vIGNvbnRhaW5pbmcgYXJyYXlzIG9mIHRhbmdlbnRzLCBub3JtYWxzLCBiaW5vcm1hbHNcclxuICpcclxuICogIHV2R2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXHJcbiAqXHJcbiAqIH1cclxuICoqL1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG5cdGlmICggdHlwZW9mKCBzaGFwZXMgKSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcclxuXHJcblx0XHRzaGFwZXMgPSBbXTtcclxuXHRcdHJldHVybjtcclxuXHJcblx0fVxyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdFeHRydWRlR2VvbWV0cnknO1xyXG5cclxuXHRzaGFwZXMgPSBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA/IHNoYXBlcyA6IFsgc2hhcGVzIF07XHJcblxyXG5cdHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcblx0Ly8gY2FuJ3QgcmVhbGx5IHVzZSBhdXRvbWF0aWMgdmVydGV4IG5vcm1hbHNcclxuXHQvLyBhcyB0aGVuIGZyb250IGFuZCBiYWNrIHNpZGVzIGdldCBzbW9vdGhlZCB0b29cclxuXHQvLyBzaG91bGQgZG8gc2VwYXJhdGUgc21vb3RoaW5nIGp1c3QgZm9yIHNpZGVzXHJcblxyXG5cdC8vdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxuXHQvL2NvbnNvbGUubG9nKCBcInRvb2tcIiwgKCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FeHRydWRlR2VvbWV0cnk7XHJcblxyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xyXG5cclxuXHR2YXIgc2wgPSBzaGFwZXMubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCB2YXIgcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBzaGFwZXNbIHMgXTtcclxuXHRcdHRoaXMuYWRkU2hhcGUoIHNoYXBlLCBvcHRpb25zICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcclxuXHJcblx0dmFyIGFtb3VudCA9IG9wdGlvbnMuYW1vdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFtb3VudCA6IDEwMDtcclxuXHJcblx0dmFyIGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDY7IC8vIDEwXHJcblx0dmFyIGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMjsgLy8gOFxyXG5cdHZhciBiZXZlbFNlZ21lbnRzID0gb3B0aW9ucy5iZXZlbFNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2VnbWVudHMgOiAzO1xyXG5cclxuXHR2YXIgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTsgLy8gZmFsc2VcclxuXHJcblx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xyXG5cclxuXHR2YXIgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcclxuXHJcblx0dmFyIGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcclxuXHR2YXIgZXh0cnVkZVB0cywgZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xyXG5cclxuXHQvLyBVc2UgZGVmYXVsdCBXb3JsZFVWR2VuZXJhdG9yIGlmIG5vIFVWIGdlbmVyYXRvcnMgYXJlIHNwZWNpZmllZC5cclxuXHR2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLlVWR2VuZXJhdG9yIDogVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3I7XHJcblxyXG5cdHZhciBzcGxpbmVUdWJlLCBiaW5vcm1hbCwgbm9ybWFsLCBwb3NpdGlvbjI7XHJcblx0aWYgKCBleHRydWRlUGF0aCApIHtcclxuXHJcblx0XHRleHRydWRlUHRzID0gZXh0cnVkZVBhdGguZ2V0U3BhY2VkUG9pbnRzKCBzdGVwcyApO1xyXG5cclxuXHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xyXG5cdFx0YmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxyXG5cclxuXHRcdC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcclxuXHJcblx0XHQvLyBSZXVzZSBUTkIgZnJvbSBUdWJlR2VvbXRyeSBmb3Igbm93LlxyXG5cdFx0Ly8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cclxuXHJcblx0XHRzcGxpbmVUdWJlID0gb3B0aW9ucy5mcmFtZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZnJhbWVzIDogbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoIGV4dHJ1ZGVQYXRoLCBzdGVwcywgZmFsc2UgKTtcclxuXHJcblx0XHQvLyBjb25zb2xlLmxvZyhzcGxpbmVUdWJlLCAnc3BsaW5lVHViZScsIHNwbGluZVR1YmUubm9ybWFscy5sZW5ndGgsICdzdGVwcycsIHN0ZXBzLCAnZXh0cnVkZVB0cycsIGV4dHJ1ZGVQdHMubGVuZ3RoKTtcclxuXHJcblx0XHRiaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cG9zaXRpb24yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBTYWZlZ3VhcmRzIGlmIGJldmVscyBhcmUgbm90IGVuYWJsZWRcclxuXHJcblx0aWYgKCAhIGJldmVsRW5hYmxlZCApIHtcclxuXHJcblx0XHRiZXZlbFNlZ21lbnRzID0gMDtcclxuXHRcdGJldmVsVGhpY2tuZXNzID0gMDtcclxuXHRcdGJldmVsU2l6ZSA9IDA7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gVmFyaWFibGVzIGluaXRpYWxpemF0aW9uXHJcblxyXG5cdHZhciBhaG9sZSwgaCwgaGw7IC8vIGxvb3Bpbmcgb2YgaG9sZXNcclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XHJcblx0dmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XHJcblxyXG5cdHZhciByZXZlcnNlID0gISBUSFJFRS5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xyXG5cclxuXHRpZiAoIHJldmVyc2UgKSB7XHJcblxyXG5cdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XHJcblxyXG5cdFx0Ly8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZSAuLi5cclxuXHJcblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHJcblx0XHRcdGlmICggVEhSRUUuU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggYWhvbGUgKSApIHtcclxuXHJcblx0XHRcdFx0aG9sZXNbIGggXSA9IGFob2xlLnJldmVyc2UoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV2ZXJzZSA9IGZhbHNlOyAvLyBJZiB2ZXJ0aWNlcyBhcmUgaW4gb3JkZXIgbm93LCB3ZSBzaG91bGRuJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGVtIGFnYWluIChob3BlZnVsbHkpIVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHR2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xyXG5cclxuXHQvKiBWZXJ0aWNlcyAqL1xyXG5cclxuXHR2YXIgY29udG91ciA9IHZlcnRpY2VzOyAvLyB2ZXJ0aWNlcyBoYXMgYWxsIHBvaW50cyBidXQgY29udG91ciBoYXMgb25seSBwb2ludHMgb2YgY2lyY3VtZmVyZW5jZVxyXG5cclxuXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG5cdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGFob2xlICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIHNjYWxlUHQyICggcHQsIHZlYywgc2l6ZSApIHtcclxuXHJcblx0XHRpZiAoICEgdmVjICkgY29uc29sZS5lcnJvciggXCJUSFJFRS5FeHRydWRlR2VvbWV0cnk6IHZlYyBkb2VzIG5vdCBleGlzdFwiICk7XHJcblxyXG5cdFx0cmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzaXplICkuYWRkKCBwdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBiLCBicywgdCwgeixcclxuXHRcdHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsXHJcblx0XHRmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xyXG5cclxuXHJcblx0Ly8gRmluZCBkaXJlY3Rpb25zIGZvciBwb2ludCBtb3ZlbWVudFxyXG5cclxuXHJcblx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xyXG5cclxuXHRcdC8vIGNvbXB1dGVzIGZvciBpblB0IHRoZSBjb3JyZXNwb25kaW5nIHBvaW50IGluUHQnIG9uIGEgbmV3IGNvbnRvdXJcclxuXHRcdC8vICAgc2hpZnRlZCBieSAxIHVuaXQgKGxlbmd0aCBvZiBub3JtYWxpemVkIHZlY3RvcikgdG8gdGhlIGxlZnRcclxuXHRcdC8vIGlmIHdlIHdhbGsgYWxvbmcgY29udG91ciBjbG9ja3dpc2UsIHRoaXMgbmV3IGNvbnRvdXIgaXMgb3V0c2lkZSB0aGUgb2xkIG9uZVxyXG5cdFx0Ly9cclxuXHRcdC8vIGluUHQnIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBwYXJhbGxlbCB0byB0aGUgdHdvXHJcblx0XHQvLyAgYWRqYWNlbnQgZWRnZXMgb2YgaW5QdCBhdCBhIGRpc3RhbmNlIG9mIDEgdW5pdCBvbiB0aGUgbGVmdCBzaWRlLlxyXG5cclxuXHRcdHZhciB2X3RyYW5zX3gsIHZfdHJhbnNfeSwgc2hyaW5rX2J5ID0gMTtcdFx0Ly8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxyXG5cclxuXHRcdC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcclxuXHRcdC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA1LV9pbnRlcnNlY3QtMS5odG1sXHJcblxyXG5cdFx0dmFyIHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsIHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XHJcblx0XHR2YXIgdl9uZXh0X3ggPSBpbk5leHQueCAtIGluUHQueCwgdl9uZXh0X3kgPSBpbk5leHQueSAtIGluUHQueTtcclxuXHJcblx0XHR2YXIgdl9wcmV2X2xlbnNxID0gKCB2X3ByZXZfeCAqIHZfcHJldl94ICsgdl9wcmV2X3kgKiB2X3ByZXZfeSApO1xyXG5cclxuXHRcdC8vIGNoZWNrIGZvciBjb2xsaW5lYXIgZWRnZXNcclxuXHRcdHZhciBjb2xsaW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xyXG5cclxuXHRcdGlmICggTWF0aC5hYnMoIGNvbGxpbmVhcjAgKSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0Ly8gbm90IGNvbGxpbmVhclxyXG5cclxuXHRcdFx0Ly8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXHJcblxyXG5cdFx0XHR2YXIgdl9wcmV2X2xlbiA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XHJcblx0XHRcdHZhciB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xyXG5cclxuXHRcdFx0Ly8gc2hpZnQgYWRqYWNlbnQgcG9pbnRzIGJ5IHVuaXQgdmVjdG9ycyB0byB0aGUgbGVmdFxyXG5cclxuXHRcdFx0dmFyIHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XHJcblx0XHRcdHZhciBwdFByZXZTaGlmdF95ID0gKCBpblByZXYueSArIHZfcHJldl94IC8gdl9wcmV2X2xlbiApO1xyXG5cclxuXHRcdFx0dmFyIHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XHJcblx0XHRcdHZhciBwdE5leHRTaGlmdF95ID0gKCBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbiApO1xyXG5cclxuXHRcdFx0Ly8gc2NhbGluZyBmYWN0b3IgZm9yIHZfcHJldiB0byBpbnRlcnNlY3Rpb24gcG9pbnRcclxuXHJcblx0XHRcdHZhciBzZiA9ICggICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cclxuXHRcdFx0XHRcdFx0KCBwdE5leHRTaGlmdF95IC0gcHRQcmV2U2hpZnRfeSApICogdl9uZXh0X3ggICAgKSAvXHJcblx0XHRcdFx0XHQgICggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcclxuXHJcblx0XHRcdC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XHJcblxyXG5cdFx0XHR2X3RyYW5zX3ggPSAoIHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54ICk7XHJcblx0XHRcdHZfdHJhbnNfeSA9ICggcHRQcmV2U2hpZnRfeSArIHZfcHJldl95ICogc2YgLSBpblB0LnkgKTtcclxuXHJcblx0XHRcdC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XHJcblx0XHRcdC8vICBidXQgcHJldmVudCBjcmF6eSBzcGlrZXNcclxuXHRcdFx0dmFyIHZfdHJhbnNfbGVuc3EgPSAoIHZfdHJhbnNfeCAqIHZfdHJhbnNfeCArIHZfdHJhbnNfeSAqIHZfdHJhbnNfeSApO1xyXG5cdFx0XHRpZiAoIHZfdHJhbnNfbGVuc3EgPD0gMiApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuXHRuZXcgVEhSRUUuVmVjdG9yMiggdl90cmFuc194LCB2X3RyYW5zX3kgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xsaW5lYXIgZWRnZXNcclxuXHJcblx0XHRcdHZhciBkaXJlY3Rpb25fZXEgPSBmYWxzZTtcdFx0Ly8gYXNzdW1lczogb3Bwb3NpdGVcclxuXHRcdFx0aWYgKCB2X3ByZXZfeCA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHZfbmV4dF94ID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCB2X3ByZXZfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2X25leHRfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIE1hdGguc2lnbiggdl9wcmV2X3kgKSA9PT0gTWF0aC5zaWduKCB2X25leHRfeSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZGlyZWN0aW9uX2VxICkge1xyXG5cclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXCIpO1xyXG5cdFx0XHRcdHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XHJcblx0XHRcdFx0dl90cmFuc195ID0gIHZfcHJldl94O1xyXG5cdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xyXG5cdFx0XHRcdHZfdHJhbnNfeCA9IHZfcHJldl94O1xyXG5cdFx0XHRcdHZfdHJhbnNfeSA9IHZfcHJldl95O1xyXG5cdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm5cdG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHR2YXIgY29udG91ck1vdmVtZW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xyXG5cclxuXHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcclxuXHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcclxuXHJcblx0XHQvLyAgKGopLS0tKGkpLS0tKGspXHJcblx0XHQvLyBjb25zb2xlLmxvZygnaSxqLGsnLCBpLCBqICwgaylcclxuXHJcblx0XHRjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBob2xlc01vdmVtZW50cyA9IFtdLCBvbmVIb2xlTW92ZW1lbnRzLCB2ZXJ0aWNlc01vdmVtZW50cyA9IGNvbnRvdXJNb3ZlbWVudHMuY29uY2F0KCk7XHJcblxyXG5cdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHJcblx0XHRvbmVIb2xlTW92ZW1lbnRzID0gW107XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcclxuXHJcblx0XHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcclxuXHRcdFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xyXG5cclxuXHRcdFx0Ly8gIChqKS0tLShpKS0tLShrKVxyXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRob2xlc01vdmVtZW50cy5wdXNoKCBvbmVIb2xlTW92ZW1lbnRzICk7XHJcblx0XHR2ZXJ0aWNlc01vdmVtZW50cyA9IHZlcnRpY2VzTW92ZW1lbnRzLmNvbmNhdCggb25lSG9sZU1vdmVtZW50cyApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBMb29wIGJldmVsU2VnbWVudHMsIDEgZm9yIHRoZSBmcm9udCwgMSBmb3IgdGhlIGJhY2tcclxuXHJcblx0Zm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xyXG5cclxuXHRcdC8vZm9yICggYiA9IGJldmVsU2VnbWVudHM7IGIgPiAwOyBiIC0tICkge1xyXG5cclxuXHRcdHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcclxuXHRcdHogPSBiZXZlbFRoaWNrbmVzcyAqICggMSAtIHQgKTtcclxuXHJcblx0XHQvL3ogPSBiZXZlbFRoaWNrbmVzcyAqIHQ7XHJcblx0XHRicyA9IGJldmVsU2l6ZSAqICggTWF0aC5zaW4gKCB0ICogTWF0aC5QSSAvIDIgKSApOyAvLyBjdXJ2ZWRcclxuXHRcdC8vYnMgPSBiZXZlbFNpemUgKiB0OyAvLyBsaW5lYXJcclxuXHJcblx0XHQvLyBjb250cmFjdCBzaGFwZVxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cclxuXHRcdFx0diggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZXhwYW5kIGhvbGVzXHJcblxyXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cclxuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIC0geiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRicyA9IGJldmVsU2l6ZTtcclxuXHJcblx0Ly8gQmFjayBmYWNpbmcgdmVydGljZXNcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xyXG5cclxuXHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XHJcblxyXG5cdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG5cdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgMCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xyXG5cclxuXHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xyXG5cdFx0XHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xyXG5cclxuXHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIDAgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xyXG5cclxuXHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxyXG5cdC8vIEluY2x1ZGluZyBmcm9udCBmYWNpbmcgdmVydGljZXNcclxuXHJcblx0dmFyIHM7XHJcblxyXG5cdGZvciAoIHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcclxuXHJcblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGFtb3VudCAvIHN0ZXBzICogcyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xyXG5cclxuXHRcdFx0XHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XHJcblx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcclxuXHJcblx0XHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIHMgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHR2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXHJcblxyXG5cdC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcclxuXHRmb3IgKCBiID0gYmV2ZWxTZWdtZW50cyAtIDE7IGIgPj0gMDsgYiAtLSApIHtcclxuXHJcblx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XHJcblx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XHJcblx0XHQvL2JzID0gYmV2ZWxTaXplICogKCAxLU1hdGguc2luICggKCAxIC0gdCApICogTWF0aC5QSS8yICkgKTtcclxuXHRcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4gKCB0ICogTWF0aC5QSSAvIDIgKTtcclxuXHJcblx0XHQvLyBjb250cmFjdCBzaGFwZVxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZXhwYW5kIGhvbGVzXHJcblxyXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcclxuXHJcblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyogRmFjZXMgKi9cclxuXHJcblx0Ly8gVG9wIGFuZCBib3R0b20gZmFjZXNcclxuXHJcblx0YnVpbGRMaWRGYWNlcygpO1xyXG5cclxuXHQvLyBTaWRlcyBmYWNlc1xyXG5cclxuXHRidWlsZFNpZGVGYWNlcygpO1xyXG5cclxuXHJcblx0Ly8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xyXG5cclxuXHRmdW5jdGlvbiBidWlsZExpZEZhY2VzKCkge1xyXG5cclxuXHRcdGlmICggYmV2ZWxFbmFibGVkICkge1xyXG5cclxuXHRcdFx0dmFyIGxheWVyID0gMDsgLy8gc3RlcHMgKyAxXHJcblx0XHRcdHZhciBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XHJcblxyXG5cdFx0XHQvLyBCb3R0b20gZmFjZXNcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblx0XHRcdFx0ZjMoIGZhY2VbIDIgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAwIF0gKyBvZmZzZXQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxheWVyID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcclxuXHRcdFx0b2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xyXG5cclxuXHRcdFx0Ly8gVG9wIGZhY2VzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMiBdICsgb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIEJvdHRvbSBmYWNlc1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHRcdFx0XHRmMyggZmFjZVsgMiBdLCBmYWNlWyAxIF0sIGZhY2VbIDAgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVG9wIGZhY2VzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXHJcblxyXG5cdGZ1bmN0aW9uIGJ1aWxkU2lkZUZhY2VzKCkge1xyXG5cclxuXHRcdHZhciBsYXllcm9mZnNldCA9IDA7XHJcblx0XHRzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICk7XHJcblx0XHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHRcdFx0c2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcclxuXHJcblx0XHRcdC8vLCB0cnVlXHJcblx0XHRcdGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApIHtcclxuXHJcblx0XHR2YXIgaiwgaztcclxuXHRcdGkgPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblx0XHR3aGlsZSAoIC0tIGkgPj0gMCApIHtcclxuXHJcblx0XHRcdGogPSBpO1xyXG5cdFx0XHRrID0gaSAtIDE7XHJcblx0XHRcdGlmICggayA8IDAgKSBrID0gY29udG91ci5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0Ly9jb25zb2xlLmxvZygnYicsIGksaiwgaS0xLCBrLHZlcnRpY2VzLmxlbmd0aCk7XHJcblxyXG5cdFx0XHR2YXIgcyA9IDAsIHNsID0gc3RlcHMgICsgYmV2ZWxTZWdtZW50cyAqIDI7XHJcblxyXG5cdFx0XHRmb3IgKCBzID0gMDsgcyA8IHNsOyBzICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgc2xlbjEgPSB2bGVuICogcztcclxuXHRcdFx0XHR2YXIgc2xlbjIgPSB2bGVuICogKCBzICsgMSApO1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4xLFxyXG5cdFx0XHRcdFx0YiA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4xLFxyXG5cdFx0XHRcdFx0YyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxyXG5cdFx0XHRcdFx0ZCA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4yO1xyXG5cclxuXHRcdFx0XHRmNCggYSwgYiwgYywgZCwgY29udG91ciwgcywgc2wsIGosIGsgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIHYoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0c2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGYzKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdGEgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cdFx0YiArPSBzaGFwZXNPZmZzZXQ7XHJcblx0XHRjICs9IHNoYXBlc09mZnNldDtcclxuXHJcblx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIDAgKSApO1xyXG5cclxuXHRcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKCBzY29wZSwgYSwgYiwgYyApO1xyXG5cclxuXHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmNCggYSwgYiwgYywgZCwgd2FsbENvbnRvdXIsIHN0ZXBJbmRleCwgc3RlcHNMZW5ndGgsIGNvbnRvdXJJbmRleDEsIGNvbnRvdXJJbmRleDIgKSB7XHJcblxyXG5cdFx0YSArPSBzaGFwZXNPZmZzZXQ7XHJcblx0XHRiICs9IHNoYXBlc09mZnNldDtcclxuXHRcdGMgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cdFx0ZCArPSBzaGFwZXNPZmZzZXQ7XHJcblxyXG5cdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkLCBudWxsLCBudWxsLCAxICkgKTtcclxuXHRcdHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCwgbnVsbCwgbnVsbCwgMSApICk7XHJcblxyXG5cdFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVViggc2NvcGUsIGEsIGIsIGMsIGQgKTtcclxuXHJcblx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDAgXSwgdXZzWyAxIF0sIHV2c1sgMyBdIF0gKTtcclxuXHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgMSBdLCB1dnNbIDIgXSwgdXZzWyAzIF0gXSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgPSB7XHJcblxyXG5cdGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblxyXG5cdFx0dmFyIGEgPSB2ZXJ0aWNlc1sgaW5kZXhBIF07XHJcblx0XHR2YXIgYiA9IHZlcnRpY2VzWyBpbmRleEIgXTtcclxuXHRcdHZhciBjID0gdmVydGljZXNbIGluZGV4QyBdO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhLngsIGEueSApLFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYi54LCBiLnkgKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGMueCwgYy55IClcclxuXHRcdF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlU2lkZVdhbGxVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgaW5kZXhBLCBpbmRleEIsIGluZGV4QywgaW5kZXhEICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdHZhciBhID0gdmVydGljZXNbIGluZGV4QSBdO1xyXG5cdFx0dmFyIGIgPSB2ZXJ0aWNlc1sgaW5kZXhCIF07XHJcblx0XHR2YXIgYyA9IHZlcnRpY2VzWyBpbmRleEMgXTtcclxuXHRcdHZhciBkID0gdmVydGljZXNbIGluZGV4RCBdO1xyXG5cclxuXHRcdGlmICggTWF0aC5hYnMoIGEueSAtIGIueSApIDwgMC4wMSApIHtcclxuXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGEueCwgMSAtIGEueiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBiLngsIDEgLSBiLnogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYy54LCAxIC0gYy56ICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGQueCwgMSAtIGQueiApXHJcblx0XHRcdF07XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGEueSwgMSAtIGEueiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBiLnksIDEgLSBiLnogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYy55LCAxIC0gYy56ICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGQueSwgMSAtIGQueiApXHJcblx0XHRcdF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TaGFwZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tXHJcbiAqXHJcbiAqIENyZWF0ZXMgYSBvbmUtc2lkZWQgcG9seWdvbmFsIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLiBTaW1pbGFyIHRvXHJcbiAqIEV4dHJ1ZGVHZW9tZXRyeS5cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICpcclxuICpcdGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXMuIE5PVCBVU0VEIEFUIFRIRSBNT01FTlQuXHJcbiAqXHJcbiAqXHRtYXRlcmlhbDogPGludD4gLy8gbWF0ZXJpYWwgaW5kZXggZm9yIGZyb250IGFuZCBiYWNrIGZhY2VzXHJcbiAqXHR1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xyXG4gKlxyXG4gKiB9XHJcbiAqKi9cclxuXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnU2hhcGVHZW9tZXRyeSc7XHJcblxyXG5cdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPT09IGZhbHNlICkgc2hhcGVzID0gWyBzaGFwZXMgXTtcclxuXHJcblx0dGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xyXG5cclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2hhcGVHZW9tZXRyeTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgYW4gYXJyYXkgb2Ygc2hhcGVzIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnkuXHJcbiAqL1xyXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dGhpcy5hZGRTaGFwZSggc2hhcGVzWyBpIF0sIG9wdGlvbnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhIHNoYXBlIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnksIGJhc2VkIG9uIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5cclxuICovXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcclxuXHJcblx0aWYgKCBvcHRpb25zID09PSB1bmRlZmluZWQgKSBvcHRpb25zID0ge307XHJcblx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xyXG5cdHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgPT09IHVuZGVmaW5lZCA/IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yIDogb3B0aW9ucy5VVkdlbmVyYXRvcjtcclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIGksIGwsIGhvbGU7XHJcblxyXG5cdHZhciBzaGFwZXNPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcclxuXHR2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xyXG5cdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xyXG5cclxuXHR2YXIgcmV2ZXJzZSA9ICEgVEhSRUUuU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcclxuXHJcblx0aWYgKCByZXZlcnNlICkge1xyXG5cclxuXHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xyXG5cclxuXHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUuLi5cclxuXHJcblx0XHRmb3IgKCBpID0gMCwgbCA9IGhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRob2xlID0gaG9sZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggVEhSRUUuU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggaG9sZSApICkge1xyXG5cclxuXHRcdFx0XHRob2xlc1sgaSBdID0gaG9sZS5yZXZlcnNlKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldmVyc2UgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xyXG5cclxuXHQvLyBWZXJ0aWNlc1xyXG5cclxuXHRmb3IgKCBpID0gMCwgbCA9IGhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0aG9sZSA9IGhvbGVzWyBpIF07XHJcblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggaG9sZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdHZhciB2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoO1xyXG5cdHZhciBmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0dmVydCA9IHZlcnRpY2VzWyBpIF07XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydC54LCB2ZXJ0LnksIDAgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcblx0XHR2YXIgYSA9IGZhY2VbIDAgXSArIHNoYXBlc09mZnNldDtcclxuXHRcdHZhciBiID0gZmFjZVsgMSBdICsgc2hhcGVzT2Zmc2V0O1xyXG5cdFx0dmFyIGMgPSBmYWNlWyAyIF0gKyBzaGFwZXNPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIG1hdGVyaWFsICkgKTtcclxuXHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHRoaXMsIGEsIGIsIGMgKSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvTGF0aGVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYXN0cm9kdWQgLyBodHRwOi8vYXN0cm9kdWQuaXNncmVhdC5vcmcvXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG4vLyBwb2ludHMgLSB0byBjcmVhdGUgYSBjbG9zZWQgdG9ydXMsIG9uZSBtdXN0IHVzZSBhIHNldCBvZiBwb2ludHNcclxuLy8gICAgbGlrZSBzbzogWyBhLCBiLCBjLCBkLCBhIF0sIHNlZSBmaXJzdCBpcyB0aGUgc2FtZSBhcyBsYXN0LlxyXG4vLyBzZWdtZW50cyAtIHRoZSBudW1iZXIgb2YgY2lyY3VtZmVyZW5jZSBzZWdtZW50cyB0byBjcmVhdGVcclxuLy8gcGhpU3RhcnQgLSB0aGUgc3RhcnRpbmcgcmFkaWFuXHJcbi8vIHBoaUxlbmd0aCAtIHRoZSByYWRpYW4gKDAgdG8gMipQSSkgcmFuZ2Ugb2YgdGhlIGxhdGhlZCBzZWN0aW9uXHJcbi8vICAgIDIqcGkgaXMgYSBjbG9zZWQgbGF0aGUsIGxlc3MgdGhhbiAyUEkgaXMgYSBwb3J0aW9uLlxyXG5cclxuVEhSRUUuTGF0aGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHBvaW50czogcG9pbnRzLFxyXG5cdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxyXG5cdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxyXG5cdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGhcclxuXHR9O1xyXG5cclxuXHRzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDEyO1xyXG5cdHBoaVN0YXJ0ID0gcGhpU3RhcnQgfHwgMDtcclxuXHRwaGlMZW5ndGggPSBwaGlMZW5ndGggfHwgMiAqIE1hdGguUEk7XHJcblxyXG5cdHZhciBpbnZlcnNlUG9pbnRMZW5ndGggPSAxLjAgLyAoIHBvaW50cy5sZW5ndGggLSAxICk7XHJcblx0dmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPD0gaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHBoaSA9IHBoaVN0YXJ0ICsgaSAqIGludmVyc2VTZWdtZW50cyAqIHBoaUxlbmd0aDtcclxuXHJcblx0XHR2YXIgc2luID0gTWF0aC5zaW4oIHBoaSApO1xyXG5cdFx0dmFyIGNvcyA9IE1hdGguY29zKCBwaGkgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHBvaW50ID0gcG9pbnRzWyBqIF07XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHZlcnRleC54ID0gcG9pbnQueCAqIHNpbjtcclxuXHRcdFx0dmVydGV4LnkgPSBwb2ludC55O1xyXG5cdFx0XHR2ZXJ0ZXgueiA9IHBvaW50LnggKiBjb3M7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR2YXIgbnAgPSBwb2ludHMubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aCAtIDE7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdHZhciBiYXNlID0gaiArIG5wICogaTtcclxuXHRcdFx0dmFyIGEgPSBiYXNlO1xyXG5cdFx0XHR2YXIgYiA9IGJhc2UgKyBucDtcclxuXHRcdFx0dmFyIGMgPSBiYXNlICsgMSArIG5wO1xyXG5cdFx0XHR2YXIgZCA9IGJhc2UgKyAxO1xyXG5cclxuXHRcdFx0dmFyIHUwID0gaSAqIGludmVyc2VTZWdtZW50cztcclxuXHRcdFx0dmFyIHYwID0gaiAqIGludmVyc2VQb2ludExlbmd0aDtcclxuXHRcdFx0dmFyIHUxID0gdTAgKyBpbnZlcnNlU2VnbWVudHM7XHJcblx0XHRcdHZhciB2MSA9IHYwICsgaW52ZXJzZVBvaW50TGVuZ3RoO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xyXG5cclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYwICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MCApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxyXG5cclxuXHRcdFx0XSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xyXG5cclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MSApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxyXG5cclxuXHRcdFx0XSApO1xyXG5cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGF0aGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuTGF0aGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MYXRoZUdlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGxhbmVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xyXG4gKi9cclxuXHJcblRIUkVFLlBsYW5lR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQbGFuZUdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXHJcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG5cdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXHJcblx0fTtcclxuXHJcblx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QbGFuZUdlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGxhbmVCdWZmZXJHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xyXG4gKi9cclxuXHJcblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xyXG5cclxuXHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQbGFuZUJ1ZmZlckdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXHJcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG5cdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXHJcblx0fTtcclxuXHJcblx0dmFyIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XHJcblx0dmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcclxuXHJcblx0dmFyIGdyaWRYID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDE7XHJcblx0dmFyIGdyaWRZID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xyXG5cclxuXHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xyXG5cdHZhciBncmlkWTEgPSBncmlkWSArIDE7XHJcblxyXG5cdHZhciBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWDtcclxuXHR2YXIgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xyXG5cdHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xyXG5cdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBncmlkWDEgKiBncmlkWTEgKiAyICk7XHJcblxyXG5cdHZhciBvZmZzZXQgPSAwO1xyXG5cdHZhciBvZmZzZXQyID0gMDtcclxuXHJcblx0Zm9yICggdmFyIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xyXG5cclxuXHRcdHZhciB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xyXG5cclxuXHRcdGZvciAoIHZhciBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcclxuXHJcblx0XHRcdHZlcnRpY2VzWyBvZmZzZXQgXSA9IHg7XHJcblx0XHRcdHZlcnRpY2VzWyBvZmZzZXQgKyAxIF0gPSAtIHk7XHJcblxyXG5cdFx0XHRub3JtYWxzWyBvZmZzZXQgKyAyIF0gPSAxO1xyXG5cclxuXHRcdFx0dXZzWyBvZmZzZXQyIF0gPSBpeCAvIGdyaWRYO1xyXG5cdFx0XHR1dnNbIG9mZnNldDIgKyAxIF0gPSAxIC0gKCBpeSAvIGdyaWRZICk7XHJcblxyXG5cdFx0XHRvZmZzZXQgKz0gMztcclxuXHRcdFx0b2Zmc2V0MiArPSAyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRvZmZzZXQgPSAwO1xyXG5cclxuXHR2YXIgaW5kaWNlcyA9IG5ldyAoICggdmVydGljZXMubGVuZ3RoIC8gMyApID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5ICkoIGdyaWRYICogZ3JpZFkgKiA2ICk7XHJcblxyXG5cdGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xyXG5cdFx0XHR2YXIgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcclxuXHRcdFx0dmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcclxuXHRcdFx0dmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XHJcblxyXG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgXSA9IGE7XHJcblx0XHRcdGluZGljZXNbIG9mZnNldCArIDEgXSA9IGI7XHJcblx0XHRcdGluZGljZXNbIG9mZnNldCArIDIgXSA9IGQ7XHJcblxyXG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyAzIF0gPSBiO1xyXG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyA0IF0gPSBjO1xyXG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyA1IF0gPSBkO1xyXG5cclxuXHRcdFx0b2Zmc2V0ICs9IDY7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xyXG5cdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9SaW5nR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIEthbGViIE11cnBoeVxyXG4gKi9cclxuXHJcblRIUkVFLlJpbmdHZW9tZXRyeSA9IGZ1bmN0aW9uICggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcclxuXHRcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcclxuXHRcdHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXHJcblx0XHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXHJcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG5cdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcblx0fTtcclxuXHJcblx0aW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cyB8fCAwO1xyXG5cdG91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgfHwgNTA7XHJcblxyXG5cdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xyXG5cclxuXHR0aGV0YVNlZ21lbnRzID0gdGhldGFTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHRoZXRhU2VnbWVudHMgKSA6IDg7XHJcblx0cGhpU2VnbWVudHMgPSBwaGlTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDEsIHBoaVNlZ21lbnRzICkgOiA4O1xyXG5cclxuXHR2YXIgaSwgbywgdXZzID0gW10sIHJhZGl1cyA9IGlubmVyUmFkaXVzLCByYWRpdXNTdGVwID0gKCAoIG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMgKSAvIHBoaVNlZ21lbnRzICk7XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgcGhpU2VnbWVudHMgKyAxOyBpICsrICkge1xyXG5cclxuXHRcdC8vIGNvbmNlbnRyaWMgY2lyY2xlcyBpbnNpZGUgcmluZ1xyXG5cclxuXHRcdGZvciAoIG8gPSAwOyBvIDwgdGhldGFTZWdtZW50cyArIDE7IG8gKysgKSB7XHJcblxyXG5cdFx0XHQvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIG8gLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XHJcblx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcclxuXHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHRcdFx0dXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCAoIHZlcnRleC54IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyLCAoIHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmFkaXVzICs9IHJhZGl1c1N0ZXA7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IHBoaVNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdC8vIGNvbmNlbnRyaWMgY2lyY2xlcyBpbnNpZGUgcmluZ1xyXG5cclxuXHRcdHZhciB0aGV0YVNlZ21lbnQgPSBpICogKCB0aGV0YVNlZ21lbnRzICsgMSApO1xyXG5cclxuXHRcdGZvciAoIG8gPSAwOyBvIDwgdGhldGFTZWdtZW50cyA7IG8gKysgKSB7XHJcblxyXG5cdFx0XHQvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxyXG5cclxuXHRcdFx0dmFyIHNlZ21lbnQgPSBvICsgdGhldGFTZWdtZW50O1xyXG5cclxuXHRcdFx0dmFyIHYxID0gc2VnbWVudDtcclxuXHRcdFx0dmFyIHYyID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xyXG5cdFx0XHR2YXIgdjMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgdjEgXS5jbG9uZSgpLCB1dnNbIHYyIF0uY2xvbmUoKSwgdXZzWyB2MyBdLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdFx0djEgPSBzZWdtZW50O1xyXG5cdFx0XHR2MiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcclxuXHRcdFx0djMgPSBzZWdtZW50ICsgMTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4uY2xvbmUoKSwgbi5jbG9uZSgpLCBuLmNsb25lKCkgXSApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyB2MSBdLmNsb25lKCksIHV2c1sgdjIgXS5jbG9uZSgpLCB1dnNbIHYzIF0uY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5SaW5nR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TcGhlcmVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BoZXJlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdTcGhlcmVHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcclxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcclxuXHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcclxuXHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxyXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG5cdH07XHJcblxyXG5cdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BoZXJlR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TcGhlcmVCdWZmZXJHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xyXG4gKiBiYXNlZCBvbiBUSFJFRS5TcGhlcmVHZW9tZXRyeVxyXG4gKi9cclxuXHJcblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcclxuXHJcblx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXHJcblx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXHJcblx0XHRwaGlTdGFydDogcGhpU3RhcnQsXHJcblx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aCxcclxuXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXHJcblx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcclxuXHR9O1xyXG5cclxuXHRyYWRpdXMgPSByYWRpdXMgfHwgNTA7XHJcblxyXG5cdHdpZHRoU2VnbWVudHMgPSBNYXRoLm1heCggMywgTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDggKTtcclxuXHRoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDYgKTtcclxuXHJcblx0cGhpU3RhcnQgPSBwaGlTdGFydCAhPT0gdW5kZWZpbmVkID8gcGhpU3RhcnQgOiAwO1xyXG5cdHBoaUxlbmd0aCA9IHBoaUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XHJcblxyXG5cdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEk7XHJcblxyXG5cdHZhciB0aGV0YUVuZCA9IHRoZXRhU3RhcnQgKyB0aGV0YUxlbmd0aDtcclxuXHJcblx0dmFyIHZlcnRleENvdW50ID0gKCAoIHdpZHRoU2VnbWVudHMgKyAxICkgKiAoIGhlaWdodFNlZ21lbnRzICsgMSApICk7XHJcblxyXG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xyXG5cdHZhciBub3JtYWxzID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMgKTtcclxuXHR2YXIgdXZzID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAyICksIDIgKTtcclxuXHJcblx0dmFyIGluZGV4ID0gMCwgdmVydGljZXMgPSBbXSwgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0Zm9yICggdmFyIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xyXG5cclxuXHRcdHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xyXG5cclxuXHRcdGZvciAoIHZhciB4ID0gMDsgeCA8PSB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHUgPSB4IC8gd2lkdGhTZWdtZW50cztcclxuXHJcblx0XHRcdHZhciBweCA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcclxuXHRcdFx0dmFyIHB5ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcclxuXHRcdFx0dmFyIHB6ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcclxuXHJcblx0XHRcdG5vcm1hbC5zZXQoIHB4LCBweSwgcHogKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdHBvc2l0aW9ucy5zZXRYWVooIGluZGV4LCBweCwgcHksIHB6ICk7XHJcblx0XHRcdG5vcm1hbHMuc2V0WFlaKCBpbmRleCwgbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xyXG5cdFx0XHR1dnMuc2V0WFkoIGluZGV4LCB1LCAxIC0gdiApO1xyXG5cclxuXHRcdFx0dmVydGljZXNSb3cucHVzaCggaW5kZXggKTtcclxuXHJcblx0XHRcdGluZGV4ICsrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBpbmRpY2VzID0gW107XHJcblxyXG5cdGZvciAoIHZhciB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdGZvciAoIHZhciB4ID0gMDsgeCA8IHdpZHRoU2VnbWVudHM7IHggKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdjEgPSB2ZXJ0aWNlc1sgeSBdWyB4ICsgMSBdO1xyXG5cdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgeSBdWyB4IF07XHJcblx0XHRcdHZhciB2MyA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4IF07XHJcblx0XHRcdHZhciB2NCA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4ICsgMSBdO1xyXG5cclxuXHRcdFx0aWYgKCB5ICE9PSAwIHx8IHRoZXRhU3RhcnQgPiAwICkgaW5kaWNlcy5wdXNoKCB2MSwgdjIsIHY0ICk7XHJcblx0XHRcdGlmICggeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSApIGluZGljZXMucHVzaCggdjIsIHYzLCB2NCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnNldEluZGV4KCBuZXcgKCBwb3NpdGlvbnMuY291bnQgPiA2NTUzNSA/IFRIUkVFLlVpbnQzMkF0dHJpYnV0ZSA6IFRIUkVFLlVpbnQxNkF0dHJpYnV0ZSApKCBpbmRpY2VzLCAxICkgKTtcclxuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxzICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIHV2cyApO1xyXG5cclxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVGV4dEdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBUZXh0ID0gM0QgVGV4dFxyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgZm9udDogPFRIUkVFLkZvbnQ+LCAvLyBmb250XHJcbiAqXHJcbiAqICBzaXplOiA8ZmxvYXQ+LCAvLyBzaXplIG9mIHRoZSB0ZXh0XHJcbiAqICBoZWlnaHQ6IDxmbG9hdD4sIC8vIHRoaWNrbmVzcyB0byBleHRydWRlIHRleHRcclxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcclxuICpcclxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXHJcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0ZXh0IGJldmVsIGdvZXNcclxuICogIGJldmVsU2l6ZTogPGZsb2F0PiAvLyBob3cgZmFyIGZyb20gdGV4dCBvdXRsaW5lIGlzIGJldmVsXHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5UZXh0R2VvbWV0cnkgPSBmdW5jdGlvbiAoIHRleHQsIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xyXG5cclxuXHR2YXIgZm9udCA9IHBhcmFtZXRlcnMuZm9udDtcclxuXHJcblx0aWYgKCBmb250IGluc3RhbmNlb2YgVEhSRUUuRm9udCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRleHRHZW9tZXRyeTogZm9udCBwYXJhbWV0ZXIgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkZvbnQuJyApO1xyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBzaGFwZXMgPSBmb250LmdlbmVyYXRlU2hhcGVzKCB0ZXh0LCBwYXJhbWV0ZXJzLnNpemUsIHBhcmFtZXRlcnMuY3VydmVTZWdtZW50cyApO1xyXG5cclxuXHQvLyB0cmFuc2xhdGUgcGFyYW1ldGVycyB0byBFeHRydWRlR2VvbWV0cnkgQVBJXHJcblxyXG5cdHBhcmFtZXRlcnMuYW1vdW50ID0gcGFyYW1ldGVycy5oZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuaGVpZ2h0IDogNTA7XHJcblxyXG5cdC8vIGRlZmF1bHRzXHJcblxyXG5cdGlmICggcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9IDEwO1xyXG5cdGlmICggcGFyYW1ldGVycy5iZXZlbFNpemUgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxTaXplID0gODtcclxuXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRUSFJFRS5FeHRydWRlR2VvbWV0cnkuY2FsbCggdGhpcywgc2hhcGVzLCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdUZXh0R2VvbWV0cnknO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRleHRHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlRleHRHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5UZXh0R2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Ub3J1c0dlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNETGl0ZS9zcmMvYXdheTNkbGl0ZS9wcmltaXRpdmVzL1RvcnVzLmFzP3I9Mjg4OFxyXG4gKi9cclxuXHJcblRIUkVFLlRvcnVzR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdUb3J1c0dlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHR0dWJlOiB0dWJlLFxyXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXHJcblx0XHRhcmM6IGFyY1xyXG5cdH07XHJcblxyXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XHJcblx0dHViZSA9IHR1YmUgfHwgNDA7XHJcblx0cmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xyXG5cdHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA2O1xyXG5cdGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcclxuXHJcblx0dmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHV2cyA9IFtdLCBub3JtYWxzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xyXG5cdFx0XHR2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xyXG5cclxuXHRcdFx0Y2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyggdSApO1xyXG5cdFx0XHRjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0dmVydGV4LnggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xyXG5cdFx0XHR2ZXJ0ZXgueSA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguc2luKCB1ICk7XHJcblx0XHRcdHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdFx0dXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdHVidWxhclNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKSApO1xyXG5cdFx0XHRub3JtYWxzLnB1c2goIHZlcnRleC5jbG9uZSgpLnN1YiggY2VudGVyICkubm9ybWFsaXplKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggdmFyIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgYSA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGkgLSAxO1xyXG5cdFx0XHR2YXIgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XHJcblx0XHRcdHZhciBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xyXG5cdFx0XHR2YXIgZCA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGk7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCwgWyBub3JtYWxzWyBhIF0uY2xvbmUoKSwgbm9ybWFsc1sgYiBdLmNsb25lKCksIG5vcm1hbHNbIGQgXS5jbG9uZSgpIF0gKTtcclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBhIF0uY2xvbmUoKSwgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0XHRmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkLCBbIG5vcm1hbHNbIGIgXS5jbG9uZSgpLCBub3JtYWxzWyBjIF0uY2xvbmUoKSwgbm9ybWFsc1sgZCBdLmNsb25lKCkgXSApO1xyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIGIgXS5jbG9uZSgpLCB1dnNbIGMgXS5jbG9uZSgpLCB1dnNbIGQgXS5jbG9uZSgpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRvcnVzR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Ub3J1c0tub3RHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXHJcbiAqIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9hd2F5M2Qvc291cmNlL2Jyb3dzZS90cnVuay9mcDEwL0F3YXkzRC9zcmMvYXdheTNkL3ByaW1pdGl2ZXMvVG9ydXNLbm90LmFzP3NwZWM9c3ZuMjQ3MyZyPTI0NzNcclxuICovXHJcblxyXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnVG9ydXNLbm90R2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdHR1YmU6IHR1YmUsXHJcblx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcblx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcclxuXHRcdHA6IHAsXHJcblx0XHRxOiBxLFxyXG5cdFx0aGVpZ2h0U2NhbGU6IGhlaWdodFNjYWxlXHJcblx0fTtcclxuXHJcblx0cmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcclxuXHR0dWJlID0gdHViZSB8fCA0MDtcclxuXHRyYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDY0O1xyXG5cdHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA4O1xyXG5cdHAgPSBwIHx8IDI7XHJcblx0cSA9IHEgfHwgMztcclxuXHRoZWlnaHRTY2FsZSA9IGhlaWdodFNjYWxlIHx8IDE7XHJcblxyXG5cdHZhciBncmlkID0gbmV3IEFycmF5KCByYWRpYWxTZWdtZW50cyApO1xyXG5cdHZhciB0YW5nID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIGJpdGFuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcmFkaWFsU2VnbWVudHM7ICsrIGkgKSB7XHJcblxyXG5cdFx0Z3JpZFsgaSBdID0gbmV3IEFycmF5KCB0dWJ1bGFyU2VnbWVudHMgKTtcclxuXHRcdHZhciB1ID0gaSAvIHJhZGlhbFNlZ21lbnRzICogMiAqIHAgKiBNYXRoLlBJO1xyXG5cdFx0dmFyIHAxID0gZ2V0UG9zKCB1LCBxLCBwLCByYWRpdXMsIGhlaWdodFNjYWxlICk7XHJcblx0XHR2YXIgcDIgPSBnZXRQb3MoIHUgKyAwLjAxLCBxLCBwLCByYWRpdXMsIGhlaWdodFNjYWxlICk7XHJcblx0XHR0YW5nLnN1YlZlY3RvcnMoIHAyLCBwMSApO1xyXG5cdFx0bi5hZGRWZWN0b3JzKCBwMiwgcDEgKTtcclxuXHJcblx0XHRiaXRhbi5jcm9zc1ZlY3RvcnMoIHRhbmcsIG4gKTtcclxuXHRcdG4uY3Jvc3NWZWN0b3JzKCBiaXRhbiwgdGFuZyApO1xyXG5cdFx0Yml0YW4ubm9ybWFsaXplKCk7XHJcblx0XHRuLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKysgaiApIHtcclxuXHJcblx0XHRcdHZhciB2ID0gaiAvIHR1YnVsYXJTZWdtZW50cyAqIDIgKiBNYXRoLlBJO1xyXG5cdFx0XHR2YXIgY3ggPSAtIHR1YmUgKiBNYXRoLmNvcyggdiApOyAvLyBUT0RPOiBIYWNrOiBOZWdhdGluZyBpdCBzbyBpdCBmYWNlcyBvdXRzaWRlLlxyXG5cdFx0XHR2YXIgY3kgPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcclxuXHJcblx0XHRcdHZhciBwb3MgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRwb3MueCA9IHAxLnggKyBjeCAqIG4ueCArIGN5ICogYml0YW4ueDtcclxuXHRcdFx0cG9zLnkgPSBwMS55ICsgY3ggKiBuLnkgKyBjeSAqIGJpdGFuLnk7XHJcblx0XHRcdHBvcy56ID0gcDEueiArIGN4ICogbi56ICsgY3kgKiBiaXRhbi56O1xyXG5cclxuXHRcdFx0Z3JpZFsgaSBdWyBqIF0gPSB0aGlzLnZlcnRpY2VzLnB1c2goIHBvcyApIC0gMTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcmFkaWFsU2VnbWVudHM7ICsrIGkgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgdHVidWxhclNlZ21lbnRzOyArKyBqICkge1xyXG5cclxuXHRcdFx0dmFyIGlwID0gKCBpICsgMSApICUgcmFkaWFsU2VnbWVudHM7XHJcblx0XHRcdHZhciBqcCA9ICggaiArIDEgKSAlIHR1YnVsYXJTZWdtZW50cztcclxuXHJcblx0XHRcdHZhciBhID0gZ3JpZFsgaSBdWyBqIF07XHJcblx0XHRcdHZhciBiID0gZ3JpZFsgaXAgXVsgaiBdO1xyXG5cdFx0XHR2YXIgYyA9IGdyaWRbIGlwIF1bIGpwIF07XHJcblx0XHRcdHZhciBkID0gZ3JpZFsgaSBdWyBqcCBdO1xyXG5cclxuXHRcdFx0dmFyIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gcmFkaWFsU2VnbWVudHMsIGogLyB0dWJ1bGFyU2VnbWVudHMgKTtcclxuXHRcdFx0dmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xyXG5cdFx0XHR2YXIgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHJhZGlhbFNlZ21lbnRzLCAoIGogKyAxICkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcclxuXHRcdFx0dmFyIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gcmFkaWFsU2VnbWVudHMsICggaiArIDEgKSAvIHR1YnVsYXJTZWdtZW50cyApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG5cdGZ1bmN0aW9uIGdldFBvcyggdSwgaW5fcSwgaW5fcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApIHtcclxuXHJcblx0XHR2YXIgY3UgPSBNYXRoLmNvcyggdSApO1xyXG5cdFx0dmFyIHN1ID0gTWF0aC5zaW4oIHUgKTtcclxuXHRcdHZhciBxdU92ZXJQID0gaW5fcSAvIGluX3AgKiB1O1xyXG5cdFx0dmFyIGNzID0gTWF0aC5jb3MoIHF1T3ZlclAgKTtcclxuXHJcblx0XHR2YXIgdHggPSByYWRpdXMgKiAoIDIgKyBjcyApICogMC41ICogY3U7XHJcblx0XHR2YXIgdHkgPSByYWRpdXMgKiAoIDIgKyBjcyApICogc3UgKiAwLjU7XHJcblx0XHR2YXIgdHogPSBoZWlnaHRTY2FsZSAqIHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0eCwgdHksIHR6ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVG9ydXNLbm90R2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UdWJlR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XHJcbiAqIEBhdXRob3IgbWluaW5nb2xkIC8gaHR0cHM6Ly9naXRodWIuY29tL21pbmluZ29sZFxyXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwczovL2dpdGh1Yi5jb20vam9ub2JyMVxyXG4gKlxyXG4gKiBNb2RpZmllZCBmcm9tIHRoZSBUb3J1c0tub3RHZW9tZXRyeSBieSBAb29zbW94aWVjb2RlXHJcbiAqXHJcbiAqIENyZWF0ZXMgYSB0dWJlIHdoaWNoIGV4dHJ1ZGVzIGFsb25nIGEgM2Qgc3BsaW5lXHJcbiAqXHJcbiAqIFVzZXMgcGFyYWxsZWwgdHJhbnNwb3J0IGZyYW1lcyBhcyBkZXNjcmliZWQgaW5cclxuICogaHR0cDovL3d3dy5jcy5pbmRpYW5hLmVkdS9wdWIvdGVjaHJlcG9ydHMvVFI0MjUucGRmXHJcbiAqL1xyXG5cclxuVEhSRUUuVHViZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBwYXRoLCBzZWdtZW50cywgcmFkaXVzLCByYWRpYWxTZWdtZW50cywgY2xvc2VkLCB0YXBlciApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnVHViZUdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0cGF0aDogcGF0aCxcclxuXHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0Y2xvc2VkOiBjbG9zZWQsXHJcblx0XHR0YXBlcjogdGFwZXJcclxuXHR9O1xyXG5cclxuXHRzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDY0O1xyXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xyXG5cdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcclxuXHRjbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XHJcblx0dGFwZXIgPSB0YXBlciB8fCBUSFJFRS5UdWJlR2VvbWV0cnkuTm9UYXBlcjtcclxuXHJcblx0dmFyIGdyaWQgPSBbXTtcclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcyxcclxuXHJcblx0XHR0YW5nZW50LFxyXG5cdFx0bm9ybWFsLFxyXG5cdFx0Ymlub3JtYWwsXHJcblxyXG5cdFx0bnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxyXG5cclxuXHRcdHUsIHYsIHIsXHJcblxyXG5cdFx0Y3gsIGN5LFxyXG5cdFx0cG9zLCBwb3MyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdGksIGosXHJcblx0XHRpcCwganAsXHJcblx0XHRhLCBiLCBjLCBkLFxyXG5cdFx0dXZhLCB1dmIsIHV2YywgdXZkO1xyXG5cclxuXHR2YXIgZnJhbWVzID0gbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoIHBhdGgsIHNlZ21lbnRzLCBjbG9zZWQgKSxcclxuXHRcdHRhbmdlbnRzID0gZnJhbWVzLnRhbmdlbnRzLFxyXG5cdFx0bm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzLFxyXG5cdFx0Ymlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFscztcclxuXHJcblx0Ly8gcHJveHkgaW50ZXJuYWxzXHJcblx0dGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xyXG5cdHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XHJcblx0dGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XHJcblxyXG5cdGZ1bmN0aW9uIHZlcnQoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0cmV0dXJuIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKSAtIDE7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gY29uc3RydWN0IHRoZSBncmlkXHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xyXG5cclxuXHRcdGdyaWRbIGkgXSA9IFtdO1xyXG5cclxuXHRcdHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XHJcblxyXG5cdFx0cG9zID0gcGF0aC5nZXRQb2ludEF0KCB1ICk7XHJcblxyXG5cdFx0dGFuZ2VudCA9IHRhbmdlbnRzWyBpIF07XHJcblx0XHRub3JtYWwgPSBub3JtYWxzWyBpIF07XHJcblx0XHRiaW5vcm1hbCA9IGJpbm9ybWFsc1sgaSBdO1xyXG5cclxuXHRcdHIgPSByYWRpdXMgKiB0YXBlciggdSApO1xyXG5cclxuXHRcdGZvciAoIGogPSAwOyBqIDwgcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XHJcblxyXG5cdFx0XHR2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogMiAqIE1hdGguUEk7XHJcblxyXG5cdFx0XHRjeCA9IC0gciAqIE1hdGguY29zKCB2ICk7IC8vIFRPRE86IEhhY2s6IE5lZ2F0aW5nIGl0IHNvIGl0IGZhY2VzIG91dHNpZGUuXHJcblx0XHRcdGN5ID0gciAqIE1hdGguc2luKCB2ICk7XHJcblxyXG5cdFx0XHRwb3MyLmNvcHkoIHBvcyApO1xyXG5cdFx0XHRwb3MyLnggKz0gY3ggKiBub3JtYWwueCArIGN5ICogYmlub3JtYWwueDtcclxuXHRcdFx0cG9zMi55ICs9IGN4ICogbm9ybWFsLnkgKyBjeSAqIGJpbm9ybWFsLnk7XHJcblx0XHRcdHBvczIueiArPSBjeCAqIG5vcm1hbC56ICsgY3kgKiBiaW5vcm1hbC56O1xyXG5cclxuXHRcdFx0Z3JpZFsgaSBdWyBqIF0gPSB2ZXJ0KCBwb3MyLngsIHBvczIueSwgcG9zMi56ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBjb25zdHJ1Y3QgdGhlIG1lc2hcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuXHRcdFx0aXAgPSAoIGNsb3NlZCApID8gKCBpICsgMSApICUgc2VnbWVudHMgOiBpICsgMTtcclxuXHRcdFx0anAgPSAoIGogKyAxICkgJSByYWRpYWxTZWdtZW50cztcclxuXHJcblx0XHRcdGEgPSBncmlkWyBpIF1bIGogXTtcdFx0Ly8gKioqIE5PVCBORUNFU1NBUklMWSBQTEFOQVIgISAqKipcclxuXHRcdFx0YiA9IGdyaWRbIGlwIF1bIGogXTtcclxuXHRcdFx0YyA9IGdyaWRbIGlwIF1bIGpwIF07XHJcblx0XHRcdGQgPSBncmlkWyBpIF1bIGpwIF07XHJcblxyXG5cdFx0XHR1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcclxuXHRcdFx0dXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcclxuXHRcdFx0dXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xyXG5cdFx0XHR1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVHViZUdlb21ldHJ5O1xyXG5cclxuVEhSRUUuVHViZUdlb21ldHJ5Lk5vVGFwZXIgPSBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdHJldHVybiAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlR1YmVHZW9tZXRyeS5TaW51c29pZGFsVGFwZXIgPSBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdHJldHVybiBNYXRoLnNpbiggTWF0aC5QSSAqIHUgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGb3IgY29tcHV0aW5nIG9mIEZyZW5ldCBmcmFtZXMsIGV4cG9zaW5nIHRoZSB0YW5nZW50cywgbm9ybWFscyBhbmQgYmlub3JtYWxzIHRoZSBzcGxpbmVcclxuVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyA9IGZ1bmN0aW9uICggcGF0aCwgc2VnbWVudHMsIGNsb3NlZCApIHtcclxuXHJcblx0dmFyXHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuXHRcdHRhbmdlbnRzID0gW10sXHJcblx0XHRub3JtYWxzID0gW10sXHJcblx0XHRiaW5vcm1hbHMgPSBbXSxcclxuXHJcblx0XHR2ZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0bWF0ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHJcblx0XHRudW1wb2ludHMgPSBzZWdtZW50cyArIDEsXHJcblx0XHR0aGV0YSxcclxuXHRcdHNtYWxsZXN0LFxyXG5cclxuXHRcdHR4LCB0eSwgdHosXHJcblx0XHRpLCB1O1xyXG5cclxuXHJcblx0Ly8gZXhwb3NlIGludGVybmFsc1xyXG5cdHRoaXMudGFuZ2VudHMgPSB0YW5nZW50cztcclxuXHR0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xyXG5cdHRoaXMuYmlub3JtYWxzID0gYmlub3JtYWxzO1xyXG5cclxuXHQvLyBjb21wdXRlIHRoZSB0YW5nZW50IHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IG51bXBvaW50czsgaSArKyApIHtcclxuXHJcblx0XHR1ID0gaSAvICggbnVtcG9pbnRzIC0gMSApO1xyXG5cclxuXHRcdHRhbmdlbnRzWyBpIF0gPSBwYXRoLmdldFRhbmdlbnRBdCggdSApO1xyXG5cdFx0dGFuZ2VudHNbIGkgXS5ub3JtYWxpemUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRpbml0aWFsTm9ybWFsMygpO1xyXG5cclxuXHQvKlxyXG5cdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwxKGxhc3RCaW5vcm1hbCkge1xyXG5cdFx0Ly8gZml4ZWQgc3RhcnQgYmlub3JtYWwuIEhhcyBkYW5nZXJzIG9mIDAgdmVjdG9yc1xyXG5cdFx0bm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdGlmIChsYXN0Qmlub3JtYWw9PT11bmRlZmluZWQpIGxhc3RCaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XHJcblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCBsYXN0Qmlub3JtYWwsIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTtcclxuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpbml0aWFsTm9ybWFsMigpIHtcclxuXHJcblx0XHQvLyBUaGlzIHVzZXMgdGhlIEZyZW5ldC1TZXJyZXQgZm9ybXVsYSBmb3IgZGVyaXZpbmcgYmlub3JtYWxcclxuXHRcdHZhciB0MiA9IHBhdGguZ2V0VGFuZ2VudEF0KCBlcHNpbG9uICk7XHJcblxyXG5cdFx0bm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5zdWJWZWN0b3JzKCB0MiwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XHJcblxyXG5cdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggYmlub3JtYWxzWyAwIF0sIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTsgLy8gbGFzdCBiaW5vcm1hbCB4IHRhbmdlbnRcclxuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XHJcblxyXG5cdH1cclxuXHQqL1xyXG5cclxuXHRmdW5jdGlvbiBpbml0aWFsTm9ybWFsMygpIHtcclxuXHJcblx0XHQvLyBzZWxlY3QgYW4gaW5pdGlhbCBub3JtYWwgdmVjdG9yIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxyXG5cdFx0Ly8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNtYWxsZXN0IHRhbmdlbnQgeHl6IGNvbXBvbmVudFxyXG5cclxuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRzbWFsbGVzdCA9IE51bWJlci5NQVhfVkFMVUU7XHJcblx0XHR0eCA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnggKTtcclxuXHRcdHR5ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueSApO1xyXG5cdFx0dHogPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS56ICk7XHJcblxyXG5cdFx0aWYgKCB0eCA8PSBzbWFsbGVzdCApIHtcclxuXHJcblx0XHRcdHNtYWxsZXN0ID0gdHg7XHJcblx0XHRcdG5vcm1hbC5zZXQoIDEsIDAsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0eSA8PSBzbWFsbGVzdCApIHtcclxuXHJcblx0XHRcdHNtYWxsZXN0ID0gdHk7XHJcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0eiA8PSBzbWFsbGVzdCApIHtcclxuXHJcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDAsIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgdmVjICk7XHJcblx0XHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxyXG5cclxuXHRmb3IgKCBpID0gMTsgaSA8IG51bXBvaW50czsgaSArKyApIHtcclxuXHJcblx0XHRub3JtYWxzWyBpIF0gPSBub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XHJcblxyXG5cdFx0Ymlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcclxuXHJcblx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSAtIDEgXSwgdGFuZ2VudHNbIGkgXSApO1xyXG5cclxuXHRcdGlmICggdmVjLmxlbmd0aCgpID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHR2ZWMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHR0aGV0YSA9IE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggdGFuZ2VudHNbIGkgLSAxIF0uZG90KCB0YW5nZW50c1sgaSBdICksIC0gMSwgMSApICk7IC8vIGNsYW1wIGZvciBmbG9hdGluZyBwdCBlcnJvcnNcclxuXHJcblx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB2ZWMsIHRoZXRhICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gaWYgdGhlIGN1cnZlIGlzIGNsb3NlZCwgcG9zdHByb2Nlc3MgdGhlIHZlY3RvcnMgc28gdGhlIGZpcnN0IGFuZCBsYXN0IG5vcm1hbCB2ZWN0b3JzIGFyZSB0aGUgc2FtZVxyXG5cclxuXHRpZiAoIGNsb3NlZCApIHtcclxuXHJcblx0XHR0aGV0YSA9IE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggbm9ybWFsc1sgMCBdLmRvdCggbm9ybWFsc1sgbnVtcG9pbnRzIC0gMSBdICksIC0gMSwgMSApICk7XHJcblx0XHR0aGV0YSAvPSAoIG51bXBvaW50cyAtIDEgKTtcclxuXHJcblx0XHRpZiAoIHRhbmdlbnRzWyAwIF0uZG90KCB2ZWMuY3Jvc3NWZWN0b3JzKCBub3JtYWxzWyAwIF0sIG5vcm1hbHNbIG51bXBvaW50cyAtIDEgXSApICkgPiAwICkge1xyXG5cclxuXHRcdFx0dGhldGEgPSAtIHRoZXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpID0gMTsgaSA8IG51bXBvaW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdC8vIHR3aXN0IGEgbGl0dGxlLi4uXHJcblx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB0YW5nZW50c1sgaSBdLCB0aGV0YSAqIGkgKSApO1xyXG5cdFx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BvbHloZWRyb25HZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgY2xvY2t3b3JrZ2VlayAvIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG9ja3dvcmtnZWVrXHJcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiovXHJcblxyXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnUG9seWhlZHJvbkdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0dmVydGljZXM6IHZlcnRpY2VzLFxyXG5cdFx0aW5kaWNlczogaW5kaWNlcyxcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHR9O1xyXG5cclxuXHRyYWRpdXMgPSByYWRpdXMgfHwgMTtcclxuXHRkZXRhaWwgPSBkZXRhaWwgfHwgMDtcclxuXHJcblx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0cHJlcGFyZSggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCB2ZXJ0aWNlc1sgaSArIDIgXSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIHAgPSB0aGlzLnZlcnRpY2VzO1xyXG5cclxuXHR2YXIgZmFjZXMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBqID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzLCBqICsrICkge1xyXG5cclxuXHRcdHZhciB2MSA9IHBbIGluZGljZXNbIGkgXSBdO1xyXG5cdFx0dmFyIHYyID0gcFsgaW5kaWNlc1sgaSArIDEgXSBdO1xyXG5cdFx0dmFyIHYzID0gcFsgaW5kaWNlc1sgaSArIDIgXSBdO1xyXG5cclxuXHRcdGZhY2VzWyBqIF0gPSBuZXcgVEhSRUUuRmFjZTMoIHYxLmluZGV4LCB2Mi5pbmRleCwgdjMuaW5kZXgsIFsgdjEuY2xvbmUoKSwgdjIuY2xvbmUoKSwgdjMuY2xvbmUoKSBdLCB1bmRlZmluZWQsIGogKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgY2VudHJvaWQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHN1YmRpdmlkZSggZmFjZXNbIGkgXSwgZGV0YWlsICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gZmFjZSBzdHJhZGRsZXMgdGhlIHNlYW1cclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcclxuXHJcblx0XHR2YXIgeDAgPSB1dnNbIDAgXS54O1xyXG5cdFx0dmFyIHgxID0gdXZzWyAxIF0ueDtcclxuXHRcdHZhciB4MiA9IHV2c1sgMiBdLng7XHJcblxyXG5cdFx0dmFyIG1heCA9IE1hdGgubWF4KCB4MCwgeDEsIHgyICk7XHJcblx0XHR2YXIgbWluID0gTWF0aC5taW4oIHgwLCB4MSwgeDIgKTtcclxuXHJcblx0XHRpZiAoIG1heCA+IDAuOSAmJiBtaW4gPCAwLjEgKSB7XHJcblxyXG5cdFx0XHQvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XHJcblxyXG5cdFx0XHRpZiAoIHgwIDwgMC4yICkgdXZzWyAwIF0ueCArPSAxO1xyXG5cdFx0XHRpZiAoIHgxIDwgMC4yICkgdXZzWyAxIF0ueCArPSAxO1xyXG5cdFx0XHRpZiAoIHgyIDwgMC4yICkgdXZzWyAyIF0ueCArPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQXBwbHkgcmFkaXVzXHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzWyBpIF0ubXVsdGlwbHlTY2FsYXIoIHJhZGl1cyApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBNZXJnZSB2ZXJ0aWNlc1xyXG5cclxuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xyXG5cclxuXHJcblx0Ly8gUHJvamVjdCB2ZWN0b3Igb250byBzcGhlcmUncyBzdXJmYWNlXHJcblxyXG5cdGZ1bmN0aW9uIHByZXBhcmUoIHZlY3RvciApIHtcclxuXHJcblx0XHR2YXIgdmVydGV4ID0gdmVjdG9yLm5vcm1hbGl6ZSgpLmNsb25lKCk7XHJcblx0XHR2ZXJ0ZXguaW5kZXggPSB0aGF0LnZlcnRpY2VzLnB1c2goIHZlcnRleCApIC0gMTtcclxuXHJcblx0XHQvLyBUZXh0dXJlIGNvb3JkcyBhcmUgZXF1aXZhbGVudCB0byBtYXAgY29vcmRzLCBjYWxjdWxhdGUgYW5nbGUgYW5kIGNvbnZlcnQgdG8gZnJhY3Rpb24gb2YgYSBjaXJjbGUuXHJcblxyXG5cdFx0dmFyIHUgPSBhemltdXRoKCB2ZWN0b3IgKSAvIDIgLyBNYXRoLlBJICsgMC41O1xyXG5cdFx0dmFyIHYgPSBpbmNsaW5hdGlvbiggdmVjdG9yICkgLyBNYXRoLlBJICsgMC41O1xyXG5cdFx0dmVydGV4LnV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIDEgLSB2ICk7XHJcblxyXG5cdFx0cmV0dXJuIHZlcnRleDtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQXBwcm94aW1hdGUgYSBjdXJ2ZWQgZmFjZSB3aXRoIHJlY3Vyc2l2ZWx5IHN1Yi1kaXZpZGVkIHRyaWFuZ2xlcy5cclxuXHJcblx0ZnVuY3Rpb24gbWFrZSggdjEsIHYyLCB2MywgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0sIHVuZGVmaW5lZCwgbWF0ZXJpYWxJbmRleCApO1xyXG5cdFx0dGhhdC5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0Y2VudHJvaWQuY29weSggdjEgKS5hZGQoIHYyICkuYWRkKCB2MyApLmRpdmlkZVNjYWxhciggMyApO1xyXG5cclxuXHRcdHZhciBhemkgPSBhemltdXRoKCBjZW50cm9pZCApO1xyXG5cclxuXHRcdHRoYXQuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcclxuXHRcdFx0Y29ycmVjdFVWKCB2MS51diwgdjEsIGF6aSApLFxyXG5cdFx0XHRjb3JyZWN0VVYoIHYyLnV2LCB2MiwgYXppICksXHJcblx0XHRcdGNvcnJlY3RVViggdjMudXYsIHYzLCBhemkgKVxyXG5cdFx0XSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBBbmFseXRpY2FsbHkgc3ViZGl2aWRlIGEgZmFjZSB0byB0aGUgcmVxdWlyZWQgZGV0YWlsIGxldmVsLlxyXG5cclxuXHRmdW5jdGlvbiBzdWJkaXZpZGUoIGZhY2UsIGRldGFpbCApIHtcclxuXHJcblx0XHR2YXIgY29scyA9IE1hdGgucG93KCAyLCBkZXRhaWwgKTtcclxuXHRcdHZhciBhID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcclxuXHRcdHZhciBiID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcclxuXHRcdHZhciBjID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcclxuXHRcdHZhciB2ID0gW107XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0Ly8gQ29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb24uXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwIDsgaSA8PSBjb2xzOyBpICsrICkge1xyXG5cclxuXHRcdFx0dlsgaSBdID0gW107XHJcblxyXG5cdFx0XHR2YXIgYWogPSBwcmVwYXJlKCBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xyXG5cdFx0XHR2YXIgYmogPSBwcmVwYXJlKCBiLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xyXG5cdFx0XHR2YXIgcm93cyA9IGNvbHMgLSBpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDw9IHJvd3M7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggaiA9PT0gMCAmJiBpID09PSBjb2xzICkge1xyXG5cclxuXHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gYWo7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBwcmVwYXJlKCBhai5jbG9uZSgpLmxlcnAoIGJqLCBqIC8gcm93cyApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ29uc3RydWN0IGFsbCBvZiB0aGUgZmFjZXMuXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY29scyA7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyICogKCBjb2xzIC0gaSApIC0gMTsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGogJSAyID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdG1ha2UoXHJcblx0XHRcdFx0XHRcdHZbIGkgXVsgayArIDEgXSxcclxuXHRcdFx0XHRcdFx0dlsgaSArIDEgXVsgayBdLFxyXG5cdFx0XHRcdFx0XHR2WyBpIF1bIGsgXSxcclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxJbmRleFxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRtYWtlKFxyXG5cdFx0XHRcdFx0XHR2WyBpIF1bIGsgKyAxIF0sXHJcblx0XHRcdFx0XHRcdHZbIGkgKyAxIF1bIGsgKyAxIF0sXHJcblx0XHRcdFx0XHRcdHZbIGkgKyAxIF1bIGsgXSxcclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxJbmRleFxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMsIGNvdW50ZXItY2xvY2t3aXNlIHdoZW4gbG9va2luZyBmcm9tIGFib3ZlLlxyXG5cclxuXHRmdW5jdGlvbiBhemltdXRoKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYXRhbjIoIHZlY3Rvci56LCAtIHZlY3Rvci54ICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIEFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZS5cclxuXHJcblx0ZnVuY3Rpb24gaW5jbGluYXRpb24oIHZlY3RvciApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hdGFuMiggLSB2ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gVGV4dHVyZSBmaXhpbmcgaGVscGVyLiBTcGhlcmVzIGhhdmUgc29tZSBvZGQgYmVoYXZpb3Vycy5cclxuXHJcblx0ZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgdmVjdG9yLCBhemltdXRoICkge1xyXG5cclxuXHRcdGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYueCAtIDEsIHV2LnkgKTtcclxuXHRcdGlmICggKCB2ZWN0b3IueCA9PT0gMCApICYmICggdmVjdG9yLnogPT09IDAgKSApIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNSwgdXYueSApO1xyXG5cdFx0cmV0dXJuIHV2LmNsb25lKCk7XHJcblxyXG5cdH1cclxuXHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRG9kZWNhaGVkcm9uR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIEFiZSBQYXpvcyAvIGh0dHBzOi8vaGFtb2lkLmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcblx0dmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcclxuXHR2YXIgciA9IDEgLyB0O1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBbXHJcblxyXG5cdFx0Ly8gKMKxMSwgwrExLCDCsTEpXHJcblx0XHQtIDEsIC0gMSwgLSAxLCAgICAtIDEsIC0gMSwgIDEsXHJcblx0XHQtIDEsICAxLCAtIDEsICAgIC0gMSwgIDEsICAxLFxyXG5cdFx0IDEsIC0gMSwgLSAxLCAgICAgMSwgLSAxLCAgMSxcclxuXHRcdCAxLCAgMSwgLSAxLCAgICAgMSwgIDEsICAxLFxyXG5cclxuXHRcdC8vICgwLCDCsTEvz4YsIMKxz4YpXHJcblx0XHQgMCwgLSByLCAtIHQsICAgICAwLCAtIHIsICB0LFxyXG5cdFx0IDAsICByLCAtIHQsICAgICAwLCAgciwgIHQsXHJcblxyXG5cdFx0Ly8gKMKxMS/PhiwgwrHPhiwgMClcclxuXHRcdC0gciwgLSB0LCAgMCwgICAgLSByLCAgdCwgIDAsXHJcblx0XHQgciwgLSB0LCAgMCwgICAgIHIsICB0LCAgMCxcclxuXHJcblx0XHQvLyAowrHPhiwgMCwgwrExL8+GKVxyXG5cdFx0LSB0LCAgMCwgLSByLCAgICAgdCwgIDAsIC0gcixcclxuXHRcdC0gdCwgIDAsICByLCAgICAgdCwgIDAsICByXHJcblx0XTtcclxuXHJcblx0dmFyIGluZGljZXMgPSBbXHJcblx0XHQgMywgMTEsICA3LCAgICAgIDMsICA3LCAxNSwgICAgICAzLCAxNSwgMTMsXHJcblx0XHQgNywgMTksIDE3LCAgICAgIDcsIDE3LCAgNiwgICAgICA3LCAgNiwgMTUsXHJcblx0XHQxNywgIDQsICA4LCAgICAgMTcsICA4LCAxMCwgICAgIDE3LCAxMCwgIDYsXHJcblx0XHQgOCwgIDAsIDE2LCAgICAgIDgsIDE2LCAgMiwgICAgICA4LCAgMiwgMTAsXHJcblx0XHQgMCwgMTIsICAxLCAgICAgIDAsICAxLCAxOCwgICAgICAwLCAxOCwgMTYsXHJcblx0XHQgNiwgMTAsICAyLCAgICAgIDYsICAyLCAxMywgICAgICA2LCAxMywgMTUsXHJcblx0XHQgMiwgMTYsIDE4LCAgICAgIDIsIDE4LCAgMywgICAgICAyLCAgMywgMTMsXHJcblx0XHQxOCwgIDEsICA5LCAgICAgMTgsICA5LCAxMSwgICAgIDE4LCAxMSwgIDMsXHJcblx0XHQgNCwgMTQsIDEyLCAgICAgIDQsIDEyLCAgMCwgICAgICA0LCAgMCwgIDgsXHJcblx0XHQxMSwgIDksICA1LCAgICAgMTEsICA1LCAxOSwgICAgIDExLCAxOSwgIDcsXHJcblx0XHQxOSwgIDUsIDE0LCAgICAgMTksIDE0LCAgNCwgICAgIDE5LCAgNCwgMTcsXHJcblx0XHQgMSwgMTIsIDE0LCAgICAgIDEsIDE0LCAgNSwgICAgICAxLCAgNSwgIDlcclxuXHRdO1xyXG5cclxuXHRUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdEb2RlY2FoZWRyb25HZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9JY29zYWhlZHJvbkdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuXHR2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBbXHJcblx0XHQtIDEsICB0LCAgMCwgICAgMSwgIHQsICAwLCAgIC0gMSwgLSB0LCAgMCwgICAgMSwgLSB0LCAgMCxcclxuXHRcdCAwLCAtIDEsICB0LCAgICAwLCAgMSwgIHQsICAgIDAsIC0gMSwgLSB0LCAgICAwLCAgMSwgLSB0LFxyXG5cdFx0IHQsICAwLCAtIDEsICAgIHQsICAwLCAgMSwgICAtIHQsICAwLCAtIDEsICAgLSB0LCAgMCwgIDFcclxuXHRdO1xyXG5cclxuXHR2YXIgaW5kaWNlcyA9IFtcclxuXHRcdCAwLCAxMSwgIDUsICAgIDAsICA1LCAgMSwgICAgMCwgIDEsICA3LCAgICAwLCAgNywgMTAsICAgIDAsIDEwLCAxMSxcclxuXHRcdCAxLCAgNSwgIDksICAgIDUsIDExLCAgNCwgICAxMSwgMTAsICAyLCAgIDEwLCAgNywgIDYsICAgIDcsICAxLCAgOCxcclxuXHRcdCAzLCAgOSwgIDQsICAgIDMsICA0LCAgMiwgICAgMywgIDIsICA2LCAgICAzLCAgNiwgIDgsICAgIDMsICA4LCAgOSxcclxuXHRcdCA0LCAgOSwgIDUsICAgIDIsICA0LCAxMSwgICAgNiwgIDIsIDEwLCAgICA4LCAgNiwgIDcsICAgIDksICA4LCAgMVxyXG5cdF07XHJcblxyXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uR2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdGRldGFpbDogZGV0YWlsXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvT2N0YWhlZHJvbkdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IFtcclxuXHRcdDEsIDAsIDAsICAgLSAxLCAwLCAwLCAgICAwLCAxLCAwLCAgICAwLCAtIDEsIDAsICAgIDAsIDAsIDEsICAgIDAsIDAsIC0gMVxyXG5cdF07XHJcblxyXG5cdHZhciBpbmRpY2VzID0gW1xyXG5cdFx0MCwgMiwgNCwgICAgMCwgNCwgMywgICAgMCwgMywgNSwgICAgMCwgNSwgMiwgICAgMSwgMiwgNSwgICAgMSwgNSwgMywgICAgMSwgMywgNCwgICAgMSwgNCwgMlxyXG5cdF07XHJcblxyXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ09jdGFoZWRyb25HZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UZXRyYWhlZHJvbkdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBbXHJcblx0XHQgMSwgIDEsICAxLCAgIC0gMSwgLSAxLCAgMSwgICAtIDEsICAxLCAtIDEsICAgIDEsIC0gMSwgLSAxXHJcblx0XTtcclxuXHJcblx0dmFyIGluZGljZXMgPSBbXHJcblx0XHQgMiwgIDEsICAwLCAgICAwLCAgMywgIDIsICAgIDEsICAzLCAgMCwgICAgMiwgIDMsICAxXHJcblx0XTtcclxuXHJcblx0VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QYXJhbWV0cmljR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKiBQYXJhbWV0cmljIFN1cmZhY2VzIEdlb21ldHJ5XHJcbiAqIGJhc2VkIG9uIHRoZSBicmlsbGlhbnQgYXJ0aWNsZSBieSBAcHJpZGVvdXQgaHR0cDovL3ByaWRlb3V0Lm5ldC9ibG9nLz9wPTQ0XHJcbiAqXHJcbiAqIG5ldyBUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkoIHBhcmFtZXRyaWNGdW5jdGlvbiwgdVNlZ21lbnRzLCB5U2VnZW1lbnRzICk7XHJcbiAqXHJcbiAqL1xyXG5cclxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBmdW5jLCBzbGljZXMsIHN0YWNrcyApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnUGFyYW1ldHJpY0dlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0ZnVuYzogZnVuYyxcclxuXHRcdHNsaWNlczogc2xpY2VzLFxyXG5cdFx0c3RhY2tzOiBzdGFja3NcclxuXHR9O1xyXG5cclxuXHR2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xyXG5cdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XHJcblx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xyXG5cclxuXHR2YXIgaSwgaiwgcDtcclxuXHR2YXIgdSwgdjtcclxuXHJcblx0dmFyIHNsaWNlQ291bnQgPSBzbGljZXMgKyAxO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8PSBzdGFja3M7IGkgKysgKSB7XHJcblxyXG5cdFx0diA9IGkgLyBzdGFja3M7XHJcblxyXG5cdFx0Zm9yICggaiA9IDA7IGogPD0gc2xpY2VzOyBqICsrICkge1xyXG5cclxuXHRcdFx0dSA9IGogLyBzbGljZXM7XHJcblxyXG5cdFx0XHRwID0gZnVuYyggdSwgdiApO1xyXG5cdFx0XHR2ZXJ0cy5wdXNoKCBwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHZhciBhLCBiLCBjLCBkO1xyXG5cdHZhciB1dmEsIHV2YiwgdXZjLCB1dmQ7XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgc3RhY2tzOyBpICsrICkge1xyXG5cclxuXHRcdGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xyXG5cclxuXHRcdFx0YSA9IGkgKiBzbGljZUNvdW50ICsgajtcclxuXHRcdFx0YiA9IGkgKiBzbGljZUNvdW50ICsgaiArIDE7XHJcblx0XHRcdGMgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgaiArIDE7XHJcblx0XHRcdGQgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgajtcclxuXHJcblx0XHRcdHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XHJcblx0XHRcdHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGogKyAxICkgLyBzbGljZXMsIGkgLyBzdGFja3MgKTtcclxuXHRcdFx0dXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XHJcblx0XHRcdHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcclxuXHJcblx0XHRcdGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XHJcblx0XHRcdHV2cy5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuXHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcclxuXHRcdFx0dXZzLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBjb25zb2xlLmxvZyh0aGlzKTtcclxuXHJcblx0Ly8gbWFnaWMgYnVsbGV0XHJcblx0Ly8gdmFyIGRpZmYgPSB0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHQvLyBjb25zb2xlLmxvZygncmVtb3ZlZCAnLCBkaWZmLCAnIHZlcnRpY2VzIGJ5IG1lcmdpbmcnKTtcclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvV2lyZWZyYW1lR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR2YXIgZWRnZSA9IFsgMCwgMCBdLCBoYXNoID0ge307XHJcblxyXG5cdGZ1bmN0aW9uIHNvcnRGdW5jdGlvbiggYSwgYiApIHtcclxuXHJcblx0XHRyZXR1cm4gYSAtIGI7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcclxuXHJcblx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblx0XHR2YXIgbnVtRWRnZXMgPSAwO1xyXG5cclxuXHRcdC8vIGFsbG9jYXRlIG1heGltYWwgc2l6ZVxyXG5cdFx0dmFyIGVkZ2VzID0gbmV3IFVpbnQzMkFycmF5KCA2ICogZmFjZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xyXG5cdFx0XHRcdGVkZ2VbIDEgXSA9IGZhY2VbIGtleXNbICggaiArIDEgKSAlIDMgXSBdO1xyXG5cdFx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XHJcblxyXG5cdFx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRcdGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XHJcblx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzICsgMSBdID0gZWRnZVsgMSBdO1xyXG5cdFx0XHRcdFx0aGFzaFsga2V5IF0gPSB0cnVlO1xyXG5cdFx0XHRcdFx0bnVtRWRnZXMgKys7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1FZGdlczsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXNbIGVkZ2VzIFsgMiAqIGkgKyBqIF0gXTtcclxuXHJcblx0XHRcdFx0dmFyIGluZGV4ID0gNiAqIGkgKyAzICogajtcclxuXHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGV4Lng7XHJcblx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDEgXSA9IHZlcnRleC55O1xyXG5cdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0ZXguejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XHJcblxyXG5cdH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdC8vIEluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcclxuXHJcblx0XHRcdHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXguYXJyYXk7XHJcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblx0XHRcdHZhciBudW1FZGdlcyA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LmFkZEdyb3VwKCAwLCBpbmRpY2VzLmxlbmd0aCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXHJcblx0XHRcdHZhciBlZGdlcyA9IG5ldyBVaW50MzJBcnJheSggMiAqIGluZGljZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgbyA9IDAsIG9sID0gZ3JvdXBzLmxlbmd0aDsgbyA8IG9sOyArKyBvICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIG8gXTtcclxuXHJcblx0XHRcdFx0dmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XHJcblx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGVkZ2VbIDAgXSA9IGluZGljZXNbIGkgKyBqIF07XHJcblx0XHRcdFx0XHRcdGVkZ2VbIDEgXSA9IGluZGljZXNbIGkgKyAoIGogKyAxICkgJSAzIF07XHJcblx0XHRcdFx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XHJcblx0XHRcdFx0XHRcdFx0ZWRnZXNbIDIgKiBudW1FZGdlcyArIDEgXSA9IGVkZ2VbIDEgXTtcclxuXHRcdFx0XHRcdFx0XHRoYXNoWyBrZXkgXSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0bnVtRWRnZXMgKys7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbnVtRWRnZXM7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBpbmRleCA9IDYgKiBpICsgMyAqIGo7XHJcblx0XHRcdFx0XHR2YXIgaW5kZXgyID0gZWRnZXNbIDIgKiBpICsgaiBdO1xyXG5cclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0aWNlcy5nZXRYKCBpbmRleDIgKTtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0aWNlcy5nZXRZKCBpbmRleDIgKTtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0aWNlcy5nZXRaKCBpbmRleDIgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5XHJcblxyXG5cdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cdFx0XHR2YXIgbnVtRWRnZXMgPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xyXG5cdFx0XHR2YXIgbnVtVHJpcyA9IG51bUVkZ2VzIC8gMztcclxuXHJcblx0XHRcdHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1UcmlzOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgaW5kZXggPSAxOCAqIGkgKyA2ICogajtcclxuXHJcblx0XHRcdFx0XHR2YXIgaW5kZXgxID0gOSAqIGkgKyAzICogajtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxIF07XHJcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXNbIGluZGV4MSArIDEgXTtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxICsgMiBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciBpbmRleDIgPSA5ICogaSArIDMgKiAoICggaiArIDEgKSAlIDMgKTtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAzIF0gPSB2ZXJ0aWNlc1sgaW5kZXgyIF07XHJcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgNCBdID0gdmVydGljZXNbIGluZGV4MiArIDEgXTtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyA1IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMiBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5XaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9BeGlzSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBzcm91Y2hlcmF5IC8gaHR0cDovL3Nyb3VjaGVyYXkub3JnL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkF4aXNIZWxwZXIgPSBmdW5jdGlvbiAoIHNpemUgKSB7XHJcblxyXG5cdHNpemUgPSBzaXplIHx8IDE7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuXHRcdDAsIDAsIDAsICBzaXplLCAwLCAwLFxyXG5cdFx0MCwgMCwgMCwgIDAsIHNpemUsIDAsXHJcblx0XHQwLCAwLCAwLCAgMCwgMCwgc2l6ZVxyXG5cdF0gKTtcclxuXHJcblx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuXHRcdDEsIDAsIDAsICAxLCAwLjYsIDAsXHJcblx0XHQwLCAxLCAwLCAgMC42LCAxLCAwLFxyXG5cdFx0MCwgMCwgMSwgIDAsIDAuNiwgMVxyXG5cdF0gKTtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnMgfSApO1xyXG5cclxuXHRUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXhpc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblRIUkVFLkF4aXNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXhpc0hlbHBlcjtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0Fycm93SGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly9naXRodWIuY29tL3p6ODVcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKlxyXG4gKiBDcmVhdGVzIGFuIGFycm93IGZvciB2aXN1YWxpemluZyBkaXJlY3Rpb25zXHJcbiAqXHJcbiAqIFBhcmFtZXRlcnM6XHJcbiAqICBkaXIgLSBWZWN0b3IzXHJcbiAqICBvcmlnaW4gLSBWZWN0b3IzXHJcbiAqICBsZW5ndGggLSBOdW1iZXJcclxuICogIGNvbG9yIC0gY29sb3IgaW4gaGV4IHZhbHVlXHJcbiAqICBoZWFkTGVuZ3RoIC0gTnVtYmVyXHJcbiAqICBoZWFkV2lkdGggLSBOdW1iZXJcclxuICovXHJcblxyXG5USFJFRS5BcnJvd0hlbHBlciA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbGluZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0bGluZUdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcclxuXHJcblx0dmFyIGNvbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAwLjUsIDEsIDUsIDEgKTtcclxuXHRjb25lR2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtIDAuNSwgMCApO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gQXJyb3dIZWxwZXIoIGRpciwgb3JpZ2luLCBsZW5ndGgsIGNvbG9yLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XHJcblxyXG5cdFx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxyXG5cclxuXHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IDB4ZmZmZjAwO1xyXG5cdFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IDE7XHJcblx0XHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XHJcblx0XHRpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIG9yaWdpbiApO1xyXG5cdFx0XHJcblx0XHR0aGlzLmxpbmUgPSBuZXcgVEhSRUUuTGluZSggbGluZUdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xyXG5cdFx0dGhpcy5saW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHRcdHRoaXMuYWRkKCB0aGlzLmxpbmUgKTtcclxuXHJcblx0XHR0aGlzLmNvbmUgPSBuZXcgVEhSRUUuTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xyXG5cdFx0dGhpcy5jb25lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHRcdHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcclxuXHJcblx0XHR0aGlzLnNldERpcmVjdGlvbiggZGlyICk7XHJcblx0XHR0aGlzLnNldExlbmd0aCggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcclxuXHJcblx0fVxyXG5cclxufSgpICk7XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJyb3dIZWxwZXI7XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBheGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgcmFkaWFucztcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHNldERpcmVjdGlvbiggZGlyICkge1xyXG5cclxuXHRcdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHRpZiAoIGRpci55ID4gMC45OTk5OSApIHtcclxuXHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDAsIDAsIDAsIDEgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBkaXIueSA8IC0gMC45OTk5OSApIHtcclxuXHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0YXhpcy5zZXQoIGRpci56LCAwLCAtIGRpci54ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRyYWRpYW5zID0gTWF0aC5hY29zKCBkaXIueSApO1xyXG5cclxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIHJhZGlhbnMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbiAoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xyXG5cclxuXHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XHJcblx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XHJcblxyXG5cdHRoaXMubGluZS5zY2FsZS5zZXQoIDEsIE1hdGgubWF4KCAwLCBsZW5ndGggLSBoZWFkTGVuZ3RoICksIDEgKTtcclxuXHR0aGlzLmxpbmUudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdHRoaXMuY29uZS5zY2FsZS5zZXQoIGhlYWRXaWR0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XHJcblx0dGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XHJcblx0dGhpcy5jb25lLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5zZXQoIGNvbG9yICk7XHJcblx0dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldCggY29sb3IgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Cb3hIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkJveEhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHR2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWyAwLCAxLCAxLCAyLCAyLCAzLCAzLCAwLCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA0LCAwLCA0LCAxLCA1LCAyLCA2LCAzLCA3IF0gKTtcclxuXHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggOCAqIDMgKTtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xyXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcclxuXHJcblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZjAwIH0gKSApO1xyXG5cclxuXHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHRoaXMudXBkYXRlKCBvYmplY3QgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb3hIZWxwZXI7XHJcblxyXG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdGJveC5zZXRGcm9tT2JqZWN0KCBvYmplY3QgKTtcclxuXHJcblx0XHRpZiAoIGJveC5pc0VtcHR5KCkgKSByZXR1cm47XHJcblxyXG5cdFx0dmFyIG1pbiA9IGJveC5taW47XHJcblx0XHR2YXIgbWF4ID0gYm94Lm1heDtcclxuXHJcblx0XHQvKlxyXG5cdFx0ICA1X19fXzRcclxuXHRcdDEvX19fMC98XHJcblx0XHR8IDZfX3xfN1xyXG5cdFx0Mi9fX18zL1xyXG5cclxuXHRcdDA6IG1heC54LCBtYXgueSwgbWF4LnpcclxuXHRcdDE6IG1pbi54LCBtYXgueSwgbWF4LnpcclxuXHRcdDI6IG1pbi54LCBtaW4ueSwgbWF4LnpcclxuXHRcdDM6IG1heC54LCBtaW4ueSwgbWF4LnpcclxuXHRcdDQ6IG1heC54LCBtYXgueSwgbWluLnpcclxuXHRcdDU6IG1pbi54LCBtYXgueSwgbWluLnpcclxuXHRcdDY6IG1pbi54LCBtaW4ueSwgbWluLnpcclxuXHRcdDc6IG1heC54LCBtaW4ueSwgbWluLnpcclxuXHRcdCovXHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cdFx0dmFyIGFycmF5ID0gcG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0YXJyYXlbICAwIF0gPSBtYXgueDsgYXJyYXlbICAxIF0gPSBtYXgueTsgYXJyYXlbICAyIF0gPSBtYXguejtcclxuXHRcdGFycmF5WyAgMyBdID0gbWluLng7IGFycmF5WyAgNCBdID0gbWF4Lnk7IGFycmF5WyAgNSBdID0gbWF4Lno7XHJcblx0XHRhcnJheVsgIDYgXSA9IG1pbi54OyBhcnJheVsgIDcgXSA9IG1pbi55OyBhcnJheVsgIDggXSA9IG1heC56O1xyXG5cdFx0YXJyYXlbICA5IF0gPSBtYXgueDsgYXJyYXlbIDEwIF0gPSBtaW4ueTsgYXJyYXlbIDExIF0gPSBtYXguejtcclxuXHRcdGFycmF5WyAxMiBdID0gbWF4Lng7IGFycmF5WyAxMyBdID0gbWF4Lnk7IGFycmF5WyAxNCBdID0gbWluLno7XHJcblx0XHRhcnJheVsgMTUgXSA9IG1pbi54OyBhcnJheVsgMTYgXSA9IG1heC55OyBhcnJheVsgMTcgXSA9IG1pbi56O1xyXG5cdFx0YXJyYXlbIDE4IF0gPSBtaW4ueDsgYXJyYXlbIDE5IF0gPSBtaW4ueTsgYXJyYXlbIDIwIF0gPSBtaW4uejtcclxuXHRcdGFycmF5WyAyMSBdID0gbWF4Lng7IGFycmF5WyAyMiBdID0gbWluLnk7IGFycmF5WyAyMyBdID0gbWluLno7XHJcblxyXG5cdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdH07XHJcblxyXG59ICkoKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0JvdW5kaW5nQm94SGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuLy8gYSBoZWxwZXIgdG8gc2hvdyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgYW4gb2JqZWN0XHJcblxyXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBoZXggKSB7XHJcblxyXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ODg4ODg4O1xyXG5cclxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0dGhpcy5ib3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSggMSwgMSwgMSApLCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB3aXJlZnJhbWU6IHRydWUgfSApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm91bmRpbmdCb3hIZWxwZXI7XHJcblxyXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmJveC5zZXRGcm9tT2JqZWN0KCB0aGlzLm9iamVjdCApO1xyXG5cclxuXHR0aGlzLmJveC5zaXplKCB0aGlzLnNjYWxlICk7XHJcblxyXG5cdHRoaXMuYm94LmNlbnRlciggdGhpcy5wb3NpdGlvbiApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0NhbWVyYUhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqXHQtIHNob3dzIGZydXN0dW0sIGxpbmUgb2Ygc2lnaHQgYW5kIHVwIG9mIHRoZSBjYW1lcmFcclxuICpcdC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xyXG4gKiBcdC0gYmFzZWQgb24gZnJ1c3R1bSB2aXN1YWxpemF0aW9uIGluIGxpZ2h0Z2wuanMgc2hhZG93bWFwIGV4YW1wbGVcclxuICpcdFx0aHR0cDovL2V2YW53LmdpdGh1Yi5jb20vbGlnaHRnbC5qcy90ZXN0cy9zaGFkb3dtYXAuaHRtbFxyXG4gKi9cclxuXHJcblRIUkVFLkNhbWVyYUhlbHBlciA9IGZ1bmN0aW9uICggY2FtZXJhICkge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZmZmLCB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLkZhY2VDb2xvcnMgfSApO1xyXG5cclxuXHR2YXIgcG9pbnRNYXAgPSB7fTtcclxuXHJcblx0Ly8gY29sb3JzXHJcblxyXG5cdHZhciBoZXhGcnVzdHVtID0gMHhmZmFhMDA7XHJcblx0dmFyIGhleENvbmUgPSAweGZmMDAwMDtcclxuXHR2YXIgaGV4VXAgPSAweDAwYWFmZjtcclxuXHR2YXIgaGV4VGFyZ2V0ID0gMHhmZmZmZmY7XHJcblx0dmFyIGhleENyb3NzID0gMHgzMzMzMzM7XHJcblxyXG5cdC8vIG5lYXJcclxuXHJcblx0YWRkTGluZSggXCJuMVwiLCBcIm4yXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcIm4yXCIsIFwibjRcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwibjRcIiwgXCJuM1wiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJuM1wiLCBcIm4xXCIsIGhleEZydXN0dW0gKTtcclxuXHJcblx0Ly8gZmFyXHJcblxyXG5cdGFkZExpbmUoIFwiZjFcIiwgXCJmMlwiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJmMlwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcImY0XCIsIFwiZjNcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwiZjNcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XHJcblxyXG5cdC8vIHNpZGVzXHJcblxyXG5cdGFkZExpbmUoIFwibjFcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJuMlwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcIm4zXCIsIFwiZjNcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwibjRcIiwgXCJmNFwiLCBoZXhGcnVzdHVtICk7XHJcblxyXG5cdC8vIGNvbmVcclxuXHJcblx0YWRkTGluZSggXCJwXCIsIFwibjFcIiwgaGV4Q29uZSApO1xyXG5cdGFkZExpbmUoIFwicFwiLCBcIm4yXCIsIGhleENvbmUgKTtcclxuXHRhZGRMaW5lKCBcInBcIiwgXCJuM1wiLCBoZXhDb25lICk7XHJcblx0YWRkTGluZSggXCJwXCIsIFwibjRcIiwgaGV4Q29uZSApO1xyXG5cclxuXHQvLyB1cFxyXG5cclxuXHRhZGRMaW5lKCBcInUxXCIsIFwidTJcIiwgaGV4VXAgKTtcclxuXHRhZGRMaW5lKCBcInUyXCIsIFwidTNcIiwgaGV4VXAgKTtcclxuXHRhZGRMaW5lKCBcInUzXCIsIFwidTFcIiwgaGV4VXAgKTtcclxuXHJcblx0Ly8gdGFyZ2V0XHJcblxyXG5cdGFkZExpbmUoIFwiY1wiLCBcInRcIiwgaGV4VGFyZ2V0ICk7XHJcblx0YWRkTGluZSggXCJwXCIsIFwiY1wiLCBoZXhDcm9zcyApO1xyXG5cclxuXHQvLyBjcm9zc1xyXG5cclxuXHRhZGRMaW5lKCBcImNuMVwiLCBcImNuMlwiLCBoZXhDcm9zcyApO1xyXG5cdGFkZExpbmUoIFwiY24zXCIsIFwiY240XCIsIGhleENyb3NzICk7XHJcblxyXG5cdGFkZExpbmUoIFwiY2YxXCIsIFwiY2YyXCIsIGhleENyb3NzICk7XHJcblx0YWRkTGluZSggXCJjZjNcIiwgXCJjZjRcIiwgaGV4Q3Jvc3MgKTtcclxuXHJcblx0ZnVuY3Rpb24gYWRkTGluZSggYSwgYiwgaGV4ICkge1xyXG5cclxuXHRcdGFkZFBvaW50KCBhLCBoZXggKTtcclxuXHRcdGFkZFBvaW50KCBiLCBoZXggKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBhZGRQb2ludCggaWQsIGhleCApIHtcclxuXHJcblx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XHJcblx0XHRnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xyXG5cclxuXHRcdGlmICggcG9pbnRNYXBbIGlkIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHBvaW50TWFwWyBpZCBdID0gW107XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHBvaW50TWFwWyBpZCBdLnB1c2goIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG5cdHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcblx0dGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMucG9pbnRNYXAgPSBwb2ludE1hcDtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2FtZXJhSGVscGVyO1xyXG5cclxuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSwgcG9pbnRNYXA7XHJcblxyXG5cdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciBjYW1lcmEgPSBuZXcgVEhSRUUuQ2FtZXJhKCk7XHJcblxyXG5cdGZ1bmN0aW9uIHNldFBvaW50KCBwb2ludCwgeCwgeSwgeiApIHtcclxuXHJcblx0XHR2ZWN0b3Iuc2V0KCB4LCB5LCB6ICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcclxuXHJcblx0XHR2YXIgcG9pbnRzID0gcG9pbnRNYXBbIHBvaW50IF07XHJcblxyXG5cdFx0aWYgKCBwb2ludHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzWyBwb2ludHNbIGkgXSBdLmNvcHkoIHZlY3RvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHRcdHBvaW50TWFwID0gdGhpcy5wb2ludE1hcDtcclxuXHJcblx0XHR2YXIgdyA9IDEsIGggPSAxO1xyXG5cclxuXHRcdC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXhcclxuXHRcdC8vIHdvcmxkIG1hdHJpeCBtdXN0IGJlIGlkZW50aXR5XHJcblxyXG5cdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdC8vIGNlbnRlciAvIHRhcmdldFxyXG5cclxuXHRcdHNldFBvaW50KCBcImNcIiwgMCwgMCwgLSAxICk7XHJcblx0XHRzZXRQb2ludCggXCJ0XCIsIDAsIDAsICAxICk7XHJcblxyXG5cdFx0Ly8gbmVhclxyXG5cclxuXHRcdHNldFBvaW50KCBcIm4xXCIsIC0gdywgLSBoLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCBcIm4yXCIsICAgdywgLSBoLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCBcIm4zXCIsIC0gdywgICBoLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCBcIm40XCIsICAgdywgICBoLCAtIDEgKTtcclxuXHJcblx0XHQvLyBmYXJcclxuXHJcblx0XHRzZXRQb2ludCggXCJmMVwiLCAtIHcsIC0gaCwgMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiZjJcIiwgICB3LCAtIGgsIDEgKTtcclxuXHRcdHNldFBvaW50KCBcImYzXCIsIC0gdywgICBoLCAxICk7XHJcblx0XHRzZXRQb2ludCggXCJmNFwiLCAgIHcsICAgaCwgMSApO1xyXG5cclxuXHRcdC8vIHVwXHJcblxyXG5cdFx0c2V0UG9pbnQoIFwidTFcIiwgICB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCBcInUyXCIsIC0gdyAqIDAuNywgaCAqIDEuMSwgLSAxICk7XHJcblx0XHRzZXRQb2ludCggXCJ1M1wiLCAgICAgICAgIDAsIGggKiAyLCAgIC0gMSApO1xyXG5cclxuXHRcdC8vIGNyb3NzXHJcblxyXG5cdFx0c2V0UG9pbnQoIFwiY2YxXCIsIC0gdywgICAwLCAxICk7XHJcblx0XHRzZXRQb2ludCggXCJjZjJcIiwgICB3LCAgIDAsIDEgKTtcclxuXHRcdHNldFBvaW50KCBcImNmM1wiLCAgIDAsIC0gaCwgMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiY2Y0XCIsICAgMCwgICBoLCAxICk7XHJcblxyXG5cdFx0c2V0UG9pbnQoIFwiY24xXCIsIC0gdywgICAwLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCBcImNuMlwiLCAgIHcsICAgMCwgLSAxICk7XHJcblx0XHRzZXRQb2ludCggXCJjbjNcIiwgICAwLCAtIGgsIC0gMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiY240XCIsICAgMCwgICBoLCAtIDEgKTtcclxuXHJcblx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRGlyZWN0aW9uYWxMaWdodEhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzaXplICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHNpemUgPSBzaXplIHx8IDE7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAgIHNpemUsIDAgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAgIHNpemUsICAgc2l6ZSwgMCApLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoICAgc2l6ZSwgLSBzaXplLCAwICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAtIHNpemUsIDAgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsICAgc2l6ZSwgMCApXHJcblx0KTtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xyXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcblx0dGhpcy5saWdodFBsYW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cdHRoaXMuYWRkKCB0aGlzLmxpZ2h0UGxhbmUgKTtcclxuXHJcblx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKClcclxuXHQpO1xyXG5cclxuXHRtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG5cdHRoaXMudGFyZ2V0TGluZSA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHR0aGlzLmFkZCggdGhpcy50YXJnZXRMaW5lICk7XHJcblxyXG5cdHRoaXMudXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyO1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5saWdodFBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0djIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0djMuc3ViVmVjdG9ycyggdjIsIHYxICk7XHJcblxyXG5cdFx0dGhpcy5saWdodFBsYW5lLmxvb2tBdCggdjMgKTtcclxuXHRcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzWyAxIF0uY29weSggdjMgKTtcclxuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvciApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRWRnZXNIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQHBhcmFtIG9iamVjdCBUSFJFRS5NZXNoIHdob3NlIGdlb21ldHJ5IHdpbGwgYmUgdXNlZFxyXG4gKiBAcGFyYW0gaGV4IGxpbmUgY29sb3JcclxuICogQHBhcmFtIHRocmVzaG9sZEFuZ2xlIHRoZSBtaW5pbXVtIGFuZ2xlIChpbiBkZWdyZWVzKSxcclxuICogYmV0d2VlbiB0aGUgZmFjZSBub3JtYWxzIG9mIGFkamFjZW50IGZhY2VzLFxyXG4gKiB0aGF0IGlzIHJlcXVpcmVkIHRvIHJlbmRlciBhbiBlZGdlLiBBIHZhbHVlIG9mIDEwIG1lYW5zXHJcbiAqIGFuIGVkZ2UgaXMgb25seSByZW5kZXJlZCBpZiB0aGUgYW5nbGUgaXMgYXQgbGVhc3QgMTAgZGVncmVlcy5cclxuICovXHJcblxyXG5USFJFRS5FZGdlc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBoZXgsIHRocmVzaG9sZEFuZ2xlICkge1xyXG5cclxuXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmZmZjtcclxuXHJcblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5FZGdlc0dlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnksIHRocmVzaG9sZEFuZ2xlICksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XHJcblxyXG5cdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkVkZ2VzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuRWRnZXNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWRnZXNIZWxwZXI7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9GYWNlTm9ybWFsc0hlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4qL1xyXG5cclxuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XHJcblxyXG5cdC8vIEZhY2VOb3JtYWxzSGVscGVyIG9ubHkgc3VwcG9ydHMgVEhSRUUuR2VvbWV0cnlcclxuXHJcblx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblxyXG5cdHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcclxuXHJcblx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XHJcblxyXG5cdHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XHJcblxyXG5cdC8vXHJcblxyXG5cdHZhciBuTm9ybWFscyA9IDA7XHJcblxyXG5cdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGg7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXI6IG9ubHkgVEhSRUUuR2VvbWV0cnkgaXMgc3VwcG9ydGVkLiBVc2UgVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlciwgaW5zdGVhZC4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xyXG5cclxuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xyXG5cclxuXHRUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMudXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcjtcclxuXHJcblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xyXG5cclxuXHRcdHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0bm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcblx0XHR2YXIgZmFjZXMgPSBvYmpHZW9tZXRyeS5mYWNlcztcclxuXHJcblx0XHR2YXIgaWR4ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0dmFyIG5vcm1hbCA9IGZhY2Uubm9ybWFsO1xyXG5cclxuXHRcdFx0djEuY29weSggdmVydGljZXNbIGZhY2UuYSBdIClcclxuXHRcdFx0XHQuYWRkKCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKVxyXG5cdFx0XHRcdC5hZGQoIHZlcnRpY2VzWyBmYWNlLmMgXSApXHJcblx0XHRcdFx0LmRpdmlkZVNjYWxhciggMyApXHJcblx0XHRcdFx0LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdHYyLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcclxuXHJcblx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XHJcblxyXG5cdFx0XHRpZHggPSBpZHggKyAxO1xyXG5cclxuXHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcclxuXHJcblx0XHRcdGlkeCA9IGlkeCArIDE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufSgpICk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9HcmlkSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5HcmlkSGVscGVyID0gZnVuY3Rpb24gKCBzaXplLCBzdGVwICkge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnMgfSApO1xyXG5cclxuXHR0aGlzLmNvbG9yMSA9IG5ldyBUSFJFRS5Db2xvciggMHg0NDQ0NDQgKTtcclxuXHR0aGlzLmNvbG9yMiA9IG5ldyBUSFJFRS5Db2xvciggMHg4ODg4ODggKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAtIHNpemU7IGkgPD0gc2l6ZTsgaSArPSBzdGVwICkge1xyXG5cclxuXHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsIDAsIGkgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIHNpemUsIDAsIGkgKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoIGksIDAsIC0gc2l6ZSApLCBuZXcgVEhSRUUuVmVjdG9yMyggaSwgMCwgc2l6ZSApXHJcblx0XHQpO1xyXG5cclxuXHRcdHZhciBjb2xvciA9IGkgPT09IDAgPyB0aGlzLmNvbG9yMSA6IHRoaXMuY29sb3IyO1xyXG5cclxuXHRcdGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yLCBjb2xvciApO1xyXG5cclxuXHR9XHJcblxyXG5cdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5HcmlkSGVscGVyO1xyXG5cclxuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24oIGNvbG9yQ2VudGVyTGluZSwgY29sb3JHcmlkICkge1xyXG5cclxuXHR0aGlzLmNvbG9yMS5zZXQoIGNvbG9yQ2VudGVyTGluZSApO1xyXG5cdHRoaXMuY29sb3IyLnNldCggY29sb3JHcmlkICk7XHJcblxyXG5cdHRoaXMuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvSGVtaXNwaGVyZUxpZ2h0SGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzcGhlcmVTaXplICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuY29sb3JzID0gWyBuZXcgVEhSRUUuQ29sb3IoKSwgbmV3IFRIUkVFLkNvbG9yKCkgXTtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XHJcblx0Z2VvbWV0cnkucm90YXRlWCggLSBNYXRoLlBJIC8gMiApO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gODsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdGdlb21ldHJ5LmZhY2VzWyBpIF0uY29sb3IgPSB0aGlzLmNvbG9yc1sgaSA8IDQgPyAwIDogMSBdO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLkZhY2VDb2xvcnMsIHdpcmVmcmFtZTogdHJ1ZSB9ICk7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblx0dGhpcy5hZGQoIHRoaXMubGlnaHRTcGhlcmUgKTtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXI7XHJcblxyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdHRoaXMubGlnaHRTcGhlcmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNvbG9yc1sgMCBdLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHRcdHRoaXMuY29sb3JzWyAxIF0uY29weSggdGhpcy5saWdodC5ncm91bmRDb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG5cclxuXHRcdHRoaXMubGlnaHRTcGhlcmUubG9va0F0KCB2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCkgKTtcclxuXHRcdHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn0oKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1BvaW50TGlnaHRIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlBvaW50TGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzcGhlcmVTaXplICkge1xyXG5cclxuXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcblx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdHRoaXMubWF0cml4ID0gdGhpcy5saWdodC5tYXRyaXhXb3JsZDtcclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0LypcclxuXHR2YXIgZGlzdGFuY2VHZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KCAxLCAyICk7XHJcblx0dmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlLCB3aXJlZnJhbWU6IHRydWUsIG9wYWNpdHk6IDAuMSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xyXG5cclxuXHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGJ1bGJHZW9tZXRyeSwgYnVsYk1hdGVyaWFsICk7XHJcblx0dGhpcy5saWdodERpc3RhbmNlID0gbmV3IFRIUkVFLk1lc2goIGRpc3RhbmNlR2VvbWV0cnksIGRpc3RhbmNlTWF0ZXJpYWwgKTtcclxuXHJcblx0dmFyIGQgPSBsaWdodC5kaXN0YW5jZTtcclxuXHJcblx0aWYgKCBkID09PSAwLjAgKSB7XHJcblxyXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xyXG5cdCovXHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50TGlnaHRIZWxwZXI7XHJcblxyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG5cclxuXHQvKlxyXG5cdHZhciBkID0gdGhpcy5saWdodC5kaXN0YW5jZTtcclxuXHJcblx0aWYgKCBkID09PSAwLjAgKSB7XHJcblxyXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IHRydWU7XHJcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XHJcblxyXG5cdH1cclxuXHQqL1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1NrZWxldG9uSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBTZWFuIEdyaWZmaW4gLyBodHRwOi8vdHdpdHRlci5jb20vc2dyaWZcclxuICogQGF1dGhvciBNaWNoYWVsIEd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuU2tlbGV0b25IZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0dGhpcy5ib25lcyA9IHRoaXMuZ2V0Qm9uZUxpc3QoIG9iamVjdCApO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XHJcblxyXG5cdFx0aWYgKCBib25lLnBhcmVudCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XHJcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcclxuXHRcdFx0Z2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggMCwgMCwgMSApICk7XHJcblx0XHRcdGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIDAsIDEsIDAgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZW9tZXRyeS5keW5hbWljID0gdHJ1ZTtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzLCBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xyXG5cclxuXHRUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdHRoaXMucm9vdCA9IG9iamVjdDtcclxuXHJcblx0dGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMudXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2tlbGV0b25IZWxwZXI7XHJcblxyXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUuZ2V0Qm9uZUxpc3QgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xyXG5cclxuXHR2YXIgYm9uZUxpc3QgPSBbXTtcclxuXHJcblx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xyXG5cclxuXHRcdGJvbmVMaXN0LnB1c2goIG9iamVjdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0Ym9uZUxpc3QucHVzaC5hcHBseSggYm9uZUxpc3QsIHRoaXMuZ2V0Qm9uZUxpc3QoIG9iamVjdC5jaGlsZHJlblsgaSBdICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gYm9uZUxpc3Q7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHJcblx0dmFyIG1hdHJpeFdvcmxkSW52ID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5nZXRJbnZlcnNlKCB0aGlzLnJvb3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0dmFyIGJvbmVNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHR2YXIgaiA9IDA7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBib25lID0gdGhpcy5ib25lc1sgaSBdO1xyXG5cclxuXHRcdGlmICggYm9uZS5wYXJlbnQgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xyXG5cclxuXHRcdFx0Ym9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc1sgaiBdLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xyXG5cclxuXHRcdFx0Ym9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNbIGogKyAxIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XHJcblxyXG5cdFx0XHRqICs9IDI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1Nwb3RMaWdodEhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4qL1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcblx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSggMCwgMSwgMSwgOCwgMSwgdHJ1ZSApO1xyXG5cclxuXHRnZW9tZXRyeS50cmFuc2xhdGUoIDAsIC0gMC41LCAwICk7XHJcblx0Z2VvbWV0cnkucm90YXRlWCggLSBNYXRoLlBJIC8gMiApO1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcclxuXHJcblx0dGhpcy5jb25lID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cdHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcG90TGlnaHRIZWxwZXI7XHJcblxyXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0dGhpcy5jb25lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHZlY3RvcjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBjb25lTGVuZ3RoID0gdGhpcy5saWdodC5kaXN0YW5jZSA/IHRoaXMubGlnaHQuZGlzdGFuY2UgOiAxMDAwMDtcclxuXHRcdHZhciBjb25lV2lkdGggPSBjb25lTGVuZ3RoICogTWF0aC50YW4oIHRoaXMubGlnaHQuYW5nbGUgKTtcclxuXHJcblx0XHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBjb25lV2lkdGgsIGNvbmVXaWR0aCwgY29uZUxlbmd0aCApO1xyXG5cclxuXHRcdHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdHZlY3RvcjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdHRoaXMuY29uZS5sb29rQXQoIHZlY3RvcjIuc3ViKCB2ZWN0b3IgKSApO1xyXG5cclxuXHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG5cdH07XHJcblxyXG59KCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9WZXJ0ZXhOb3JtYWxzSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiovXHJcblxyXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xyXG5cclxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0dGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xyXG5cclxuXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmMDAwMDtcclxuXHJcblx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIG5Ob3JtYWxzID0gMDtcclxuXHJcblx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcblx0XHRuTm9ybWFscyA9IG9iakdlb21ldHJ5LmZhY2VzLmxlbmd0aCAqIDM7XHJcblxyXG5cdH0gZWxzZSBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5jb3VudFxyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHR2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIG5Ob3JtYWxzICogMiAqIDMsIDMgKTtcclxuXHJcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcclxuXHJcblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSApO1xyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyO1xyXG5cclxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuXHJcblx0XHR2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xyXG5cclxuXHRcdHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0bm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcblx0XHRcdHZhciBmYWNlcyA9IG9iakdlb21ldHJ5LmZhY2VzO1xyXG5cclxuXHRcdFx0dmFyIGlkeCA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBmYWNlWyBrZXlzWyBqIF0gXSBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciBub3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHNbIGogXTtcclxuXHJcblx0XHRcdFx0XHR2MS5jb3B5KCB2ZXJ0ZXggKS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdFx0djIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xyXG5cclxuXHRcdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XHJcblxyXG5cdFx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcclxuXHJcblx0XHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xyXG5cclxuXHRcdFx0XHRcdGlkeCA9IGlkeCArIDE7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0dmFyIG9ialBvcyA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG5cdFx0XHR2YXIgb2JqTm9ybSA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuXHRcdFx0dmFyIGlkeCA9IDA7XHJcblxyXG5cdFx0XHQvLyBmb3Igc2ltcGxpY2l0eSwgaWdub3JlIGluZGV4IGFuZCBkcmF3Y2FsbHMsIGFuZCByZW5kZXIgZXZlcnkgbm9ybWFsXHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gb2JqUG9zLmNvdW50OyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHYxLnNldCggb2JqUG9zLmdldFgoIGogKSwgb2JqUG9zLmdldFkoIGogKSwgb2JqUG9zLmdldFooIGogKSApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0djIuc2V0KCBvYmpOb3JtLmdldFgoIGogKSwgb2JqTm9ybS5nZXRZKCBqICksIG9iak5vcm0uZ2V0WiggaiApICk7XHJcblxyXG5cdFx0XHRcdHYyLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcclxuXHJcblx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcclxuXHJcblx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcclxuXHJcblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59KCkgKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1dpcmVmcmFtZUhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuV2lyZWZyYW1lSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCApIHtcclxuXHJcblx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmZmY7XHJcblxyXG5cdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBuZXcgVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xyXG5cclxuXHR0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5XaXJlZnJhbWVIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5XaXJlZnJhbWVIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2lyZWZyYW1lSGVscGVyO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL29iamVjdHMvSW1tZWRpYXRlUmVuZGVyT2JqZWN0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgPSBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggcmVuZGVyQ2FsbGJhY2sgKSB7fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3Q7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvb2JqZWN0cy9Nb3JwaEJsZW5kTWVzaC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHR0aGlzLmFuaW1hdGlvbnNNYXAgPSB7fTtcclxuXHR0aGlzLmFuaW1hdGlvbnNMaXN0ID0gW107XHJcblxyXG5cdC8vIHByZXBhcmUgZGVmYXVsdCBhbmltYXRpb25cclxuXHQvLyAoYWxsIGZyYW1lcyBwbGF5ZWQgdG9nZXRoZXIgaW4gMSBzZWNvbmQpXHJcblxyXG5cdHZhciBudW1GcmFtZXMgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7XHJcblxyXG5cdHZhciBuYW1lID0gXCJfX2RlZmF1bHRcIjtcclxuXHJcblx0dmFyIHN0YXJ0RnJhbWUgPSAwO1xyXG5cdHZhciBlbmRGcmFtZSA9IG51bUZyYW1lcyAtIDE7XHJcblxyXG5cdHZhciBmcHMgPSBudW1GcmFtZXMgLyAxO1xyXG5cclxuXHR0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIGZwcyApO1xyXG5cdHRoaXMuc2V0QW5pbWF0aW9uV2VpZ2h0KCBuYW1lLCAxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTW9ycGhCbGVuZE1lc2g7XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuY3JlYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lLCBzdGFydCwgZW5kLCBmcHMgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB7XHJcblxyXG5cdFx0c3RhcnQ6IHN0YXJ0LFxyXG5cdFx0ZW5kOiBlbmQsXHJcblxyXG5cdFx0bGVuZ3RoOiBlbmQgLSBzdGFydCArIDEsXHJcblxyXG5cdFx0ZnBzOiBmcHMsXHJcblx0XHRkdXJhdGlvbjogKCBlbmQgLSBzdGFydCApIC8gZnBzLFxyXG5cclxuXHRcdGxhc3RGcmFtZTogMCxcclxuXHRcdGN1cnJlbnRGcmFtZTogMCxcclxuXHJcblx0XHRhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdHRpbWU6IDAsXHJcblx0XHRkaXJlY3Rpb246IDEsXHJcblx0XHR3ZWlnaHQ6IDEsXHJcblxyXG5cdFx0ZGlyZWN0aW9uQmFja3dhcmRzOiBmYWxzZSxcclxuXHRcdG1pcnJvcmVkTG9vcDogZmFsc2VcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF0gPSBhbmltYXRpb247XHJcblx0dGhpcy5hbmltYXRpb25zTGlzdC5wdXNoKCBhbmltYXRpb24gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoIGZwcyApIHtcclxuXHJcblx0dmFyIHBhdHRlcm4gPSAvKFthLXpdKylfPyhcXGQrKS9pO1xyXG5cclxuXHR2YXIgZmlyc3RBbmltYXRpb24sIGZyYW1lUmFuZ2VzID0ge307XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XHJcblx0XHR2YXIgY2h1bmtzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xyXG5cclxuXHRcdGlmICggY2h1bmtzICYmIGNodW5rcy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0dmFyIG5hbWUgPSBjaHVua3NbIDEgXTtcclxuXHJcblx0XHRcdGlmICggISBmcmFtZVJhbmdlc1sgbmFtZSBdICkgZnJhbWVSYW5nZXNbIG5hbWUgXSA9IHsgc3RhcnQ6IEluZmluaXR5LCBlbmQ6IC0gSW5maW5pdHkgfTtcclxuXHJcblx0XHRcdHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIGkgPCByYW5nZS5zdGFydCApIHJhbmdlLnN0YXJ0ID0gaTtcclxuXHRcdFx0aWYgKCBpID4gcmFuZ2UuZW5kICkgcmFuZ2UuZW5kID0gaTtcclxuXHJcblx0XHRcdGlmICggISBmaXJzdEFuaW1hdGlvbiApIGZpcnN0QW5pbWF0aW9uID0gbmFtZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggdmFyIG5hbWUgaW4gZnJhbWVSYW5nZXMgKSB7XHJcblxyXG5cdFx0dmFyIHJhbmdlID0gZnJhbWVSYW5nZXNbIG5hbWUgXTtcclxuXHRcdHRoaXMuY3JlYXRlQW5pbWF0aW9uKCBuYW1lLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBmcHMgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmZpcnN0QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkZvcndhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiA9IDE7XHJcblx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRGlyZWN0aW9uQmFja3dhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiA9IC0gMTtcclxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkZQUyA9IGZ1bmN0aW9uICggbmFtZSwgZnBzICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5mcHMgPSBmcHM7XHJcblx0XHRhbmltYXRpb24uZHVyYXRpb24gPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5mcHM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIGR1cmF0aW9uICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG5cdFx0YW5pbWF0aW9uLmZwcyA9ICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbldlaWdodCA9IGZ1bmN0aW9uICggbmFtZSwgd2VpZ2h0ICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi53ZWlnaHQgPSB3ZWlnaHQ7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICggbmFtZSwgdGltZSApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24udGltZSA9IHRpbWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIHRpbWUgPSAwO1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdHRpbWUgPSBhbmltYXRpb24udGltZTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGltZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBkdXJhdGlvbiA9IC0gMTtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRkdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZHVyYXRpb247XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLnRpbWUgPSAwO1xyXG5cdFx0YW5pbWF0aW9uLmFjdGl2ZSA9IHRydWU7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLk1vcnBoQmxlbmRNZXNoOiBhbmltYXRpb25bXCIgKyBuYW1lICsgXCJdIHVuZGVmaW5lZCBpbiAucGxheUFuaW1hdGlvbigpXCIgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5hY3RpdmUgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoIGRlbHRhICkge1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5hbmltYXRpb25zTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTGlzdFsgaSBdO1xyXG5cclxuXHRcdGlmICggISBhbmltYXRpb24uYWN0aXZlICkgY29udGludWU7XHJcblxyXG5cdFx0dmFyIGZyYW1lVGltZSA9IGFuaW1hdGlvbi5kdXJhdGlvbiAvIGFuaW1hdGlvbi5sZW5ndGg7XHJcblxyXG5cdFx0YW5pbWF0aW9uLnRpbWUgKz0gYW5pbWF0aW9uLmRpcmVjdGlvbiAqIGRlbHRhO1xyXG5cclxuXHRcdGlmICggYW5pbWF0aW9uLm1pcnJvcmVkTG9vcCApIHtcclxuXHJcblx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPiBhbmltYXRpb24uZHVyYXRpb24gfHwgYW5pbWF0aW9uLnRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uICo9IC0gMTtcclxuXHJcblx0XHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHRcdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdGFuaW1hdGlvbi50aW1lID0gMDtcclxuXHRcdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi50aW1lICUgYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA8IDAgKSBhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZHVyYXRpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBrZXlmcmFtZSA9IGFuaW1hdGlvbi5zdGFydCArIFRIUkVFLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIGFuaW1hdGlvbi50aW1lIC8gZnJhbWVUaW1lICksIDAsIGFuaW1hdGlvbi5sZW5ndGggLSAxICk7XHJcblx0XHR2YXIgd2VpZ2h0ID0gYW5pbWF0aW9uLndlaWdodDtcclxuXHJcblx0XHRpZiAoIGtleWZyYW1lICE9PSBhbmltYXRpb24uY3VycmVudEZyYW1lICkge1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9IDA7XHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSAxICogd2VpZ2h0O1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGtleWZyYW1lIF0gPSAwO1xyXG5cclxuXHRcdFx0YW5pbWF0aW9uLmxhc3RGcmFtZSA9IGFuaW1hdGlvbi5jdXJyZW50RnJhbWU7XHJcblx0XHRcdGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgPSBrZXlmcmFtZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1peCA9ICggYW5pbWF0aW9uLnRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcclxuXHJcblx0XHRpZiAoIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgKSBtaXggPSAxIC0gbWl4O1xyXG5cclxuXHRcdGlmICggYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSAhPT0gYW5pbWF0aW9uLmxhc3RGcmFtZSApIHtcclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSBtaXggKiB3ZWlnaHQ7XHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAoIDEgLSBtaXggKSAqIHdlaWdodDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IHdlaWdodDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5cclxuLy8gRXhwb3J0IHRoZSBUSFJFRSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXHJcbi8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cclxuLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxyXG4vLyBmb3IgQ2xvc3VyZSBDb21waWxlciBcImFkdmFuY2VkXCIgbW9kZS5cclxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVEhSRUU7XHJcbiAgfVxyXG4gIGV4cG9ydHMuVEhSRUUgPSBUSFJFRTtcclxufSBlbHNlIHtcclxuICB0aGlzWydUSFJFRSddID0gVEhSRUU7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGhyZWUvdGhyZWUuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU2hhZGVyUGFzcyA9IGZ1bmN0aW9uICggc2hhZGVyLCB0ZXh0dXJlSUQgKSB7XG5cblx0dGhpcy50ZXh0dXJlSUQgPSAoIHRleHR1cmVJRCAhPT0gdW5kZWZpbmVkICkgPyB0ZXh0dXJlSUQgOiBcInREaWZmdXNlXCI7XG5cblx0dGhpcy51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApO1xuXG5cdHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcblxuXHRcdGRlZmluZXM6IHNoYWRlci5kZWZpbmVzIHx8IHt9LFxuXHRcdHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuXHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyXG5cblx0fSApO1xuXG5cdHRoaXMucmVuZGVyVG9TY3JlZW4gPSBmYWxzZTtcblxuXHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHR0aGlzLm5lZWRzU3dhcCA9IHRydWU7XG5cdHRoaXMuY2xlYXIgPSBmYWxzZTtcblxuXG5cdHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggLSAxLCAxLCAxLCAtIDEsIDAsIDEgKTtcblx0dGhpcy5zY2VuZSAgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblxuXHR0aGlzLnF1YWQgPSBuZXcgVEhSRUUuTWVzaCggbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoIDIsIDIgKSwgbnVsbCApO1xuXHR0aGlzLnNjZW5lLmFkZCggdGhpcy5xdWFkICk7XG5cbn07XG5cblRIUkVFLlNoYWRlclBhc3MucHJvdG90eXBlID0ge1xuXG5cdHJlbmRlcjogZnVuY3Rpb24gKCByZW5kZXJlciwgd3JpdGVCdWZmZXIsIHJlYWRCdWZmZXIsIGRlbHRhICkge1xuXG5cdFx0aWYgKCB0aGlzLnVuaWZvcm1zWyB0aGlzLnRleHR1cmVJRCBdICkge1xuXG5cdFx0XHR0aGlzLnVuaWZvcm1zWyB0aGlzLnRleHR1cmVJRCBdLnZhbHVlID0gcmVhZEJ1ZmZlcjtcblxuXHRcdH1cblxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG5cblx0XHRpZiAoIHRoaXMucmVuZGVyVG9TY3JlZW4gKSB7XG5cblx0XHRcdHJlbmRlcmVyLnJlbmRlciggdGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlbmRlcmVyLnJlbmRlciggdGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHdyaXRlQnVmZmVyLCB0aGlzLmNsZWFyICk7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3dlYl9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL1NoYWRlclBhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTWFza1Bhc3MgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0dGhpcy5zY2VuZSA9IHNjZW5lO1xuXHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblxuXHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHR0aGlzLmNsZWFyID0gdHJ1ZTtcblx0dGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcblxuXHR0aGlzLmludmVyc2UgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuTWFza1Bhc3MucHJvdG90eXBlID0ge1xuXG5cdHJlbmRlcjogZnVuY3Rpb24gKCByZW5kZXJlciwgd3JpdGVCdWZmZXIsIHJlYWRCdWZmZXIsIGRlbHRhICkge1xuXG5cdFx0dmFyIGNvbnRleHQgPSByZW5kZXJlci5jb250ZXh0O1xuXG5cdFx0Ly8gZG9uJ3QgdXBkYXRlIGNvbG9yIG9yIGRlcHRoXG5cblx0XHRjb250ZXh0LmNvbG9yTWFzayggZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UgKTtcblx0XHRjb250ZXh0LmRlcHRoTWFzayggZmFsc2UgKTtcblxuXHRcdC8vIHNldCB1cCBzdGVuY2lsXG5cblx0XHR2YXIgd3JpdGVWYWx1ZSwgY2xlYXJWYWx1ZTtcblxuXHRcdGlmICggdGhpcy5pbnZlcnNlICkge1xuXG5cdFx0XHR3cml0ZVZhbHVlID0gMDtcblx0XHRcdGNsZWFyVmFsdWUgPSAxO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0d3JpdGVWYWx1ZSA9IDE7XG5cdFx0XHRjbGVhclZhbHVlID0gMDtcblxuXHRcdH1cblxuXHRcdGNvbnRleHQuZW5hYmxlKCBjb250ZXh0LlNURU5DSUxfVEVTVCApO1xuXHRcdGNvbnRleHQuc3RlbmNpbE9wKCBjb250ZXh0LlJFUExBQ0UsIGNvbnRleHQuUkVQTEFDRSwgY29udGV4dC5SRVBMQUNFICk7XG5cdFx0Y29udGV4dC5zdGVuY2lsRnVuYyggY29udGV4dC5BTFdBWVMsIHdyaXRlVmFsdWUsIDB4ZmZmZmZmZmYgKTtcblx0XHRjb250ZXh0LmNsZWFyU3RlbmNpbCggY2xlYXJWYWx1ZSApO1xuXG5cdFx0Ly8gZHJhdyBpbnRvIHRoZSBzdGVuY2lsIGJ1ZmZlclxuXG5cdFx0cmVuZGVyZXIucmVuZGVyKCB0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSwgcmVhZEJ1ZmZlciwgdGhpcy5jbGVhciApO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggdGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHdyaXRlQnVmZmVyLCB0aGlzLmNsZWFyICk7XG5cblx0XHQvLyByZS1lbmFibGUgdXBkYXRlIG9mIGNvbG9yIGFuZCBkZXB0aFxuXG5cdFx0Y29udGV4dC5jb2xvck1hc2soIHRydWUsIHRydWUsIHRydWUsIHRydWUgKTtcblx0XHRjb250ZXh0LmRlcHRoTWFzayggdHJ1ZSApO1xuXG5cdFx0Ly8gb25seSByZW5kZXIgd2hlcmUgc3RlbmNpbCBpcyBzZXQgdG8gMVxuXG5cdFx0Y29udGV4dC5zdGVuY2lsRnVuYyggY29udGV4dC5FUVVBTCwgMSwgMHhmZmZmZmZmZiApOyAgLy8gZHJhdyBpZiA9PSAxXG5cdFx0Y29udGV4dC5zdGVuY2lsT3AoIGNvbnRleHQuS0VFUCwgY29udGV4dC5LRUVQLCBjb250ZXh0LktFRVAgKTtcblxuXHR9XG5cbn07XG5cblxuVEhSRUUuQ2xlYXJNYXNrUGFzcyA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG59O1xuXG5USFJFRS5DbGVhck1hc2tQYXNzLnByb3RvdHlwZSA9IHtcblxuXHRyZW5kZXI6IGZ1bmN0aW9uICggcmVuZGVyZXIsIHdyaXRlQnVmZmVyLCByZWFkQnVmZmVyLCBkZWx0YSApIHtcblxuXHRcdHZhciBjb250ZXh0ID0gcmVuZGVyZXIuY29udGV4dDtcblxuXHRcdGNvbnRleHQuZGlzYWJsZSggY29udGV4dC5TVEVOQ0lMX1RFU1QgKTtcblxuXHR9XG5cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vd2ViX21vZHVsZXMvcG9zdHByb2Nlc3NpbmcvTWFza1Bhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuUmVuZGVyUGFzcyA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCwgY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApIHtcblxuXHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXG5cdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0dGhpcy5jbGVhckNvbG9yID0gY2xlYXJDb2xvcjtcblx0dGhpcy5jbGVhckFscGhhID0gKCBjbGVhckFscGhhICE9PSB1bmRlZmluZWQgKSA/IGNsZWFyQWxwaGEgOiAxO1xuXG5cdHRoaXMub2xkQ2xlYXJDb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpO1xuXHR0aGlzLm9sZENsZWFyQWxwaGEgPSAxO1xuXG5cdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cdHRoaXMuY2xlYXIgPSB0cnVlO1xuXHR0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5SZW5kZXJQYXNzLnByb3RvdHlwZSA9IHtcblxuXHRyZW5kZXI6IGZ1bmN0aW9uICggcmVuZGVyZXIsIHdyaXRlQnVmZmVyLCByZWFkQnVmZmVyLCBkZWx0YSApIHtcblxuXHRcdHRoaXMuc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IHRoaXMub3ZlcnJpZGVNYXRlcmlhbDtcblxuXHRcdGlmICggdGhpcy5jbGVhckNvbG9yICkge1xuXG5cdFx0XHR0aGlzLm9sZENsZWFyQ29sb3IuY29weSggcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcigpICk7XG5cdFx0XHR0aGlzLm9sZENsZWFyQWxwaGEgPSByZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG5cblx0XHRcdHJlbmRlcmVyLnNldENsZWFyQ29sb3IoIHRoaXMuY2xlYXJDb2xvciwgdGhpcy5jbGVhckFscGhhICk7XG5cblx0XHR9XG5cblx0XHRyZW5kZXJlci5yZW5kZXIoIHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCByZWFkQnVmZmVyLCB0aGlzLmNsZWFyICk7XG5cblx0XHRpZiAoIHRoaXMuY2xlYXJDb2xvciApIHtcblxuXHRcdFx0cmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggdGhpcy5vbGRDbGVhckNvbG9yLCB0aGlzLm9sZENsZWFyQWxwaGEgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XG5cblx0fVxuXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3dlYl9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL1JlbmRlclBhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRWZmZWN0Q29tcG9zZXIgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCByZW5kZXJUYXJnZXQgKSB7XG5cblx0dGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXG5cdGlmICggcmVuZGVyVGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHR2YXIgcGl4ZWxSYXRpbyA9IHJlbmRlcmVyLmdldFBpeGVsUmF0aW8oKTtcblxuXHRcdHZhciB3aWR0aCAgPSBNYXRoLmZsb29yKCByZW5kZXJlci5jb250ZXh0LmNhbnZhcy53aWR0aCAgLyBwaXhlbFJhdGlvICkgfHwgMTtcblx0XHR2YXIgaGVpZ2h0ID0gTWF0aC5mbG9vciggcmVuZGVyZXIuY29udGV4dC5jYW52YXMuaGVpZ2h0IC8gcGl4ZWxSYXRpbyApIHx8IDE7XG5cdFx0dmFyIHBhcmFtZXRlcnMgPSB7IG1pbkZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLCBtYWdGaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgZm9ybWF0OiBUSFJFRS5SR0JGb3JtYXQsIHN0ZW5jaWxCdWZmZXI6IGZhbHNlIH07XG5cblx0XHRyZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0dGhpcy5yZW5kZXJUYXJnZXQxID0gcmVuZGVyVGFyZ2V0O1xuXHR0aGlzLnJlbmRlclRhcmdldDIgPSByZW5kZXJUYXJnZXQuY2xvbmUoKTtcblxuXHR0aGlzLndyaXRlQnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXQxO1xuXHR0aGlzLnJlYWRCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldDI7XG5cblx0dGhpcy5wYXNzZXMgPSBbXTtcblxuXHRpZiAoIFRIUkVFLkNvcHlTaGFkZXIgPT09IHVuZGVmaW5lZCApXG5cdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5FZmZlY3RDb21wb3NlciByZWxpZXMgb24gVEhSRUUuQ29weVNoYWRlclwiICk7XG5cblx0dGhpcy5jb3B5UGFzcyA9IG5ldyBUSFJFRS5TaGFkZXJQYXNzKCBUSFJFRS5Db3B5U2hhZGVyICk7XG5cbn07XG5cblRIUkVFLkVmZmVjdENvbXBvc2VyLnByb3RvdHlwZSA9IHtcblxuXHRzd2FwQnVmZmVyczogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdG1wID0gdGhpcy5yZWFkQnVmZmVyO1xuXHRcdHRoaXMucmVhZEJ1ZmZlciA9IHRoaXMud3JpdGVCdWZmZXI7XG5cdFx0dGhpcy53cml0ZUJ1ZmZlciA9IHRtcDtcblxuXHR9LFxuXG5cdGFkZFBhc3M6IGZ1bmN0aW9uICggcGFzcyApIHtcblxuXHRcdHRoaXMucGFzc2VzLnB1c2goIHBhc3MgKTtcblxuXHR9LFxuXG5cdGluc2VydFBhc3M6IGZ1bmN0aW9uICggcGFzcywgaW5kZXggKSB7XG5cblx0XHR0aGlzLnBhc3Nlcy5zcGxpY2UoIGluZGV4LCAwLCBwYXNzICk7XG5cblx0fSxcblxuXHRyZW5kZXI6IGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cblx0XHR0aGlzLndyaXRlQnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXQxO1xuXHRcdHRoaXMucmVhZEJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MjtcblxuXHRcdHZhciBtYXNrQWN0aXZlID0gZmFsc2U7XG5cblx0XHR2YXIgcGFzcywgaSwgaWwgPSB0aGlzLnBhc3Nlcy5sZW5ndGg7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRwYXNzID0gdGhpcy5wYXNzZXNbIGkgXTtcblxuXHRcdFx0aWYgKCAhIHBhc3MuZW5hYmxlZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRwYXNzLnJlbmRlciggdGhpcy5yZW5kZXJlciwgdGhpcy53cml0ZUJ1ZmZlciwgdGhpcy5yZWFkQnVmZmVyLCBkZWx0YSwgbWFza0FjdGl2ZSApO1xuXG5cdFx0XHRpZiAoIHBhc3MubmVlZHNTd2FwICkge1xuXG5cdFx0XHRcdGlmICggbWFza0FjdGl2ZSApIHtcblxuXHRcdFx0XHRcdHZhciBjb250ZXh0ID0gdGhpcy5yZW5kZXJlci5jb250ZXh0O1xuXG5cdFx0XHRcdFx0Y29udGV4dC5zdGVuY2lsRnVuYyggY29udGV4dC5OT1RFUVVBTCwgMSwgMHhmZmZmZmZmZiApO1xuXG5cdFx0XHRcdFx0dGhpcy5jb3B5UGFzcy5yZW5kZXIoIHRoaXMucmVuZGVyZXIsIHRoaXMud3JpdGVCdWZmZXIsIHRoaXMucmVhZEJ1ZmZlciwgZGVsdGEgKTtcblxuXHRcdFx0XHRcdGNvbnRleHQuc3RlbmNpbEZ1bmMoIGNvbnRleHQuRVFVQUwsIDEsIDB4ZmZmZmZmZmYgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5zd2FwQnVmZmVycygpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcGFzcyBpbnN0YW5jZW9mIFRIUkVFLk1hc2tQYXNzICkge1xuXG5cdFx0XHRcdG1hc2tBY3RpdmUgPSB0cnVlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBwYXNzIGluc3RhbmNlb2YgVEhSRUUuQ2xlYXJNYXNrUGFzcyApIHtcblxuXHRcdFx0XHRtYXNrQWN0aXZlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9LFxuXG5cdHJlc2V0OiBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0MS5jbG9uZSgpO1xuXG5cdFx0XHR2YXIgcGl4ZWxSYXRpbyA9IHRoaXMucmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpO1xuXG5cdFx0XHRyZW5kZXJUYXJnZXQud2lkdGggID0gTWF0aC5mbG9vciggdGhpcy5yZW5kZXJlci5jb250ZXh0LmNhbnZhcy53aWR0aCAgLyBwaXhlbFJhdGlvICk7XG5cdFx0XHRyZW5kZXJUYXJnZXQuaGVpZ2h0ID0gTWF0aC5mbG9vciggdGhpcy5yZW5kZXJlci5jb250ZXh0LmNhbnZhcy5oZWlnaHQgLyBwaXhlbFJhdGlvICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnJlbmRlclRhcmdldDEuZGlzcG9zZSgpO1xuXHRcdHRoaXMucmVuZGVyVGFyZ2V0MSA9IHJlbmRlclRhcmdldDtcblx0XHR0aGlzLnJlbmRlclRhcmdldDIuZGlzcG9zZSgpO1xuXHRcdHRoaXMucmVuZGVyVGFyZ2V0MiA9IHJlbmRlclRhcmdldC5jbG9uZSgpO1xuXG5cdFx0dGhpcy53cml0ZUJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MTtcblx0XHR0aGlzLnJlYWRCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldDI7XG5cblx0fSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHR0aGlzLnJlbmRlclRhcmdldDEuc2V0U2l6ZSggd2lkdGgsIGhlaWdodCApO1xuXHRcdHRoaXMucmVuZGVyVGFyZ2V0Mi5zZXRTaXplKCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0fVxuXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3dlYl9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL0VmZmVjdENvbXBvc2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IEJhc2VQYXNzIGZyb20gJy4vYmFzZS1wYXNzLmpzJ1xuXG5cbmNvbnN0IE1JTl9GTE9XID0gMC4wNlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcnVzaFBhc3MgZXh0ZW5kcyBCYXNlUGFzcyB7XG5cblx0Y29uc3RydWN0b3IocmVuZGVyZXIsIHcsIGgpIHtcblxuXHRcdGxldCB1bmlmb3JtcyA9IHtcblx0XHRcdGFzcGVjdDoge3R5cGU6ICdmJywgdmFsdWU6IGggLyB3fSxcblx0XHRcdHByZXY6IHt0eXBlOiAndCcsIHZhbHVlOiBudWxsfSxcblx0XHRcdGltYWdlOiB7dHlwZTogJ3QnLCB2YWx1ZTogd2luZG93Lmt1bWlrb30sXG5cdFx0XHRjdXJzb3I6IHt0eXBlOiAndjInLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoKX0sXG5cdFx0XHRpbWFnZU9wYWNpdHk6IHt0eXBlOiAnZicsIHZhbHVlOiAwfSxcblx0XHRcdGZyZXF1ZW5jeToge3R5cGU6ICdmJywgdmFsdWU6IDJ9LFxuXHRcdFx0c3BlZWQ6IHt0eXBlOiAnZicsIHZhbHVlOiBNSU5fRkxPV30sXG5cdFx0XHRzcGVlZEFtcDoge3R5cGU6ICdmJywgdmFsdWU6IDAuMDAyfSxcblx0XHRcdHNlZWQ6IHt0eXBlOiAnZicsIHZhbHVlOiAwfVxuXHRcdH1cblxuXHRcdHN1cGVyKHJlbmRlcmVyLCB7XG5cdFx0XHRmcmFnbWVudFNoYWRlcjogcmVxdWlyZSgnLi9zaGFkZXJzL2JydXNoLXBhc3MuZnJhZycpLFxuXHRcdFx0dW5pZm9ybXM6IHVuaWZvcm1zXG5cdFx0fSlcblxuXHRcdGxldCB0YXJnZXRPcHRpb24gPSB7XG5cdFx0XHQvLyB3cmFwUzogVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyxcblx0XHRcdC8vIHdyYXBUOiBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nXG5cdFx0fVxuXG5cdFx0dGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyXG5cblx0XHR0aGlzLnByZXZUZXh0dXJlID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KHcsIGgsIHRhcmdldE9wdGlvbilcblx0XHR0aGlzLnRleHR1cmUgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQodywgaCwgdGFyZ2V0T3B0aW9uKVxuXG5cdFx0dGhpcy51bmlmb3Jtcy5wcmV2LnZhbHVlID0gdGhpcy50ZXh0dXJlXG5cblx0XHQvLyB0aGlzLnBhc3MgPSBuZXcgQmFzZVBhc3ModGhpcy5yZW5kZXJlciwge1xuXHRcdC8vIFx0ZnJhZ21lbnRTaGFkZXI6IHJlcXVpcmUoJy4vc2hhZGVycy9icnVzaC1wYXNzLmZyYWcnKSxcblx0XHQvLyBcdHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zXG5cdFx0Ly8gfSlcblxuXHRcdC8vIGV2ZW50XG5cdFx0d2luZG93LkludGVyZmFjZS5vbignY2hhbmdlLWZsb3cnLCB0aGlzLm9uQ2hhbmdlRmxvdy5iaW5kKHRoaXMpKVxuXHRcdHdpbmRvdy5JbnRlcmZhY2Uub24oJ292ZXJjb2F0JywgdGhpcy5vbk92ZXJjb2F0LmJpbmQodGhpcykpXG5cdFx0d2luZG93LkludGVyZmFjZS5vbigndm9sdW1lJywgdGhpcy5vbkNoYW5nZVZvbHVtZS5iaW5kKHRoaXMpKVxuXHRcdHdpbmRvdy5JbnRlcmZhY2Uub24oJ2Zsb3ctc3BlZWQnLCB0aGlzLm9uQ2hhbmdlRmxvd1NwZWVkLmJpbmQodGhpcykpXG5cdH1cblxuXHRvbkNoYW5nZUZsb3dTcGVlZCh2YWx1ZSkge1xuXG5cdFx0dGhpcy51bmlmb3Jtcy5zcGVlZEFtcC52YWx1ZSA9IHZhbHVlICogMC4wNVxuXHR9XG5cblx0b25DaGFuZ2VGbG93KHZhbHVlKSB7XG5cblx0XHR0aGlzLnVuaWZvcm1zLnNlZWQudmFsdWUgPSBNYXRoLnJhbmRvbSgpXG5cdH1cblxuXHRvbk92ZXJjb2F0KHZhbHVlKSB7XG5cdFx0Ly8gdGhpcy51bmlmb3Jtcy5jdXJzb3IudmFsdWUuc2V0KGUub2Zmc2V0WCwgZS5vZmZzZXRZKVxuXG5cdFx0dGhpcy51bmlmb3Jtcy5pbWFnZU9wYWNpdHkudmFsdWUgPSAxXG5cdH1cblxuXHRvbkNoYW5nZVZvbHVtZSh2YWx1ZSkge1xuXHRcdC8vIGNvbnNvbGUubG9nKHZhbHVlKVxuXHRcdHRoaXMudW5pZm9ybXMuc3BlZWQudmFsdWUgPSAgTWF0aC5wb3codmFsdWUsIDMpICogKDEgLSBNSU5fRkxPVykgKyBNSU5fRkxPV1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXG5cdFx0bGV0IHN3YXAgPSB0aGlzLnByZXZUZXh0dXJlXG5cdFx0dGhpcy5wcmV2VGV4dHVyZSA9IHRoaXMudGV4dHVyZVxuXHRcdHRoaXMudGV4dHVyZSA9IHN3YXBcblxuXHRcdHRoaXMudW5pZm9ybXMucHJldi52YWx1ZSA9IHRoaXMucHJldlRleHR1cmVcblxuXHRcdHN1cGVyLnJlbmRlcih0aGlzLnRleHR1cmUpXG5cblx0XHR0aGlzLnVuaWZvcm1zLmltYWdlT3BhY2l0eS52YWx1ZSA9IDBcblx0fVxuXG5cdHNldFNpemUodywgaCkge1xuXHRcdHN1cGVyLnNldFNpemUodywgaClcblx0XHR0aGlzLnVuaWZvcm1zLmFzcGVjdC52YWx1ZSA9IGggLyB3XG5cdFx0dGhpcy5wcmV2VGV4dHVyZS5zZXRTaXplKHcsIGgpXG5cdFx0dGhpcy50ZXh0dXJlLnNldFNpemUodywgaClcblx0fVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9icnVzaC1wYXNzLmpzXG4gKiovIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZVBhc3Mge1xuXG5cdGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBvcHRpb24pIHtcblxuXHRcdHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKVxuXG5cdFx0dGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyXG5cblx0XHQvLyBjYW1lcmFcblx0XHR0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoLTEsIDEsIDEsIC0xLCAxLCAxMDAwKVxuXHRcdHRoaXMuY2FtZXJhLnBvc2l0aW9uLnNldCgwLCAwLCAxMClcblx0XHR0aGlzLnNjZW5lLmFkZCh0aGlzLmNhbWVyYSlcblxuXHRcdHRoaXMudW5pZm9ybXMgPSBvcHRpb24udW5pZm9ybXNcblxuXHRcdGxldCBtYXQgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuXHRcdFx0dW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IG9wdGlvbi52ZXJ0ZXhTaGFkZXIgfHwgcmVxdWlyZSgnLi9zaGFkZXJzL2Jhc2UtcGFzcy52ZXJ0JyksXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogb3B0aW9uLmZyYWdtZW50U2hhZGVyXG5cdFx0fSlcblxuXHRcdGxldCBwbGFuZSA9IG5ldyBUSFJFRS5NZXNoKFxuXHRcdFx0bmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoMiwgMiksXG5cdFx0XHRtYXRcblx0XHQpXG5cblx0XHR0aGlzLnNjZW5lLmFkZChwbGFuZSlcblx0fVxuXG5cdHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KVxuXHR9XG5cblx0cmVuZGVyKHRhcmdldFJlbmRlcmVyKSB7XG5cdFx0dGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRhcmdldFJlbmRlcmVyKVxuXHR9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9iYXNlLXBhc3MuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgcG9zO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0cG9zID0gdmVjMih1di54LCB1di55KTtcXG5cXHRnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEuMCk7XFxufVxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9zaGFkZXJzL2Jhc2UtcGFzcy52ZXJ0XG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuLy9cXG4vLyBEZXNjcmlwdGlvbiA6IEFycmF5IGFuZCB0ZXh0dXJlbGVzcyBHTFNMIDJEIHNpbXBsZXggbm9pc2UgZnVuY3Rpb24uXFxuLy8gICAgICBBdXRob3IgOiBJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0cy5cXG4vLyAgTWFpbnRhaW5lciA6IGlqbVxcbi8vICAgICBMYXN0bW9kIDogMjAxMTA4MjIgKGlqbSlcXG4vLyAgICAgTGljZW5zZSA6IENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4vLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcXG4vL1xcblxcbnZlYzMgbW9kMjg5XzFfMCh2ZWMzIHgpIHtcXG4gIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLjAgLyAyODkuMCkpICogMjg5LjA7XFxufVxcblxcbnZlYzIgbW9kMjg5XzFfMCh2ZWMyIHgpIHtcXG4gIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLjAgLyAyODkuMCkpICogMjg5LjA7XFxufVxcblxcbnZlYzMgcGVybXV0ZV8xXzEodmVjMyB4KSB7XFxuICByZXR1cm4gbW9kMjg5XzFfMCgoKHgqMzQuMCkrMS4wKSp4KTtcXG59XFxuXFxuZmxvYXQgc25vaXNlXzFfMih2ZWMyIHYpXFxuICB7XFxuICBjb25zdCB2ZWM0IEMgPSB2ZWM0KDAuMjExMzI0ODY1NDA1MTg3LCAgLy8gKDMuMC1zcXJ0KDMuMCkpLzYuMFxcbiAgICAgICAgICAgICAgICAgICAgICAwLjM2NjAyNTQwMzc4NDQzOSwgIC8vIDAuNSooc3FydCgzLjApLTEuMClcXG4gICAgICAgICAgICAgICAgICAgICAtMC41NzczNTAyNjkxODk2MjYsICAvLyAtMS4wICsgMi4wICogQy54XFxuICAgICAgICAgICAgICAgICAgICAgIDAuMDI0MzkwMjQzOTAyNDM5KTsgLy8gMS4wIC8gNDEuMFxcbi8vIEZpcnN0IGNvcm5lclxcbiAgdmVjMiBpICA9IGZsb29yKHYgKyBkb3QodiwgQy55eSkgKTtcXG4gIHZlYzIgeDAgPSB2IC0gICBpICsgZG90KGksIEMueHgpO1xcblxcbi8vIE90aGVyIGNvcm5lcnNcXG4gIHZlYzIgaTE7XFxuICAvL2kxLnggPSBzdGVwKCB4MC55LCB4MC54ICk7IC8vIHgwLnggPiB4MC55ID8gMS4wIDogMC4wXFxuICAvL2kxLnkgPSAxLjAgLSBpMS54O1xcbiAgaTEgPSAoeDAueCA+IHgwLnkpID8gdmVjMigxLjAsIDAuMCkgOiB2ZWMyKDAuMCwgMS4wKTtcXG4gIC8vIHgwID0geDAgLSAwLjAgKyAwLjAgKiBDLnh4IDtcXG4gIC8vIHgxID0geDAgLSBpMSArIDEuMCAqIEMueHggO1xcbiAgLy8geDIgPSB4MCAtIDEuMCArIDIuMCAqIEMueHggO1xcbiAgdmVjNCB4MTIgPSB4MC54eXh5ICsgQy54eHp6O1xcbiAgeDEyLnh5IC09IGkxO1xcblxcbi8vIFBlcm11dGF0aW9uc1xcbiAgaSA9IG1vZDI4OV8xXzAoaSk7IC8vIEF2b2lkIHRydW5jYXRpb24gZWZmZWN0cyBpbiBwZXJtdXRhdGlvblxcbiAgdmVjMyBwID0gcGVybXV0ZV8xXzEoIHBlcm11dGVfMV8xKCBpLnkgKyB2ZWMzKDAuMCwgaTEueSwgMS4wICkpXFxuICAgICsgaS54ICsgdmVjMygwLjAsIGkxLngsIDEuMCApKTtcXG5cXG4gIHZlYzMgbSA9IG1heCgwLjUgLSB2ZWMzKGRvdCh4MCx4MCksIGRvdCh4MTIueHkseDEyLnh5KSwgZG90KHgxMi56dyx4MTIuencpKSwgMC4wKTtcXG4gIG0gPSBtKm0gO1xcbiAgbSA9IG0qbSA7XFxuXFxuLy8gR3JhZGllbnRzOiA0MSBwb2ludHMgdW5pZm9ybWx5IG92ZXIgYSBsaW5lLCBtYXBwZWQgb250byBhIGRpYW1vbmQuXFxuLy8gVGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OSBpcyBjbG9zZSB0byBhIG11bHRpcGxlIG9mIDQxICg0MSo3ID0gMjg3KVxcblxcbiAgdmVjMyB4ID0gMi4wICogZnJhY3QocCAqIEMud3d3KSAtIDEuMDtcXG4gIHZlYzMgaCA9IGFicyh4KSAtIDAuNTtcXG4gIHZlYzMgb3ggPSBmbG9vcih4ICsgMC41KTtcXG4gIHZlYzMgYTAgPSB4IC0gb3g7XFxuXFxuLy8gTm9ybWFsaXNlIGdyYWRpZW50cyBpbXBsaWNpdGx5IGJ5IHNjYWxpbmcgbVxcbi8vIEFwcHJveGltYXRpb24gb2Y6IG0gKj0gaW52ZXJzZXNxcnQoIGEwKmEwICsgaCpoICk7XFxuICBtICo9IDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogKCBhMCphMCArIGgqaCApO1xcblxcbi8vIENvbXB1dGUgZmluYWwgbm9pc2UgdmFsdWUgYXQgUFxcbiAgdmVjMyBnO1xcbiAgZy54ICA9IGEwLnggICogeDAueCAgKyBoLnggICogeDAueTtcXG4gIGcueXogPSBhMC55eiAqIHgxMi54eiArIGgueXogKiB4MTIueXc7XFxuICByZXR1cm4gMTMwLjAgKiBkb3QobSwgZyk7XFxufVxcblxcblxcblxcbmNvbnN0IGZsb2F0IFBJXzJfMyA9IDMuMTQxNTkyNjUzNTk7XFxuXFxuXFxuXFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgcHJldjtcXG51bmlmb3JtIHNhbXBsZXIyRCBpbWFnZTtcXG51bmlmb3JtIGZsb2F0IGFzcGVjdDtcXG51bmlmb3JtIHZlYzIgY3Vyc29yO1xcbnVuaWZvcm0gZmxvYXQgaW1hZ2VPcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgZnJlcXVlbmN5O1xcbnVuaWZvcm0gZmxvYXQgc3BlZWQ7XFxudW5pZm9ybSBmbG9hdCBzcGVlZEFtcDtcXG51bmlmb3JtIGZsb2F0IHNlZWQ7XFxuXFxuXFxudmFyeWluZyB2ZWMyIHBvcztcXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuXFx0Ly8gdW5ldW5lXFxuXFx0Ly8gZmxvYXQgYW5nbGUgPSBzbm9pc2UyKChwb3MgKyBjdXJzb3IgLyByZXNvbHV0aW9uKSAqIGZyZXF1ZW5jeSkgKiAyLjAgKiBQSSArIChwb3MueCArIHBvcy55IC0gMS4wKSAqIDQwLjA7XFxuXFx0Ly8gdmVjMiB2ZWwgPSB2ZWMyKGNvcyhhbmdsZSksIHNpbihhbmdsZSkpICogc3BlZWQ7XFxuXFxuXFx0Ly8gdW5ldW5lXFxuXFx0ZmxvYXQgYW5nbGUgPSBzbm9pc2VfMV8yKChwb3MgKyB2ZWMyKHNlZWQgKiAyMC4wLCBzZWVkICogMTAuMCkpICogZnJlcXVlbmN5KSAqIDIuMCAqIFBJXzJfMztcXG5cXHR2ZWMyIHZlbCA9IHZlYzIoY29zKGFuZ2xlKSwgc2luKGFuZ2xlKSAvIGFzcGVjdCkgKiBzcGVlZCAqIHNwZWVkQW1wO1xcblxcblxcdC8vIHZlYzIgdmVsID0gdmVjMigwLjAsIDAuMCk7XFxuXFxuXFx0dmVjMiBvcmlnaW5Qb3MgPSBwb3MgKyB2ZWw7Ly9mcmFjdChwb3MgKyB2ZWwpO1xcblxcblxcdHZlYzMgaW1hZ2VDb2xvciA9IHRleHR1cmUyRChpbWFnZSwgcG9zKS5yZ2I7XFxuXFx0dmVjMyBwcmV2Q29sb3IgPSB0ZXh0dXJlMkQocHJldiwgb3JpZ2luUG9zKS5yZ2I7XFxuXFxuXFx0dmVjMyBjb2xvciA9IG1peChwcmV2Q29sb3IsIGltYWdlQ29sb3IsIGltYWdlT3BhY2l0eSk7XFxuXFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcXG5cXG59XFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3NoYWRlcnMvYnJ1c2gtcGFzcy5mcmFnXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxuLy8gdW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG5cXG52YXJ5aW5nIHZlYzIgcG9zO1xcblxcbnZvaWQgbWFpbigpIHtcXG5cXG5cXHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHRleHR1cmUsIHBvcyk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXFxufVxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9zaGFkZXJzL3JlbmRlci1wYXNzLmZyYWdcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJ1xuaW1wb3J0IE9TQyBmcm9tICdub2RlLW9zYydcblxuaW1wb3J0IEF1ZGlvQW5hbHl6ZXIgZnJvbSAnLi9hdWRpby1hbmFseXNlci5qcydcblxuXG5cbmNvbnN0IFRZUEUgPSB7XG5cdGV2ZXJ5OiAxLFxuXHRvbjogMlxufVxuXG5jb25zdCBPU0NMaXN0ID0ge1xuXHQnL3ZvbHVtZSc6IFRZUEUuZXZlcnksXG5cdCcvZmxvdy1zcGVlZCc6IFRZUEUuZXZlcnksXG5cdCcvb3ZlcmNvYXQnOiBUWVBFLm9uLFxuXHQnL2NoYW5nZS1mbG93JzogVFlQRS5vblxufVxuXG5jbGFzcyBWSkludGVyZmFjZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKVxuXG5cdFx0dGhpcy5vc2NTZXJ2ZXIgPSBuZXcgT1NDLlNlcnZlcigxMjM0LCAnMC4wLjAuMCcpXG5cblx0XHR0aGlzLm9zY1NlcnZlci5vbignbWVzc2FnZScsIHRoaXMub25SZWNlaXZlT1NDLmJpbmQodGhpcykpXG5cblx0XHQvLyB0aGlzLmF1ZGlvQW5hbHl6ZXIgPSBuZXcgQXVkaW9BbmFseXplcigpXG5cblx0fVxuXG5cdHVwZGF0ZSgpIHtcblx0XHQvLyB0aGlzLmF1ZGlvQW5hbHl6ZXIudXBkYXRlKClcblx0XHQvLyB0aGlzLmVtaXQoJ3ZvbHVtZScsIHRoaXMuYXVkaW9BbmFseXplci52b2x1bWUpXG5cdH1cblxuXHRvblJlY2VpdmVPU0MobXNnLCByaW5mbykge1xuXG5cdFx0bGV0IG5hbWUgPSBtc2dbMF1cblx0XHRsZXQgdmFsdWUgPSBtc2dbMV1cblxuXHRcdGlmIChPU0NMaXN0W25hbWVdID09IFRZUEUuZXZlcnkpIHtcblx0XHRcdHRoaXMuZW1pdChuYW1lLnN1YnN0cigxKSwgdmFsdWUpXG5cdFx0fSBlbHNlIGlmIChPU0NMaXN0W25hbWVdID09IFRZUEUub24gJiYgdmFsdWUgPT0gMSkge1xuXHRcdFx0dGhpcy5lbWl0KG5hbWUuc3Vic3RyKDEpLCB2YWx1ZSlcblx0XHR9XG5cdH1cblxufVxuXG5cblxuZXhwb3J0IGRlZmF1bHQgbmV3IFZKSW50ZXJmYWNlKClcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3ZqLWludGVyZmFjZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLy9cbi8vIFdlIHN0b3JlIG91ciBFRSBvYmplY3RzIGluIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGB+YCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBvdmVycmlkZGVuIG9yXG4vLyB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vLyBXZSBhbHNvIGFzc3VtZSB0aGF0IGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBhdmFpbGFibGUgd2hlbiB0aGUgZXZlbnQgbmFtZVxuLy8gaXMgYW4gRVM2IFN5bWJvbC5cbi8vXG52YXIgcHJlZml4ID0gdHlwZW9mIE9iamVjdC5jcmVhdGUgIT09ICdmdW5jdGlvbicgPyAnficgOiBmYWxzZTtcblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBFdmVudEVtaXR0ZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRXZlbnQgaGFuZGxlciB0byBiZSBjYWxsZWQuXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IENvbnRleHQgZm9yIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IGVtaXQgb25jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIEV2ZW50RW1pdHRlciBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogRXZlbnRFbWl0dGVyIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHsgLyogTm90aGluZyB0byBzZXQgKi8gfVxuXG4vKipcbiAqIEhvbGRzIHRoZSBhc3NpZ25lZCBFdmVudEVtaXR0ZXJzIGJ5IG5hbWUuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGFzc2lnbmVkIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50cyB0aGF0IHNob3VsZCBiZSBsaXN0ZWQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGV4aXN0cyBXZSBvbmx5IG5lZWQgdG8ga25vdyBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0FycmF5fEJvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCwgZXhpc3RzKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBhdmFpbGFibGUgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGV4aXN0cykgcmV0dXJuICEhYXZhaWxhYmxlO1xuICBpZiAoIWF2YWlsYWJsZSkgcmV0dXJuIFtdO1xuICBpZiAoYXZhaWxhYmxlLmZuKSByZXR1cm4gW2F2YWlsYWJsZS5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdmFpbGFibGUubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gYXZhaWxhYmxlW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBFbWl0IGFuIGV2ZW50IHRvIGFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRpb24gaWYgd2UndmUgZW1pdHRlZCBhbiBldmVudC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBuZXcgRXZlbnRMaXN0ZW5lciBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IFRoZSBjb250ZXh0IG9mIHRoZSBmdW5jdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IHRoaXMpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSBwcmVmaXggPyB7fSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHRoaXMuX2V2ZW50c1tldnRdID0gbGlzdGVuZXI7XG4gIGVsc2Uge1xuICAgIGlmICghdGhpcy5fZXZlbnRzW2V2dF0uZm4pIHRoaXMuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICAgIGVsc2UgdGhpcy5fZXZlbnRzW2V2dF0gPSBbXG4gICAgICB0aGlzLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJcbiAgICBdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBFdmVudExpc3RlbmVyIHRoYXQncyBvbmx5IGNhbGxlZCBvbmNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBUaGUgY29udGV4dCBvZiB0aGUgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgdGhpcywgdHJ1ZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHByZWZpeCA/IHt9IDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgdGhpcy5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lcjtcbiAgZWxzZSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XS5mbikgdGhpcy5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gICAgZWxzZSB0aGlzLl9ldmVudHNbZXZ0XSA9IFtcbiAgICAgIHRoaXMuX2V2ZW50c1tldnRdLCBsaXN0ZW5lclxuICAgIF07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHdlIHdhbnQgdG8gcmVtb3ZlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIHRoYXQgd2UgbmVlZCB0byBmaW5kLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBPbmx5IHJlbW92ZSBsaXN0ZW5lcnMgbWF0Y2hpbmcgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uY2UgbGlzdGVuZXJzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgZXZlbnRzID0gW107XG5cbiAgaWYgKGZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgICAgaWYgKFxuICAgICAgICAgICBsaXN0ZW5lcnMuZm4gIT09IGZuXG4gICAgICAgIHx8IChvbmNlICYmICFsaXN0ZW5lcnMub25jZSlcbiAgICAgICAgfHwgKGNvbnRleHQgJiYgbGlzdGVuZXJzLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmblxuICAgICAgICAgIHx8IChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSlcbiAgICAgICAgICB8fCAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICAgKSB7XG4gICAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgLy9cbiAgaWYgKGV2ZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIG9yIG9ubHkgdGhlIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHdhbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuXG4gIGlmIChldmVudCkgZGVsZXRlIHRoaXMuX2V2ZW50c1twcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XTtcbiAgZWxzZSB0aGlzLl9ldmVudHMgPSBwcmVmaXggPyB7fSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gZG9lc24ndCBhcHBseSBhbnltb3JlLlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9ldmVudGVtaXR0ZXIzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMydcblxuXG5jbGFzcyBUaWNrZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKClcblx0XHR0aGlzLnVwZGF0ZSA9IHRoaXMudXBkYXRlLmJpbmQodGhpcylcblx0XHR0aGlzLnByZXZpb3VzVGltZSA9IDBcblx0fVxuXG5cdHN0YXJ0KCkge1xuXHRcdGNvbnNvbGUubG9nKCdzdGFydCB0aWNrZXInKVxuXHRcdHRoaXMudXBkYXRlKClcblx0fVxuXG5cdHN0b3AoKSB7XG5cdFx0Y2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXF1aWVzdElkKVxuXHR9XG5cblx0dXBkYXRlKHQpIHtcblx0XHR0aGlzLnJlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZSlcblx0XHRsZXQgZWxhcHNlZCA9IHQgLSB0aGlzLnByZXZpb3VzVGltZVxuXHRcdHRoaXMucHJldmlvdXNUaW1lID0gdFxuXHRcdGlmIChlbGFwc2VkKSB7XG5cdFx0XHR0aGlzLmVtaXQoJ3VwZGF0ZScsIGVsYXBzZWQpXG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBUaWNrZXIoKVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvdGlja2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTWVzc2FnZTogcmVxdWlyZSgnLi9NZXNzYWdlJyksXG4gIENsaWVudDogcmVxdWlyZSgnLi9DbGllbnQnKSxcbiAgU2VydmVyOiByZXF1aXJlKCcuL1NlcnZlcicpXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbm9kZS1vc2MvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gTWVzc2FnZShhZGRyZXNzKSB7XG4gICAgdGhpcy5vc2NUeXBlID0gJ21lc3NhZ2UnO1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgdGhpcy5hcmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFwcGVuZChhcmd1bWVudHNbaV0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gQXJndW1lbnQodHlwZSwgdmFsdWUpe1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuXG5NZXNzYWdlLnByb3RvdHlwZSA9IHtcbiAgICBhcHBlbmQ6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIGFyZ091dDtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgYXJnKSB7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChhcmdbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvblxcJ3Qga25vdyBob3cgdG8gZW5jb2RlIG9iamVjdCAnICsgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IoYXJnKSA9PT0gYXJnKSB7XG4gICAgICAgICAgICAgICAgYXJnT3V0ID0gbmV3IEFyZ3VtZW50KCdpbnRlZ2VyJywgYXJnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3MucHVzaChhcmdPdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdPdXQgPSBuZXcgQXJndW1lbnQoJ2Zsb2F0JywgYXJnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3MucHVzaChhcmdPdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBhcmdPdXQgPSBuZXcgQXJndW1lbnQoJ3N0cmluZycsIGFyZyk7XG4gICAgICAgICAgICB0aGlzLmFyZ3MucHVzaChhcmdPdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvblxcJ3Qga25vdyBob3cgdG8gZW5jb2RlICcgKyBhcmcpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbm9kZS1vc2MvbGliL01lc3NhZ2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGdyYW0gPSByZXF1aXJlKCdkZ3JhbScpO1xuXG52YXIgbWluID0gcmVxdWlyZSgnb3NjLW1pbicpO1xuXG52YXIgTWVzc2FnZSA9IHJlcXVpcmUoJy4vTWVzc2FnZScpO1xuXG52YXIgQ2xpZW50ID0gZnVuY3Rpb24gKGhvc3QsIHBvcnQpIHtcbiAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIHRoaXMucG9ydCA9IHBvcnQ7XG4gICAgdGhpcy5fc29jayA9IGRncmFtLmNyZWF0ZVNvY2tldCh7XG4gICAgICB0eXBlOiAndWRwNCcsXG4gICAgICByZXVzZUFkZHI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc29jay5jbG9zZSgpO1xuICAgIH07XG59O1xuXG5DbGllbnQucHJvdG90eXBlID0ge1xuICAgIHNlbmQ6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBtZXM7XG4gICAgICAgIHZhciBidWY7XG4gICAgICAgIHZhciBjYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB2YXIgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgbWVzc2FnZSkge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBidWYgPSBtaW4udG9CdWZmZXIobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc29jay5zZW5kKGJ1ZiwgMCwgYnVmLmxlbmd0aCwgdGhpcy5wb3J0LCB0aGlzLmhvc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgbWVzID0gbmV3IE1lc3NhZ2UoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcy5hcHBlbmQoYXJnc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZiA9IG1pbi50b0J1ZmZlcihtZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NvY2suc2VuZChidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXMucG9ydCwgdGhpcy5ob3N0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhhdCBNZXNzYWdlIEp1c3QgRG9lc25cXCd0IFNlZW0gUmlnaHQnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbm9kZS1vc2MvbGliL0NsaWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJkZ3JhbVwiKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwiZGdyYW1cIlxuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKSB7XG4gIFxuLy9+cmVhZG1lLm91dH5cbi8vWyFbYnVpbGQgc3RhdHVzXShodHRwczovL3NlY3VyZS50cmF2aXMtY2kub3JnL3J1c3NlbGxtY2Mvbm9kZS1vc2MtbWluLnBuZyldKGh0dHA6Ly90cmF2aXMtY2kub3JnL3J1c3NlbGxtY2Mvbm9kZS1vc2MtbWluKVxuLy8jIG9zYy1taW5cbi8vIFxuLy8gX3NpbXBsZSB1dGlsaXRpZXMgZm9yIG9wZW4gc291bmQgY29udHJvbCBpbiBub2RlLmpzX1xuLy9cbi8vIFRoaXMgcGFja2FnZSBwcm92aWRlcyBzb21lIG5vZGUuanMgdXRpbGl0aWVzIGZvciB3b3JraW5nIHdpdGggXG4vLyBbT1NDXShodHRwOi8vb3BlbnNvdW5kY29udHJvbC5vcmcvKSwgYSBmb3JtYXQgZm9yIHNvdW5kIGFuZCBzeXN0ZW1zIGNvbnRyb2wuICBcbi8vIEhlcmUgd2UgaW1wbGVtZW50IHRoZSBbT1NDIDEuMV1bc3BlYzExXSBzcGVjaWZpY2F0aW9uLiAgT1NDIGlzIGEgdHJhbnNwb3J0LWluZGVwZW5kZW50XG4vLyBwcm90b2NvbCwgc28gd2UgZG9uJ3QgcHJvdmlkZSBhbnkgc2VydmVyIG9iamVjdHMsIGFzIHlvdSBzaG91bGQgYmUgYWJsZSB0byBcbi8vIHVzZSBPU0Mgb3ZlciBhbnkgdHJhbnNwb3J0IHlvdSBsaWtlLiAgVGhlIG1vc3QgY29tbW9uIGlzIHByb2JhYmx5IHVkcCwgYnV0IHRjcFxuLy8gaXMgbm90IHVuaGVhcmQgb2YuXG4vL1xuLy8gW3NwZWMxMV06IGh0dHA6Ly9vcGVuc291bmRjb250cm9sLm9yZy9zcGVjLTFfMVxuLy9cbi8vLS0tLVxuLy8jIyBJbnN0YWxsYXRpb25cbi8vfmluc3RhbGxhdGlvbn5cbi8vLS0tLVxuLy8jIyBFeGFtcGxlc1xuLy9+ZXhhbXBsZXN+XG4vL1xuLy8gbW9yZSBleGFtcGxlcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBgZXhhbXBsZXMvYCBkaXJlY3RvcnkuXG4vL1xuLy8tLS0tXG4vL35hcGl+XG4vLy0tLS1cbi8vfnJlcHJlc2VudGF0aW9uflxuXG4vL35yZXByZXNlbnRhdGlvbn5cbi8vIyMgSmF2YXNjcmlwdCByZXByZXNlbnRhdGlvbnMgb2YgdGhlIE9TQyB0eXBlcy4gIFxuLy8gU2VlIHRoZSBbc3BlY11bc3BlY10gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIE9TQyB0eXBlcy5cbi8vXG4vLyArIEFuIF9PU0MgUGFja2V0XyBpcyBhbiBfT1NDIE1lc3NhZ2VfIG9yIGFuIF9PU0MgQnVuZGxlXy5cbi8vXG4vLyArIEFuIF9PU0MgTWVzc2FnZV86XG4vL1xuLy8gICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgb3NjVHlwZSA6IFwibWVzc2FnZVwiXG4vLyAgICAgICAgICAgICAgIGFkZHJlc3MgOiBcIi9hZGRyZXNzL3BhdHRlcm4vbWlnaHQvaGF2ZS93aWxkY2FyZHNcIlxuLy8gICAgICAgICAgICAgICBhcmdzIDogW2FyZzEsYXJnMl1cbi8vICAgICAgICAgICB9XG4vL1xuLy8gICAgV2hlcmUgYXJncyBpcyBhbiBhcnJheSBvZiBfT1NDIEFyZ3VtZW50c18uICBgb3NjVHlwZWAgaXMgb3B0aW9uYWwuXG4vLyAgICBgYXJnc2AgY2FuIGJlIGEgc2luZ2xlIGVsZW1lbnQuXG4vL1xuLy8gKyBBbiBfT1NDIEFyZ3VtZW50XyBpcyByZXByZXNlbnRlZCBhcyBhIGphdmFzY3JpcHQgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBsYXlvdXQ6XG4vL1xuLy8gICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgdHlwZSA6IFwic3RyaW5nXCJcbi8vICAgICAgICAgICAgICAgdmFsdWUgOiBcInZhbHVlXCJcbi8vICAgICAgICAgICB9XG4vL1xuLy8gICAgV2hlcmUgdGhlIGB0eXBlYCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbi8vICAgICsgYHN0cmluZ2AgLSBzdHJpbmcgdmFsdWVcbi8vICAgICsgYGZsb2F0YCAtIG51bWVyaWMgdmFsdWVcbi8vICAgICsgYGludGVnZXJgIC0gbnVtZXJpYyB2YWx1ZVxuLy8gICAgKyBgYmxvYmAgLSBub2RlLmpzIEJ1ZmZlciB2YWx1ZVxuLy8gICAgKyBgdHJ1ZWAgLSB2YWx1ZSBpcyBib29sZWFuIHRydWVcbi8vICAgICsgYGZhbHNlYCAtIHZhbHVlIGlzIGJvb2xlYW4gZmFsc2Vcbi8vICAgICsgYG51bGxgIC0gbm8gdmFsdWVcbi8vICAgICsgYGJhbmdgIC0gbm8gdmFsdWUgKHRoaXMgaXMgdGhlIGBJYCB0eXBlIHRhZylcbi8vICAgICsgYHRpbWV0YWdgIC0gbnVtZXJpYyB2YWx1ZVxuLy8gICAgKyBgYXJyYXlgIC0gYXJyYXkgb2YgX09TQyBBcmd1bWVudHNfXG4vLyBcbi8vICAgIE5vdGUgdGhhdCBgdHlwZWAgaXMgYWx3YXlzIGEgc3RyaW5nIC0gaS5lLiBgXCJ0cnVlXCJgIHJhdGhlciB0aGFuIGB0cnVlYC5cbi8vICAgXG4vLyAgICBUaGUgZm9sbG93aW5nIG5vbi1zdGFuZGFyZCB0eXBlcyBhcmUgYWxzbyBzdXBwb3J0ZWQ6XG4vLyAgICArIGBkb3VibGVgIC0gbnVtZXJpYyB2YWx1ZSAoZW5jb2RlcyB0byBhIGZsb2F0NjQgdmFsdWUpXG4vL1xuLy8gICAgXG4vLyAgICBGb3IgbWVzc2FnZXMgc2VudCB0byB0aGUgYHRvQnVmZmVyYCBmdW5jdGlvbiwgYHR5cGVgIGlzIG9wdGlvbmFsLlxuLy8gICAgSWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3QsIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgZWl0aGVyXG4vLyAgICBgc3RyaW5nYCwgYGZsb2F0YCwgYGFycmF5YCBvciBgYmxvYmAsIGRlcGVuZGluZyBvbiBpdHMgamF2YXNjcmlwdCB0eXBlXG4vLyAgICAoU3RyaW5nLCBOdW1iZXIsIEFycmF5LCBCdWZmZXIsIHJlc3BlY3RpdmVseSlcbi8vXG4vLyArIEFuIF9PU0MgQnVuZGxlXyBpcyByZXByZXNlbnRlZCBhcyBhIGphdmFzY3JpcHQgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBsYXlvdXRcbi8vXG4vLyAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICBvc2NUeXBlIDogXCJidW5kbGVcIlxuLy8gICAgICAgICAgICAgICB0aW1ldGFnIDogN1xuLy8gICAgICAgICAgICAgICBlbGVtZW50cyA6IFtlbGVtZW50MSwgZWxlbWVudF1cbi8vICAgICAgICAgICB9XG4vL1xuLy8gICBXaGVyZSB0aGUgdGltZXRhZyBpcyBhIGphdmFzY3JpcHQtbmF0aXZlIG51bWVyaWMgdmFsdWUgb2YgdGhlIHRpbWV0YWcsXG4vLyAgIGFuZCBlbGVtZW50cyBpcyBhbiBhcnJheSBvZiBlaXRoZXIgYW4gX09TQyBCdW5kbGVfIG9yIGFuIF9PU0MgTWVzc2FnZV9cbi8vICAgVGhlIGBvc2NUeXBlYCBmaWVsZCBpcyBvcHRpb25hbCwgYnV0IGlzIGFsd2F5cyByZXR1cm5lZCBieSBhcGkgZnVuY3Rpb25zLlxuLy9cbi8vIFtzcGVjXTogaHR0cDovL29wZW5zb3VuZGNvbnRyb2wub3JnL3NwZWMtMV8wXG4gIFxuICB2YXIgdXRpbHMsIGNvZmZlZTtcbiAgdXRpbHMgPSByZXF1aXJlKFwiLi9vc2MtdXRpbGl0aWVzXCIpO1xuLy8gfmFwaX5cbi8vIyMgRXhwb3J0ZWQgZnVuY3Rpb25zXG4vL1xuLy8tLS0tLS1cbi8vIyMjIC5mcm9tQnVmZmVyKGJ1ZmZlciwgW3N0cmljdF0pXG4vLyB0YWtlcyBhIG5vZGUuanMgQnVmZmVyIG9mIGEgY29tcGxldGUgX09TQyBQYWNrZXRfIGFuZCBcbi8vIG91dHB1dHMgdGhlIGphdmFzY3JpcHQgcmVwcmVzZW50YXRpb24sIG9yIHRocm93cyBpZiB0aGUgYnVmZmVyIGlzIGlsbC1mb3JtZWQuXG4vL1xuLy8gYHN0cmljdGAgaXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgbWFrZXMgdGhlIGZ1bmN0aW9uIGZhaWwgbW9yZSBvZnRlbi5cbiAgZXhwb3J0cy5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgfSBlbHNlIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5mcm9tT3NjUGFja2V0KGJ1ZmZlciwgc3RyaWN0KTtcbiAgfTtcblxuLy9+YXBpflxuLy8tLS0tXG4vLyMjIyAudG9CdWZmZXIob2JqZWN0LCBbc3RyaWN0XSlcbi8vIHRha2VzIGEgX09TQyBwYWNrZXRfIGphdmFzY3JpcHQgcmVwcmVzZW50YXRpb24gYXMgZGVmaW5lZCBiZWxvdyBhbmQgcmV0dXJuc1xuLy8gYSBub2RlLmpzIEJ1ZmZlciwgb3IgdGhyb3dzIGlmIHRoZSByZXByZXNlbnRhdGlvbiBpcyBpbGwtZm9ybWVkLlxuLy9cbi8vLS0tLVxuLy8jIyMgLnRvQnVmZmVyKGFkZHJlc3MsIGFyZ3NbXSwgW3N0cmljdF0pXG4vLyBhbHRlcm5hdGl2ZSBzeW50YXggZm9yIGFib3ZlLiAgQXNzdW1lcyB0aGlzIGlzIGFuIF9PU0MgTWVzc2FnZV8gYXMgZGVmaW5lZCBiZWxvdywgXG4vLyBhbmQgYGFyZ3NgIGlzIGFuIGFycmF5IG9mIF9PU0MgQXJndW1lbnRzXyBvciBzaW5nbGUgX09TQyBBcmd1bWVudF9cbiAgZXhwb3J0cy50b0J1ZmZlciA9IGZ1bmN0aW9uKG9iamVjdCwgc3RyaWN0LCBvcHQpIHtcbiAgICBpZih0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHV0aWxzLnRvT3NjUGFja2V0KHsnYWRkcmVzcycgOiBvYmplY3QsICdhcmdzJyA6IHN0cmljdH0sIG9wdCk7XG4gICAgcmV0dXJuIHV0aWxzLnRvT3NjUGFja2V0KG9iamVjdCwgc3RyaWN0KTtcbiAgfTtcblxuLy9+YXBpflxuLy8tLS0tXG4vLyMjIyAuYXBwbHlBZGRyZXNzVHJhbnNmb3JtKGJ1ZmZlciwgdHJhbnNmb3JtKVxuLy8gdGFrZXMgYSBjYWxsYmFjayB0aGF0IHRha2VzIGEgc3RyaW5nIGFuZCBvdXRwdXRzIGEgc3RyaW5nLFxuLy8gYW5kIGFwcGxpZXMgdGhhdCB0byB0aGUgYWRkcmVzcyBvZiB0aGUgbWVzc2FnZSBlbmNvZGVkIGluIHRoZSBidWZmZXIsXG4vLyBhbmQgb3V0cHV0cyBhbiBlbmNvZGVkIGJ1ZmZlci5cbi8vXG4vLyBJZiB0aGUgYnVmZmVyIGVuY29kZXMgYW4gX09TQyBCdW5kbGVfLCB0aGlzIGFwcGxpZXMgdGhlIGZ1bmN0aW9uIHRvIGVhY2ggYWRkcmVzcyBcbi8vIGluIHRoZSBidW5kbGUuXG4vL1xuLy8gVGhlcmUncyB0d28gc3VidGxlIHJlYXNvbnMgeW91J2Qgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiBcbi8vIGNvbXBvc2luZyBgZnJvbUJ1ZmZlcmAgYW5kIGB0b0J1ZmZlcmA6XG4vLyAgIC0gRnV0dXJlLXByb29maW5nIC0gaWYgdGhlIE9TQyBtZXNzYWdlIHVzZXMgYW4gYXJndW1lbnQgdHlwZWNvZGUgdGhhdFxuLy8gICAgIHdlIGRvbid0IHVuZGVyc3RhbmQsIGNhbGxpbmcgYGZyb21CdWZmZXJgIHdpbGwgdGhyb3cuICBUaGUgb25seSB0aW1lXG4vLyAgICAgd2hlbiBgYXBwbHlBZGRyZXNzVHJhbmZvcm1gIG1pZ2h0IGZhaWwgaXMgaWYgdGhlIGFkZHJlc3MgaXMgbWFsZm9ybWVkLlxuLy8gICAtIEFjY3VyYWN5IC0gamF2YXNjcmlwdCByZXByZXNlbnRzIG51bWJlcnMgYXMgNjQtYml0IGZsb2F0cywgc28gc29tZVxuLy8gICAgIE9TQyB0eXBlcyB3aWxsIG5vdCBiZSBhYmxlIHRvIGJlIHJlcHJlc2VudGVkIGFjY3VyYXRlbHkuICBJZiBhY2N1cmFjeVxuLy8gICAgIGlzIGltcG9ydGFudCB0byB5b3UsIHRoZW4sIHlvdSBzaG91bGQgbmV2ZXIgY29udmVydCB0aGUgT1NDIG1lc3NhZ2UgdG8gYVxuLy8gICAgIGphdmFzY3JpcHQgcmVwcmVzZW50YXRpb24uXG4gIGV4cG9ydHMuYXBwbHlBZGRyZXNzVHJhbnNmb3JtID0gZnVuY3Rpb24oYnVmZmVyLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gdXRpbHMuYXBwbHlUcmFuc2Zvcm0oYnVmZmVyLCB1dGlscy5hZGRyZXNzVHJhbnNmb3JtKHRyYW5zZm9ybSkpO1xuICB9O1xuICBcbi8vfmFwaX5cbi8vLS0tLVxuLy8jIyMgLmFwcGx5TWVzc2FnZVRyYW5zZm9ybShidWZmZXIsIHRyYW5zZm9ybSlcbi8vIHRha2VzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbmQgcmV0dXJucyBhIGphdmFzY3JpcHQgX09TQyBNZXNzYWdlXyByZXByZXNlbnRhdGlvbixcbi8vIGFuZCBhcHBsaWVzIHRoYXQgdG8gZWFjaCBtZXNzYWdlIGVuY29kZWQgaW4gdGhlIGJ1ZmZlcixcbi8vIGFuZCBvdXRwdXRzIGEgbmV3IGJ1ZmZlciB3aXRoIHRoZSBuZXcgYWRkcmVzcy5cbi8vXG4vLyBJZiB0aGUgYnVmZmVyIGVuY29kZXMgYW4gb3NjLWJ1bmRsZSwgdGhpcyBhcHBsaWVzIHRoZSBmdW5jdGlvbiB0byBlYWNoIG1lc3NhZ2UgXG4vLyBpbiB0aGUgYnVuZGxlLlxuLy9cbi8vIFNlZSBub3RlcyBhYm92ZSBmb3IgYXBwbHlBZGRyZXNzVHJhbnNmb3JtIGZvciB3aHkgeW91IG1pZ2h0IHdhbnQgdG8gdXNlIHRoaXMuXG4vLyBXaGlsZSB0aGlzIGRvZXMgcGFyc2UgYW5kIHJlLXBhY2sgdGhlIG1lc3NhZ2VzLCB0aGUgYnVuZGxlIHRpbWV0YWdzIGFyZSBsZWZ0XG4vLyBpbiB0aGVpciBhY2N1cmF0ZSBhbmQgcHJlc3RpbmUgc3RhdGUuXG4gIGV4cG9ydHMuYXBwbHlNZXNzYWdlVHJhbnNmb3JtID0gZnVuY3Rpb24oYnVmZmVyLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gdXRpbHMuYXBwbHlUcmFuc2Zvcm0oYnVmZmVyLCB1dGlscy5tZXNzYWdlVHJhbnNmb3JtKHRyYW5zZm9ybSkpO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vb3NjLW1pbi9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjguMFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgSXNBcnJheSwgU3RyaWN0RXJyb3IsIGJpbnBhY2ssIGdldEFycmF5QXJnLCBpc09zY0J1bmRsZUJ1ZmZlciwgbWFwQnVuZGxlTGlzdCwgb3NjVHlwZUNvZGVzLCBwYWRkaW5nLCB0b09zY1R5cGVBbmRBcmdzLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGJpbnBhY2sgPSByZXF1aXJlKFwiYmlucGFja1wiKTtcblxuICBleHBvcnRzLmNvbmNhdCA9IGZ1bmN0aW9uKGJ1ZmZlcnMpIHtcbiAgICB2YXIgYnVmZmVyLCBjb3B5VG8sIGRlc3RCdWZmZXIsIHN1bUxlbmd0aCwgX2ksIF9qLCBfaywgX2xlbiwgX2xlbjEsIF9sZW4yO1xuICAgIGlmICghSXNBcnJheShidWZmZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uY2F0IG11c3QgdGFrZSBhbiBhcnJheSBvZiBidWZmZXJzXCIpO1xuICAgIH1cbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGJ1ZmZlcnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlcnNbX2ldO1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25jYXQgbXVzdCB0YWtlIGFuIGFycmF5IG9mIGJ1ZmZlcnNcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHN1bUxlbmd0aCA9IDA7XG4gICAgZm9yIChfaiA9IDAsIF9sZW4xID0gYnVmZmVycy5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlcnNbX2pdO1xuICAgICAgc3VtTGVuZ3RoICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIGRlc3RCdWZmZXIgPSBuZXcgQnVmZmVyKHN1bUxlbmd0aCk7XG4gICAgY29weVRvID0gMDtcbiAgICBmb3IgKF9rID0gMCwgX2xlbjIgPSBidWZmZXJzLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgYnVmZmVyID0gYnVmZmVyc1tfa107XG4gICAgICBidWZmZXIuY29weShkZXN0QnVmZmVyLCBjb3B5VG8pO1xuICAgICAgY29weVRvICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBkZXN0QnVmZmVyO1xuICB9O1xuXG4gIGV4cG9ydHMudG9Pc2NTdHJpbmcgPSBmdW5jdGlvbihzdHIsIHN0cmljdCkge1xuICAgIHZhciBpLCBudWxsSW5kZXgsIF9pLCBfcmVmO1xuICAgIGlmICghKHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBwYWNrIGEgbm9uLXN0cmluZyBpbnRvIGFuIG9zYy1zdHJpbmdcIik7XG4gICAgfVxuICAgIG51bGxJbmRleCA9IHN0ci5pbmRleE9mKFwiXFx1MDAwMFwiKTtcbiAgICBpZiAobnVsbEluZGV4ICE9PSAtMSAmJiBzdHJpY3QpIHtcbiAgICAgIHRocm93IFN0cmljdEVycm9yKFwiQ2FuJ3QgcGFjayBhbiBvc2Mtc3RyaW5nIHRoYXQgY29udGFpbnMgTlVMTCBjaGFyYWN0ZXJzXCIpO1xuICAgIH1cbiAgICBpZiAobnVsbEluZGV4ICE9PSAtMSkge1xuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIG51bGxJbmRleCk7XG4gICAgfVxuICAgIGZvciAoaSA9IF9pID0gMCwgX3JlZiA9IHBhZGRpbmcoc3RyKTsgMCA8PSBfcmVmID8gX2kgPCBfcmVmIDogX2kgPiBfcmVmOyBpID0gMCA8PSBfcmVmID8gKytfaSA6IC0tX2kpIHtcbiAgICAgIHN0ciArPSBcIlxcdTAwMDBcIjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3RyKTtcbiAgfTtcblxuICBleHBvcnRzLnNwbGl0T3NjU3RyaW5nID0gZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgbnVsbEluZGV4LCByYXdTdHIsIHJlc3QsIHNwbGl0UG9pbnQsIHN0ciwgX2ksIF9yZWY7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgdGhyb3cgU3RyaWN0RXJyb3IoXCJDYW4ndCBzcGxpdCBzb21ldGhpbmcgdGhhdCBpc24ndCBhIGJ1ZmZlclwiKTtcbiAgICB9XG4gICAgcmF3U3RyID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgICBudWxsSW5kZXggPSByYXdTdHIuaW5kZXhPZihcIlxcdTAwMDBcIik7XG4gICAgaWYgKG51bGxJbmRleCA9PT0gLTEpIHtcbiAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxsIG9zYy1zdHJpbmdzIG11c3QgY29udGFpbiBhIG51bGwgY2hhcmFjdGVyXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaW5nOiByYXdTdHIsXG4gICAgICAgIHJlc3Q6IG5ldyBCdWZmZXIoMClcbiAgICAgIH07XG4gICAgfVxuICAgIHN0ciA9IHJhd1N0ci5zbGljZSgwLCBudWxsSW5kZXgpO1xuICAgIHNwbGl0UG9pbnQgPSBCdWZmZXIuYnl0ZUxlbmd0aChzdHIpICsgcGFkZGluZyhzdHIpO1xuICAgIGlmIChzdHJpY3QgJiYgc3BsaXRQb2ludCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRocm93IFN0cmljdEVycm9yKFwiTm90IGVub3VnaCBwYWRkaW5nIGZvciBvc2Mtc3RyaW5nXCIpO1xuICAgIH1cbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICBmb3IgKGkgPSBfaSA9IF9yZWYgPSBCdWZmZXIuYnl0ZUxlbmd0aChzdHIpOyBfcmVmIDw9IHNwbGl0UG9pbnQgPyBfaSA8IHNwbGl0UG9pbnQgOiBfaSA+IHNwbGl0UG9pbnQ7IGkgPSBfcmVmIDw9IHNwbGl0UG9pbnQgPyArK19pIDogLS1faSkge1xuICAgICAgICBpZiAoYnVmZmVyW2ldICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgU3RyaWN0RXJyb3IoXCJOb3QgZW5vdWdoIG9yIGluY29ycmVjdCBwYWRkaW5nIGZvciBvc2Mtc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3QgPSBidWZmZXIuc2xpY2Uoc3BsaXRQb2ludCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmluZzogc3RyLFxuICAgICAgcmVzdDogcmVzdFxuICAgIH07XG4gIH07XG5cbiAgZXhwb3J0cy5zcGxpdEludGVnZXIgPSBmdW5jdGlvbihidWZmZXIsIHR5cGUpIHtcbiAgICB2YXIgYnl0ZXMsIG51bSwgcmVzdCwgdmFsdWU7XG4gICAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IFwiSW50MzJcIjtcbiAgICB9XG4gICAgYnl0ZXMgPSAoYmlucGFja1tcInBhY2tcIiArIHR5cGVdKDApKS5sZW5ndGg7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBieXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnVmZmVyIGlzIG5vdCBiaWcgZW5vdWdoIGZvciBpbnRlZ2VyIHR5cGVcIik7XG4gICAgfVxuICAgIG51bSA9IDA7XG4gICAgdmFsdWUgPSBiaW5wYWNrW1widW5wYWNrXCIgKyB0eXBlXShidWZmZXIuc2xpY2UoMCwgYnl0ZXMpLCBcImJpZ1wiKTtcbiAgICByZXN0ID0gYnVmZmVyLnNsaWNlKGJ5dGVzLCBidWZmZXIubGVuZ3RoKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW50ZWdlcjogdmFsdWUsXG4gICAgICByZXN0OiByZXN0XG4gICAgfTtcbiAgfTtcblxuICBleHBvcnRzLnRvSW50ZWdlckJ1ZmZlciA9IGZ1bmN0aW9uKG51bWJlciwgdHlwZSkge1xuICAgIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAgIHR5cGUgPSBcIkludDMyXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbnVtYmVyICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgcGFjayBhIG5vbi1udW1iZXIgaW50byBhbiBpbnRlZ2VyIGJ1ZmZlclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpbnBhY2tbXCJwYWNrXCIgKyB0eXBlXShudW1iZXIsIFwiYmlnXCIpO1xuICB9O1xuXG4gIG9zY1R5cGVDb2RlcyA9IHtcbiAgICBzOiB7XG4gICAgICByZXByZXNlbnRhdGlvbjogXCJzdHJpbmdcIixcbiAgICAgIHNwbGl0OiBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgICAgICB2YXIgc3BsaXQ7XG4gICAgICAgIHNwbGl0ID0gZXhwb3J0cy5zcGxpdE9zY1N0cmluZyhidWZmZXIsIHN0cmljdCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHNwbGl0LnN0cmluZyxcbiAgICAgICAgICByZXN0OiBzcGxpdC5yZXN0XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9Bcmc6IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy50b09zY1N0cmluZyh2YWx1ZSwgc3RyaWN0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGk6IHtcbiAgICAgIHJlcHJlc2VudGF0aW9uOiBcImludGVnZXJcIixcbiAgICAgIHNwbGl0OiBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgICAgICB2YXIgc3BsaXQ7XG4gICAgICAgIHNwbGl0ID0gZXhwb3J0cy5zcGxpdEludGVnZXIoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogc3BsaXQuaW50ZWdlcixcbiAgICAgICAgICByZXN0OiBzcGxpdC5yZXN0XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9Bcmc6IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy50b0ludGVnZXJCdWZmZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdDoge1xuICAgICAgcmVwcmVzZW50YXRpb246IFwidGltZXRhZ1wiLFxuICAgICAgc3BsaXQ6IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBzcGxpdDtcbiAgICAgICAgc3BsaXQgPSBleHBvcnRzLnNwbGl0SW50ZWdlcihidWZmZXIsIFwiVUludDY0XCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBzcGxpdC5pbnRlZ2VyLFxuICAgICAgICAgIHJlc3Q6IHNwbGl0LnJlc3RcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0b0FyZzogZnVuY3Rpb24odmFsdWUsIHN0cmljdCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBvcnRzLnRvSW50ZWdlckJ1ZmZlcih2YWx1ZSwgXCJVSW50NjRcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICBmOiB7XG4gICAgICByZXByZXNlbnRhdGlvbjogXCJmbG9hdFwiLFxuICAgICAgc3BsaXQ6IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGJpbnBhY2sudW5wYWNrRmxvYXQzMihidWZmZXIuc2xpY2UoMCwgNCksIFwiYmlnXCIpLFxuICAgICAgICAgIHJlc3Q6IGJ1ZmZlci5zbGljZSg0LCBidWZmZXIubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRvQXJnOiBmdW5jdGlvbih2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpbnBhY2sucGFja0Zsb2F0MzIodmFsdWUsIFwiYmlnXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZDoge1xuICAgICAgcmVwcmVzZW50YXRpb246IFwiZG91YmxlXCIsXG4gICAgICBzcGxpdDogZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogYmlucGFjay51bnBhY2tGbG9hdDY0KGJ1ZmZlci5zbGljZSgwLCA4KSwgXCJiaWdcIiksXG4gICAgICAgICAgcmVzdDogYnVmZmVyLnNsaWNlKDgsIGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9Bcmc6IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmlucGFjay5wYWNrRmxvYXQ2NCh2YWx1ZSwgXCJiaWdcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICBiOiB7XG4gICAgICByZXByZXNlbnRhdGlvbjogXCJibG9iXCIsXG4gICAgICBzcGxpdDogZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGxlbmd0aCwgX3JlZjtcbiAgICAgICAgX3JlZiA9IGV4cG9ydHMuc3BsaXRJbnRlZ2VyKGJ1ZmZlciksIGxlbmd0aCA9IF9yZWYuaW50ZWdlciwgYnVmZmVyID0gX3JlZi5yZXN0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBidWZmZXIuc2xpY2UoMCwgbGVuZ3RoKSxcbiAgICAgICAgICByZXN0OiBidWZmZXIuc2xpY2UobGVuZ3RoLCBidWZmZXIubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRvQXJnOiBmdW5jdGlvbih2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBzaXplO1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBub2RlLmpzIEJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBzaXplID0gZXhwb3J0cy50b0ludGVnZXJCdWZmZXIodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29uY2F0KFtzaXplLCB2YWx1ZV0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgVDoge1xuICAgICAgcmVwcmVzZW50YXRpb246IFwidHJ1ZVwiLFxuICAgICAgc3BsaXQ6IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdDogYnVmZmVyLFxuICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9Bcmc6IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiBzdHJpY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnVlIG11c3QgYmUgdHJ1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIEY6IHtcbiAgICAgIHJlcHJlc2VudGF0aW9uOiBcImZhbHNlXCIsXG4gICAgICBzcGxpdDogZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN0OiBidWZmZXIsXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9Bcmc6IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHN0cmljdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhbHNlIG11c3QgYmUgZmFsc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBOOiB7XG4gICAgICByZXByZXNlbnRhdGlvbjogXCJudWxsXCIsXG4gICAgICBzcGxpdDogZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN0OiBidWZmZXIsXG4gICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0b0FyZzogZnVuY3Rpb24odmFsdWUsIHN0cmljdCkge1xuICAgICAgICBpZiAodmFsdWUgJiYgc3RyaWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibnVsbCBtdXN0IGJlIGZhbHNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKDApO1xuICAgICAgfVxuICAgIH0sXG4gICAgSToge1xuICAgICAgcmVwcmVzZW50YXRpb246IFwiYmFuZ1wiLFxuICAgICAgc3BsaXQ6IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdDogYnVmZmVyLFxuICAgICAgICAgIHZhbHVlOiBcImJhbmdcIlxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRvQXJnOiBmdW5jdGlvbih2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBleHBvcnRzLm9zY1R5cGVDb2RlVG9UeXBlU3RyaW5nID0gZnVuY3Rpb24oY29kZSkge1xuICAgIHZhciBfcmVmO1xuICAgIHJldHVybiAoX3JlZiA9IG9zY1R5cGVDb2Rlc1tjb2RlXSkgIT0gbnVsbCA/IF9yZWYucmVwcmVzZW50YXRpb24gOiB2b2lkIDA7XG4gIH07XG5cbiAgZXhwb3J0cy50eXBlU3RyaW5nVG9Pc2NUeXBlQ29kZSA9IGZ1bmN0aW9uKHJlcCkge1xuICAgIHZhciBjb2RlLCBzdHI7XG4gICAgZm9yIChjb2RlIGluIG9zY1R5cGVDb2Rlcykge1xuICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChvc2NUeXBlQ29kZXMsIGNvZGUpKSBjb250aW51ZTtcbiAgICAgIHN0ciA9IG9zY1R5cGVDb2Rlc1tjb2RlXS5yZXByZXNlbnRhdGlvbjtcbiAgICAgIGlmIChzdHIgPT09IHJlcCkge1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgZXhwb3J0cy5hcmdUb1R5cGVDb2RlID0gZnVuY3Rpb24oYXJnLCBzdHJpY3QpIHtcbiAgICB2YXIgY29kZSwgdmFsdWU7XG4gICAgaWYgKCgoYXJnICE9IG51bGwgPyBhcmcudHlwZSA6IHZvaWQgMCkgIT0gbnVsbCkgJiYgKHR5cGVvZiBhcmcudHlwZSA9PT0gJ3N0cmluZycpICYmICgoY29kZSA9IGV4cG9ydHMudHlwZVN0cmluZ1RvT3NjVHlwZUNvZGUoYXJnLnR5cGUpKSAhPSBudWxsKSkge1xuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIHZhbHVlID0gKGFyZyAhPSBudWxsID8gYXJnLnZhbHVlIDogdm9pZCAwKSAhPSBudWxsID8gYXJnLnZhbHVlIDogYXJnO1xuICAgIGlmIChzdHJpY3QgJiYgKHZhbHVlID09IG51bGwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IGhhcyBubyB2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuICdzJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnZic7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2InO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gJ1QnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdGJztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ04nO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJIGRvbid0IGtub3cgd2hhdCB0eXBlIHRoaXMgaXMgc3VwcG9zZWQgdG8gYmUuXCIpO1xuICB9O1xuXG4gIGV4cG9ydHMuc3BsaXRPc2NBcmd1bWVudCA9IGZ1bmN0aW9uKGJ1ZmZlciwgdHlwZSwgc3RyaWN0KSB7XG4gICAgdmFyIG9zY3R5cGU7XG4gICAgb3NjdHlwZSA9IGV4cG9ydHMudHlwZVN0cmluZ1RvT3NjVHlwZUNvZGUodHlwZSk7XG4gICAgaWYgKG9zY3R5cGUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9zY1R5cGVDb2Rlc1tvc2N0eXBlXS5zcGxpdChidWZmZXIsIHN0cmljdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkkgZG9uJ3QgdW5kZXJzdGFuZCBob3cgSSdtIHN1cHBvc2VkIHRvIHVucGFjayBcIiArIHR5cGUpO1xuICAgIH1cbiAgfTtcblxuICBleHBvcnRzLnRvT3NjQXJndW1lbnQgPSBmdW5jdGlvbih2YWx1ZSwgdHlwZSwgc3RyaWN0KSB7XG4gICAgdmFyIG9zY3R5cGU7XG4gICAgb3NjdHlwZSA9IGV4cG9ydHMudHlwZVN0cmluZ1RvT3NjVHlwZUNvZGUodHlwZSk7XG4gICAgaWYgKG9zY3R5cGUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9zY1R5cGVDb2Rlc1tvc2N0eXBlXS50b0FyZyh2YWx1ZSwgc3RyaWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSSBkb24ndCBrbm93IGhvdyB0byBwYWNrIFwiICsgdHlwZSk7XG4gICAgfVxuICB9O1xuXG4gIGV4cG9ydHMuZnJvbU9zY01lc3NhZ2UgPSBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgIHZhciBhZGRyZXNzLCBhcmcsIGFyZ3MsIGFycmF5U3RhY2ssIGJ1aWx0LCB0eXBlLCB0eXBlU3RyaW5nLCB0eXBlcywgX2ksIF9sZW4sIF9yZWYsIF9yZWYxO1xuICAgIF9yZWYgPSBleHBvcnRzLnNwbGl0T3NjU3RyaW5nKGJ1ZmZlciwgc3RyaWN0KSwgYWRkcmVzcyA9IF9yZWYuc3RyaW5nLCBidWZmZXIgPSBfcmVmLnJlc3Q7XG4gICAgaWYgKHN0cmljdCAmJiBhZGRyZXNzWzBdICE9PSAnLycpIHtcbiAgICAgIHRocm93IFN0cmljdEVycm9yKCdhZGRyZXNzZXMgbXVzdCBzdGFydCB3aXRoIC8nKTtcbiAgICB9XG4gICAgaWYgKCFidWZmZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICBhcmdzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgX3JlZjEgPSBleHBvcnRzLnNwbGl0T3NjU3RyaW5nKGJ1ZmZlciwgc3RyaWN0KSwgdHlwZXMgPSBfcmVmMS5zdHJpbmcsIGJ1ZmZlciA9IF9yZWYxLnJlc3Q7XG4gICAgaWYgKHR5cGVzWzBdICE9PSAnLCcpIHtcbiAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgU3RyaWN0RXJyb3IoJ0FyZ3VtZW50IGxpc3RzIG11c3QgYmVnaW4gd2l0aCAsJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICBhcmdzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgdHlwZXMgPSB0eXBlcy5zbGljZSgxLCArdHlwZXMubGVuZ3RoICsgMSB8fCA5ZTkpO1xuICAgIGFyZ3MgPSBbXTtcbiAgICBhcnJheVN0YWNrID0gW2FyZ3NdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdHlwZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIHR5cGUgPSB0eXBlc1tfaV07XG4gICAgICBpZiAodHlwZSA9PT0gJ1snKSB7XG4gICAgICAgIGFycmF5U3RhY2sucHVzaChbXSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICddJykge1xuICAgICAgICBpZiAoYXJyYXlTdGFjay5sZW5ndGggPD0gMSkge1xuICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdHJpY3RFcnJvcihcIk1pc21hdGNoZWQgJ10nIGNoYXJhY3Rlci5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1aWx0ID0gYXJyYXlTdGFjay5wb3AoKTtcbiAgICAgICAgICBhcnJheVN0YWNrW2FycmF5U3RhY2subGVuZ3RoIC0gMV0ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgdmFsdWU6IGJ1aWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0eXBlU3RyaW5nID0gZXhwb3J0cy5vc2NUeXBlQ29kZVRvVHlwZVN0cmluZyh0eXBlKTtcbiAgICAgIGlmICh0eXBlU3RyaW5nID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSSBkb24ndCB1bmRlcnN0YW5kIHRoZSBhcmd1bWVudCBjb2RlIFwiICsgdHlwZSk7XG4gICAgICB9XG4gICAgICBhcmcgPSBleHBvcnRzLnNwbGl0T3NjQXJndW1lbnQoYnVmZmVyLCB0eXBlU3RyaW5nLCBzdHJpY3QpO1xuICAgICAgaWYgKGFyZyAhPSBudWxsKSB7XG4gICAgICAgIGJ1ZmZlciA9IGFyZy5yZXN0O1xuICAgICAgfVxuICAgICAgYXJyYXlTdGFja1thcnJheVN0YWNrLmxlbmd0aCAtIDFdLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlU3RyaW5nLFxuICAgICAgICB2YWx1ZTogYXJnICE9IG51bGwgPyBhcmcudmFsdWUgOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYXJyYXlTdGFjay5sZW5ndGggIT09IDEgJiYgc3RyaWN0KSB7XG4gICAgICB0aHJvdyBuZXcgU3RyaWN0RXJyb3IoXCJNaXNtYXRjaGVkICdbJyBjaGFyYWN0ZXJcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgYXJnczogYXJncyxcbiAgICAgIG9zY1R5cGU6IFwibWVzc2FnZVwiXG4gICAgfTtcbiAgfTtcblxuICBleHBvcnRzLmZyb21Pc2NCdW5kbGUgPSBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgIHZhciBidW5kbGVUYWcsIGNvbnZlcnRlZEVsZW1zLCB0aW1ldGFnLCBfcmVmLCBfcmVmMTtcbiAgICBfcmVmID0gZXhwb3J0cy5zcGxpdE9zY1N0cmluZyhidWZmZXIsIHN0cmljdCksIGJ1bmRsZVRhZyA9IF9yZWYuc3RyaW5nLCBidWZmZXIgPSBfcmVmLnJlc3Q7XG4gICAgaWYgKGJ1bmRsZVRhZyAhPT0gXCJcXCNidW5kbGVcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3NjLWJ1bmRsZXMgbXVzdCBiZWdpbiB3aXRoIFxcI2J1bmRsZVwiKTtcbiAgICB9XG4gICAgX3JlZjEgPSBleHBvcnRzLnNwbGl0SW50ZWdlcihidWZmZXIsIFwiVUludDY0XCIpLCB0aW1ldGFnID0gX3JlZjEuaW50ZWdlciwgYnVmZmVyID0gX3JlZjEucmVzdDtcbiAgICBjb252ZXJ0ZWRFbGVtcyA9IG1hcEJ1bmRsZUxpc3QoYnVmZmVyLCBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmZyb21Pc2NQYWNrZXQoYnVmZmVyLCBzdHJpY3QpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB0aW1ldGFnOiB0aW1ldGFnLFxuICAgICAgZWxlbWVudHM6IGNvbnZlcnRlZEVsZW1zLFxuICAgICAgb3NjVHlwZTogXCJidW5kbGVcIlxuICAgIH07XG4gIH07XG5cbiAgZXhwb3J0cy5mcm9tT3NjUGFja2V0ID0gZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICBpZiAoaXNPc2NCdW5kbGVCdWZmZXIoYnVmZmVyLCBzdHJpY3QpKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5mcm9tT3NjQnVuZGxlKGJ1ZmZlciwgc3RyaWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZnJvbU9zY01lc3NhZ2UoYnVmZmVyLCBzdHJpY3QpO1xuICAgIH1cbiAgfTtcblxuICBnZXRBcnJheUFyZyA9IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmIChJc0FycmF5KGFyZykpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfSBlbHNlIGlmICgoKGFyZyAhPSBudWxsID8gYXJnLnR5cGUgOiB2b2lkIDApID09PSBcImFycmF5XCIpICYmIChJc0FycmF5KGFyZyAhPSBudWxsID8gYXJnLnZhbHVlIDogdm9pZCAwKSkpIHtcbiAgICAgIHJldHVybiBhcmcudmFsdWU7XG4gICAgfSBlbHNlIGlmICgoYXJnICE9IG51bGwpICYmIChhcmcudHlwZSA9PSBudWxsKSAmJiAoSXNBcnJheShhcmcudmFsdWUpKSkge1xuICAgICAgcmV0dXJuIGFyZy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHRvT3NjVHlwZUFuZEFyZ3MgPSBmdW5jdGlvbihhcmdMaXN0LCBzdHJpY3QpIHtcbiAgICB2YXIgYXJnLCBidWZmLCBvc2NhcmdzLCBvc2N0eXBlLCB0aGlzQXJncywgdGhpc1R5cGUsIHR5cGVDb2RlLCB2YWx1ZSwgX2ksIF9sZW4sIF9yZWY7XG4gICAgb3NjdHlwZSA9IFwiXCI7XG4gICAgb3NjYXJncyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gYXJnTGlzdC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgYXJnID0gYXJnTGlzdFtfaV07XG4gICAgICBpZiAoKGdldEFycmF5QXJnKGFyZykpICE9IG51bGwpIHtcbiAgICAgICAgX3JlZiA9IHRvT3NjVHlwZUFuZEFyZ3MoZ2V0QXJyYXlBcmcoYXJnKSwgc3RyaWN0KSwgdGhpc1R5cGUgPSBfcmVmWzBdLCB0aGlzQXJncyA9IF9yZWZbMV07XG4gICAgICAgIG9zY3R5cGUgKz0gXCJbXCIgKyB0aGlzVHlwZSArIFwiXVwiO1xuICAgICAgICBvc2NhcmdzID0gb3NjYXJncy5jb25jYXQodGhpc0FyZ3MpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHR5cGVDb2RlID0gZXhwb3J0cy5hcmdUb1R5cGVDb2RlKGFyZywgc3RyaWN0KTtcbiAgICAgIGlmICh0eXBlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gYXJnICE9IG51bGwgPyBhcmcudmFsdWUgOiB2b2lkIDA7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFsdWUgPSBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZiA9IGV4cG9ydHMudG9Pc2NBcmd1bWVudCh2YWx1ZSwgZXhwb3J0cy5vc2NUeXBlQ29kZVRvVHlwZVN0cmluZyh0eXBlQ29kZSksIHN0cmljdCk7XG4gICAgICAgIGlmIChidWZmICE9IG51bGwpIHtcbiAgICAgICAgICBvc2NhcmdzLnB1c2goYnVmZik7XG4gICAgICAgICAgb3NjdHlwZSArPSB0eXBlQ29kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW29zY3R5cGUsIG9zY2FyZ3NdO1xuICB9O1xuXG4gIGV4cG9ydHMudG9Pc2NNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSwgc3RyaWN0KSB7XG4gICAgdmFyIGFkZHJlc3MsIGFsbEFyZ3MsIGFyZ3MsIG9sZF9hcmcsIG9zY2FkZHIsIG9zY2FyZ3MsIG9zY3R5cGUsIF9yZWY7XG4gICAgYWRkcmVzcyA9IChtZXNzYWdlICE9IG51bGwgPyBtZXNzYWdlLmFkZHJlc3MgOiB2b2lkIDApICE9IG51bGwgPyBtZXNzYWdlLmFkZHJlc3MgOiBtZXNzYWdlO1xuICAgIGlmICh0eXBlb2YgYWRkcmVzcyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWVzc2FnZSBtdXN0IGNvbnRhaW4gYW4gYWRkcmVzc1wiKTtcbiAgICB9XG4gICAgYXJncyA9IG1lc3NhZ2UgIT0gbnVsbCA/IG1lc3NhZ2UuYXJncyA6IHZvaWQgMDtcbiAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7XG4gICAgICBhcmdzID0gW107XG4gICAgfVxuICAgIGlmICghSXNBcnJheShhcmdzKSkge1xuICAgICAgb2xkX2FyZyA9IGFyZ3M7XG4gICAgICBhcmdzID0gW107XG4gICAgICBhcmdzWzBdID0gb2xkX2FyZztcbiAgICB9XG4gICAgb3NjYWRkciA9IGV4cG9ydHMudG9Pc2NTdHJpbmcoYWRkcmVzcywgc3RyaWN0KTtcbiAgICBfcmVmID0gdG9Pc2NUeXBlQW5kQXJncyhhcmdzLCBzdHJpY3QpLCBvc2N0eXBlID0gX3JlZlswXSwgb3NjYXJncyA9IF9yZWZbMV07XG4gICAgb3NjdHlwZSA9IFwiLFwiICsgb3NjdHlwZTtcbiAgICBhbGxBcmdzID0gZXhwb3J0cy5jb25jYXQob3NjYXJncyk7XG4gICAgb3NjdHlwZSA9IGV4cG9ydHMudG9Pc2NTdHJpbmcob3NjdHlwZSk7XG4gICAgcmV0dXJuIGV4cG9ydHMuY29uY2F0KFtvc2NhZGRyLCBvc2N0eXBlLCBhbGxBcmdzXSk7XG4gIH07XG5cbiAgZXhwb3J0cy50b09zY0J1bmRsZSA9IGZ1bmN0aW9uKGJ1bmRsZSwgc3RyaWN0KSB7XG4gICAgdmFyIGFsbEVsZW1zLCBidWZmLCBlLCBlbGVtLCBlbGVtZW50cywgZWxlbXN0ciwgb3NjQnVuZGxlVGFnLCBvc2NFbGVtcywgb3NjVGltZVRhZywgc2l6ZSwgdGltZXRhZywgX2ksIF9sZW4sIF9yZWYsIF9yZWYxO1xuICAgIGlmIChzdHJpY3QgJiYgKChidW5kbGUgIT0gbnVsbCA/IGJ1bmRsZS50aW1ldGFnIDogdm9pZCAwKSA9PSBudWxsKSkge1xuICAgICAgdGhyb3cgU3RyaWN0RXJyb3IoXCJidW5kbGVzIG11c3QgaGF2ZSB0aW1ldGFncy5cIik7XG4gICAgfVxuICAgIHRpbWV0YWcgPSAoX3JlZiA9IGJ1bmRsZSAhPSBudWxsID8gYnVuZGxlLnRpbWV0YWcgOiB2b2lkIDApICE9IG51bGwgPyBfcmVmIDogMDtcbiAgICBlbGVtZW50cyA9IChfcmVmMSA9IGJ1bmRsZSAhPSBudWxsID8gYnVuZGxlLmVsZW1lbnRzIDogdm9pZCAwKSAhPSBudWxsID8gX3JlZjEgOiBbXTtcbiAgICBpZiAoIUlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICBlbGVtc3RyID0gZWxlbWVudHM7XG4gICAgICBlbGVtZW50cyA9IFtdO1xuICAgICAgZWxlbWVudHMucHVzaChlbGVtc3RyKTtcbiAgICB9XG4gICAgb3NjQnVuZGxlVGFnID0gZXhwb3J0cy50b09zY1N0cmluZyhcIlxcI2J1bmRsZVwiKTtcbiAgICBvc2NUaW1lVGFnID0gZXhwb3J0cy50b0ludGVnZXJCdWZmZXIodGltZXRhZywgXCJVSW50NjRcIik7XG4gICAgb3NjRWxlbXMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGVsZW1lbnRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBlbGVtID0gZWxlbWVudHNbX2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYnVmZiA9IGV4cG9ydHMudG9Pc2NQYWNrZXQoZWxlbSwgc3RyaWN0KTtcbiAgICAgICAgc2l6ZSA9IGV4cG9ydHMudG9JbnRlZ2VyQnVmZmVyKGJ1ZmYubGVuZ3RoKTtcbiAgICAgICAgb3NjRWxlbXMucHVzaChleHBvcnRzLmNvbmNhdChbc2l6ZSwgYnVmZl0pKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBhbGxFbGVtcyA9IGV4cG9ydHMuY29uY2F0KG9zY0VsZW1zKTtcbiAgICByZXR1cm4gZXhwb3J0cy5jb25jYXQoW29zY0J1bmRsZVRhZywgb3NjVGltZVRhZywgYWxsRWxlbXNdKTtcbiAgfTtcblxuICBleHBvcnRzLnRvT3NjUGFja2V0ID0gZnVuY3Rpb24oYnVuZGxlT3JNZXNzYWdlLCBzdHJpY3QpIHtcbiAgICBpZiAoKGJ1bmRsZU9yTWVzc2FnZSAhPSBudWxsID8gYnVuZGxlT3JNZXNzYWdlLm9zY1R5cGUgOiB2b2lkIDApICE9IG51bGwpIHtcbiAgICAgIGlmIChidW5kbGVPck1lc3NhZ2Uub3NjVHlwZSA9PT0gXCJidW5kbGVcIikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy50b09zY0J1bmRsZShidW5kbGVPck1lc3NhZ2UsIHN0cmljdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwb3J0cy50b09zY01lc3NhZ2UoYnVuZGxlT3JNZXNzYWdlLCBzdHJpY3QpO1xuICAgIH1cbiAgICBpZiAoKChidW5kbGVPck1lc3NhZ2UgIT0gbnVsbCA/IGJ1bmRsZU9yTWVzc2FnZS50aW1ldGFnIDogdm9pZCAwKSAhPSBudWxsKSB8fCAoKGJ1bmRsZU9yTWVzc2FnZSAhPSBudWxsID8gYnVuZGxlT3JNZXNzYWdlLmVsZW1lbnRzIDogdm9pZCAwKSAhPSBudWxsKSkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMudG9Pc2NCdW5kbGUoYnVuZGxlT3JNZXNzYWdlLCBzdHJpY3QpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy50b09zY01lc3NhZ2UoYnVuZGxlT3JNZXNzYWdlLCBzdHJpY3QpO1xuICB9O1xuXG4gIGV4cG9ydHMuYXBwbHlNZXNzYWdlVHJhbmZvcm1lclRvQnVuZGxlID0gZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgdmFyIGJ1bmRsZVRhZ0J1ZmZlciwgY29weUluZGV4LCBlbGVtLCBlbGVtcywgbGVuZ3RoQnVmZiwgb3V0QnVmZmVyLCBzdHJpbmcsIHRpbWV0YWdCdWZmZXIsIHRvdGFsTGVuZ3RoLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmO1xuICAgICAgX3JlZiA9IGV4cG9ydHMuc3BsaXRPc2NTdHJpbmcoYnVmZmVyKSwgc3RyaW5nID0gX3JlZi5zdHJpbmcsIGJ1ZmZlciA9IF9yZWYucmVzdDtcbiAgICAgIGlmIChzdHJpbmcgIT09IFwiXFwjYnVuZGxlXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3NjLWJ1bmRsZXMgbXVzdCBiZWdpbiB3aXRoIFxcI2J1bmRsZVwiKTtcbiAgICAgIH1cbiAgICAgIGJ1bmRsZVRhZ0J1ZmZlciA9IGV4cG9ydHMudG9Pc2NTdHJpbmcoc3RyaW5nKTtcbiAgICAgIHRpbWV0YWdCdWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgOCk7XG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoOCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgICBlbGVtcyA9IG1hcEJ1bmRsZUxpc3QoYnVmZmVyLCBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYXBwbHlUcmFuc2Zvcm0oYnVmZmVyLCB0cmFuc2Zvcm0sIGV4cG9ydHMuYXBwbHlNZXNzYWdlVHJhbmZvcm1lclRvQnVuZGxlKHRyYW5zZm9ybSkpO1xuICAgICAgfSk7XG4gICAgICB0b3RhbExlbmd0aCA9IGJ1bmRsZVRhZ0J1ZmZlci5sZW5ndGggKyB0aW1ldGFnQnVmZmVyLmxlbmd0aDtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZWxlbXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZWxlbSA9IGVsZW1zW19pXTtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gNCArIGVsZW0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgb3V0QnVmZmVyID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aCk7XG4gICAgICBidW5kbGVUYWdCdWZmZXIuY29weShvdXRCdWZmZXIsIDApO1xuICAgICAgdGltZXRhZ0J1ZmZlci5jb3B5KG91dEJ1ZmZlciwgYnVuZGxlVGFnQnVmZmVyLmxlbmd0aCk7XG4gICAgICBjb3B5SW5kZXggPSBidW5kbGVUYWdCdWZmZXIubGVuZ3RoICsgdGltZXRhZ0J1ZmZlci5sZW5ndGg7XG4gICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBlbGVtcy5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgZWxlbSA9IGVsZW1zW19qXTtcbiAgICAgICAgbGVuZ3RoQnVmZiA9IGV4cG9ydHMudG9JbnRlZ2VyQnVmZmVyKGVsZW0ubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoQnVmZi5jb3B5KG91dEJ1ZmZlciwgY29weUluZGV4KTtcbiAgICAgICAgY29weUluZGV4ICs9IDQ7XG4gICAgICAgIGVsZW0uY29weShvdXRCdWZmZXIsIGNvcHlJbmRleCk7XG4gICAgICAgIGNvcHlJbmRleCArPSBlbGVtLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRCdWZmZXI7XG4gICAgfTtcbiAgfTtcblxuICBleHBvcnRzLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24oYnVmZmVyLCBtVHJhbnNmb3JtLCBidW5kbGVUcmFuc2Zvcm0pIHtcbiAgICBpZiAoYnVuZGxlVHJhbnNmb3JtID09IG51bGwpIHtcbiAgICAgIGJ1bmRsZVRyYW5zZm9ybSA9IGV4cG9ydHMuYXBwbHlNZXNzYWdlVHJhbmZvcm1lclRvQnVuZGxlKG1UcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAoaXNPc2NCdW5kbGVCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgcmV0dXJuIGJ1bmRsZVRyYW5zZm9ybShidWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbVRyYW5zZm9ybShidWZmZXIpO1xuICAgIH1cbiAgfTtcblxuICBleHBvcnRzLmFkZHJlc3NUcmFuc2Zvcm0gPSBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICB2YXIgcmVzdCwgc3RyaW5nLCBfcmVmO1xuICAgICAgX3JlZiA9IGV4cG9ydHMuc3BsaXRPc2NTdHJpbmcoYnVmZmVyKSwgc3RyaW5nID0gX3JlZi5zdHJpbmcsIHJlc3QgPSBfcmVmLnJlc3Q7XG4gICAgICBzdHJpbmcgPSB0cmFuc2Zvcm0oc3RyaW5nKTtcbiAgICAgIHJldHVybiBleHBvcnRzLmNvbmNhdChbZXhwb3J0cy50b09zY1N0cmluZyhzdHJpbmcpLCByZXN0XSk7XG4gICAgfTtcbiAgfTtcblxuICBleHBvcnRzLm1lc3NhZ2VUcmFuc2Zvcm0gPSBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICB2YXIgbWVzc2FnZTtcbiAgICAgIG1lc3NhZ2UgPSBleHBvcnRzLmZyb21Pc2NNZXNzYWdlKGJ1ZmZlcik7XG4gICAgICByZXR1cm4gZXhwb3J0cy50b09zY01lc3NhZ2UodHJhbnNmb3JtKG1lc3NhZ2UpKTtcbiAgICB9O1xuICB9O1xuXG4gIElzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gIFN0cmljdEVycm9yID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIlN0cmljdCBFcnJvcjogXCIgKyBzdHIpO1xuICB9O1xuXG4gIHBhZGRpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgYnVmZmxlbmd0aDtcbiAgICBidWZmbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKTtcbiAgICByZXR1cm4gNCAtIChidWZmbGVuZ3RoICUgNCk7XG4gIH07XG5cbiAgaXNPc2NCdW5kbGVCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgIHZhciBzdHJpbmc7XG4gICAgc3RyaW5nID0gZXhwb3J0cy5zcGxpdE9zY1N0cmluZyhidWZmZXIsIHN0cmljdCkuc3RyaW5nO1xuICAgIHJldHVybiBzdHJpbmcgPT09IFwiXFwjYnVuZGxlXCI7XG4gIH07XG5cbiAgbWFwQnVuZGxlTGlzdCA9IGZ1bmN0aW9uKGJ1ZmZlciwgZnVuYykge1xuICAgIHZhciBlLCBlbGVtLCBlbGVtcywgbm9uTnVsbEVsZW1zLCBzaXplLCB0aGlzRWxlbUJ1ZmZlciwgX2ksIF9sZW47XG4gICAgZWxlbXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgd2hpbGUgKGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgX3JlZiA9IGV4cG9ydHMuc3BsaXRJbnRlZ2VyKGJ1ZmZlciksIHNpemUgPSBfcmVmLmludGVnZXIsIGJ1ZmZlciA9IF9yZWYucmVzdDtcbiAgICAgICAgaWYgKHNpemUgPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBidW5kbGUgbGlzdDogc2l6ZSBvZiBlbGVtZW50IGlzIGJpZ2dlciB0aGFuIGJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzRWxlbUJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgwLCBzaXplKTtcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKHNpemUsIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goZnVuYyh0aGlzRWxlbUJ1ZmZlcikpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9KSgpO1xuICAgIG5vbk51bGxFbGVtcyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZWxlbXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGVsZW0gPSBlbGVtc1tfaV07XG4gICAgICBpZiAoZWxlbSAhPSBudWxsKSB7XG4gICAgICAgIG5vbk51bGxFbGVtcy5wdXNoKGVsZW0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9uTnVsbEVsZW1zO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vb3NjLW1pbi9saWIvb3NjLXV0aWxpdGllcy5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyB0IGlzIGEgYmlucGFjayB0eXBlbmFtZVxudmFyIHNpemVPZlR5cGUgPSBmdW5jdGlvbih0KSB7XG4gICAgLy8gdW5zaWduZWQgYXJlIHRoZSBzYW1lIGxlbmd0aCBhcyBzaWduZWRcbiAgICBpZih0WzBdID09PSAnVScpIHtcbiAgICAgICAgdCA9IHQuc2xpY2UoMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ0Zsb2F0MzInIDogNCxcbiAgICAgICAgJ0Zsb2F0NjQnIDogOCxcbiAgICAgICAgJ0ludDgnIDogMSxcbiAgICAgICAgJ0ludDE2JyA6IDIsXG4gICAgICAgICdJbnQzMicgOiA0LFxuICAgICAgICAnSW50NjQnIDogOFxuICAgIH1bdF07XG59O1xuXG52YXIgZW5kaWFuQ29udiA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAvLyBub2RlIGRvZXNuJ3QgZGVmaW5lIDggYml0IGVuZGlhbm5lc3NcbiAgICBpZih0W3QubGVuZ3RoIC0gMV0gPT09ICc4JylcbiAgICAgICAgcmV0dXJuICcnO1xuXG4gICAgaWYoZSA9PT0gJ2JpZycpIHtcbiAgICAgICAgcmV0dXJuICdCRSc7XG4gICAgfVxuICAgIHJldHVybiAnTEUnO1xufTtcblxudmFyIGFkZEJpbmRpbmdzID0gZnVuY3Rpb24oYmlucGFja1R5cGVuYW1lLCBub2RlVHlwZW5hbWUpe1xuICAgIGlmKCEodHlwZW9mIG5vZGVUeXBlbmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBub2RlVHlwZW5hbWUgIT09IG51bGwpKSB7XG4gICAgICAgIG5vZGVUeXBlbmFtZSA9IGJpbnBhY2tUeXBlbmFtZTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHNbJ3BhY2snICsgYmlucGFja1R5cGVuYW1lXSA9IGZ1bmN0aW9uKG51bSwgZW5kaWFuKXtcbiAgICAgICAgYiA9IG5ldyBCdWZmZXIoc2l6ZU9mVHlwZShiaW5wYWNrVHlwZW5hbWUpKTtcbiAgICAgICAgYlsnd3JpdGUnICsgbm9kZVR5cGVuYW1lICsgZW5kaWFuQ29udihlbmRpYW4sIGJpbnBhY2tUeXBlbmFtZSldKG51bSwgMCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzWyd1bnBhY2snICsgYmlucGFja1R5cGVuYW1lXSA9IGZ1bmN0aW9uKGJ1ZmYsIGVuZGlhbil7XG4gICAgICAgIHJldHVybiBidWZmWydyZWFkJyArIG5vZGVUeXBlbmFtZSArIGVuZGlhbkNvbnYoZW5kaWFuLCBiaW5wYWNrVHlwZW5hbWUpXSgwKTtcbiAgICB9XG59XG5cbnZhciBhZGRJbnRCaW5kaW5ncyA9IGZ1bmN0aW9uKG4pIHtcbiAgICBhZGRCaW5kaW5ncyhcIkludFwiICsgbik7XG4gICAgYWRkQmluZGluZ3MoXCJVSW50XCIgKyBuKTtcbn1cblxuYWRkSW50QmluZGluZ3MoOCk7XG5hZGRJbnRCaW5kaW5ncygxNik7XG5hZGRJbnRCaW5kaW5ncygzMik7XG5cbnR3b1RvVGhlMzIgPSBNYXRoLnBvdygyLCAzMik7XG5cbi8vIDY0IGJpdCBiaW5kaW5ncyByZXF1aXJlIHNwZWNpYWwgY2FyZVxudmFyIHJlYWQ2NCA9IGZ1bmN0aW9uKHVuc2lnbmVkKXtyZXR1cm4gZnVuY3Rpb24oYnVmZiwgZW5kaWFuKXtcbiAgICB2YXIgZSA9IGVuZGlhbkNvbnYoZW5kaWFuLCAnJyk7XG4gICAgdmFyIHUgPSB1bnNpZ25lZCA/ICdVJyA6ICcnO1xuICAgIHZhciBsb3csIGhpZ2g7XG4gICAgaWYoZSA9PT0gJ0xFJykge1xuICAgICAgICBsb3cgPSBidWZmLnJlYWRVSW50MzJMRSgwKTtcbiAgICAgICAgaGlnaCA9IGJ1ZmZbJ3JlYWQnICsgdSArICdJbnQzMkxFJ10oNCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG93ID0gYnVmZi5yZWFkVUludDMyQkUoNCk7XG4gICAgICAgIGhpZ2ggPSBidWZmWydyZWFkJyArIHUgKyAnSW50MzJCRSddKDApO1xuICAgIH1cbiAgICByZXR1cm4gaGlnaCAqIHR3b1RvVGhlMzIgKyBsb3c7XG59O307XG5cbnZhciB3cml0ZTY0ID0gZnVuY3Rpb24odW5zaWduZWQpe3JldHVybiBmdW5jdGlvbihudW0sIGVuZGlhbil7XG4gICAgdmFyIGUgPSBlbmRpYW5Db252KGVuZGlhbiwgJycpO1xuICAgIHZhciB1ID0gdW5zaWduZWQgPyAnVScgOiAnJztcbiAgICB2YXIgYiA9IG5ldyBCdWZmZXIoOCk7XG4gICAgdmFyIGhpZ2ggPSBNYXRoLmZsb29yKG51bSAvIHR3b1RvVGhlMzIpO1xuICAgIHZhciBsb3cgPSBNYXRoLmZsb29yKG51bSAtIGhpZ2ggKiB0d29Ub1RoZTMyKTtcbiAgICBpZihlID09ICdMRScpIHtcbiAgICAgICAgYi53cml0ZVVJbnQzMkxFKGxvdywgMCwgdHJ1ZSk7XG4gICAgICAgIGJbJ3dyaXRlJyArIHUgKyAnSW50MzJMRSddKGhpZ2gsIDQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGIud3JpdGVVSW50MzJCRShsb3csIDQsIHRydWUpO1xuICAgICAgICBiWyd3cml0ZScgKyB1ICsgJ0ludDMyQkUnXShoaWdoLCAwLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGI7XG59O307XG5cbm1vZHVsZS5leHBvcnRzLnVucGFja0ludDY0ID0gcmVhZDY0KGZhbHNlKTtcbm1vZHVsZS5leHBvcnRzLnVucGFja1VJbnQ2NCA9IHJlYWQ2NCh0cnVlKTtcbm1vZHVsZS5leHBvcnRzLnBhY2tJbnQ2NCA9IHdyaXRlNjQoZmFsc2UpO1xubW9kdWxlLmV4cG9ydHMucGFja1VJbnQ2NCA9IHdyaXRlNjQodHJ1ZSk7XG5cbmFkZEJpbmRpbmdzKFwiRmxvYXQzMlwiLCBcIkZsb2F0XCIpO1xuYWRkQmluZGluZ3MoXCJGbG9hdDY0XCIsIFwiRG91YmxlXCIpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmlucGFjay9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZ3JhbSA9IHJlcXVpcmUoJ2RncmFtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcblxudmFyIGRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5cbnZhciBTZXJ2ZXIgPSBmdW5jdGlvbihwb3J0LCBob3N0KSB7XG4gICAgdmFyIHNlcnZlcjtcbiAgICBldmVudHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIHRoaXMuX3NvY2sgPSBkZ3JhbS5jcmVhdGVTb2NrZXQoe1xuICAgICAgdHlwZTogJ3VkcDQnLFxuICAgICAgcmV1c2VBZGRyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fc29jay5iaW5kKHBvcnQpO1xuICAgIHNlcnZlciA9IHRoaXM7XG4gICAgdGhpcy5fc29jay5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChtc2csIHJpbmZvKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZGVjb2RlZCA9IGRlY29kZShtc2cpO1xuICAgICAgICAgICAgLy8gWzxhZGRyZXNzPiwgPHR5cGV0YWdzPiwgPHZhbHVlcz4qXVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY2FuXFwndCBkZWNvZGUgaW5jb21pbmcgbWVzc2FnZTogJyArIGUubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVjb2RlZCkge1xuICAgICAgICAgICAgc2VydmVyLmVtaXQoJ21lc3NhZ2UnLCBkZWNvZGVkLCByaW5mbyk7XG4gICAgICAgICAgICBzZXJ2ZXIuZW1pdChkZWNvZGVkWzBdLCBkZWNvZGVkLCByaW5mbyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc29jay5jbG9zZSgpO1xuICAgIH07XG59O1xuXG51dGlsLmluaGVyaXRzKFNlcnZlciwgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmVyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbm9kZS1vc2MvbGliL1NlcnZlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJ1dGlsXCJcbiAqKiBtb2R1bGUgaWQgPSAyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJldmVudHNcIlxuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxudmFyIFRJbnQgPSB0eXBlcy5USW50O1xudmFyIFRGbG9hdCA9IHR5cGVzLlRGbG9hdDtcbnZhciBUU3RyaW5nID0gdHlwZXMuVFN0cmluZztcbnZhciBUQmxvYiA9IHR5cGVzLlRCbG9iO1xudmFyIFREb3VibGUgPSB0eXBlcy5URG91YmxlO1xudmFyIFRUaW1lID0gdHlwZXMuVFRpbWU7XG5cbi8vIGZvciBlYWNoIE9TQyB0eXBlIHRhZyB3ZSB1c2UgYSBzcGVjaWZpYyBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBkZWNvZGUgaXRzIHJlc3BlY3RpdmUgZGF0YVxudmFyIHRhZ1RvQ29uc3RydWN0b3IgPSB7ICdpJzogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFRJbnQoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAnZic6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBURmxvYXQoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAncyc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBUU3RyaW5nKCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ2InOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgVEJsb2IoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAnZCc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBURG91YmxlKCk7IH0gfTtcblxuZnVuY3Rpb24gZGVjb2RlIChkYXRhKSB7XG4gICAgLy8gdGhpcyBzdG9yZXMgdGhlIGRlY29kZWQgZGF0YSBhcyBhbiBhcnJheVxuICAgIHZhciBtZXNzYWdlID0gW107XG5cbiAgICAvLyB3ZSBzdGFydCBnZXR0aW5nIHRoZSA8YWRkcmVzcz4gYW5kIDxyZXN0PiBvZiBPU0MgbXNnIC88YWRkcmVzcz5cXDA8cmVzdD5cXDA8dHlwZXRhZ3M+XFwwPGRhdGE+XG4gICAgdmFyIGFkZHJlc3MgPSBuZXcgVFN0cmluZygpO1xuICAgIGRhdGEgPSBhZGRyZXNzLmRlY29kZShkYXRhKTtcblxuICAgIC8vIENoZWNraW5nIGlmIHdlIHJlY2VpdmVkIGEgYnVuZGxlICh0eXBpY2FsIGZvciBUVUlPL09TQylcbiAgICBpZiAoYWRkcmVzcy52YWx1ZSA9PT0gJyNidW5kbGUnKSB7XG4gICAgICAgIHZhciB0aW1lID0gbmV3IFRUaW1lKCk7XG4gICAgICAgIGRhdGEgPSB0aW1lLmRlY29kZShkYXRhKTtcblxuICAgICAgICBtZXNzYWdlLnB1c2goJyNidW5kbGUnKTtcbiAgICAgICAgbWVzc2FnZS5wdXNoKHRpbWUudmFsdWUpO1xuXG4gICAgICAgIHZhciBsZW5ndGgsIHBhcnQ7XG4gICAgICAgIHdoaWxlKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gbmV3IFRJbnQoKTtcbiAgICAgICAgICAgIGRhdGEgPSBsZW5ndGguZGVjb2RlKGRhdGEpO1xuXG4gICAgICAgICAgICBwYXJ0ID0gZGF0YS5zbGljZSgwLCBsZW5ndGgudmFsdWUpO1xuICAgICAgICAgICAgLy9tZXNzYWdlID0gbWVzc2FnZS5jb25jYXQoZGVjb2RlKHBhcnQpKTtcbiAgICAgICAgICAgIG1lc3NhZ2UucHVzaChkZWNvZGUocGFydCkpO1xuXG4gICAgICAgICAgICBkYXRhID0gZGF0YS5zbGljZShsZW5ndGgudmFsdWUsIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbWVzc2FnZS5wdXNoKGFkZHJlc3MudmFsdWUpO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgcmVzdCwgbWF5YmUgd2UgaGF2ZSBzb21lIHR5cGV0YWdzLi4uIGxldCBzZWUuLi5cblxuICAgICAgICAvLyBub3cgd2UgYWR2YW5jZSBvbiB0aGUgb2xkIHJlc3QsIGdldHRpbmcgPHR5cGV0YWdzPlxuICAgICAgICB2YXIgdHlwZXRhZ3MgPSBuZXcgVFN0cmluZygpO1xuICAgICAgICBkYXRhID0gdHlwZXRhZ3MuZGVjb2RlKGRhdGEpO1xuICAgICAgICB0eXBldGFncyA9IHR5cGV0YWdzLnZhbHVlO1xuICAgICAgICAvLyBzbyB3ZSBzdGFydCBidWlsZGluZyBvdXIgbWVzc2FnZSBsaXN0XG4gICAgICAgIGlmICh0eXBldGFnc1swXSAhPT0gJywnKSB7XG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB0eXBlIHRhZyBpbiBpbmNvbWluZyBPU0MgbWVzc2FnZSwgbXVzdCBzdGFydCB3aXRoIGNvbW1hJztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHR5cGV0YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RydWN0b3IgPSB0YWdUb0NvbnN0cnVjdG9yW3R5cGV0YWdzW2ldXTtcbiAgICAgICAgICAgIGlmICghY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVW5zdXBwb3J0ZWQgT1NDIHR5cGUgdGFnICcgKyB0eXBldGFnc1tpXSArICcgaW4gaW5jb21pbmcgbWVzc2FnZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJndW1lbnQgPSBjb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgZGF0YSA9IGFyZ3VtZW50LmRlY29kZShkYXRhKTtcbiAgICAgICAgICAgIG1lc3NhZ2UucHVzaChhcmd1bWVudC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9ub2RlLW9zYy9saWIvZGVjb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGpzcGFjayA9IHJlcXVpcmUoJ2pzcGFjaycpLmpzcGFjaztcblxudmFyIHBhY2sgPSBqc3BhY2sucGFja1RvO1xuXG5mdW5jdGlvbiBTaG9ydEJ1ZmZlcih0eXBlLCBidWYsIHJlcXVpcmVkTGVuZ3RoKVxue1xuICAgIHRoaXMudHlwZSA9ICdTaG9ydEJ1ZmZlcic7XG4gICAgdmFyIG1lc3NhZ2UgPSAnYnVmZmVyIFsnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9ICcsICc7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZSArPSBidWYuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgbWVzc2FnZSArPSAnXSB0b28gc2hvcnQgZm9yICcgKyB0eXBlICsgJywgJyArIHJlcXVpcmVkTGVuZ3RoICsgJyBieXRlcyByZXF1aXJlZCc7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuZnVuY3Rpb24gVFN0cmluZyAodmFsdWUpIHsgdGhpcy52YWx1ZSA9IHZhbHVlOyB9XG5cblRTdHJpbmcucHJvdG90eXBlID0ge1xuICAgIHR5cGV0YWc6ICdzJyxcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBlbmQgPSAwO1xuICAgICAgICB3aGlsZSAoZGF0YVtlbmRdICYmIGVuZCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ09TQyBzdHJpbmcgbm90IG51bGwgdGVybWluYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBkYXRhLnRvU3RyaW5nKCdhc2NpaScsIDAsIGVuZCk7XG4gICAgICAgIHZhciBuZXh0RGF0YSA9IHBhcnNlSW50KE1hdGguY2VpbCgoZW5kICsgMSkgLyA0LjApICogNCk7XG4gICAgICAgIHJldHVybiBkYXRhLnNsaWNlKG5leHREYXRhKTtcbiAgICB9LFxuICAgIGVuY29kZTogZnVuY3Rpb24gKGJ1ZiwgcG9zKSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLmNlaWwoKHRoaXMudmFsdWUubGVuZ3RoICsgMSkgLyA0LjApICogNDtcbiAgICAgICAgcmV0dXJuIHBhY2soJz4nICsgbGVuICsgJ3MnLCBidWYsIHBvcywgWyB0aGlzLnZhbHVlIF0pO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuVFN0cmluZyA9IFRTdHJpbmc7XG5cbmZ1bmN0aW9uIFRJbnQgKHZhbHVlKSB7IHRoaXMudmFsdWUgPSB2YWx1ZTsgfVxuXG5USW50LnByb3RvdHlwZSA9IHtcbiAgICB0eXBldGFnOiAnaScsXG4gICAgZGVjb2RlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hvcnRCdWZmZXIoJ2ludCcsIGRhdGEsIDQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGpzcGFjay5VbnBhY2soJz5pJywgZGF0YS5zbGljZSgwLCA0KSlbMF07XG4gICAgICAgIHJldHVybiBkYXRhLnNsaWNlKDQpO1xuICAgIH0sXG4gICAgZW5jb2RlOiBmdW5jdGlvbiAoYnVmLCBwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBhY2soJz5pJywgYnVmLCBwb3MsIFsgdGhpcy52YWx1ZSBdKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLlRJbnQgPSBUSW50O1xuXG5mdW5jdGlvbiBUVGltZSAodmFsdWUpIHsgdGhpcy52YWx1ZSA9IHZhbHVlOyB9XG5cblRUaW1lLnByb3RvdHlwZSA9IHtcbiAgICB0eXBldGFnOiAndCcsXG4gICAgZGVjb2RlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hvcnRCdWZmZXIoJ3RpbWUnLCBkYXRhLCA4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmF3ID0ganNwYWNrLlVucGFjaygnPkxMJywgZGF0YS5zbGljZSgwLCA4KSk7XG4gICAgICAgIHZhciBzZWNzID0gcmF3WzBdO1xuICAgICAgICB2YXIgZnJhY3MgPSByYXdbMV07XG4gICAgICAgIHRoaXMudmFsdWUgPSBzZWNzICsgZnJhY3MgLyA0Mjk0OTY3Mjk2O1xuICAgICAgICByZXR1cm4gZGF0YS5zbGljZSg4KTtcbiAgICB9LFxuICAgIGVuY29kZTogZnVuY3Rpb24gKGJ1ZiwgcG9zKSB7XG4gICAgICAgIHJldHVybiBwYWNrKCc+TEwnLCBidWYsIHBvcywgdGhpcy52YWx1ZSk7XG4gICAgfVxufTtcblxuZXhwb3J0cy5UVGltZSA9IFRUaW1lO1xuXG5mdW5jdGlvbiBURmxvYXQgKHZhbHVlKSB7IHRoaXMudmFsdWUgPSB2YWx1ZTsgfVxuVEZsb2F0LnByb3RvdHlwZSA9IHtcbiAgICB0eXBldGFnOiAnZicsXG4gICAgZGVjb2RlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hvcnRCdWZmZXIoJ2Zsb2F0JywgZGF0YSwgNCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbHVlID0ganNwYWNrLlVucGFjaygnPmYnLCBkYXRhLnNsaWNlKDAsIDQpKVswXTtcbiAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2UoNCk7XG4gICAgfSxcbiAgICBlbmNvZGU6IGZ1bmN0aW9uIChidWYsIHBvcykge1xuICAgICAgICByZXR1cm4gcGFjaygnPmYnLCBidWYsIHBvcywgWyB0aGlzLnZhbHVlIF0pO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuVEZsb2F0ID0gVEZsb2F0O1xuXG5mdW5jdGlvbiBUQmxvYiAodmFsdWUpIHsgdGhpcy52YWx1ZSA9IHZhbHVlOyB9XG5UQmxvYi5wcm90b3R5cGUgPSB7XG4gICAgdHlwZXRhZzogJ2InLFxuICAgIGRlY29kZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGpzcGFjay5VbnBhY2soJz5pJywgZGF0YS5zbGljZSgwLCA0KSlbMF07XG4gICAgICAgIHZhciBuZXh0RGF0YSA9IHBhcnNlSW50KE1hdGguY2VpbCgobGVuZ3RoKSAvIDQuMCkgKiA0KSArIDQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSBkYXRhLnNsaWNlKDQsIGxlbmd0aCArIDQpO1xuICAgICAgICByZXR1cm4gZGF0YS5zbGljZShuZXh0RGF0YSk7XG4gICAgfSxcbiAgICBlbmNvZGU6IGZ1bmN0aW9uIChidWYsIHBvcykge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5jZWlsKCh0aGlzLnZhbHVlLmxlbmd0aCkgLyA0LjApICogNDtcbiAgICAgICAgcmV0dXJuIHBhY2soJz5pJyArIGxlbiArICdzJywgYnVmLCBwb3MsIFtsZW4sIHRoaXMudmFsdWVdKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLlRCbG9iID0gVEJsb2I7XG5cbmZ1bmN0aW9uIFREb3VibGUgKHZhbHVlKSB7IHRoaXMudmFsdWUgPSB2YWx1ZTsgfVxuVERvdWJsZS5wcm90b3R5cGUgPSB7XG4gICAgdHlwZXRhZzogJ2QnLFxuICAgIGRlY29kZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgOCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNob3J0QnVmZmVyKCdkb3VibGUnLCBkYXRhLCA4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0ganNwYWNrLlVucGFjaygnPmQnLCBkYXRhLnNsaWNlKDAsIDgpKVswXTtcbiAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2UoOCk7XG4gICAgfSxcbiAgICBlbmNvZGU6IGZ1bmN0aW9uIChidWYsIHBvcykge1xuICAgICAgICByZXR1cm4gcGFjaygnPmQnLCBidWYsIHBvcywgWyB0aGlzLnZhbHVlIF0pO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuVERvdWJsZSA9IFREb3VibGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9ub2RlLW9zYy9saWIvdHlwZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiAgQ29weXJpZ2h0IMKpIDIwMDggRmFpciBPYWtzIExhYnMsIEluYy5cbiAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8vIFV0aWxpdHkgb2JqZWN0OiAgRW5jb2RlL0RlY29kZSBDLXN0eWxlIGJpbmFyeSBwcmltaXRpdmVzIHRvL2Zyb20gb2N0ZXQgYXJyYXlzXG5mdW5jdGlvbiBKU1BhY2soKVxue1xuXHQvLyBNb2R1bGUtbGV2ZWwgKHByaXZhdGUpIHZhcmlhYmxlc1xuXHR2YXIgZWwsICBiQkUgPSBmYWxzZSwgbSA9IHRoaXM7XG5cblxuXHQvLyBSYXcgYnl0ZSBhcnJheXNcblx0bS5fRGVBcnJheSA9IGZ1bmN0aW9uIChhLCBwLCBsKVxuXHR7XG5cdFx0cmV0dXJuIFthLnNsaWNlKHAscCtsKV07XG5cdH07XG5cdG0uX0VuQXJyYXkgPSBmdW5jdGlvbiAoYSwgcCwgbCwgdilcblx0e1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbDsgYVtwK2ldID0gdltpXT92W2ldOjAsIGkrKyk7XG5cdH07XG5cblx0Ly8gQVNDSUkgY2hhcmFjdGVyc1xuXHRtLl9EZUNoYXIgPSBmdW5jdGlvbiAoYSwgcClcblx0e1xuXHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGFbcF0pO1xuXHR9O1xuXHRtLl9FbkNoYXIgPSBmdW5jdGlvbiAoYSwgcCwgdilcblx0e1xuXHRcdGFbcF0gPSB2LmNoYXJDb2RlQXQoMCk7XG5cdH07XG5cblx0Ly8gTGl0dGxlLWVuZGlhbiAodW4pc2lnbmVkIE4tYnl0ZSBpbnRlZ2Vyc1xuXHRtLl9EZUludCA9IGZ1bmN0aW9uIChhLCBwKVxuXHR7XG5cdFx0dmFyIGxzYiA9IGJCRT8oZWwubGVuLTEpOjAsIG5zYiA9IGJCRT8tMToxLCBzdG9wID0gbHNiK25zYiplbC5sZW4sIHJ2LCBpLCBmO1xuXHRcdGZvciAocnYgPSAwLCBpID0gbHNiLCBmID0gMTsgaSAhPSBzdG9wOyBydis9KGFbcCtpXSpmKSwgaSs9bnNiLCBmKj0yNTYpO1xuXHRcdGlmIChlbC5iU2lnbmVkICYmIChydiAmIE1hdGgucG93KDIsIGVsLmxlbio4LTEpKSkgeyBydiAtPSBNYXRoLnBvdygyLCBlbC5sZW4qOCk7IH1cblx0XHRyZXR1cm4gcnY7XG5cdH07XG5cdG0uX0VuSW50ID0gZnVuY3Rpb24gKGEsIHAsIHYpXG5cdHtcblx0XHR2YXIgbHNiID0gYkJFPyhlbC5sZW4tMSk6MCwgbnNiID0gYkJFPy0xOjEsIHN0b3AgPSBsc2IrbnNiKmVsLmxlbiwgaTtcblx0XHR2ID0gKHY8ZWwubWluKT9lbC5taW46KHY+ZWwubWF4KT9lbC5tYXg6djtcblx0XHRmb3IgKGkgPSBsc2I7IGkgIT0gc3RvcDsgYVtwK2ldPXYmMHhmZiwgaSs9bnNiLCB2Pj49OCk7XG5cdH07XG5cblx0Ly8gQVNDSUkgY2hhcmFjdGVyIHN0cmluZ3Ncblx0bS5fRGVTdHJpbmcgPSBmdW5jdGlvbiAoYSwgcCwgbClcblx0e1xuXHRcdGZvciAodmFyIHJ2ID0gbmV3IEFycmF5KGwpLCBpID0gMDsgaSA8IGw7IHJ2W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShhW3AraV0pLCBpKyspO1xuXHRcdHJldHVybiBydi5qb2luKCcnKTtcblx0fTtcblx0bS5fRW5TdHJpbmcgPSBmdW5jdGlvbiAoYSwgcCwgbCwgdilcblx0e1xuXHRcdGZvciAodmFyIHQsIGkgPSAwOyBpIDwgbDsgYVtwK2ldID0gKHQ9di5jaGFyQ29kZUF0KGkpKT90OjAsIGkrKyk7XG5cdH07XG5cblx0Ly8gTGl0dGxlLWVuZGlhbiBOLWJpdCBJRUVFIDc1NCBmbG9hdGluZyBwb2ludFxuXHRtLl9EZTc1NCA9IGZ1bmN0aW9uIChhLCBwKVxuXHR7XG5cdFx0dmFyIHMsIGUsIG0sIGksIGQsIG5CaXRzLCBtTGVuLCBlTGVuLCBlQmlhcywgZU1heDtcblx0XHRtTGVuID0gZWwubUxlbiwgZUxlbiA9IGVsLmxlbio4LWVsLm1MZW4tMSwgZU1heCA9ICgxPDxlTGVuKS0xLCBlQmlhcyA9IGVNYXg+PjE7XG5cblx0XHRpID0gYkJFPzA6KGVsLmxlbi0xKTsgZCA9IGJCRT8xOi0xOyBzID0gYVtwK2ldOyBpKz1kOyBuQml0cyA9IC03O1xuXHRcdGZvciAoZSA9IHMmKCgxPDwoLW5CaXRzKSktMSksIHM+Pj0oLW5CaXRzKSwgbkJpdHMgKz0gZUxlbjsgbkJpdHMgPiAwOyBlPWUqMjU2K2FbcCtpXSwgaSs9ZCwgbkJpdHMtPTgpO1xuXHRcdGZvciAobSA9IGUmKCgxPDwoLW5CaXRzKSktMSksIGU+Pj0oLW5CaXRzKSwgbkJpdHMgKz0gbUxlbjsgbkJpdHMgPiAwOyBtPW0qMjU2K2FbcCtpXSwgaSs9ZCwgbkJpdHMtPTgpO1xuXG5cdFx0c3dpdGNoIChlKVxuXHRcdHtcblx0XHRcdGNhc2UgMDpcblx0XHRcdFx0Ly8gWmVybywgb3IgZGVub3JtYWxpemVkIG51bWJlclxuXHRcdFx0XHRlID0gMS1lQmlhcztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIGVNYXg6XG5cdFx0XHRcdC8vIE5hTiwgb3IgKy8tSW5maW5pdHlcblx0XHRcdFx0cmV0dXJuIG0/TmFOOigocz8tMToxKSpJbmZpbml0eSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHQvLyBOb3JtYWxpemVkIG51bWJlclxuXHRcdFx0XHRtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuXHRcdFx0XHRlID0gZSAtIGVCaWFzO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0cmV0dXJuIChzPy0xOjEpICogbSAqIE1hdGgucG93KDIsIGUtbUxlbik7XG5cdH07XG5cdG0uX0VuNzU0ID0gZnVuY3Rpb24gKGEsIHAsIHYpXG5cdHtcblx0XHR2YXIgcywgZSwgbSwgaSwgZCwgYywgbUxlbiwgZUxlbiwgZUJpYXMsIGVNYXg7XG5cdFx0bUxlbiA9IGVsLm1MZW4sIGVMZW4gPSBlbC5sZW4qOC1lbC5tTGVuLTEsIGVNYXggPSAoMTw8ZUxlbiktMSwgZUJpYXMgPSBlTWF4Pj4xO1xuXG5cdFx0cyA9IHY8MD8xOjA7XG5cdFx0diA9IE1hdGguYWJzKHYpO1xuXHRcdGlmIChpc05hTih2KSB8fCAodiA9PSBJbmZpbml0eSkpXG5cdFx0e1xuXHRcdFx0bSA9IGlzTmFOKHYpPzE6MDtcblx0XHRcdGUgPSBlTWF4O1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0ZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codikvTWF0aC5MTjIpO1x0XHRcdC8vIENhbGN1bGF0ZSBsb2cyIG9mIHRoZSB2YWx1ZVxuXHRcdFx0aWYgKHYqKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkgeyBlLS07IGMqPTI7IH1cdFx0Ly8gTWF0aC5sb2coKSBpc24ndCAxMDAlIHJlbGlhYmxlXG5cblx0XHRcdC8vIFJvdW5kIGJ5IGFkZGluZyAxLzIgdGhlIHNpZ25pZmljYW5kJ3MgTFNEXG5cdFx0XHRpZiAoZStlQmlhcyA+PSAxKSB7IHYgKz0gZWwucnQvYzsgfVx0XHRcdC8vIE5vcm1hbGl6ZWQ6ICBtTGVuIHNpZ25pZmljYW5kIGRpZ2l0c1xuXHRcdFx0ZWxzZSB7IHYgKz0gZWwucnQqTWF0aC5wb3coMiwgMS1lQmlhcyk7IH0gXHRcdC8vIERlbm9ybWFsaXplZDogIDw9IG1MZW4gc2lnbmlmaWNhbmQgZGlnaXRzXG5cdFx0XHRpZiAodipjID49IDIpIHsgZSsrOyBjLz0yOyB9XHRcdFx0XHQvLyBSb3VuZGluZyBjYW4gaW5jcmVtZW50IHRoZSBleHBvbmVudFxuXG5cdFx0XHRpZiAoZStlQmlhcyA+PSBlTWF4KVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBPdmVyZmxvd1xuXHRcdFx0XHRtID0gMDtcblx0XHRcdFx0ZSA9IGVNYXg7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChlK2VCaWFzID49IDEpXG5cdFx0XHR7XG5cdFx0XHRcdC8vIE5vcm1hbGl6ZWQgLSB0ZXJtIG9yZGVyIG1hdHRlcnMsIGFzIE1hdGgucG93KDIsIDUyLWUpIGFuZCB2Kk1hdGgucG93KDIsIDUyKSBjYW4gb3ZlcmZsb3dcblx0XHRcdFx0bSA9ICh2KmMtMSkqTWF0aC5wb3coMiwgbUxlbik7XG5cdFx0XHRcdGUgPSBlICsgZUJpYXM7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdC8vIERlbm9ybWFsaXplZCAtIGFsc28gY2F0Y2hlcyB0aGUgJzAnIGNhc2UsIHNvbWV3aGF0IGJ5IGNoYW5jZVxuXHRcdFx0XHRtID0gdipNYXRoLnBvdygyLCBlQmlhcy0xKSpNYXRoLnBvdygyLCBtTGVuKTtcblx0XHRcdFx0ZSA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gYkJFPyhlbC5sZW4tMSk6MCwgZD1iQkU/LTE6MTsgbUxlbiA+PSA4OyBhW3AraV09bSYweGZmLCBpKz1kLCBtLz0yNTYsIG1MZW4tPTgpO1xuXHRcdGZvciAoZT0oZTw8bUxlbil8bSwgZUxlbis9bUxlbjsgZUxlbiA+IDA7IGFbcCtpXT1lJjB4ZmYsIGkrPWQsIGUvPTI1NiwgZUxlbi09OCk7XG5cdFx0YVtwK2ktZF0gfD0gcyoxMjg7XG5cdH07XG5cblx0Ly8gQ29udmVydCBpbnQ2NCB0byBhcnJheSB3aXRoIDMgZWxlbWVudHM6IFtsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWRGbGFnXVxuXHQvLyAnPj4+JyB0cmljayB0byBjb252ZXJ0IHNpZ25lZCAzMmJpdCBpbnQgdG8gdW5zaWduZWQgaW50IChiZWNhdXNlIDw8IGFsd2F5cyByZXN1bHRzIGluIGEgc2lnbmVkIDMyYml0IGludClcblx0bS5fRGVJbnQ2NCA9IGZ1bmN0aW9uIChhLCBwKSB7XG5cdFx0dmFyIHN0YXJ0ID0gYkJFID8gMCA6IDcsIG5zYiA9IGJCRSA/IDEgOiAtMSwgc3RvcCA9IHN0YXJ0ICsgbnNiICogOCwgcnYgPSBbMCwwLCAhZWwuYlNpZ25lZF0sIGksIGYsIHJ2aTtcblx0XHRmb3IgKGkgPSBzdGFydCwgcnZpID0gMSwgZiA9IDA7XG5cdFx0XHRpICE9IHN0b3A7XG5cdFx0XHRydltydmldID0gKCgocnZbcnZpXTw8OCk+Pj4wKSArIGFbcCArIGldKSwgaSArPSBuc2IsIGYrKywgcnZpID0gKGYgPCA0ID8gMSA6IDApKTtcblx0XHRyZXR1cm4gcnY7XG5cdH07XG5cdG0uX0VuSW50NjQgPSBmdW5jdGlvbiAoYSwgcCwgdikge1xuXHRcdHZhciBzdGFydCA9IGJCRSA/IDAgOiA3LCBuc2IgPSBiQkUgPyAxIDogLTEsIHN0b3AgPSBzdGFydCArIG5zYiAqIDgsIGksIGYsIHJ2aSwgcztcblx0XHRmb3IgKGkgPSBzdGFydCwgcnZpID0gMSwgZiA9IDAsIHMgPSAyNDtcblx0XHRcdGkgIT0gc3RvcDtcblx0XHRcdGFbcCArIGldID0gdltydmldPj5zICYgMHhmZiwgaSArPSBuc2IsIGYrKywgcnZpID0gKGYgPCA0ID8gMSA6IDApLCBzID0gMjQgLSAoOCAqIChmICUgNCkpKTtcblx0fTtcblx0XG5cblx0Ly8gQ2xhc3MgZGF0YVxuXHRtLl9zUGF0dGVyblx0PSAnKFxcXFxkKyk/KFtBeGNiQmhIc2ZkaUlsTHFRXSknO1xuXHRtLl9sZW5MdXRcdD0geydBJzoxLCAneCc6MSwgJ2MnOjEsICdiJzoxLCAnQic6MSwgJ2gnOjIsICdIJzoyLCAncyc6MSwgJ2YnOjQsICdkJzo4LCAnaSc6NCwgJ0knOjQsICdsJzo0LCAnTCc6NCwgJ3EnOjgsICdRJzo4fTtcblx0bS5fZWxMdXRcdD0ge1x0J0EnOiB7ZW46bS5fRW5BcnJheSwgZGU6bS5fRGVBcnJheX0sXG5cdFx0XHRcdCdzJzoge2VuOm0uX0VuU3RyaW5nLCBkZTptLl9EZVN0cmluZ30sXG5cdFx0XHRcdCdjJzoge2VuOm0uX0VuQ2hhciwgZGU6bS5fRGVDaGFyfSxcblx0XHRcdFx0J2InOiB7ZW46bS5fRW5JbnQsIGRlOm0uX0RlSW50LCBsZW46MSwgYlNpZ25lZDp0cnVlLCBtaW46LU1hdGgucG93KDIsIDcpLCBtYXg6TWF0aC5wb3coMiwgNyktMX0sXG5cdFx0XHRcdCdCJzoge2VuOm0uX0VuSW50LCBkZTptLl9EZUludCwgbGVuOjEsIGJTaWduZWQ6ZmFsc2UsIG1pbjowLCBtYXg6TWF0aC5wb3coMiwgOCktMX0sXG5cdFx0XHRcdCdoJzoge2VuOm0uX0VuSW50LCBkZTptLl9EZUludCwgbGVuOjIsIGJTaWduZWQ6dHJ1ZSwgbWluOi1NYXRoLnBvdygyLCAxNSksIG1heDpNYXRoLnBvdygyLCAxNSktMX0sXG5cdFx0XHRcdCdIJzoge2VuOm0uX0VuSW50LCBkZTptLl9EZUludCwgbGVuOjIsIGJTaWduZWQ6ZmFsc2UsIG1pbjowLCBtYXg6TWF0aC5wb3coMiwgMTYpLTF9LFxuXHRcdFx0XHQnaSc6IHtlbjptLl9FbkludCwgZGU6bS5fRGVJbnQsIGxlbjo0LCBiU2lnbmVkOnRydWUsIG1pbjotTWF0aC5wb3coMiwgMzEpLCBtYXg6TWF0aC5wb3coMiwgMzEpLTF9LFxuXHRcdFx0XHQnSSc6IHtlbjptLl9FbkludCwgZGU6bS5fRGVJbnQsIGxlbjo0LCBiU2lnbmVkOmZhbHNlLCBtaW46MCwgbWF4Ok1hdGgucG93KDIsIDMyKS0xfSxcblx0XHRcdFx0J2wnOiB7ZW46bS5fRW5JbnQsIGRlOm0uX0RlSW50LCBsZW46NCwgYlNpZ25lZDp0cnVlLCBtaW46LU1hdGgucG93KDIsIDMxKSwgbWF4Ok1hdGgucG93KDIsIDMxKS0xfSxcblx0XHRcdFx0J0wnOiB7ZW46bS5fRW5JbnQsIGRlOm0uX0RlSW50LCBsZW46NCwgYlNpZ25lZDpmYWxzZSwgbWluOjAsIG1heDpNYXRoLnBvdygyLCAzMiktMX0sXG5cdFx0XHRcdCdmJzoge2VuOm0uX0VuNzU0LCBkZTptLl9EZTc1NCwgbGVuOjQsIG1MZW46MjMsIHJ0Ok1hdGgucG93KDIsIC0yNCktTWF0aC5wb3coMiwgLTc3KX0sXG5cdFx0XHRcdCdkJzoge2VuOm0uX0VuNzU0LCBkZTptLl9EZTc1NCwgbGVuOjgsIG1MZW46NTIsIHJ0OjB9LFxuXHRcdFx0XHQncSc6IHtlbjptLl9FbkludDY0LCBkZTptLl9EZUludDY0LCBiU2lnbmVkOnRydWV9LFxuXHRcdFx0XHQnUSc6IHtlbjptLl9FbkludDY0LCBkZTptLl9EZUludDY0LCBiU2lnbmVkOmZhbHNlfX07XG5cblx0Ly8gVW5wYWNrIGEgc2VyaWVzIG9mIG4gZWxlbWVudHMgb2Ygc2l6ZSBzIGZyb20gYXJyYXkgYSBhdCBvZmZzZXQgcCB3aXRoIGZ4blxuXHRtLl9VbnBhY2tTZXJpZXMgPSBmdW5jdGlvbiAobiwgcywgYSwgcClcblx0e1xuXHRcdGZvciAodmFyIGZ4biA9IGVsLmRlLCBydiA9IFtdLCBpID0gMDsgaSA8IG47IHJ2LnB1c2goZnhuKGEsIHAraSpzKSksIGkrKyk7XG5cdFx0cmV0dXJuIHJ2O1xuXHR9O1xuXG5cdC8vIFBhY2sgYSBzZXJpZXMgb2YgbiBlbGVtZW50cyBvZiBzaXplIHMgZnJvbSBhcnJheSB2IGF0IG9mZnNldCBpIHRvIGFycmF5IGEgYXQgb2Zmc2V0IHAgd2l0aCBmeG5cblx0bS5fUGFja1NlcmllcyA9IGZ1bmN0aW9uIChuLCBzLCBhLCBwLCB2LCBpKVxuXHR7XG5cdFx0Zm9yICh2YXIgZnhuID0gZWwuZW4sIG8gPSAwOyBvIDwgbjsgZnhuKGEsIHArbypzLCB2W2krb10pLCBvKyspO1xuXHR9O1xuXG5cdC8vIFVucGFjayB0aGUgb2N0ZXQgYXJyYXkgYSwgYmVnaW5uaW5nIGF0IG9mZnNldCBwLCBhY2NvcmRpbmcgdG8gdGhlIGZtdCBzdHJpbmdcblx0bS5VbnBhY2sgPSBmdW5jdGlvbiAoZm10LCBhLCBwKVxuXHR7XG5cdFx0Ly8gU2V0IHRoZSBwcml2YXRlIGJCRSBmbGFnIGJhc2VkIG9uIHRoZSBmb3JtYXQgc3RyaW5nIC0gYXNzdW1lIGJpZy1lbmRpYW5uZXNzXG5cdFx0YkJFID0gKGZtdC5jaGFyQXQoMCkgIT0gJzwnKTtcblxuXHRcdHAgPSBwP3A6MDtcblx0XHR2YXIgcmUgPSBuZXcgUmVnRXhwKHRoaXMuX3NQYXR0ZXJuLCAnZycpLCBtLCBuLCBzLCBydiA9IFtdO1xuXHRcdHdoaWxlIChtID0gcmUuZXhlYyhmbXQpKVxuXHRcdHtcblx0XHRcdG4gPSAoKG1bMV09PXVuZGVmaW5lZCl8fChtWzFdPT0nJykpPzE6cGFyc2VJbnQobVsxXSk7XG5cdFx0XHRzID0gdGhpcy5fbGVuTHV0W21bMl1dO1xuXHRcdFx0aWYgKChwICsgbipzKSA+IGEubGVuZ3RoKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoIChtWzJdKVxuXHRcdFx0e1xuXHRcdFx0XHRjYXNlICdBJzogY2FzZSAncyc6XG5cdFx0XHRcdFx0cnYucHVzaCh0aGlzLl9lbEx1dFttWzJdXS5kZShhLCBwLCBuKSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2MnOiBjYXNlICdiJzogY2FzZSAnQic6IGNhc2UgJ2gnOiBjYXNlICdIJzpcblx0XHRcdFx0Y2FzZSAnaSc6IGNhc2UgJ0knOiBjYXNlICdsJzogY2FzZSAnTCc6IGNhc2UgJ2YnOiBjYXNlICdkJzogY2FzZSAncSc6IGNhc2UgJ1EnOlxuXHRcdFx0XHRcdGVsID0gdGhpcy5fZWxMdXRbbVsyXV07XG5cdFx0XHRcdFx0cnYucHVzaCh0aGlzLl9VbnBhY2tTZXJpZXMobiwgcywgYSwgcCkpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cCArPSBuKnM7XG5cdFx0fVxuXHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBydik7XG5cdH07XG5cblx0Ly8gUGFjayB0aGUgc3VwcGxpZWQgdmFsdWVzIGludG8gdGhlIG9jdGV0IGFycmF5IGEsIGJlZ2lubmluZyBhdCBvZmZzZXQgcCwgYWNjb3JkaW5nIHRvIHRoZSBmbXQgc3RyaW5nXG5cdG0uUGFja1RvID0gZnVuY3Rpb24gKGZtdCwgYSwgcCwgdmFsdWVzKVxuXHR7XG5cdFx0Ly8gU2V0IHRoZSBwcml2YXRlIGJCRSBmbGFnIGJhc2VkIG9uIHRoZSBmb3JtYXQgc3RyaW5nIC0gYXNzdW1lIGJpZy1lbmRpYW5uZXNzXG5cdFx0YkJFID0gKGZtdC5jaGFyQXQoMCkgIT0gJzwnKTtcblxuXHRcdHZhciByZSA9IG5ldyBSZWdFeHAodGhpcy5fc1BhdHRlcm4sICdnJyksIG0sIG4sIHMsIGkgPSAwLCBqO1xuXHRcdHdoaWxlIChtID0gcmUuZXhlYyhmbXQpKVxuXHRcdHtcblx0XHRcdG4gPSAoKG1bMV09PXVuZGVmaW5lZCl8fChtWzFdPT0nJykpPzE6cGFyc2VJbnQobVsxXSk7XG5cdFx0XHRzID0gdGhpcy5fbGVuTHV0W21bMl1dO1xuXHRcdFx0aWYgKChwICsgbipzKSA+IGEubGVuZ3RoKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKG1bMl0pXG5cdFx0XHR7XG5cdFx0XHRcdGNhc2UgJ0EnOiBjYXNlICdzJzpcblx0XHRcdFx0XHRpZiAoKGkgKyAxKSA+IHZhbHVlcy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdFx0dGhpcy5fZWxMdXRbbVsyXV0uZW4oYSwgcCwgbiwgdmFsdWVzW2ldKTtcblx0XHRcdFx0XHRpICs9IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2MnOiBjYXNlICdiJzogY2FzZSAnQic6IGNhc2UgJ2gnOiBjYXNlICdIJzpcblx0XHRcdFx0Y2FzZSAnaSc6IGNhc2UgJ0knOiBjYXNlICdsJzogY2FzZSAnTCc6IGNhc2UgJ2YnOiBjYXNlICdkJzogY2FzZSAncSc6IGNhc2UgJ1EnOlxuXHRcdFx0XHRcdGVsID0gdGhpcy5fZWxMdXRbbVsyXV07XG5cdFx0XHRcdFx0aWYgKChpICsgbikgPiB2YWx1ZXMubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdHRoaXMuX1BhY2tTZXJpZXMobiwgcywgYSwgcCwgdmFsdWVzLCBpKTtcblx0XHRcdFx0XHRpICs9IG47XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3gnOlxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHsgYVtwK2pdID0gMDsgfVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cCArPSBuKnM7XG5cdFx0fVxuXHRcdHJldHVybiBhO1xuXHR9O1xuXG5cdC8vIFBhY2sgdGhlIHN1cHBsaWVkIHZhbHVlcyBpbnRvIGEgbmV3IG9jdGV0IGFycmF5LCBhY2NvcmRpbmcgdG8gdGhlIGZtdCBzdHJpbmdcblx0bS5QYWNrID0gZnVuY3Rpb24gKGZtdCwgdmFsdWVzKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuUGFja1RvKGZtdCwgbmV3IEFycmF5KHRoaXMuQ2FsY0xlbmd0aChmbXQpKSwgMCwgdmFsdWVzKTtcblx0fTtcblxuXHQvLyBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBieXRlcyByZXByZXNlbnRlZCBieSB0aGUgZm9ybWF0IHN0cmluZ1xuXHRtLkNhbGNMZW5ndGggPSBmdW5jdGlvbiAoZm10KVxuXHR7XG5cdFx0dmFyIHJlID0gbmV3IFJlZ0V4cCh0aGlzLl9zUGF0dGVybiwgJ2cnKSwgbSwgc3VtID0gMDtcblx0XHR3aGlsZSAobSA9IHJlLmV4ZWMoZm10KSlcblx0XHR7XG5cdFx0XHRzdW0gKz0gKCgobVsxXT09dW5kZWZpbmVkKXx8KG1bMV09PScnKSk/MTpwYXJzZUludChtWzFdKSkgKiB0aGlzLl9sZW5MdXRbbVsyXV07XG5cdFx0fVxuXHRcdHJldHVybiBzdW07XG5cdH07XG59O1xuXG5leHBvcnRzLmpzcGFjayA9IG5ldyBKU1BhY2soKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2pzcGFjay9qc3BhY2suanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwid2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dFxud2luZG93Lm5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSB3aW5kb3cubmF2aWdhdG9yLmdldFVzZXJNZWRpYSB8fCB3aW5kb3cubmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYVxuXG5cbmNvbnN0IFNPVVJDRV9OQU1FID0gJ1NvdW5kZmxvd2VyICgyY2gpJ1xuLy8gY29uc3QgU09VUkNFX05BTUUgPSAnRGVmYXVsdCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXVkaW9BbmFseXNlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy52b2x1bWUgPSAwXG5cdFx0dGhpcy5pbml0VXNlck1lZGlhID0gdGhpcy5pbml0VXNlck1lZGlhLmJpbmQodGhpcylcblxuXHRcdHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrLmdldFNvdXJjZXModGhpcy5nb3RTb3VyY2VzLmJpbmQodGhpcykpXG5cdH1cblxuXHRnb3RTb3VyY2VzKHNvdXJjZUluZm9zKSB7XG5cblx0XHQvLyBjb25zb2xlLmxvZyhzb3VyY2VJbmZvcylcblxuXHRcdGxldCBzb3VyY2VJZCA9IG51bGxcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlSW5mb3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBpbmZvID0gc291cmNlSW5mb3NbaV1cblx0XHRcdGlmIChpbmZvLmxhYmVsID09IFNPVVJDRV9OQU1FKSB7XG5cdFx0XHRcdHNvdXJjZUlkID0gaW5mby5pZFxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IG9wdGlvbiA9IHtcblx0XHRcdGF1ZGlvOiB7XG5cdFx0XHRcdG9wdGlvbmFsOiBbXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0c291cmNlSWQ6IHNvdXJjZUlkXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRdXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gbGV0IG9wdGlvbiA9IHthdWRpbzogdHJ1ZX1cblxuXHRcdHdpbmRvdy5uYXZpZ2F0b3IuZ2V0VXNlck1lZGlhKG9wdGlvbiwgdGhpcy5pbml0VXNlck1lZGlhLCAoKSA9PiB7fSlcblx0fVxuXG5cdGluaXRVc2VyTWVkaWEoc3RyZWFtKSB7XG5cblx0XHRsZXQgY29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKVxuXHRcdGxldCBzb3VyY2UgPSBjb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSlcblxuXHRcdHRoaXMuYW5hbHlzZXIgPSBjb250ZXh0LmNyZWF0ZUFuYWx5c2VyKClcblxuXHRcdHNvdXJjZS5jb25uZWN0KHRoaXMuYW5hbHlzZXIpXG5cdFx0Ly8gdGhpcy5hbmFseXNlci5jb25uZWN0KGNvbnRleHQuZGVzdGluYXRpb24pXG5cblx0XHQvLyBjcmVhdGUgZGF0YVxuXHRcdHRoaXMuZnJlcXVlbmN5RGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpXG5cblx0XHR0aGlzLnVwZGF0ZSA9IHRoaXMuX3VwZGF0ZVxuXG5cblx0fVxuXG5cdHVwZGF0ZSgpIHt9XG5cblx0X3VwZGF0ZSgpIHtcblxuXHRcdHRoaXMuYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEodGhpcy5mcmVxdWVuY3lEYXRhKVxuXG5cdFx0Ly8gY2FsYyBhdmVyYWdlXG5cdFx0dGhpcy52b2x1bWUgPSB0aGlzLmZyZXF1ZW5jeURhdGFbNTEyXVxuXHRcdC8vIGZvciAobGV0IGkgPSAwOyBpIDwgMTAyNDsgaSsrKSB7XG5cdFx0Ly8gXHQvLyBhdmVyYWdlICs9IHRoaXMuZnJlcXVlbmN5RGF0YVtpXVxuXHRcdC8vIFx0dGhpcy52b2x1bWUgPSBNYXRoLm1heCh0aGlzLnZvbHVtZSwgdGhpcy5mcmVxdWVuY3lEYXRhW2ldKVxuXHRcdC8vIH1cblxuXHRcdGNvbnNvbGUubG9nKHRoaXMudm9sdW1lKVxuXHRcdHRoaXMudm9sdW1lIC89IDI1Ni4wXG5cdH1cblxuXG5cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2F1ZGlvLWFuYWx5c2VyLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==